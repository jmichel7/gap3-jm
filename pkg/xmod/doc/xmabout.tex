%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  about.tex  for the XMOD package                         version  10/ 1/97
%A
%A  GAP documentation                               Chris Wensley & Murat Alp
%%

\documentstyle{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  The following commands intructs {\LaTeX} to stuff more on each  page  and
%%  to move each page towards to outer border.
%%
\topmargin 0 pt
\textheight 47\baselineskip
\advance\textheight by \topskip
\oddsidemargin  0.5 in
\evensidemargin  .25in
\textwidth 5.5in


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  The following commands instruct  {\LaTeX}  to  separate the paragraphs in
%%  this manual with a small space and to leave them unindented.
%%
\parskip 1.0ex plus 0.5ex minus 0.5ex
\parindent 0pt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  'text'
%%
%%  'text' prints the text in  monospaced  typewriter  font  in  the  printed
%%  manual  and  is  displayed  unchanged  in  the  on-screen  documentation.
%%  It should be used for names of GAP variables and functions and other text
%%  that the user may actually enter into his computer and see on his screen.
%%  The text may contain all the usual characters  and |<name>| placeholders.
%%  |\'| can be used to enter a single  quote  character  into  the  text.
%%
\catcode`\'=13 \gdef'#1'{{\tt #1}}
\gdef\'{\char`'}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  <text>
%%
%%  <text> prints  the text in  an italics font  in the printed manual and is
%%  displayed  unchanged in the  on-screen  documentation.  It should be used
%%  for arguments  in description of  GAP functions and   other placeholders.
%%  The  text should not contain any special characters.  |\<| can be used to
%%  enter a less than character into the text.
%%
\catcode`\<=13 \gdef<#1>{{\it #1\/}}
\gdef\<{\char`<}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  *text*
%%
%%  *text*  prints the text  in boldface font   in the printed manual and  is
%%  displayed unchanged in the on-screen  documentation.  It  should  be used
%%  for the definition  of mathematical  keywords.   The text may contain all
%%  the usual characters.  |\*| can be used to enter a star into the text.
%%
\catcode`\*=13 \gdef*#1*{{\bf #1}}
\gdef\*{\char`*}
\gdef\^{\char`^}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  |text|
%%
%%  |text| prints the text between the two  pipe  symbols in typewriter style
%%  obeying the   linebreaks and spaces  in  the   manual.   In the on-screen
%%  documentation it  remains unchanged, except  that the pipes are stripped.
%%  It should be used to  enter lengthy examples  into the text.  If the hash
%%  character '\#' appears in the example the text between it and  the end of
%%  the line  is set in  ordinary mode,  i.e., in  roman   font with  all the
%%  possibilities ordinary available.  |\|'\|' can be used to  enter  a  pipe
%%  symbol into the text.
%%
\catcode`\@=11

{\catcode`\ =\active\gdef\xvobeyspaces{\catcode`\ \active\let \xobeysp}}
\def\xobeysp{\leavevmode{} }

\catcode`\|=13
\gdef|{\leavevmode{}\hbox{}\begingroup
\def|{\endgroup}%
\catcode`\\=12\catcode`\{=12\catcode`\}=12\catcode`\$=12\catcode`\&=13
\catcode`\#=13\catcode`\^=12\catcode`\_=12\catcode`\ =12\catcode`\%=12
\catcode`\~=12\catcode`\'=12\catcode`\<=12\catcode`\"=12\catcode`\|=13
\catcode`\*=12\catcode`\:=12
\leftskip\@totalleftmargin\rightskip\z@
\parindent\z@\parfillskip\@flushglue\parskip\z@
\@tempswafalse\def\par{\if@tempswa\hbox{}\fi\@tempswatrue\@@par}%
\tt\obeylines\frenchspacing\xvobeyspaces\samepage}

\catcode`\@=12

{\catcode`\#=13
\gdef#{\begingroup
\catcode`\\=0 \catcode`\{=1 \catcode`\}=2 \catcode`\$=3 \catcode`\&=4
\catcode`\#=6 \catcode`\^=7 \catcode`\_=8 \catcode`\ =10\catcode`\%=14
\catcode`\~=13\catcode`\'=13\catcode`\<=13\catcode`\"=13\catcode`\|=13
\catcode`\*=13\catcode`\:=13
\catcode`\^^M=12 \Comment}}
{\catcode`\^^M=12
\gdef\Comment#1^^M{\rm \# #1 \endgroup \Newline}}
{\obeylines
\gdef\Newline{
}}

{\catcode`\&=13
\gdef&{\#}}

\gdef\|{\char`|}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  <item>: <text>
%%
%%  This formats the  paragraph  <text>, i.e.,  everything between  the colon
%%  '\:' and the next  empty  line, indented 1 cm to the right in the printed
%%  manual and is displayed  unchanged in the  on-screen documentation.  This
%%  convention should be  used to format  a list or an enumeration.    <item>
%%  should be  a single  word  or a short phrase.  It  may contain  all usual
%%  characters and the usual formatting stuff.  <text> is a  normal paragraph
%%  and may contain everything.   \:  can be used  to enter a colon character
%%  into the text.  As  an example consider the  following description.  This
%%  will print quite similar in the printed manual.
%%
%%      A group is represented by a record that must have the components
%%
%%      'generators': \\
%%              a list of group elements that  generate  the  group  that  is
%%              given by the group record.
%%
%%      'identity': \\
%%              the identity element of the group that is given by the  group
%%              record.
%%
\catcode`\:=13
\gdef:{\hangafter=1\hangindent=1cm\hspace{1cm}{}}
\gdef\:{\char`:}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  \GAP
%%
%%  \GAP can be used to enter the *sans serif* GAP logo  into  the  text.  If
%%  this is followed by spaces it should be enclosed in curly  braces  as  in
%%  |{\GAP}| is wonderful.
%%
\newcommand{\GAP}{{\sf GAP}}
\newcommand{\CAS}{{\sf CAS}}
\newcommand{\ATLAS}{{\sf ATLAS}}
\newcommand{\Z}{\mbox{$Z\!\!\! Z$}}
\newcommand{\Q}{\mbox{$Q\mskip-11mu\prime\,\,$}}

\newcommand{\semidirect}{\hspace{0.3em}\rule[0.03em]{0.05em}{0.45em}
                         \hspace{-0.35em} \times }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  make the title page
%%
\begin{document}

\title{
{\Huge XMOD}  \\
  \mbox{}     \\
A brief introduction\\
  \mbox{}     \\
Crossed Modules and Cat1-Groups in GAP\\
  \mbox{}     \\
Version 1.3
}
\author{Chris Wensley \& Murat Alp\\
School of Mathematics,\\
University of Wales, Bangor,\\
Gwynedd, LL57 1UT, U.K.}
\date{10th January 1997}

\maketitle


\section{About XMOD}

This document is a brief introduction to a package for the {\GAP}
group theory language which enables computations with the 
equivalent notions of finite, permutation
{\em crossed modules} and {\em cat1-groups}.

The package divides into six parts, each of which has its own 
introduction, and it is these sections from the full manual
which are included here.

The first part is concerned with the standard constructions for crossed
modules and their morphisms, direct products, image and kernel of a morphism,
normal sub-crossed modules and quotients.

The second part contains functions for constructing cat1-groups
and their morphisms and for converting between cat1-groups and
crossed modules.

The third part deals with the equivalent notions of
derivation for a crossed module and section for a cat1-group,
and the monoids which they form under the Whitehead multiplication.

The fourth part deals with actor crossed modules and actor cat1-groups.
These are the automorphism objects in the appropriate categories.
For the actor crossed module ${\rm Act}({\cal X})$ of a
crossed module ${\cal X}$ we require permutation representations
for the Whitehead group of regular derivations of ${\cal X}$
and for the group of automorphisms of ${\cal X}$.
The construction also provides an inner morphism from  ${\cal X}$  
to  ${\rm Act}({\cal X})$  whose kernel is the centre of ${\cal X}$.

The fifth part implements induced constructions.
A morphism of crossed modules factors naturally through
an induced crossed module and an equivalent factorisation
holds for a morphism of cat1-groups.
These constructions also have applications to algebraic topology,
which was where crossed modules were first defined.

The final part contains a set of utility functions,
in particular functions for isomorphic pairs of groups.

The package may be obtained as a compressed file by ftp from one of 
the sites with a {\GAP} archive.  After decompression,
instructions for installing the package may be found in the |README| file.

The following constructions are planned for the next version of the package.
Firstly, although sub-crossed module functions have been included,
the equivalent set of sub-cat1-groups functions is not complete.
Secondly, functions for pre-crossed modules, the Peiffer subgroup of a
pre-crossed module and the associated crossed modules, will be added.
Group-graphs provide examples of pre-crossed modules and their
implementation will require interaction with graph-theoretic
functions in {\GAP}.
Just as crossed modules may be thought of as $2$-dimensional groups, so
crossed squares and the equivalent cat2-groups are the structures
which arise as $3$-dimensional groups.  
Examples of these are implicitly included already, namely inclusions of normal 
sub-crossed modules, and the inner morphism from a crossed module to its actor.


\section{About crossed modules}
\index{About!for crossed modules}

The term crossed module was introduced by J. H. C. Whitehead in 
\cite{W2}, \cite{W1}.
In \cite{L1} Loday reformulated the notion of a 
crossed module as a cat1-group.
Norrie \cite{N1}, \cite{N2} and Gilbert \cite{G1} have studied
derivations, automorphisms of crossed modules and the actor 
of a crossed module, while
Ellis \cite{E1} has investigated higher dimensional analogues.
Properties of induced crossed modules have been determined by 
Brown, Higgins and Wensley in \cite{BH1}, \cite{BW1} and \cite{BW2}.
For further references see \cite{AW1} where we discuss some of the
data structures and algorithms used in this package, and also tabulate
isomorphism classes of cat1-groups up to size $30$.

We first recall the descriptions of three equivalent categories\: ~
\textbf{XMod}, the category of crossed modules and their morphisms; ~
\textbf{Cat1}, the category of cat1-groups and their morphisms; and ~
\textbf{GpGpd}, the subcategory of group objects in the category
\textbf{Gpd} of groupoids.
We also include functors between these categories which exhibit
the equivalences.
Most papers on crossed modules use left actions, but we give the
alternative right action axioms here, which are more suitable for
use in computational group theory programs.

A crossed module  ${\cal X} = (\partial \: S \to R )$ 
consists of a group homomorphism $\partial $, 
called the {\em boundary} of $\mathcal{X}$, 
with {\em source} $S$  and {\em range} $R$,
together with an action 
$\alpha \: R \to \mathrm{Aut}(S)$ satisfying,  
for all $s,s_1,s_2 \in S$  and  $r \in R$,
\begin{center}
\begin{tabular}{c r c l }
\textbf{XMod\ 1\:} &  $\partial(s^r)$   &  =  &  $r^{-1} (\partial s) r$ \\
\textbf{XMod\ 2\:} &  $s_1^{\partial s_2}$  &  =  &  $s_2^{-1}s_1 s_2$.
\end{tabular}
\end{center}
The kernel of  $\partial$  is abelian.


The standard constructions for crossed modules are as follows:

\begin{enumerate}
\item A {\em conjugation crossed module}
      is an inclusion of a normal subgroup  $S \unlhd R$,
      where $R$ acts on $S$ by conjugation.
\item A {\em central extension crossed module} has as boundary a surjection
      $\partial \: S \to R$ with central kernel,
      where $r \in R$ acts on $S$ by conjugation with $\partial^{-1}r$.
\item An {\em automorphism crossed module} has as range a subgroup $R$
      of the automorphism group  $\mbox{Aut}(S)$  of  $S$
      which contains the inner automorphism group of $S$.
      The boundary maps $s \in S$  to the inner automorphism of $S$ by $s$.
\item A {\em trivial action crossed module}  $\partial \: S \to R$
      has  $s^r = s$  for all  $s \in S, \; r \in R$,  
      the source is abelian
      and the image lies in the centre of the range.
\item An {\em R-Module crossed module} has an $R$-module as source
      and the zero map as boundary.
\item The direct product  ${\cal X}_{1} \times {\cal X}_{2}$
      of two crossed modules has source  $S_1 \times S_2$,
      range  $R_1 \times R_2$  and boundary
      $\partial_1 \times \partial_2$,  with  $R_1,\ R_2$  acting
      trivially on  $S_2,\ S_1$  respectively.
\end{enumerate}

A morphism between two crossed modules 
${\cal X}_{1} = (\partial_1 \: S_1 \to R_1)$ and  
${\cal X}_{2} = (\partial_2 \: S_2 \to R_2)$ 
is a pair  $(\sigma, \rho)$, where 
$ \sigma \: S_1 \to S_2$ and $ \rho \: R_1 \to R_2$ 
are homomorphisms satisfying
$$
\partial_2 \sigma = \rho \partial_1, \; \;
\sigma(s^r) = (\sigma s)^{\rho r}.
$$
When ${\cal X}_{1} = {\cal X}_{2}$
and $ \sigma, \rho $ are automorphisms then 
$(\sigma, \rho)$  is an automorphism of ${\cal X}_1$. 
The group of automorphisms is denoted 
by $\mathrm{Aut}({\cal X}_1 ).$ 


In this implementation a crossed module  |X|  is a record with fields:

\begin{tabular}{ll}
|X.source|,     & the source $S$ of $\partial$,       \\
|X.boundary|,   & the homomorphsim $\partial$,        \\
|X.range|,      & the range $R$ of $\partial$,        \\
|X.aut|,        & a group of automorphisms of $S$,    \\
|X.action|,     & a homomorphism from $R$ to |X.aut|, \\
|X.isXMod|,     & a boolean flag, normally |true|,    \\
|X.isDomain|,   & always true,                        \\
|X.operations|, & special set of operations 'XModOps' \\
|X.name|,       & a concatenation of the names of the source and range.
\end{tabular}

Here is a simple example of an automorphism crossed module, 
the holomorph of the cyclic group of size five.

|    gap> c5 := CyclicGroup( 5 );;   c5.name := "c5";;
    gap> X1 := AutomorphismXMod( c5 );
    Crossed module [c5->PermAut(c5)]
    gap> XModPrint( X1 );
    Crossed module [c5->PermAut(c5)] :- 
    : Source group c5 has generators:
      [ (1,2,3,4,5) ]
    : Range group = PermAut(c5) has generators:
      [ (1,2,4,3) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,4,3) --> { source gens --> [ (1,3,5,2,4) ] }
      This automorphism generates the group of automorphisms.    |


Implementation of the standard constructions is described in sections
|ConjugationXMod|, |CentralExtensionXMod|, 
|AutomorphismXMod|, |TrivialActionXMod| and |RModuleXMod|.
With these building blocks, sub-crossed modules |SubXMod|,
quotients of normal sub-crossed modules |FactorXMod|
and direct products |XModOps.DirectProduct| may be constructed.
An extra function  |XModSelect|  is used to call these constructions
using groups of order up to $47$ and data from file in |Cat1List|.

A morphism from a crossed module ${\cal X}_1$ to a crossed module 
${\cal X}_2$  is a pair of homomorphisms  $(\sigma, \rho)$,  
where  $\sigma, \rho$
are respectively homomorphisms between the sources and ranges
of  ${\cal X}_1$  and  ${\cal X}_2$,  
which commute with the two boundary maps
and which are morphisms for the two actions.
In the following code we construct a simple automorphism of |X1|.

|    gap> sigma1 := GroupHomomorphismByImages( c5, c5, [ (1,2,3,4,5) ]
            [ (1,5,4,3,2) ] );;
    gap> rho1 := InclusionMorphism( X1.range, X1.range );;
    gap> mor1 := XModMorphism( X1, X1, [ sigma1, rho1 ] );
    Morphism of crossed modules [c5->PermAut(c5)] >-> [c5->PermAut(c5)]>
    gap> IsXModMorphism( mor1 );
    true
    gap> XModMorphismPrint( mor1 );
    Morphism of crossed modules :- 
    : Source = Crossed module [c5->PermAut(c5)] with generating sets:
      [ (1,2,3,4,5) ]
      [ (1,2,4,3) ]
    : Range = Source
    : Source Homomorphism maps source generators to:
      [ (1,5,4,3,2) ]
    : Range Homomorphism maps range generators to:
      [ (1,2,4,3) ]
    : isXModMorphism? true
    gap> IsAutomorphism( mor1 );
    true  |

The functors between \textbf{XMod} and \textbf{Cat1}, 
are implemented as functions  |XModCat1| and |Cat1XMod|.

An integer variable 'XModPrintLevel' is set initially equal to '1'.
If it is increased, additional information is printed out during
the execution of many of the functions.

\newpage



\section{About cat1-groups}%

In \cite{L1} Loday reformulated the notion of a 
crossed module as a cat1-group, 
namely a group $G$ with a pair of homomorphisms $t,h \: G \to G$
having  a common image $R$ and satisfying certain axioms.
We find it convenient to define a cat1-group 
${\cal C} = (e;t,h \: G \to R )$  as having source group  $G$,
range group $R$,  and three homomorphisms\: \  two surjections  
$t,h \: G \to R$  and an embedding  $e \: R \to G$  satisfying\:
\begin{center}
\begin{tabular}{r l}
\textbf{Cat\ 1\:}  &  $te = he = \mathrm{id}_R $, \\
\textbf{Cat\ 2\:}  &  $[\ker t, \ker h] = \{ 1_G \}$.
\end{tabular}
\end{center}
It follows that  $teh = h, \; het = t, \; tet = t, \; heh = h$.


The maps  $t,h$  are often referred to as the {\em source} and {\em target},
but we choose to call them the
{\em tail} and {\em head} of  ${\cal C}$, 
because {\em source} is the {\GAP} term for the domain of a function.

A morphism  ${\cal C}_1 \to {\cal C}_2$  
of cat1-groups is a pair  $(\gamma, \rho)$  where
$\gamma \: G_1 \to G_2$  and  $\rho \: R_1 \to R_2$  
are homomorphisms satisfying
$$
h_2 \gamma = \rho h_1, \;\; t_2 \gamma = \rho t_1, \;\; e_2 \rho = \gamma e_1.
$$


In this implementation a cat1-group $ {\cal C}$ 
is a record with the following fields\:

\begin{tabular}{ll}
|C.source|,     & the source 'G',                                      \\
|C.range|,      & the range 'R',                                       \\
|C.tail|,       & the tail homomorphism 't',                           \\
|C.head|,       & the head homomorphism 'h',                           \\
|C.embedRange|, & the embedding of 'R' in 'G',                         \\
|C.kernel|,     & a permutation group isomorphic to the kernel of 't', \\
|C.embedKernel|,& the inclusion of the kernel in 'G',                \\
|C.boundary|,   & the restriction of 'h' to the kernel,                \\
|C.isDomain|,   & set 'true',                                          \\
|C.operations|, & a special set of operations 'Cat1Ops'                \\
|C.name|,       & a concatenation of the names of the source and range.\\
|C.isCat1| & a boolean flag, normally |true|.
\end{tabular}

The following listing shows a simple example\:

|    gap> s3c4gen := s3c4.generators;
    [ (1,2), (2,3), (4,5,6,7) ]
    gap> t1 := GroupHomomorphismByImages( s3c4, s3, s3c4gen,
          [ (1,2), (2,3), () ] );;
    gap> C1 := Cat1( s3c4, t1, t1 );
    cat1-group [s3c4 ==> s3] 
    gap> Cat1Print( C1 );
    cat1-group [s3c4 ==> s3] :- 
    : source group has generators:
      [ (1,2), (2,3), (4,5,6,7) ]
    :  range group has generators:
      [ (1,2), (2,3) ]
    : tail homomorphism maps source generators to:
      [ ( 1, 2), ( 2, 3), () ]
    : head homomorphism maps source generators to:
      [ ( 1, 2), ( 2, 3), () ]
    : range embedding maps range generators to:
      [ (1,2), (2,3) ]
    : kernel has generators:
      [ (4,5,6,7) ]
    : boundary homomorphism maps generators of kernel to:
      [ () ]
    : kernel embedding maps generators of kernel to:
      [ (4,5,6,7) ]  |


The category of crossed modules is equivalent to the category of cat1-groups,
and the functors between these two categories may be described as follows.

Starting with the crossed module 
${\cal X} = (\partial \: S \to R)$ the group $ G $ is defined 
as the semidirect product $ G = R \semidirect S$
using the action from  ${\cal X}$.
The structural morphisms are given by
$$
t(r,s) = r, \; h(r,s) = r (\partial s), \; er = (r,1).
$$

On the other hand, starting with a cat1-group 
$ {\cal C} = (e;t,h \: G \to R)$  we define 
$ S = \ker t$, the range $R$ remains unchanged and 
$ \partial = h\mid_S $.
The action of  $R$  on  $S$  is conjugation in  $S$  via the embedding
of  $R$  in  $G$.

|    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> CX1 := Cat1XMod(X1);
    cat1-group [Perm(PermAut(c5) |'\|'|X c5) ==> PermAut(c5)] 
    gap> CX1.source.generators;
    [ (2,3,5,4), (1,2,3,4,5) ]
    gap>
    gap> XC1 := XModCat1( C1 );
    Crossed module [ker([s3c4 ==> s3])->s3]
    gap> WhatTypeXMod( XC1 );
    [ " triv, ", " zero, ", " RMod, " ]  |



\section{About derivations and sections}%

The Whitehead monoid  $\rm{Der}({\cal X})$  of  ${\cal X}$ 
was defined in \cite{W2} 
to be the monoid of all {\it derivations}
from $ R $ to $S$, that is the set of all maps  $R \to S$,
with composition  $\ \circ \ $, satisfying
\begin{center}
\begin{tabular}{c r c l }
\textbf{Der\ 1\:}  &  $\chi(qr)$              &  = 
           & $(\chi q)^{r} \; (\chi r)$  \\
\textbf{Der\ 2\:}  &  $(\chi_1 \circ \chi_2)(r)$  &  =
           & $(\chi_1 r)(\chi_2 r)(\chi_1 \partial \chi_2 r)$. 
\end{tabular}
\end{center}

\noindent
The zero map is the identity for this composition.
Invertible elements in the monoid are called {\em regular}.
The Whitehead group of ${\cal X}$ 
is the group of regular derivations in $\rm{Der}({\cal X} )$. 
In the next section the {\em actor} of ${\cal X}$ 
is defined as a crossed module whose source and range are permutation 
representations of the Whitehead group and the automorphism group of 
${\cal X}$.

The construction for cat1-groups equivalent to the derivation of a
crossed module is the {\em section}. 
The monoid of sections of  ${\cal C}$  is the set of group homomorphisms
$\xi \: R \to G$, with composition  $\ \circ \ $,  satisfying\:
\begin{center}
\begin{tabular}{l l}
\textbf{Sect\ 1\:}  &  $t \xi = \mathrm{id}_R$,               \\
\textbf{Sect\ 2\:}  &  $(\xi_1 \circ \xi_2)(r) =
                       (\xi_{2}r)(e h \xi_{2}r)^{-1}(\xi_{1} h \xi_{2}r)$.
\end{tabular}
\end{center}
The embedding  $e$  is the identity for this composition,
and  $h(\xi_1 \circ \xi_2) = (h \xi_1)(h \xi_2)$.
A section is  {\em regular}  when  $h \xi$  is an automorphism and,
of course, the group of regular sections is isomorphic to the
Whitehead group.

Derivations are stored like group homomorphisms by specifying the images
of a generating set.  Images of the remaining elements may then be
obtained using axiom  \textbf{Der\ 1}.  The function |IsDerivation|
is automatically called to check that this procedure is well-defined.

|    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> chi1 := XModDerivationByImages( X1, [ () ] );
    XModDerivationByImages( PermAut(c5), c5, [ (1,2,4,3) ], [ () ] )
    gap> IsDerivation( chi1 );
    true  |

A derivation is stored as a record |chi| with fields\:

\begin{tabular}{ll}
|chi.source|,      & the range group $R$ of ${\cal X}$,         \\
|chi.range|,       & the source group $S$ of ${\cal X}$,        \\
|chi.generators|,  & a fixed generating set for $R$,            \\
|chi.genimages|,   & the chosen images of the generators,       \\
|chi.xmod|,        & the crossed module ${\cal X}$,             \\
|chi.operations|,  & special set of operations |XModDerivationByImagesOps|, \\
|chi.isDerivation|,& a boolean flag, normally |true|.
\end{tabular}

Sections \emph{are} group homomorphisms, and are stored as such, but with
a modified set of operations  |Cat1SectionByImagesOps|  which includes
a special |.Print| function to display the section in the manner shown below.
Functions |SectionDerivation| and |DerivationSection| convert derivations to 
sections, and vice-versa, calling |Cat1XMod| and |XModCat1| automatically.

The equation   $\xi r = (er)(\chi r)$   determines a section   
$\xi$  of  $\mathcal{C}$,  given a derivation  $\chi$  of
$\mathcal{X}$, and conversely.

|    gap> xi1 := SectionDerivation( chi1 );
    Cat1SectionByImages( PermAut(c5), Perm(PermAut(c5) |'\|'|X c5),
        [ (1,2,4,3) ], [ (2,3,5,4) ] )
    gap> xi1.cat1;
    cat1-group [Perm(PermAut(c5) |'\|'|X c5) ==> PermAut(c5)]  |

There are two functions to determine all the elements of the Whitehead group 
and the Whitehead monoid of ${\cal X}$,
namely  |RegularDerivations| and |AllDerivations|.  
If the whole monoid is needed at some stage, then the latter function 
should be used.  
A field  |D = X.derivations|  is created which stores all the required 
information\:

\begin{tabular}{ll}
|D.areDerivations|,  & a boolean flag, normally |true|,                    \\
|D.isReg|,           & |true| when only the regular derivations are known, \\
|D.isAll|,           & |true| when all the derivations have been found,    \\
|D.generators|,      & a \emph{copy} of |R.generators|,                    \\
|D.genimageList|,    & a list of |.genimages| lists for the derivations,   \\
|D.regular|,         & the number of regular derivations (if known),       \\
|D.xmod|,            & the crossed module ${\cal X}$,                      \\
|D.operations|,      & a special set of operations |XModDerivationsOps|.
\end{tabular}

Using our standard example |X1| we find that there are just five derivations,
all of them regular, so the associated group is cyclic of size 5.

|    gap> RegularDerivations( X1 );
    RegularDerivations record for crossed module [c5->PermAut(c5)],
    : 5 regular derivations, others not found.
    gap> AllDerivations( X1 );
    AllDerivations record for crossed module [c5->PermAut(c5)],
    : 5 derivations found but unsorted.
    gap> DerivationsSorted( X1 );
    true
    gap> imder1 := X1.derivations.genimageList;
    [ [()], [(1,2,3,4,5)], [(1,3,5,2,4)], [(1,4,2,5,3)], [(1,5,4,3,2)] ] |

The functions |RegularSections| and |AllSections| perform corresponding 
tasks for a cat1-group.
Two strategies for calculating derivations and sections are implemented,
see \cite{AW1}.
The default method for |AllDerivations| is to search for all possible
sets of images using a backtracking procedure, and when all the derivations
are found it is not known which are regular.
The function |DerivationsSorted| sorts the |.genImageList| field, placing
the regular ones at the top of the list and adding the |.regular| field.
The default method for |AllSections( C )| computes all endomorphisms
on the range group |R| of |C| as possibilities for the composite $h\xi$.
A backtrack method then finds possible images for such a section.
When either the set of derivations or the set of sections already exists, 
the other set is computed using |SectionDerivation| or |DerivationSection|.

|    gap> CX1 := Cat1XMod( X1 );
    cat1-group [Perm(PermAut(c5) |'\|'|X c5) ==> PermAut(c5)] 
    gap> CX1.source.name := "Hol(c5)";; Cat1Name( CX1 );
    gap> RegularSections( CX1 );
    RegularSections record for cat1-group [Hol(c5) ==> PermAut(c5)],
    : 5 regular sections, others not found.
    gap> CX1.sections.genimageList;
    [ [(2,3,5,4)], [(1,2,4,3)], [(1,3,2,5)], [(1,4,5,2)], [(1,5,3,4)] ]  |

The derivation images and the composition table may be listed as follows.

|    gap> chi2 := XModDerivationByImages( X1, imder1[2] ); 
    XModDerivationByImages( PermAut(c5), c5, [(1,2,4,3)], [(1,2,3,4,5)] )
    gap> DerivationImage( chi2, (1,4)(2,3) );
    ( 1, 4, 2, 5, 3)
    gap> DerivationImages( chi2 );
    [ 1, 2, 3, 4 ]

    gap> PrintList( DerivationTable( X1 ) )
    [ 1, 1, 1, 1 ]
    [ 1, 2, 3, 4 ]
    [ 1, 3, 5, 2 ]
    [ 1, 4, 2, 5 ]
    [ 1, 5, 4, 3 ]

    gap> PrintList( WhiteheadGroupTable( X1 ) );
    [ 1, 2, 3, 4, 5 ]
    [ 2, 3, 4, 5, 1 ]
    [ 3, 4, 5, 1, 2 ]
    [ 4, 5, 1, 2, 3 ]
    [ 5, 1, 2, 3, 4 ]  |


Each  $\chi$  or  $\xi$  determines endomorphisms of  
$R, S, G, {\cal X}$ and ${\cal C}$, namely\:
\begin{center}
\begin{tabular}{rccl}
    $\rho$  &  \:  &  $R \to R,$ 
                  &  $r \mapsto r(\partial \chi r) = h \xi r$,  \\
  $\sigma$  &  \:  &  $S \to S,$
                  &  $s \mapsto s(\chi \partial s)$,            \\
  $\gamma$  &  \:  &  $G \to G,$
                  &  $g \mapsto (eh \xi tg)(\xi tg^{-1})g(ehg^{-1})(\xi hg)$,\\
  $(\sigma,\rho)$ & \:  & ${\cal X} \to {\cal X},$              \\
  $(\gamma,\rho)$ & \:  & ${\cal C} \to {\cal C}$.
\end{tabular}
\end{center}

When these endomorphisms are automorphisms, the derivation is regular.  
When the boundary of ${\cal X}$ is the zero map,
both $\sigma$ and $\rho$ are identity homomorphisms, 
and every derivation is regular, which is the case in this example.

|    gap> sigma2 := SourceEndomorphismDerivation( chi2 );
    GroupHomomorphismByImages( c5, c5, [ (1,2,3,4,5) ], [ (1,2,3,4,5) ] )
    gap> rho2 := RangeEndomorphismDerivation( chi2 );
    GroupHomomorphismByImages( PermAut(c5), PermAut(c5), [ (1,2,4,3) ], 
       [ (1,2,4,3) ] )
    gap> xi2 := SectionDerivation( chi2 );;
    gap> gamma2 := SourceEndomorphismSection( xi2 );
    GroupHomomorphismByImages( Hol(c5), Hol(c5), [(2,3,5,4),(1,2,3,4,5)],
       [(2,3,5,4),(1,2,3,4,5)] )
    gap> mor2 := XModMorphism( X1, X1, [sigma2,rho2] );
    Morphism of crossed modules <[c5->PermAut(c5)] >-> [c5->PermAut(c5)]>
    gap> mu2 := Cat1Morphism( CX1, CX1, [gamma2,rho2] );
    Morphism of cat1-groups <[Hol(c5) ==> PermAut(c5)]-->
       [Hol(c5) ==> PermAut(c5)]>  |



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{About actors}


The \emph{actor} of ${\cal X}$  is a crossed module
$(\Delta \: {\cal W}({\cal X}) \to {\rm Aut}({\cal X}))$
which was shown by Lue and Norrie, in \cite{N2} and \cite{N1} to give
the automorphism object of a crossed module ${\cal X}$.
The source of the actor is a permutation representation $W$ 
of the Whitehead group of regular derivations and the range is a 
permutation representation $A$ of the automorphism group 
${\rm Aut}({\cal X})$ of ${\cal X}$.

An automorphism $( \sigma, \rho )$ of |X| acts on the Whitehead monoid by
$\chi^{(\sigma,\rho)} = \sigma^{-1} \chi \rho$, and this action
determines the action for the actor.

In fact the four groups $R, S, W, A$,  the homomorphisms between them
and the various actions, form five crossed modules\:

\begin{tabular}{rcll}
   ${\cal X}$ &\:& $S \to R$  &  the initial crossed module,                 \\
${\cal W(X)}$ &\:& $S \to W$  &  the Whitehead crossed module of ${\cal X}$, \\
${\cal L(X)}$ &\:& $S \to A$  &  the Lue crossed module of ${\cal X}$,       \\
${\cal N(X)}$ &\:& $R \to A$  &  the Norrie crossed module of ${\cal X}$, and \\
${\rm Act}({\cal X})$ &\:& $W \to A$  &  the actor crossed module of ${\cal X}$.
\end{tabular}

These $5$ crossed modules, together with the evaluation  
$W \times R \to S, \ \ (\chi,r) \mapsto \chi r$, 
form a crossed square\:

|                        S ------ WX ------> W
                        :  \                :
                        :     \             :
                        X        LX        ActX
                        :           \       :
                        :              \    :
                        V                 \ V
                        R ------ NX ------> A  |

in which pairs of boundaries or identity mappings
provide six morphisms of crossed modules.
In particular, the boundaries of |WX| and |NX| form the
\emph{inner morphism} of |X|, mapping source elements to inner derivations
and range elements to inner automorphisms.  The image of |X| under this
morphism is the \emph{inner actor} of |X|, while the kernel 
is the \emph{centre} of |X|.

In the example which follows, using the usual |(X1 : c5 -> Aut(c5))|,
\ |Act(X1)|  is isomorphic to  |X1|  and to  |LX1|  
while the Whitehead and Norrie boundaries are identity homomorphisms.

|    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> WGX1 := WhiteheadPermGroup( X1 );
    WG([c5->PermAut(c5)])
    gap> WGX1.generators;
    [ (1,2,3,4,5) ]
    gap> AX1 := AutomorphismPermGroup( X1 );
    PermAut([c5->PermAut(c5)])
    gap> AX1.generators;
    [ (1,2,4,3) ]
    gap> XModMorphismAutoPerm( X1, AX1.generators[1] );
    Morphism of crossed modules <[c5->PermAut(c5)] >-> [c5->PermAut(c5)]>

    gap> WX1 := Whitehead( X1 );
    Crossed module Whitehead[c5->PermAut(c5)]
    gap> NX1 := Norrie( X1 );
    Crossed module Norrie[c5->PermAut(c5)]
    gap> LX1 := Lue( X1 );
    Crossed module Lue[c5->PermAut(c5)]
    gap> ActX1 := Actor( X1 );;
    gap> XModPrint( ActX1);
    Crossed module Actor[c5->PermAut(c5)] :- 
    : Source group WG([c5->PermAut(c5)]) has generators:
      [ (1,2,3,4,5) ]
    : Range group has parent ( PermAut(c5)xPermAut(PermAut(c5)) )
        and has generators:  [ (1,2,4,3) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,4,3) --> { source gens --> [ (1,3,5,2,4) ] }
      This automorphism generates the group of automorphisms.

    gap> InActX1 := InnerActor( X1 );
    Crossed module Actor[c5->PermAut(c5)]
    gap> InActX1 = ActX1;
    true
    gap> InnerMorphism( X1 );
    Morphism of crossed modules
        <[c5->PermAut(c5)] >-> Actor[c5->PermAut(c5)])>
    gap> Centre( X1 );
    Crossed module Centre[c5->PermAut(c5)]  |

All of these constructions are stored in a sub-record |X1.actorSquare|.


\section{About induced constructions}%

A morphism of crossed modules
$(\sigma, \rho) \: {\cal X}_1 \to {\cal X}_2$
factors uniquely through an induced crossed module
$\rho_{\ast} {\cal X}_1 = (\delta \: \rho_{\ast} S_1 \to R_2)$.
Similarly, a morphism of cat1-groups factors through an induced cat1-group.
Calculation of induced crossed modules of ${\cal X}$ also
provides an algebraic means of determining the homotopy $2$-type
of homotopy pushouts of the classifying space of ${\cal X}$.
For more background from algebraic topology see references in
\cite{BH1}, \cite{BW1}, \cite{BW2}.
Induced crossed modules and induced cat1-groups also provide the
building blocks for constructing pushouts in the categories
\textbf{XMod} and \textbf{Cat1}.

Data for the cases of algebraic interest is provided by a conjugation
crossed module  ${\cal X} = (\partial \: S \to R)$
and a homomorphism  $\iota$  from  $R$  to a third group  $Q$.
The output from the calculation is a crossed module
$\iota_{\ast}{\cal X} = (\delta \: \iota_{\ast}S \to Q)$
together with a morphism of crossed modules
${\cal X} \to \iota_{\ast}{\cal X}$.
When $\iota$ is a surjection with kernel $K$ then
$\iota_{\ast}S = [S,K]$ (see \cite{BH1}).
When $\iota$ is an inclusion the induced crossed module may be
calculated using a copower construction \cite{BW1} or,
in the case when $R$ is normal in $Q$, as a coproduct of crossed modules 
(\cite{BW2}, but not yet implemented).
When $\iota$ is neither a surjection nor an inclusion, $\iota$
is written as the composite of the surjection onto the image
and the inclusion of the image in $Q$, and then the composite induced
crossed module is constructed.

These constructions require modifications to some of the Tietze 
transformation routines in |fptietze.g|.
These have yet to be released as part of the {\GAP} library
and so are made available in this package in file |felsch.g|,
but are not documented here.

As a simple example we take for ${\cal X}$ the conjugation crossed
module $(\partial \: c4 \to d8)$ and for $\iota$ the inclusion of
$d8$ in $d16$.  The induced crossed module has $c4 \times c4$
as source.

|    gap> d16 := DihedralGroup( 16 );  d16.name := "d16";;
    Group( (1,2,3,4,5,6,7,8), (2,8)(3,7)(4,6) )
    gap> d8 := Subgroup( d16, [ (1,3,5,7)(2,4,6,8), (1,3)(4,8)(5,7) ] );;
    gap> c4 := Subgroup( d8, [ (1,3,5,7)(2,4,6,8) ] );;
    gap> d8.name :=  "d8";;  c4.name := "c4";;
    gap> DX := ConjugationXMod( d8, c4 );
    Crossed module [c4->d8]
    gap> iota := InclusionMorphism( d8, d16 );;
    gap> IDXincl := InducedXMod( DX, iota );

    Action of RQ on generators of I :- 
      (1,2,3,4,5,6,7,8) : (1,4)(2,3)
      (2,8)(3,7)(4,6) : (1,2)(3,4)

    |\#|I  Protecting the first 1 generators.
    |\#|I  there are 2 generators and 3 relators of total length 12
    partitioning the generators: [ [ 2 ], [ 1 ] ]
    Simplified presentation for I :- 
    |\#|I  generators: [ fI.1, fI.3 ]
    |\#|I  relators:
    |\#|I  1.  4  [ 1, 1, 1, 1 ]
    |\#|I  2.  4  [ 2, 2, 2, 2 ]
    |\#|I  3.  4  [ 2, -1, -2, 1 ]

     I has Size: 16
    **************** 
    Group is abelian 
    factor 1 is abelian with invariants: [ 4 ]
    factor 2 is abelian with invariants: [ 4 ]
    Image of I has index 4 in RQ and is generated by :   
    [ ( 1, 3, 5, 7)( 2, 4, 6, 8), ( 1, 7, 5, 3)( 2, 8, 6, 4) ]

    gap> XModPrint( IDXincl );
    Crossed module [i*(c4)->d16] :- 
    : Source group i*(c4) has generators:
      [ ( 1, 2, 4, 7)( 3, 5, 8,11)( 6, 9,12,14)(10,13,15,16), 
        ( 1, 3, 6,10)( 2, 5, 9,13)( 4, 8,12,15)( 7,11,14,16) ]
    : Range group = d16 has generators:
      [ (1,2,3,4,5,6,7,8), (2,8)(3,7)(4,6) ]
    : Boundary homomorphism maps source generators to:
      [ ( 1, 3, 5, 7)( 2, 4, 6, 8), ( 1, 7, 5, 3)( 2, 8, 6, 4) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3,4,5,6,7,8) --> { source gens --> 
    [ ( 1,10, 6, 3)( 2,13, 9, 5)( 4,15,12, 8)( 7,16,14,11), 
      ( 1, 7, 4, 2)( 3,11, 8, 5)( 6,14,12, 9)(10,16,15,13) ] }
      (2,8)(3,7)(4,6) --> { source gens --> 
    [ ( 1, 7, 4, 2)( 3,11, 8, 5)( 6,14,12, 9)(10,16,15,13), 
      ( 1,10, 6, 3)( 2,13, 9, 5)( 4,15,12, 8)( 7,16,14,11) ] }
      These 2 automorphisms generate the group of automorphisms.
    : Kernel of the crossed module has generators:
      [ ( 1, 5,12,16)( 2, 8,14,10)( 3, 9,15, 7)( 4,11, 6,13) ]
    : Induced XMod from Crossed module [c4->d8]  with source morphism:
      [ (1,3,5,7)(2,4,6,8) ]
       --> [ ( 1, 2, 4, 7)( 3, 5, 8,11)( 6, 9,12,14)(10,13,15,16) ]  |



\section{About utilities}

By a utility function we mean a {\GAP} function which is\:
\begin{itemize}
\item needed by other functions in this package,
\item not (as far as we know) provided by the standard {\GAP} library,
\item more suitable for inclusion in the main library than in this package.
\end{itemize}

The first two utilities give particular group homomorphisms,
|InclusionMorphism(H,G)| and |ZeroMorphism(G,H)|.
We often prefer

|    gap> InclusionMorphism( s3, s3 );
    IdentityMapping( s3 )
    gap> last.genimages;
    [ (1,2), (2,3) ]  |

to |IdentityMapping(s3)| because the latter does not provide the
|.generators| and the |.genimages| fields which many of the functions 
in this package expect homomorphisms to possess.

The second set of utilities involve endomorphisms and automorphisms of 
groups.  For example\:

|    gap> end8 := EndomorphismClasses( d8 );;
    gap> RecFields( end8 );
    [ "isDomain", "isEndomorphismClasses", "areNonTrivial", "classes",
      "intersectionFree", "group", "latticeLength", "latticeReps" ]
    gap> Length( end8.classes );
    11
    gap> end8.classes[3];
    rec(
      quotient := d8.Q3,
      projection := OperationHomomorphism( d8, d8.Q3 ),
      autoGroup := Group( IdentityMapping( d8.Q3 ) ),
      rangeNumber := 2,
      isomorphism := GroupHomomorphismByImages( d8.Q3, d8.H2, [ (1,2) ], 
        [ (1,5)(2,6)(3,7)(4,8) ] ),
      conj := [ () ] )
    gap> innd8 := InnerAutomorphismGroup( d8 );
    Inn(d8)
    gap> innd8.generators;
    [ InnerAutomorphism( d8, (1,3,5,7)(2,4,6,8) ), 
      InnerAutomorphism( d8, (1,3)(4,8)(5,7) ) ]
    gap> IsAutomorphismGroup( innd8 );
    true   |

The third set of functions construct isomorphic pairs of groups,
where a faithful permutation representation of a given type of group 
is constructed.  Types covered include finitely presented groups,
groups of automorphisms and semidirect products.  
A typical pair record includes the following fields\:

\begin{tabular}{ll}
.type         &  the given group $G$,                \\
.perm         &  the permutation representation $P$, \\
.t2p          &  the isomorphism  $G \to P$,         \\
.p2t          &  the inverse isomorphism  $P \to G$, \\
.isTypePair   &  a boolean flag, normally |true|.
\end{tabular}

The inner automorphism group of the dihedral group |d8| is 
isomorphic to |k4|\:

|    gap> Apair := AutomorphismPair( innd8 );
    rec(
      auto := Inn(d8),
      perm := PermInn(d8),
      a2p := OperationHomomorphism( Inn(d8), PermInn(d8) ),
      p2a := GroupHomomorphismByImages( PermInn(d8), Inn(d8), [(1,3),(2,4)],
        [ InnerAutomorphism( d8, (1,3,5,7)(2,4,6,8) ), 
          InnerAutomorphism( d8, (1,3)(4,8)(5,7) ) ] ),
      isAutomorphismPair := true )
    gap> IsAutomorphismPair( Apair );
    true   |

The final set of functions deal with lists of subsets of |[1..n]|
and construct systems of distinct and common representatives using
simple, non-recursive, combinatorial algorithms.
The latter function returns two lists\: \ the set of representatives, 
and a permutation of the subsets of the second list.
It may also be used to provide a common transversal
for sets of left and right cosets of a subgroup $H$ of a group $G$,
although a greedy algorithm is usually quicker.

|    gap> L := [ [1,4], [1,2], [2,3], [1,3], [5] ];;
    gap> DistinctRepresentatives( L );
    [ 4, 2, 3, 1, 5 ]
    gap> M := [ [2,5], [3,5], [4,5], [1,2,3], [1,2,3] ];;
    gap> CommonRepresentatives( L, M );
    [ [ 4, 1, 3, 1, 5 ], [ 3, 5, 2, 4, 1 ] ]
    gap> CommonTransversal( s4, c3 );
    [ (), (3,4), (2,3), (1,3)(2,4), (1,2)(3,4), (2,4), (1,4), (1,4)(2,3) ] |

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  and the bibliography
%%
\begin{sloppypar}
\bibliographystyle{alpha}
\newcommand{\ignore}[1]{}
\catcode`\'=12 \catcode`\<=12 \catcode`\*=12
\catcode`\|=12 \catcode`\:=12 \catcode`\"=12
\bibliography{manual}
\end{sloppypar}


\end{document}
