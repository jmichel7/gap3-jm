# For a Group generated by true reflections,
# check that deg(rho_chi)=q^N deg(rho_{\chi tensor sign})(q^-1)
CHEVIE.AddTest("CurtisDualityDegrees",
function(W)local q,p,i,N,ud;
  q:=X(Cyclotomics);q.name:="q";
  ud:=UnipotentCharacters(W);
  ud:=UnipotentDegrees(W,q){ud.harishChandra[1].charNumbers};
  p:=DetPerm(W);
  N:=Sum(ReflectionDegrees(W)-1);
  CHEVIE.Check.EqLists(ud{p},List(ud,x->q^N*Value(x,q^-1)),
    "ud sign permuted","computed Curtis dual ud");
end,
W->not IsSpets(W) and Set(W.EigenvaluesGeneratingReflections)=[1/2] and
  IsSpetsial(W));

# DegreesFromHC(W,[ser [,guess]])
# Checks that unipotent degrees from Harish-Chandra series no. ser of the Spets
# W agree with degrees coming from Schur elements of relative Hecke algebra
CHEVIE.AddTest("DegreesFromHC",
function(arg)local W,i,uw,hw,L,index,cusp,t,R,q,l,ud,o,aA,reldeg,
  sch,den,sgnpos,para;
  W:=arg[1];
  uw:=UnipotentCharacters(W); 
  if Length(arg)=1 then
    for i in [1..Length(uw.harishChandra)] do
      if uw.harishChandra[i].relativeType<>[] then 
        CHEVIE.Test("DegreesFromHC",W,i);
      fi;
    od;
    InfoChevie("\n   ");
    return;
  fi;
  i:=arg[2];
  hw:=uw.harishChandra[i];
  L:=ReflectionSubgroup(W,hw.levi);#ReflectionType(L);
  q:=Mvp("q"); # X(Cyclotomics) faster but no automatic roots
  index:=CycPol(GenericOrder(W,q)/GenericOrder(L,q));index.valuation:=0;
  cusp:=CycPolUnipotentDegrees(L)[FindCuspidalInLevi(hw.cuspidalName,L)];
  InfoChevie("\n   #DegreesFromHC_",ReflectionName(L),"(cusp=",
    TeXStrip(hw.cuspidalName),":",cusp,")[G:L]=",index);
  CHEVIE.Testing("(",ReflectionName(L),")");
  R:=ApplyFunc(ReflectionGroup,hw.relativeType);
# check parameters of relative algebra by the formula
# u_{s,j}=\zeta_s^j  q^(([a+A]_\rho_{det_s^j}-[a+A]_\rho_{\Id})/e_s#class(s)
# where \rho_\chi is the unip. char corresp. to \chi in relative group
  aA:=List(hw.charNumbers,x->uw.a[x]+uw.A[x]);
# InfoChevie("a+A-Inf(a+A)=",FormatGAP(aA-Minimum(aA)));
# for o in HyperplaneOrbits(R) do 
#   InfoChevie(" es=",o.e_s," esNs=",o.e_s*o.N_s);
# od;
  o:=Set(R.orbitRepresentative);
  o:=List(R.generatingReflections,i->Position(o,R.orbitRepresentative[i]));
  para:=List(o,function(i)local h,m;h:=HyperplaneOrbits(R)[i];
    h:=List(h.det_s,i->(aA[i]-aA[PositionId(R)])/h.e_s/h.N_s);
    m:=Maximum(Maximum(h),0);return m-Concatenation([0],h);end);
  para:=List(para,function(l)
    if ForAll(l{[2..Length(l)]},x->x=0) then return l[1];
    else return l;
    fi;end);
  if para<>hw.parameterExponents then
     ChevieErr("Parameter: computed:",FormatGAP(para),
        " stored:",FormatGAP(hw.parameterExponents)," for ",ReflectionName(R));
  fi;
  if Length(hw.parameterExponents)=0 then den:=1;
  else den:=Lcm(List(Flat(hw.parameterExponents),Denominator));
  fi;
  ud:=CycPolUnipotentDegrees(W);
  reldeg:=List(ud{hw.charNumbers},x->Value(cusp*index/x,q^den));
  R:=UnipotentCharactersOps.RelativeHecke(uw,i,q^den);
  InfoChevie("\n     Relative ",R);
  sch:=SchurElements(R);
  if ForAny(sch,x->x=false) then
    ChevieErr("Schur elements not implemented for ",R,"!\n");
    return false;
  fi;
  sch:=sch*q^0;
  CHEVIE.Check.EqLists(sch,reldeg,SPrint("Schur(",R,")"),"ud");
  if Length(arg)=3 and arg[3]=true then  return reldeg;
  else return List(sch,x->Value(cusp*index,q^den)/x);
  fi;
end,
W->IsSpetsial(W));

# GendegsHCInduce(W[,J]) check unipotent degrees of W are consistent with 
# HC induction from those of L_J
CHEVIE.AddTest("GendegsHCInduce",
function(arg)
  local W,J,L,index,q,pred,ind,nh,inddeg,p,tbl;
  W:=arg[1];
  if Length(arg)=1 then 
    for J in ParabolicRepresentatives(W) do 
      CHEVIE.Testing(J);
      CHEVIE.Test("GendegsHCInduce",W,J);
    od;
    return;
  fi;
  J:=arg[2];
  q:=X(Cyclotomics);
  if IsSpets(W) then L:=SubSpets(W,J);
  else L:=ReflectionSubgroup(W,J);
  fi;
  index:=GenericOrder(W,q)/GenericOrder(L,q);index.valuation:=0;
  if IsSpets(W) then index:=index*GenericSign(L)/GenericSign(W);fi;
  pred:=UnipotentDegrees(L,q)*index;
  tbl:=HarishChandraInductionTable(L,W);
  ind:=List(TransposedMat(tbl.scalar),x->UnipotentCharacter(W,x));
  inddeg:=List(ind,Degree);
  if pred<>inddeg then
    nh:=CharNames(UnipotentCharacters(L));
    ChevieErr("Relgroups:",Join(List(tbl.pieces,x->ReflectionName(x.g))));
    CHEVIE.Check.EqLists(pred,inddeg,"udLevi*index","viaHCInductionTable");
  fi;
end,
W->IsSpetsial(W));

# check UnipotentCharacters(W).almostHarishChandra
CHEVIE.AddTest("AlmostHarishChandra",
function(W)local h,r,t,i,tt,hh,uc;
  uc:=UnipotentCharacters(W);
  for h in uc.almostHarishChandra do
  if IsSpets(W) then 
    r:=RelativeCoset(W,h.levi);
    t:=ReflectionType(r);
    if Length(t)<>Length(h.relativeType) then Error();fi;
    for i in [1..Length(t)] do
      if Length(t[i].orbit)>1 then Error("not irred");fi;
      tt:=t[i].orbit[1];
      if not IsBound(h.relativeType[i].orbit) then
        if t[i].twist<>() then Error("should be twisted");fi;
        hh:=h.relativeType[i];
      else hh:=h.relativeType[i].orbit[1];
      fi;
      if hh.series<>tt.series then 
          ChevieErr("series do not match: is ",hh.series,
                " should be ",tt.series,"\n");fi;
      if hh.indices<>Group(r).relativeIndices{tt.indices} then 
        ChevieErr("indices do not match: are ",hh.indices,
              " should be ",Group(r).relativeIndices{tt.indices},"\n"); fi;
    od;
  else
    if IsCoxeterGroup(W) then r:=RelativeGroup(W,h.levi);
    else r:=RelativeGroup(W,h.levi,Concatenation(List(h.relativeType,
          x->Concatenation(List(x.orbit,y->y.indices)))));fi;
    t:=ReflectionType(r);
    if Length(t)<>Length(h.relativeType) then Error();fi;
    for i in [1..Length(t)] do
      tt:=t[i];
      if h.relativeType[i].orbit[1].series<>tt.series then 
        ChevieErr("stored series is ",h.relativeType[i].orbit[1].series,
                " should be ",tt.series,"\n");fi;
      if not IsBound(tt.indices) then
        ChevieErr("could not find indices (expected ",
                  h.relativeType[i].orbit[1].indices,")");
      elif Maximum(tt.indices)>Length(r.relativeIndices) then
        ChevieErr("use non-simple roots:",tt.indices," of ",r,
            "<",Join(r.relativeIndices),">\n");
      elif h.relativeType[i].orbit[1].indices<>r.relativeIndices{tt.indices} 
      then ChevieErr("stored indices are ",
         h.relativeType[i].orbit[1].indices,
        " should be ",r.relativeIndices{tt.indices},"\n"); fi;
    od;
  fi;
  od;
end,
W->IsSpetsial(W));

# The sum of squares of fakedegrees should equal the sum of
# normsquares of unipotent degrees
CHEVIE.AddTest("SumofSquares",
function(W)local q;
  q:=X(Cyclotomics);
  if Sum(FakeDegrees(W,q),x->x^2)<>Sum(UnipotentDegrees(W,q),
   x->x*ComplexConjugate(x)) then ChevieErr("fails\n");fi;
end,
W->IsSpetsial(W));

# check that stored a and A are correct
CHEVIE.AddTest("aA",
function(W)local uc,ud,q;
  uc:=UnipotentCharacters(W);
  q:=X(Cyclotomics); ud:=UnipotentDegrees(W,q);
  if IsBound(uc.a) then 
    CHEVIE.Check.EqLists(uc.a,List(ud,x->x.valuation),"stored a","computed a");
  fi;
  if IsBound(uc.A) then 
    CHEVIE.Check.EqLists(uc.A,List(ud,Degree),"stored A","computed A");
  fi;
end,
W->IsSpetsial(W));

# check eigenvalues in families agree with those in HC series
CHEVIE.AddTest("Eigen",
function(W)local uc,i,e,j,f,n;
  uc:=UnipotentCharacters(W);
  e:=Eigenvalues(uc);
  for i in [1..Length(uc.harishChandra)] do
    f:=uc.harishChandra[i];
    for j in [1..Length(f.charNumbers)] do
      n:=f.charNumbers[j];
      if e[n]<>f.eigenvalue then
        ChevieErr("HCfamily ",i,"#",j,":",uc.TeXCharNames[n],"=",n,
          " eigen from fam.=",e[n]," but from HC=",f.eigenvalue,"\n");
      fi;
    od;
  od;
end,
W->IsSpetsial(W));

# check fractional eigenvalues of Frobenius wrt. values stored in HC series
CHEVIE.AddTest("qEigen",
function(W)local uc,i,e,j,f,n,q;
  uc:=UnipotentCharacters(W);
  e:=uc.operations.qEigen(uc);
  for i in [1..Length(uc.families)] do
    f:=uc.families[i];
    if IsBound(f.qEigen) then q:=f.qEigen;
    else q:=f.charNumbers*0;
    fi;
    for j in [1..Length(f.charNumbers)] do
      n:=f.charNumbers[j];
      if e[n]<>q[j] then
        ChevieErr("HCfamily ",i,"#",j,":",uc.TeXCharNames[n],"=",n,
          " eigen from HC.=",e[n]," but from fam=",q[j],"\n");
      fi;
    od;
  od;
end,
W->IsSpetsial(W));

# LusztigInduction(WF[, J or L])
CHEVIE.AddTest("LusztigInduction",
function(arg)local J,L,WF,W,t,uh,hd,ud,index,pred,ind,j,q,h,rhs,c,m,u,f;
  WF:=arg[1];if not IsSpets(WF) then WF:=Spets(WF);fi;
  W:=Group(WF);
  if Length(arg)=1 then 
    InfoChevie("\n");
    for J in Filtered(ParabolicRepresentatives(W),
          x->Length(x)<W.nbGeneratingReflections) do
      CHEVIE.Test("LusztigInduction",WF,J);
    od;
    return;
  elif IsList(arg[2]) then J:=arg[2];
    for L in Twistings(WF,J) do CHEVIE.Test("LusztigInduction",WF,L);od;
    return;
  fi;
  L:=arg[2];
  t:=LusztigInductionTable(L,WF);
  if t=false then return;fi;
  InfoChevie("   # ");if L.phi=WF.phi then InfoChevie("Split ");fi;
  InfoChevie("R^{",ReflectionName(t.g),"}_{",ReflectionName(t.u),"}");
  CHEVIE.Testing(" from ",ReflectionName(t.u));
  if IsBound(t.scalars) then InfoChevie("************** scalars=",t.scalars);fi;
  InfoChevie("\n");
  if L.phi=WF.phi then 
    h:=HarishChandraInductionTable(L,WF);
    if h.scalar<>t.scalar then CHEVIE.Check.EqTables(h,t);fi;
  fi;
  uh:=UnipotentCharacters(L);
#  if uh=false then return;fi;
  q:=X(Cyclotomics);
  uh:=CharNames(uh); hd:=UnipotentDegrees(L,q); ud:=UnipotentDegrees(WF,q);
  index:=GenericOrder(WF,q)/GenericOrder(L,q);index.valuation:=0;
  index:=index*GenericSign(L)/GenericSign(WF);
  pred:=hd*index;
  ind:=List(TransposedMat(t.scalar),x->UnipotentCharacter(WF,x));
  for j in [1..Length(hd)] do
    if pred[j]<>Degree(ind[j]) then
      ChevieErr("  RLG(",uh[j],")=",Format(ind[j]),"\n  ",
        CycPol(Degree(ind[j]))," instead of ",CycPol(pred[j]),
        " quotient ", CycPol(Degree(ind[j]))/CycPol(pred[j]),"\n");
    fi;
  od;
  f:=FusionConjugacyClasses(L,WF);
#  Check Mackey with Tori
  c:=Zip(CharTable(WF).centralizers{f},CharTable(L).centralizers,
         function(a,b)return a/b;end);
  u:=DeligneLusztigCharacterTable(L);
  rhs:=List([1..NrConjugacyClasses(WF)],function(i)local l;
   l:=Positions(f,i);if l=[] then return u[1]*0;else return Sum(l,j->u[j]*c[j]);fi;
   end);
  rhs:=rec(scalar:=rhs, u:=L,g:=WF,
    uNames:=function(t,opt)return CharNames(UnipotentCharacters(L),opt);end,
    gNames:=function(t,opt)
      return List([1..NrConjugacyClasses(WF)],i->ClassName(WF,i,opt));end,
    head:=function(t,opt)return "Sum_w'~w<chi,RTwL>";end,
    what:="Mackey ",
    operations:=InductionTableOps);
  m:=ShallowCopy(rhs);
  m.scalar:=DeligneLusztigCharacterTable(WF)*t.scalar;
  m.head:=function(t,opt)return "<RTwG,RLG chi>";end;
  if m.scalar<>rhs.scalar then CHEVIE.Check.EqTables(m,rhs,2);fi;
  # Check transitivity with RTL
  CHEVIE.Check.EqLists(DeligneLusztigCharacterTable(L)*TransposedMat(t.scalar),
     DeligneLusztigCharacterTable(WF){f},"RLG o RTL","RTG");
end,
W->IsSpetsial(W));

# test that a family satisfies Lusztig's "exotic fourier transform" properties.
# Families(W [,opt]]) or 
# Families(W[,famno [,opt]]) or
# Families(family record [,opt])
# option: hard:=show details
CHEVIE.AddTest("Families",
function(arg)local W,f,inds,O,P,S,Sbar,Id,real,wreal,i,j,v,
  check,tS,ud,opt,ps,uc,fd,special,s,p,cospecial,max,a,A;
  if IsGroup(arg[1]) or IsSpets(arg[1]) then 
    W:=arg[1]; uc:=UnipotentCharacters(W);
    if Length(arg)=2 and IsRec(arg[2]) then opt:=arg[2];arg:=[arg[1]];fi;
    if Length(arg)=1 then 
      if not IsBound(opt) then opt:=rec();fi;
      for i in [1..Length(uc.families)] do 
        CHEVIE.Test("Families",W,i,opt);
      od;
      InfoChevie("\n   ");
      return;
    fi;
    f:=uc.families[arg[2]];
    v:=SPrint(" ",ReflectionName(W),".",arg[2]);
    arg:=arg{[3..Length(arg)]};
  else f:=arg[1]; arg:=arg{[2..Length(arg)]};v:="";
  fi;
  if Length(arg)>0 then opt:=arg[1];else opt:=rec();fi;
  if Length(f.eigenvalues)=1 then return;fi; # nothing interesting to test
  O:=DiagonalMat(f.eigenvalues);S:=f.fourierMat;
  Sbar:=ComplexConjugate(S);Id:=IdentityMat(Length(S));tS:=TransposedMat(S);
  PrintToString(v,"#",Length(f.fourierMat));
  if IsBound(f.name) then PrintToString(v,"(",TeXStrip(f.name),")");fi;
  InfoChevie("\n   #Check",v,"\c");
  CHEVIE.Testing(v);
  ps:=SignedPermListList(Sbar,S);
  if ps=false then ChevieErr("S* is not ps(S)\n| ");fi;
  wreal:=IsBound(f.perm);
  if not IsBound(f.sh) and wreal<>ForAll(ps,x->x>0) then
    Error("weakly real=",wreal," but ps=",ps,"\n");
  fi;
  if wreal then # S^2 is perm
    real:=PermListList(ComplexConjugate(f.eigenvalues),f.eigenvalues);
    if real<>false then PrintToString(v,"+");
    else PrintToString(v,"P");fi;
  else real:=false;
  fi;
  if IsBound(opt.hard) then Print("[",v,"] ...\n| ");fi;
  check:=function(a,msg)
    if not a then InfoChevie("\n");ChevieErr("failed:",msg,"\n| ");
    elif IsBound(opt.hard) then InfoChevie(" ",msg,",\c"); 
    fi;
  end;
  inds:=[1..Length(f.eigenvalues)];
  if IsBound(W) then
    ud:=CycPolUnipotentDegrees(W){f.charNumbers};
    a:=Set(List(ud,Valuation)); A:=Set(List(ud,Degree));
    if Length(a)<>1 or Length(A)<>1 then ChevieErr("a or A not constant");
    else a:=a[1];A:=A[1];fi;
    fd:=FakeDegrees(uc,X(Rationals)){f.charNumbers};
    special:=Positions(List(fd,Valuation),a);
    cospecial:=Positions(List(fd,Degree),A);
    if Length(special)<>1 or Length(cospecial)<>1 then 
      ChevieErr("special or cospecial not unique");
    else special:=special[1];cospecial:=cospecial[1];fi;
    check(f.special=special,SPrint(".special=",f.special," min b=",special));
    if special<>cospecial then
      if not IsBound(f.cospecial) then
        ChevieErr(" .cospecial is not bound; should be ",cospecial,"\n| ");
      else check(f.cospecial=cospecial,
         SPrint(".cospecial=",f.cospecial," max B=",cospecial));
      fi;
    elif IsBound(f.cospecial) and f.special<>f.cospecial then
      ChevieErr("\n.cospecial=",f.cospecial," should be",special,"\n");
    fi;
    check(ComplexConjugate(ud)=SignPermuted(ud,ps),"ud*=ud^p");
    if real<>false then
      check(Permuted(f.eigenvalues,real/f.perm)=f.eigenvalues,"eig*=eig^perm");
    fi;
    if IsBound(opt.hard) then
      if S=Sbar then Print("\n|  S real");
      else Print("\n|  S->S* is p=",Concatenation(List(CyclesSignedPerm(ps),
        x->SPrint("(",Join(x),")"))),"\n| ");fi;
      if wreal then # check ps is a sub-permutation of perm
        if not ForAll(inds,x->ps[x]=x or ps[x]=x^f.perm) then
          ChevieErr("*** S->S* is not a sub-perm of .perm\n| ");
        fi;
      fi;
    fi;
    # check Shintani preserves ud. We have Sh=O^-1 SO^-1
    ud:=List(ud,x->Value(x,X(Cyclotomics)));
    if IsBound(f.sh) then check(DiagonalMat(f.sh)*S*ud=S*ud,"Shud=ud");
    elif IsBound(f.lusztig) then check(S*O*ud=O*ud,"Shud=ud");
    else check(S*O^-1*ud=O*ud,"Shud=ud");
    fi;
  elif IsBound(f.special) then special:=f.special;
  else ChevieErr(".special not bound\n| ");special:=1;
  fi;
  check(not 0 in S[special],"not 0 in S[special]");
  check(S*TransposedMat(Sbar)=Id,"S unitary");
  if wreal then P:=Permuted(S^0,f.perm);check(S*P=P*S,"[S,P]=1"); fi;
  if IsBound(f.sh) then 
    check((O*tS*DiagonalMat(f.sh)^-1*S)^2=S^0,"(O*tS*Sh-1*S)^2=1");
  else 
    if IsBound(f.lusztig) then
      if not f.lusztig then Error(".lusztig bound but false");fi;
      if not wreal then Error(".lusztig bound but not .perm");fi;
      check((O*S*P)^3=Id,"(OSP)^3=1");
    else check((O*S)^3=Id,"(OS)^3=1");
    fi;
    check(S=tS,"S symmetric");
    check(O*S^2=S^2*O,"[S^2,O]=1");
  fi;
  check((S*tS)^2=Id,"(S*tS)^2=1");
# Print("\n| ");
# check(O=S*O*S,"O=SOS");
# if real then Print(" evalf(S[special]): ",
#     List(S[special]/S[special][special],evalf));
# fi;
  if IsBound(opt.hard) then Print("\n| ");fi;
  if Length(S)<=40 or IsBound(opt.hard) then
  s:=List(TransposedMat(Sbar),x->x/x[special]);
  max:=0;
  for i in inds do 
    if Length(S)>10 or IsBound(opt.hard) then Print(".\c");fi;
    for j in inds do 
      v:=List(inds,k->S[i][k]*S[i][k])*s;
      max:=Maximum(max,Number(v,y->y<>0));
   #  Print("e[",i,"]*e[",j,"]=",v,"\n");
      if not ForAll(v,IsInt) then
        ChevieErr("not integral:",i,",",j,":",Format(v),"\n| ");
      fi;
      p:=ForAll(v,x->x>=0);
      if wreal and not p then 
        if ForAll(v,x->x<=0) then
          ChevieErr("family is wreal but Sums[",i,",",j,"]<=0\n| ");
        else
          ChevieErr("family is wreal but Sums[",i,",",j,"]=",Format(v),"\n| ");
        fi;
      fi;
      if IsBound(opt.hard) then if p then Print("+\c");else Print(".\c");fi;fi;
    od;
  od;
# Print("max=",max,"\n");
  fi;
  if IsBound(opt.hard) and Length(S)<50 then Print("\n");fi;
end,
W->IsSpetsial(W));

CHEVIE.AddTest("UdFdImprimitive",
function(W)local cs,ud,i,vud,uc,n,fd,vfd;
  ud:=CycPolUnipotentDegrees(W);
  uc:=UnipotentCharacters(W);
  cs:=List(uc.charSymbols,x->x[1]);
  vud:=List(cs,CycPolGenericDegreeSymbol);
  for i in [1..Length(cs)] do CHEVIE.Check.EqCycPol(vud[i],ud[i],
     SPrint("Deg",StringSymbol(cs[i])),"ud");
  od;
  n:=ReflectionName(W);
  cs:=List(uc.almostCharSymbols{uc.almostHarishChandra[1].charNumbers},x->x[1]);
  fd:=List(FakeDegrees(W,X(Cyclotomics)),CycPol);
  if Length(n)>1 and n{[1,2]} in ["2D","2I","2B","2G"] then 
       vfd:=List(cs,x->CycPolFakeDegreeSymbol(x,1));
  else vfd:=List(cs,CycPolFakeDegreeSymbol);
  fi;
  for i in [1..Length(cs)] do CHEVIE.Check.EqCycPol(vfd[i],fd[i],
    SPrint("Deg",StringSymbol(cs[i])),"fd");
  od;
end,
function(W)local n;
  n:=ReflectionType(W);
  if Length(n)>1 then return false; elif Length(n)=0 then return true;fi;
  n:=n[1];
  if IsBound(n.series) then return n.series in ["A","B","C","D","G","I"] 
    or n.series="ST" and IsBound(n.p);
  elif IsBound(n.orbit) then return n.orbit[1].series in ["B","C","D","I"]
    and OrderPerm(n.twist)<>3; # type 2A excluded for now....???
  fi;
end,
"Test unipotent degrees and fake degrees of classical Spets against formulas");
