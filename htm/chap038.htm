<html><head><title>GAP3 Manual: 38 Group Libraries</title></head>
<body bgcolor="ffffff">
<h1>38 Group Libraries</h1>
<P><P><P>
When you start <strong>GAP3</strong> it  already knows several groups.  Currently <strong>GAP3</strong>
initially knows the  following groups:

<P>&bull; some basic groups,  such as cyclic groups or symmetric groups  (see
      <a href="chap038.htm#SECT001">The Basic Groups Library</a>),
<P>&bull; the  primitive permutation groups  of degree  at most 50  (see <a href="chap038.htm#SECT005">The
      Primitive Groups Library</a>),
<P>&bull; the transitive permutation groups  of degree  at most 15  (see <a href="chap038.htm#SECT006">The
      Transitive Groups Library</a>),
<P>&bull; the solvable groups  of size at most 100  (see <a href="chap038.htm#SECT007">The Solvable Groups
      Library</a>),
<P>&bull; the  2-groups  of size  at most  256  (see <a href="chap038.htm#SECT008">The 2-Groups Library</a>),
<P>&bull; the  3-groups  of size  at most  729  (see <a href="chap038.htm#SECT009">The 3-Groups Library</a>),
<P>&bull; the irreducible solvable subgroups of  <I>GL(n,p)</I>  for  <I>n &gt; 1</I>  and
      <I>p<sup>n</sup>  &lt;  256</I>   (see  <a href="chap038.htm#SECT010">The  Irreducible  Solvable  Linear  Groups
      Library</a>),
<P>&bull; the  finite perfect groups  of size  at most  <I>10<sup>6</sup></I>  (excluding 11
      sizes) (see <a href="chap038.htm#SECT011">The Library of Finite Perfect Groups</a>),
<P>&bull; the irreducible maximal finite integral matrix groups  of dimension
      at  most  24  (see  <a href="chap038.htm#SECT012">Irreducible  Maximal  Finite  Integral  Matrix
      Groups</a>),
<P>&bull; the  crystallographic  groups  of  dimension  at most  4  (see <a href="chap038.htm#SECT013">The
      Crystallographic Groups Library</a>).
<P>&bull; the groups of order at most 1000 except for 512 and 768 (see
      <a href="chap038.htm#SECT014">The Small Groups Library</a>).

<P>
Each of the set of groups above is called a <strong>library</strong>.   The whole set of
groups that <strong>GAP3</strong>  knows initially is  called the  <strong>GAP3</strong> <strong>collection of
group libraries</strong>.  There is usually no relation between the groups in the
different libraries.
<P>
Several of the libraries  are accessed in  a uniform manner.  For each of
these libraries there is a so called <strong>selection function</strong> that allows you
to select the list of groups that satisfy given criterias from a library.
The  <strong>example  function</strong> allows you to  select  one  group that satisfies
given   criteria from the library.   The  low-level <strong>extraction function</strong>
allows you  to extract a  single  group from a   library, using a  simple
indexing scheme. These functions are described in the sections <a href="chap038.htm#SECT002">Selection
Functions</a>, <a href="chap038.htm#SECT003">Example Functions</a>, and <a href="chap038.htm#SECT004">Extraction Functions</a>.
<P>
Note  that  a system administrator may  choose  to install  all, or  only
a few, or even none of the libraries.  So some of the libraries mentioned
below may not be available on your installation.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap038.htm#SECT001">The Basic Groups Library</a>
<LI> <A HREF="chap038.htm#SECT002">Selection Functions</a>
<LI> <A HREF="chap038.htm#SECT003">Example Functions</a>
<LI> <A HREF="chap038.htm#SECT004">Extraction Functions</a>
<LI> <A HREF="chap038.htm#SECT005">The Primitive Groups Library</a>
<LI> <A HREF="chap038.htm#SECT006">The Transitive Groups Library</a>
<LI> <A HREF="chap038.htm#SECT007">The Solvable Groups Library</a>
<LI> <A HREF="chap038.htm#SECT008">The 2-Groups Library</a>
<LI> <A HREF="chap038.htm#SECT009">The 3-Groups Library</a>
<LI> <A HREF="chap038.htm#SECT010">The Irreducible Solvable Linear Groups Library</a>
<LI> <A HREF="chap038.htm#SECT011">The Library of Finite Perfect Groups</a>
<LI> <A HREF="chap038.htm#SECT012">Irreducible Maximal Finite Integral Matrix Groups</a>
<LI> <A HREF="chap038.htm#SECT013">The Crystallographic Groups Library</a>
<LI> <A HREF="chap038.htm#SECT014">The Small Groups Library</a>
</ol>
<A NAME="SECT001"><h2>38.1 The Basic Groups Library</h2></a>
<P><P><P>
<code>CyclicGroup( <var>n</var> )</code>
<A name = "I0"></a>
 <BR> 
<code>CyclicGroup( <var>D</var>, <var>n</var> )</code>
<P>
In the first form <code>CyclicGroup</code> returns the cyclic group of size <var>n</var> as a
permutation group.   In the second form   <var>D</var> must be   a domain of group
elements,  e.g., <code>Permutations</code> or  <code>AgWords</code>, and <code>CyclicGroup</code>  returns
the cyclic group of size <var>n</var> as a group of elements of that type.
<P>
<pre>    gap> c12 := CyclicGroup( 12 );
    Group( ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12) )
    gap> c105 := CyclicGroup( AgWords, 5*3*7 );
    Group( c105_1, c105_2, c105_3 )
    gap> Order(c105,c105.1); Order(c105,c105.2); Order(c105,c105.3);
    105
    35
    7 </pre>
<P>
<P>
<code>AbelianGroup( <var>sizes</var> )</code>
<A name = "I1"></a>
 <BR> 
<code>AbelianGroup( <var>D</var>, <var>sizes</var> )</code>
<P>
In the first form  <code>AbelianGroup</code> returns the abelian group <I>C<sub>sizes[1]</sub>
* C<sub>sizes[2]</sub> * ... * C<sub>sizes[n]</sub></I>, where <var>sizes</var>  must be a list
of  positive  integers, as a permutation  group.  In the  second form <var>D</var>
must  be a  domain of group elements,  e.g., <code>Permutations</code> or <code>AgWords</code>,
and  <code>AbelianGroup</code> returns the  abelian group as a  group of elements of
this type.
<P>
<pre>    gap> g := AbelianGroup( AgWords, [ 2, 3, 7 ] );
    Group( a, b, c )
    gap> Size( g );
    42
    gap> IsAbelian( g );
    true </pre>
<P>
The default function <code>GroupElementsOps.AbelianGroup</code> uses  the  functions
<code>CyclicGroup</code> and <code>DirectProduct</code> (see <a href="chap007.htm#SECT099">DirectProduct</a>)  to construct the
abelian group.
<P>
<P>
<code>ElementaryAbelianGroup( <var>n</var> )</code>
<A name = "I2"></a>
 <BR> 
<code>ElementaryAbelianGroup( <var>D</var>, <var>n</var> )</code>
<P>
In the first form <code>ElementaryAbelianGroup</code> returns the elementary abelian
group of size <var>n</var> as a  permutation group.  <var>n</var>  must be a positive prime
power of course.   In the  second form <var>D</var>  must be  a  domain of   group
elements, e.g., <code>Permutations</code> or <code>AgWords</code>, and <code>ElementaryAbelianGroup</code>
returns the elementary abelian group as a group of elements of this type.
<P>
<pre>    gap> ElementaryAbelianGroup( 16 );
    Group( (1,2), (3,4), (5,6), (7,8) )
    gap> ElementaryAbelianGroup( AgWords, 3 ^ 10 );
    Group( m59049_1, m59049_2, m59049_3, m59049_4, m59049_5, m59049_6,
    m59049_7, m59049_8, m59049_9, m59049_10 ) </pre>
<P>
The  default    function  <code>GroupElementsOps.ElementaryAbelianGroup</code>  uses
<code>CyclicGroup</code>  and <code>DirectProduct</code>  (see <a href="chap007.htm#SECT099">DirectProduct</a> to construct the
elementary abelian group.
<P>
<P>
<code>DihedralGroup( <var>n</var> )</code>
<A name = "I3"></a>
 <BR> 
<code>DihedralGroup( <var>D</var>, <var>n</var> )</code>
<P>
In  the first form <code>DihedralGroup</code> returns the dihedral group of size <var>n</var>
as a permutation group.   <var>n</var> must be a positive  even  integer.   In the
second form  <var>D</var> must be a domain of group elements, e.g., <code>Permutations</code>
or <code>AgWords</code>, and <code>DihedralGroup</code>  returns the dihedral group  as a group
of elements of this type.
<P>
<pre>    gap> DihedralGroup( 12 );
    Group( (1,2,3,4,5,6), (2,6)(3,5) ) </pre>
<P>
<P>
<code>PolyhedralGroup( <var>p</var>, <var>q</var> )</code>
<A name = "I4"></a>
 <BR> 
<code>PolyhedralGroup( <var>D</var>, <var>p</var>, <var>q</var> )</code>
<P>
In the  first form <code>PolyhedralGroup</code> returns the polyhedral group of size
<code><var>p</var> *  <var>q</var></code>  as a  permutation group.   <var>p</var> and  <var>q</var> must  be positive
integers and there must exist a  nontrivial <var>p</var>-th root  of  unity modulo
every prime factor  of <var>q</var>.  In the  second form <var>D</var> must be a domain  of
group  elements,  e.g., <code>Permutations</code> or  <code>Words</code>, and <code>PolyhedralGroup</code>
returns the polyhedral group as a group of elements of this type.
<P>
<pre>    gap> PolyhedralGroup( 3, 13 );
    Group( ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13), ( 2, 4,10)( 3, 7, 6)
    ( 5,13,11)( 8, 9,12) )
    gap> Size( last );
    39 </pre>
<P>
<P>
<code>SymmetricGroup( <var>d</var> )</code>
<A name = "I5"></a>
 <BR> 
<code>SymmetricGroup( <var>D</var>, <var>d</var> )</code>
<P>
In the first form <code>SymmetricGroup</code> returns the symmetric group of  degree
<var>d</var>  as  a  permutation group.   <var>d</var>  must be a positive integer.  In the
second form <var>D</var>  must be a domain of group elements, e.g., <code>Permutations</code>
or <code>Words</code>,  and <code>SymmetricGroup</code> returns the symmetric group as a  group
of elements of this type.
<P>
<pre>    gap> SymmetricGroup( 8 );
    Group( (1,8), (2,8), (3,8), (4,8), (5,8), (6,8), (7,8) )
    gap> Size( last );
    40320 </pre>
<P>
<P>
<code>AlternatingGroup( <var>d</var> )</code>
<A name = "I6"></a>
 <BR> 
<code>AlternatingGroup( <var>D</var>, <var>d</var> )</code>
<P>
In the  first  form  <code>AlternatingGroup</code> returns the alternating  group of
degree <var>d</var> as a permutation group.  <var>d</var> must be a  positive integer.   In
the  second  form  <var>D</var>  must  be  a  domain  of  group   elements,  e.g.,
<code>Permutations</code> or <code>Words</code>, and <code>AlternatingGroup</code> returns the alternating
group as a group of elements of this type.
<P>
<pre>    gap> AlternatingGroup( 8 );
    Group( (1,2,8), (2,3,8), (3,4,8), (4,5,8), (5,6,8), (6,7,8) )
    gap> Size( last );
    20160 </pre>
<P>
<P>
<code>GeneralLinearGroup( <var>n</var>, <var>q</var> )</code>
<A name = "I7"></a>
 <BR> 
<code>GeneralLinearGroup( <var>D</var>, <var>n</var>, <var>q</var> )</code>
<P>
In the first  form <code>GeneralLinearGroup</code> returns the general  linear group
<I>GL(  <var>n</var>, <var>q</var> )</I> as a  matrix group.  In the second form <var>D</var>  must  be a
domain  of  group  elements,  e.g.,  <code>Permutations</code>  or  <code>AgWords</code>,   and
<code>GeneralLinearGroup</code> returns <I>GL( <var>n</var>,  <var>q</var>  )</I> as a group of elements of
that type.
<P>
<pre>    gap> g := GeneralLinearGroup( 2, 4 ); Size( g );
    GL(2,4)
    180 </pre>
<P>
<P>
<code>SpecialLinearGroup( <var>n</var>, <var>q</var> )</code>
<A name = "I8"></a>
 <BR> 
<code>SpecialLinearGroup( <var>D</var>, <var>n</var>, <var>q</var> )</code>
<P>
In the first form <code>SpecialLinearGroup</code> returns  the special  linear group
<I>SL( <var>n</var>, <var>q</var>  )</I> as a matrix group.   In the second form  <var>D</var> must  be a
domain  of  group  elements,  e.g.,  <code>Permutations</code>   or  <code>AgWords</code>,  and
<code>SpecialLinearGroup</code> returns <I>SL(  <var>n</var>, <var>q</var> )</I> as a  group of elements of
that type.
<P>
<pre>    gap> g := SpecialLinearGroup( 3, 4 ); Size( g );
    SL(3,4)
    60480 </pre>
<P>
<P>
<code>SymplecticGroup( <var>n</var>, <var>q</var> )</code>
<A name = "I9"></a>
 <BR> 
<code>SymplecticGroup( <var>D</var>, <var>n</var>, <var>q</var> )</code>
<P>
In the  first  form <code>SymplecticGroup</code>  returns the symplectic  group <I>SP(
<var>n</var>,  <var>q</var> )</I> as a  matrix group.  In the second form <var>D</var> must be a domain
of    group   elements,   e.g.,    <code>Permutations</code>   or   <code>AgWords</code>,   and
<code>SymplecticGroup</code> returns <I>SP( <var>n</var>, <var>q</var> )</I> as a group of elements of that
type.
<P>
<pre>    gap> g := SymplecticGroup( 4, 2 ); Size( g );
    SP(4,2)
    720 </pre>
<P>
<P>
<code>GeneralUnitaryGroup( <var>n</var>, <var>q</var> )</code>
<A name = "I10"></a>
 <BR> 
<code>GeneralUnitaryGroup( <var>D</var>, <var>n</var>, <var>q</var> )</code>
<P>
In the first form <code>GeneralUnitaryGroup</code> returns the general unitary group
<I>GU(  <var>n</var>, <var>q</var> )</I> as  a  matrix group.  In the second  form <var>D</var> must be a
domain  of  group  elements,   e.g.,  <code>Permutations</code>  or  <code>AgWords</code>,  and
<code>GeneralUnitaryGroup</code> returns <I>GU( <var>n</var>, <var>q</var> )</I> as  a group of elements of
that type.
<P>
<pre>    gap> g := GeneralUnitaryGroup( 3, 3 ); Size( g );
    GU(3,3)
    24192 </pre>
<P>
<P>
<code>SpecialUnitaryGroup( <var>n</var>, <var>q</var> )</code>
<A name = "I11"></a>
 <BR> 
<code>SpecialUnitaryGroup( <var>D</var>, <var>n</var>, <var>q</var> )</code>
<P>
In the first form <code>SpecialUnitaryGroup</code> returns the special unitary group
<I>SU( <var>n</var>,  <var>q</var> )</I> as a matrix  group.  In the second form  <var>D</var>  must be a
domain  of  group  elements,  e.g.,  <code>Permutations</code>  or  <code>AgWords</code>,   and
<code>SpecialUnitaryGroup</code> returns <I>SU( <var>n</var>, <var>q</var> )</I> as  a group of elements of
that type.
<P>
<pre>    gap> g := SpecialUnitaryGroup( 3, 3 ); Size( g );
    SU(3,3)
    6048 </pre>
<P>
<P>
<code>MathieuGroup( <var>d</var> )</code>
<A name = "I12"></a>

<P>
<code>MathieuGroup</code> returns the Mathieu group of degree  <var>d</var>  as a permutation
group. <var>d</var> is expected to be 11, 12, 22, 23, or 24.
<P>
<pre>    gap> g := MathieuGroup( 12 ); Size( g );
    Group( ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11), ( 3, 7,11, 8)
    ( 4,10, 5, 6), ( 1,12)( 2,11)( 3, 6)( 4, 8)( 5, 9)( 7,10) )
    95040</pre>
<P><A NAME="SECT002"><h2>38.2 Selection Functions</h2></a>
<P><P><P>
<code>All<var>Library</var>Groups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<P>
For each  group library there  is a  <strong>selection function</strong>.  This function
allows you to select all groups from the library that have a given set of
properties.
<P>
The name of the selection functions always  begins with <code>All</code> and  always
ends with <code>Groups</code>.  Inbetween is a name  that hints at the nature of the
group library. For example, the selection function for the library of all
primitive groups  of  degree  at  most  50  (see  <a href="chap038.htm#SECT005">The  Primitive  Groups
Library</a>) is called <code>AllPrimitiveGroups</code>, and the  selection function for
the library of  all  2-groups of  size  at  most 256 (see  <a href="chap038.htm#SECT008">The  2-Groups
Library</a>) is called <code>AllTwoGroups</code>.
<P>
These  functions take an  arbitrary number of  pairs of  arguments.   The
first argument in such a pair  is a function  that can  be applied to the
groups in the library,  and the second  argument is either a single value
that this  function must return in  order  to have this group included in
the selection, or a list of such values.
<P>
For example
<P>
<pre>    AllPrimitiveGroups( DegreeOperation,  [10..15],
                        Size,             [1..100],
                        IsAbelian,        false    );</pre>
<P>
should return a list of all primitive  groups with  degree between 10 and
15 and size less than 100 that are not abelian.
<P>
Thus  the <code>AllPrimitiveGroups</code>  behaves  as if   it was implemented  by a
function similar to the one defined below, where <code>PrimitiveGroupsList</code> is
a list of all primitive groups.  Note, in  the definition below we assume
for simplicity that <code>AllPrimitiveGroups</code> accepts exactly 4 arguments.  It
is of course  obvious how to change this  definition so that the function
would accept a variable number of arguments.
<P>
<pre>    AllPrimitiveGroups := function ( fun1, val1, fun2, val2 )
        local    groups, g, i;
        groups := [];
        for i  in [ 1 .. Length( PrimitiveGroupsList ) ] do
            g := PrimitiveGroupsList[i];
            if      fun1(g) = val1  or IsList(val1) and fun1(g) in val1
                and fun2(g) = val2  or IsList(val2) and fun2(g) in val2
            then
                Add( groups, g );
            fi;
        od;
        return groups;
    end; </pre>
<P>
Note that the real  selection functions are considerably more  difficult,
to improve the efficiency.  Most important, each recognizes a certain set
of  functions and handles those  properties using  an index  (see  <a href="chap001.htm#SECT026">About
Group Libraries</a>).
<P><A NAME="SECT003"><h2>38.3 Example Functions</h2></a>
<P><P><P>
<code>One<var>Library</var>Group( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<P>
For  each  group library there  is  a  <strong>example function</strong>.  This function
allows you to find one group  from  the  library that has a given  set of
properties.
<P>
The name of the example  functions always  begins  with  <code>One</code> and always
ends with <code>Group</code>.  Inbetween is a name that hints  at the nature of  the
group  library. For example, the example function for the  library of all
primitive  groups  of  degree  at  most  50 (see  <a href="chap038.htm#SECT005">The  Primitive  Groups
Library</a>) is called <code>OnePrimitiveGroup</code>, and the example function for the
library of  all 2-groups of size at most 256 (see <a href="chap038.htm#SECT008">The 2-Groups Library</a>)
is called <code>OneTwoGroup</code>.
<P>
These  functions take an  arbitrary number of  pairs of  arguments.   The
first argument in such a pair  is a function  that can  be applied to the
groups in the library,  and the second  argument is either a single value
that this  function must return in  order  to have this group returned by
the example function, or a list of such values.
<P>
For example
<P>
<pre>    OnePrimitiveGroup( DegreeOperation,  [10..15],
                        Size,             [1..100],
                        IsAbelian,        false    );</pre>
<P>
should return one primitive group  with degree between 10 and 15 and size
size less than 100 that is not abelian.
<P>
Thus  the <code>OnePrimitiveGroup</code>  behaves  as  if it  was  implemented by  a
function similar to the one defined below, where <code>PrimitiveGroupsList</code> is
a list of all primitive groups.   Note, in the definition below we assume
for simplicity that <code>OnePrimitiveGroup</code>  accepts exactly 4 arguments.  It
is of course obvious how to change  this  definition so that the function
would accept a variable number of arguments.
<P>
<pre>    OnePrimitiveGroup := function ( fun1, val1, fun2, val2 )
        local    g, i;
        for i  in [ 1 .. Length( PrimitiveGroupsList ) ] do
            g := PrimitiveGroupsList[i];
            if      fun1(g) = val1  or IsList(val1) and fun1(g) in val1
                and fun2(g) = val2  or IsList(val2) and fun2(g) in val2
            then
                return g;
            fi;
        od;
        return false;
    end; </pre>
<P>
Note that the real example functions are  considerably more difficult, to
improve the efficiency.  Most important, each recognizes a certain set of
functions and handles those properties using an  index (see <a href="chap001.htm#SECT026">About  Group
Libraries</a>).
<P><A NAME="SECT004"><h2>38.4 Extraction Functions</h2></a>
<P><P><P>
For each group library there is an <strong>extraction function</strong>.  This function
allows you to extract single groups from the library.
<P>
The  name of the extraction function always ends with <code>Group</code>  and begins
with a name that hints at  the  nature  of the  library.  For example the
extraction  function  for  the library  of  primitive  groups  (see  <a href="chap038.htm#SECT005">The
Primitive Groups Library</a>) is called <code>PrimitiveGroup</code>, and the extraction
function for  the library of all 2-groups  of size at most 256  (see <a href="chap038.htm#SECT008">The
2-Groups Library</a>) is called <code>TwoGroup</code>.
<P>
What  arguments  the  extraction  function  accepts,  and  how  they  are
interpreted is described in the  sections  that  describe  the individual
group libraries.
<P>
For example
<P>
<code>    PrimitiveGroup( 10, 4 ); </code>
<P>
returns the 4-th primitive group of degree 10.
<P>
The reason for the extraction function is as follows.  A group library is
usually  not  stored  as  a  list  of  groups.   Instead a  more  compact
representation for  the groups is used.   For  example  the groups in the
library  of  2-groups are  represented  by 4  integers.   The  extraction
function hides this representation from you, and allows you to access the
group library  as  if it was  a  table of groups  (two dimensional in the
above example).
<P><A NAME="SECT005"><h2>38.5 The Primitive Groups Library</h2></a>
<P><P><P>
This group library contains all primitive permutation groups of degree at
most 50.  There are a total of 406 such groups.   Actually to be a little
bit more precise,  there are 406  inequivalent primitive operations on at
most 50 points.  Quite a few of the 406 groups are isomorphic.
<P>
<P>
<code>AllPrimitiveGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I13"></a>

<P>
<code>AllPrimitiveGroups</code> returns a list containing all primitive groups  that
have  the properties given  as arguments.  Each property  is specified by
passing a  pair of  arguments, the first being a function,  which will be
applied to all  groups in the library,  and the second being a value or a
list of values,  that  this  function must return in order to  have  this
group included in the list returned by <code>AllPrimitiveGroups</code>.
<P>
The  first argument must  be  <code>DegreeOperation</code>  and the  second argument
either a degree or a list of degrees, otherwise <code>AllPrimitiveGroups</code> will
print a warning to the effect that the library  contains only groups with
degrees between 1 and 50.
<P>
<pre>    gap> l := AllPrimitiveGroups( Size, 120, IsSimple, false );
    #W  AllPrimitiveGroups: degree automatically restricted to [1..50]
    [ S(5), PGL(2,5), S(5) ]
    gap> List( l, g -> g.generators );
    [ [ (1,2,3,4,5), (1,2) ], [ (1,2,3,4,5), (2,3,5,4), (1,6)(3,4) ],
      [ ( 1, 8)( 2, 5, 6, 3)( 4, 9, 7,10), ( 1, 5, 7)( 2, 9, 4)( 3, 8,10)
         ] ] </pre>
<P>
<P>
<code>OnePrimitiveGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I14"></a>

<P>
<code>OnePrimitiveGroup</code>  returns one primitive  group that has the properties
given  as  argument.  Each property  is specified  by passing  a pair  of
arguments,  the  first  being  a function, which will  be applied to  all
groups in the library, and the second being a value  or a list of values,
that this function must  return in order to  have this group  returned by
<code>OnePrimitiveGroup</code>.  If no such group exists, <code>false</code> is returned.
<P>
The  first  argument  must  be <code>DegreeOperation</code>  and the second argument
either a degree or a list of degrees,  otherwise <code>OnePrimitiveGroup</code> will
print a warning to the  effect that the library contains only groups with
degrees between 1 and 50.
<P>
<pre>    gap> g := OnePrimitiveGroup( DegreeOperation,5, IsSolvable,false );
    A(5)
    gap> Size( g );
    60 </pre>
<P>
<code>AllPrimitiveGroups</code>  and  <code>OnePrimitiveGroup</code>  recognize  the  following
functions  and handle  them usually quite efficient.   <code>DegreeOperation</code>,
<code>Size</code>, <code>Transitivity</code>, and <code>IsSimple</code>.  You should  pass those functions
first, e.g., it  is more efficient to say <code>AllPrimitiveGroups( Size,120 ,
IsAbelian,false  )</code> than  to  say  <code>AllPrimitiveGroups(  IsAbelian,false,
Size,120 )</code> (see <a href="chap001.htm#SECT026">About Group Libraries</a>).
<P>
<P>
<code>PrimitiveGroup( <var>deg</var>, <var>nr</var> )</code>
<A name = "I15"></a>

<P>
<code>PrimitiveGroup</code> returns the  <var>nr</var>-th  primitive group  of degree  <var>deg</var>.
Both  <var>deg</var> and <var>nr</var> must be positive integers.  The primitive  groups of
equal degree are  sorted  with respect to  their  size,  so  for  example
<code>PrimitiveGroup( <var>deg</var>, 1  )</code> is  the smallest primitive group  of degree
<var>deg</var>,  e.g,  the  cyclic  group  of size  <var>deg</var>,  if  <var>deg</var> is a  prime.
Primitive groups of equal degree and size are in no particular order.
<P>
<pre>    gap>  g := PrimitiveGroup( 8, 1 );
    AGL(1,8)
    gap> g.generators;
    [ (1,2,3,4,5,6,7), (1,8)(2,4)(3,7)(5,6) ] </pre>
<P>
Apart from the usual components described in  <a href="chap007.htm#SECT118">Group Records</a>, the  group
records returned by the above functions have the following components.
<P>
<DL><DT><code>transitivity</code>:<DD> <BR> 
        degree of transitivity of <var>G</var>.
</DL><P>
<DL><DT><code>isSharpTransitive</code>:<DD> <BR> 
        <code>true</code> if <var>G</var> is sharply <code><var>G</var>.transitivity</code>-fold  transitive  and
        <code>false</code> otherwise.
</DL><P>
<DL><DT><code>isKPrimitive</code>:<DD> <BR> 
        <code>true</code> if <var>G</var> is <var>k</var>-fold primitive, and <code>false</code> otherwise.
</DL><P>
<DL><DT><code>isOdd</code>:<DD> <BR> 
        <code>false</code> if <var>G</var> is a subgroup of the alternating  group  of degree
        <code><var>G</var>.degree</code> and <code>true</code> otherwise.
</DL><P>
<DL><DT><code>isFrobeniusGroup</code>:<DD> <BR> 
        <code>true</code> if <var>G</var> is a  Frobenius group  <A name = "I16"></a>
  and
        <code>false</code> otherwise.
</DL><P>
This  library  was  computed  by  Charles Sims.   The  list  of primitive
permutation groups  of  degree  at most 20 was published in <A href="biblio.htm#Sim70"><cite>Sim70</cite></a>.
The    library   was    brought    into   <strong>GAP3</strong>    format    by   Martin
Sch&ouml;nert.  He assumes the responsibility for all mistakes.
<P><A NAME="SECT006"><h2>38.6 The Transitive Groups Library</h2></a>
<P><P>
<A name = "I17"></a>

<A name = "I18"></a>

<A name = "I19"></a>

<P>
The transitive groups library contains representatives for all transitive
permutation groups of degree at most  22.  Two permutations groups of the
same degree are considered to be equivalent, if there is a renumbering of
points, which maps one group into the other one.  In other words, if they
lie in the save  conjugacy class  under operation  of the  full symmetric
group by conjugation.
<P>
There are a total of 4945 such groups up to degree 22.
<P>
<P>
<code>AllTransitiveGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<P>
<code>AllTransitiveGroups</code> returns   a list containing   all transitive groups
that have the properties given as arguments.   Each property is specified
by  passing a pair   of arguments, the   first being a function, and  the
second being a   value or a  list of  values.  <code>AllTransitiveGroups</code> will
return  all groups  from the  transitive  groups  library, for which  all
specified functions have the specified values.
<P>
If the degree is not restricted to 22 at most, <code>AllTransitiveGroups</code> will
print a warning.
<P>
<P>
<code>OneTransitiveGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<P>
<code>OneTransitiveGroup</code> returns one transitive group that has the properties
given  as  argument.  Each  property  is specified by   passing a pair of
arguments, the first being a function, and the second  being a value or a
list of values.   <code>OneTransitiveGroup</code>  will return one groups   from the
transitive  groups library, for which  all  specified functions have  the
specified values.  If no such group exists, <code>false</code> is returned.
<P>
If the degree is not restricted  to 22 at most, <code>OneTransitiveGroup</code> will
print a warning.
<P>
<code>AllTransitiveGroups</code>  and <code>OneTransitiveGroup</code>   recognize the following
functions and get the corresponding properties from a precomputed list to
speed up  processing:<BR> <code>DegreeOperation</code>, <code>Size</code>, <code>Transitivity</code>, and
<code>IsPrimitive</code>.  You do not  need to pass   those functions first,  as the
selection function picks the these properties first.
<P>
<P>
<code>TransitiveGroup( <var>deg</var>, <var>nr</var> )</code>
<P>
<code>TransitiveGroup</code> returns the  <var>nr</var>-th transitive group of  degree <var>deg</var>.
Both <var>deg</var> and <var>nr</var> must be positive integers.   The transitive groups of
equal  degree are  sorted with  respect  to  their  size, so for  example
<code>TransitiveGroup( <var>deg</var>, 1 )</code> is the smallest  transitive group of degree
<var>deg</var>, e.g, the cyclic group  of size <var>deg</var>, if <var>deg</var>   is a prime.   The
ordering  of  the groups    corresponds  to  the list  in    Butler/McKay
<A href="biblio.htm#BM83"><cite>BM83</cite></a>.
<P>
This library was computed by Gregory Butler, John McKay, Gordon Royle and
Alexander Hulpke. The  list    of transitive groups   up   to degree  11
was  published in <A href="biblio.htm#BM83"><cite>BM83</cite></a>, the list of degree  12 was published in
<A href="biblio.htm#Roy87"><cite>Roy87</cite></a>, degree 14 and 15 were published in <A href="biblio.htm#But93"><cite>But93</cite></a>.
<P>
The library was  brought into <strong>GAP3</strong> format by  Alexander  Hulpke, who is
responsible for all mistakes.
<P>
<pre>    gap> TransitiveGroup(10,22);
    S(5)[x]2
    gap> l:=AllTransitiveGroups(DegreeOperation,12,Size,1440,
    > IsSolvable,false);
    [ S(6)[x]2, M_10.2(12) = A_6.E_4(12) = [S_6[1/720]{M_10}S_6]2 ]
    gap> List(l,IsSolvable);
    [ false, false ] </pre>
<P>
<P>
<code>TransitiveIdentification( <var>G</var> )</code>
<P>
Let <var>G</var> be a permutation group, acting transitively on a set  of up to 22
points.  Then <code>TransitiveIdentification</code> will return the position of this
group in the transitive  groups library.  This means,  if <var>G</var> operates on
<I>m</I> points and    <code>TransitiveIdentification</code>  returns <I>n</I>,  then <var>G</var>   is
permutation isomorphic to the group <code>TransitiveGroup(m,n)</code>.
<P>
<pre>    gap> TransitiveIdentification(Group((1,2),(1,2,3)));
    2 </pre>
<P><A NAME="SECT007"><h2>38.7 The Solvable Groups Library</h2></a>
<P><P><P>
<strong>GAP3</strong> has a library of the 1045 solvable  groups  of size between 2  and
100.   The  groups are  from lists  computed by  M. Hall and J. K. Senior
(size  64, see  <A href="biblio.htm#HS64"><cite>HS64</cite></a>),  R. Laue (size 96,  see  <A href="biblio.htm#Lau82"><cite>Lau82</cite></a>)  and
J. Neub&uuml;ser (other sizes, see <A href="biblio.htm#Neu67"><cite>Neu67</cite></a>).
<P>
<P>
<code>AllSolvableGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I20"></a>

<P>
<code>AllSolvableGroups</code>  returns a  list  containing all solvable groups that
have the properties  given  as arguments.  Each property is specified  by
passing a pair of arguments, the first  being  a function, which will  be
applied to all the groups in the library, and the second being a value or
a list of  values, that this function must return in  order to have  this
group included in the list returned by <code>AllSolvableGroups</code>.
<P>
<pre>    gap> AllSolvableGroups(Size,24,IsNontrivialDirectProduct,false);
    [ 12.2, grp_24_11, D24, Q8+S3, Sl(2,3), S4 ] </pre>
<P>
<P>
<code>OneSolvableGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I21"></a>

<P>
<code>OneSolvableGroup</code>   returns   a   solvable  group  with   the  specified
properties.   Each property is specified by passing  a pair of arguments,
the first being a  function, which will  be applied to all  the groups in
the library, and the second being  a value or a list of values, that this
function  must   return  in  order   to   have  this  group  returned  by
<code>OneSolvableGroup</code>.  If no such group exists, <code>false</code> is returned.
<P>
<pre>    gap> OneSolvableGroup(Size,100,x->Size(DerivedSubgroup(x)),10);
    false
    gap> OneSolvableGroup(Size,24,IsNilpotent,false);
    S3x2^2 </pre>
<P>
<code>AllSolvableGroups</code> and  <code>OneSolvableGroup</code>   recognize   the   following
functions and handle them usually very efficiently: <code>Size</code>, <code>IsAbelian</code>,
<code>IsNilpotent</code>, and <code>IsNonTrivialDirectProduct</code>.
<P>
<P>
<code>SolvableGroup( <var>size</var>, <var>nr</var> )</code>
<A name = "I22"></a>

<P>
<code>SolvableGroup</code> returns the <var>nr</var>-th group of size  <var>size</var> in the library.
<code>SolvableGroup</code>  will signal an error if <var>size</var> is not between 2 and 100,
or if <var>nr</var> is larger  than the number of solvable groups of  size <var>size</var>.
The group is returned as finite polycyclic  group (see <a href="chap025.htm">Finite Polycyclic
Groups</a>).
<P>
<pre>    gap> SolvableGroup( 32 , 15 );
    Q8x4 </pre>
<P><A NAME="SECT008"><h2>38.8 The 2-Groups Library</h2></a>
<P><P>
<A name = "I23"></a>

<P>
The  library  of 2-groups contains all the 2-groups of size dividing 256.
There  are a total of 58760 such groups, 1  of size 2,  2 of size 4, 5 of
size  8, 14 of size 16, 51  of size 32, 267 of size 64, 2328 of size 128,
and 56092 of size 256.
<P>
<P>
<code>AllTwoGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I24"></a>

<P>
<code>AllTwoGroups</code>  returns the  list  of  all  the  2-groups that  have  the
properties given as arguments.   Each property  is specified by passing a
pair of arguments,  the first  is  a function that can be applied to each
group, the second is either a  single value or  a list of values that the
function must return in order to select that group.
<P>
<pre>    gap> l := AllTwoGroups( Size, 256, Rank, 3, pClass, 2 );
    [ Group( a1, a2, a3, a4, a5, a6, a7, a8 ),
      Group( a1, a2, a3, a4, a5, a6, a7, a8 ),
      Group( a1, a2, a3, a4, a5, a6, a7, a8 ),
      Group( a1, a2, a3, a4, a5, a6, a7, a8 ) ]
    gap> List( l, g -> Length( ConjugacyClasses( g ) ) );
    [ 112, 88, 88, 88 ] </pre>
<P>
<P>
<code>OneTwoGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I25"></a>

<P>
<code>OneTwoGroup</code> returns a single 2-group that  has the  properties given as
arguments.   Each property is  specified by passing a pair of  arguments,
the first is a function that can  be applied to each group, the second is
either a single value or a list  of values that the function  must return
in order to select that group.
<P>
<pre>    gap> g := OneTwoGroup( Size, [64..128], Rank, [2..3], pClass, 5 );
    #I  size restricted to [ 64, 128 ]
    Group( a1, a2, a3, a4, a5, a6 )
    gap> Size( g );
    64
    gap> Rank( g );
    2 </pre>
<P>
<code>AllTwoGroups</code> and  <code>OneTwoGroup</code> recognize the  following  functions and
handle them usually very efficiently.  <code>Size</code>, <code>Rank</code> for the rank of the
Frattini quotient  of the group, and  <code>pClass</code> for the exponent-<I>p</I> class
of the group.  Note that  <code>Rank</code> and  <code>pClass</code>  are  dummy functions that
can  be  used  only in  this context, i.e., they  can not  be  applied to
arbitrary groups.
<P>
<P>
<code>TwoGroup( <var>size</var>, <var>nr</var> )</code>
<A name = "I26"></a>

<P>
<code>TwoGroup</code>  returns  the <var>nr</var>-th  group of  size  <var>size</var>.   The  group is
returned as a finite polycyclic group  (see <a href="chap025.htm">Finite Polycyclic  Groups</a>).
<code>TwoGroup</code>  will signal an error if <var>size</var> is not  a power of 2 between 2
and 256, or <var>nr</var> is larger than the number of groups of size <var>size</var>.
<P>
Within each size the  following criteria have  been  used,  in  turn,  to
determine the index position of a group in the list
<P>
<DL><DT>1:<DD>      increasing generator number;
</DL><P>
<DL><DT>2:<DD>      increasing exponent-2 class;
</DL><P>
<DL><DT>3:<DD>      the position of its parent in the list of groups  of  appropriate
        size;
</DL><P>
<DL><DT>4:<DD>      the  list  in which the Newman and O'Brien implementation of the
        <I>p</I>-group generation algorithm outputs the immediate  descendants
        of a group.
</DL><P>
<pre>    gap> g := TwoGroup( 32, 45 );
    Group( a1, a2, a3, a4, a5 )
    gap> Rank( g );
    4
    gap> pClass( g );
    2
    gap> g.abstractRelators;
    [ a1^2*a5^-1, a2^2, a2^-1*a1^-1*a2*a1, a3^2, a3^-1*a1^-1*a3*a1,
      a3^-1*a2^-1*a3*a2, a4^2, a4^-1*a1^-1*a4*a1, a4^-1*a2^-1*a4*a2,
      a4^-1*a3^-1*a4*a3, a5^2, a5^-1*a1^-1*a5*a1, a5^-1*a2^-1*a5*a2,
      a5^-1*a3^-1*a5*a3, a5^-1*a4^-1*a5*a4 ] </pre>
<P>
Apart from the usual components described in  <a href="chap007.htm#SECT118">Group Records</a>, the  group
records returned by the above functions have the following components.
<P>
<DL><DT><code>rank</code>:<DD><BR> 
        rank of Frattini quotient of <var>G</var>.
</DL><P>
<DL><DT><code>pclass</code>:<DD> <BR> 
        exponent-<I>p</I> class of <var>G</var>.
</DL><P>
<DL><DT><code>abstractGenerators</code>:<DD> <BR> 
        a list of abstract generators of <var>G</var> (see <a href="chap022.htm#SECT001">AbstractGenerator</a>).
</DL><P>
<DL><DT><code>abstractRelators</code>:<DD> <BR> 
        a  list of  relators  of <var>G</var>  stored  as  words in  the  abstract
        generators.
</DL><P>
Descriptions of the algorithms used in constructing  the library data may
be found in <A href="biblio.htm#OBr90"><cite>OBr90,OBr91</cite></a>.  Using  these techniques,  a library  was
first  prepared  in  1987 by  M.F. Newman  and  E.A. O'Brien; a  partial
description may be found in <A href="biblio.htm#NO89"><cite>NO89</cite></a>.
<P>
The  library was brought into  the <strong>GAP3</strong> format by Werner Nickel,  Alice
Niemeyer, and E.A. O'Brien.
<P><A NAME="SECT009"><h2>38.9 The 3-Groups Library</h2></a>
<P><P>
<A name = "I27"></a>

<P>
The  library  of 3-groups contains all the 3-groups of size dividing 729.
There  are  a total of 594 such groups, 1  of size 3,  2 of size 9,  5 of
size 27,  15 of size 81,   67 of size 243, and  504 of size 729.
<P>
<P>
<code>AllThreeGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I28"></a>

<P>
<code>AllThreeGroups</code>  returns the  list  of  all the 3-groups that  have  the
properties given as arguments.  Each  property  is specified by passing a
pair of arguments,  the first  is  a function that can be applied to each
group, the second is either a  single value or  a list of values that the
function must return in order to select that group.
<P>
<pre>    gap> l := AllThreeGroups( Size, 243, Rank, [2..4], pClass, 3 );;
    gap> Length ( l );
    33
    gap>  List( l, g -> Length( ConjugacyClasses( g ) ) );
    [ 35, 35, 35, 35, 35, 35, 35, 243, 99, 99, 51, 51, 51, 51, 51, 51,
      51, 51, 99, 35, 243, 99, 99, 51, 51, 51, 51, 51, 35, 35, 35, 35, 35
     ] </pre>
<P>
<P>
<code>OneThreeGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I29"></a>

<P>
<code>OneThreeGroup</code> returns a single 3-group that has the properties given as
arguments.   Each property is  specified by passing a pair of  arguments,
the first is a function that can  be applied to each group, the second is
either a single value or a list  of values that the function  must return
in order to select that group.
<P>
<pre>    gap> g := OneThreeGroup( Size, 729, Rank, 4, pClass, [3..5] );
    Group( a1, a2, a3, a4, a5, a6 )
    gap> IsAbelian( g );
    true </pre>
<P>
<code>AllThreeGroups</code> and  <code>OneThreeGroup</code> recognize the  following  functions
and handle them usually very efficiently.  <code>Size</code>, <code>Rank</code> for the rank of
the Frattini quotient  of the  group, and  <code>pClass</code> for  the exponent-<I>p</I>
class  of  the group. Note that <code>Rank</code> and  <code>pClass</code> are  dummy functions
that can be  used only  in  this context, i.e., they cannot be applied to
arbitrary groups.
<P>
<P>
<code>ThreeGroup( <var>size</var>, <var>nr</var> )</code>
<A name = "I30"></a>

<P>
<code>ThreeGroup</code> returns  the <var>nr</var>-th  group of  size  <var>size</var>. The  group is
returned as a finite polycyclic group  (see <a href="chap025.htm">Finite Polycyclic  Groups</a>).
<code>ThreeGroup</code> will signal an error if <var>size</var> is not  a power of 3 between
3 and 729, or <var>nr</var> is larger than the number of groups of size <var>size</var>.
<P>
Within each size the  following criteria have  been  used,  in  turn,  to
determine the index position of a group in the list
<P>
<DL><DT>1:<DD>      increasing generator number;
</DL><P>
<DL><DT>2:<DD>      increasing exponent-3 class;
</DL><P>
<DL><DT>3:<DD>      the position of its parent in the list of groups  of  appropriate
        size;
</DL><P>
<DL><DT>4:<DD>      the  list  in which the Newman and O'Brien implementation of the
        <I>p</I>-group generation algorithm outputs the immediate  descendants
        of a group.
</DL><P>
<pre>    gap> g := ThreeGroup( 243, 56 );
    Group( a1, a2, a3, a4, a5 )
    gap> pClass( g );
    3
    gap> g.abstractRelators;
    [ a1^3, a2^3, a2^-1*a1^-1*a2*a1*a4^-1, a3^3, a3^-1*a1^-1*a3*a1,
      a3^-1*a2^-1*a3*a2*a5^-1, a4^3, a4^-1*a1^-1*a4*a1*a5^-1,
      a4^-1*a2^-1*a4*a2, a4^-1*a3^-1*a4*a3, a5^3, a5^-1*a1^-1*a5*a1,
      a5^-1*a2^-1*a5*a2, a5^-1*a3^-1*a5*a3, a5^-1*a4^-1*a5*a4 ] </pre>
<P>
Apart from the usual components described in  <a href="chap007.htm#SECT118">Group Records</a>, the  group
records returned by the above functions have the following components.
<P>
<DL><DT><code>rank</code>:<DD><BR> 
        rank of Frattini quotient of <var>G</var>.
</DL><P>
<DL><DT><code>pclass</code>:<DD> <BR> 
        exponent-<I>p</I> class of <var>G</var>.
</DL><P>
<DL><DT><code>abstractGenerators</code>:<DD> <BR> 
        a list of abstract generators of <var>G</var> (see <a href="chap022.htm#SECT001">AbstractGenerator</a>).
</DL><P>
<DL><DT><code>abstractRelators</code>:<DD> <BR> 
        a  list of  relators  of <var>G</var>  stored  as  words in  the  abstract
        generators.
</DL><P>
Descriptions of the algorithms used in constructing  the library data may
be found in <A href="biblio.htm#OBr90"><cite>OBr90,OBr91</cite></a>.
<P>
The library was generated and brought into <strong>GAP3</strong> format by E.A. O'Brien
and  Colin Rhodes.  David Baldwin,  M.F. Newman,  and   Maris Ozols  have
contributed in various ways to this  project and to correctly determining
these groups.  The library  design is modelled on and borrows extensively
from  the  2-groups  library, which  was  brought  into <strong>GAP3</strong>  format by
Werner Nickel, Alice Niemeyer, and E.A. O'Brien.
<P><A NAME="SECT010"><h2>38.10 The Irreducible Solvable Linear Groups Library</h2></a>
<P><P><P>
The <strong>IrredSol</strong> group library  provides access to the irreducible solvable
subgroups of <I>GL(n,p)</I>,  where <I>n &gt;  1</I>, <I>p</I> is prime  and <I>p<sup>n</sup> &lt; 256</I>.
The  library contains exactly one member  from each  of the 370 conjugacy
classes of such subgroups.
<P>
By well known theory, this library also doubles as a library of primitive
solvable permutation groups of non-prime degree less than 256.  To access
the  data in  this form, you   must first  build  the  matrix group(s) of
interest and then call the function <BR>
<code>PrimitivePermGroupIrreducibleMatGroup( <var>matgrp</var> )</code> <BR>
This  function returns a permutation  group  isomorphic to the semidirect
product of an   irreducible matrix group  (over a  finite field) and  its
underlying vector space.
<P>
<P>
<code>AllIrreducibleSolvableGroups( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I31"></a>

<P>
<code>AllIrreducibleSolvableGroups</code> returns a  list containing all irreducible
solvable linear groups that have the properties given as arguments.  Each
property is specified by  passing a pair  of arguments, the first being a
function which will be   applied to all  groups  in the library, and  the
second being a  value or a list of  values that this function must return
in  order to     have this group    included  in  the   list  returned by
<code>AllIrreducibleSolvableGroups</code>.
<P>
<pre>    gap> AllIrreducibleSolvableGroups( Dimension, 2,
    >                                   CharFFE, 3,
    >                                   Size, 8 );
    [ Group( [ [ 0*Z(3), Z(3)^0 ], [ Z(3)^0, 0*Z(3) ] ],
        [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0 ] ],
        [ [ Z(3)^0, 0*Z(3) ], [ 0*Z(3), Z(3) ] ] ),
      Group( [ [ 0*Z(3), Z(3)^0 ], [ Z(3), 0*Z(3) ] ],
        [ [ Z(3)^0, Z(3) ], [ Z(3), Z(3) ] ] ),
      Group( [ [ 0*Z(3), Z(3)^0 ], [ Z(3)^0, Z(3) ] ] ) ] </pre>
<P>
<P>
<code>OneIrreducibleSolvableGroup( <var>fun1</var>, <var>val1</var>, <var>fun2</var>, <var>val2</var>, ... )</code>
<A name = "I32"></a>

<P>
<code>OneIrreducibleSolvableGroup</code>  returns   one irreducible  solvable linear
group  that has  the properties   given  as arguments.  Each  property is
specified by  passing  a pair of   arguments, the first being  a function
which will be applied to all groups in  the library, and the second being
a value  or a list of values  that this function  must return in order to
have  this group returned by  <code>OneIrreducibleSolvableGroup</code>.   If no such
group exists, <code>false</code> is returned.
<P>
<pre>    gap> OneIrreducibleSolvableGroup( Dimension, 4,
    >                                  IsLinearlyPrimitive, false );
    Group( [ [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ],
      [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ],
      [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ],
      [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ],
    [ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ],
      [ Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2) ],
      [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ],
      [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ],
    [ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ],
      [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ],
      [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ],
      [ 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ] ] ) </pre>
<P>
<code>AllIrreducibleSolvableGroups</code>     and      <code>OneIrreducibleSolvableGroup</code>
recognize the following   functions  and  handle them very    efficiently
(because the information is stored with the groups and so no computations
are needed): <code>Dimension</code> for the linear  degree, <code>CharFFE</code> for the field
characteristic,         <code>Size</code>,          <code>IsLinearlyPrimitive</code>,       and
<code>MinimalBlockDimension</code>.  Note that the last two are dummy functions that
can be used  only in this context. Their  meaning is explained at the end
of this section.
<P>
<P>
<code>IrreducibleSolvableGroup( <var>n</var>, <var>p</var>, <var>i</var> )</code>
<A name = "I33"></a>

<P>
<code>IrreducibleSolvableGroup</code>   returns  the   <var>i</var>-th  irreducible  solvable
subgroup  of <I>GL</I>(  <var>n</var>,  <var>p</var> ).  The  irreducible  solvable subgroups of
<DL><DT><I>GL(n,p)</I> are ordered with respect to the following criteria:<DD>

<P>&bull; increasing size;
<P>&bull; increasing guardian number.

If two groups have the same size and guardian, they  are in no particular
order.  (See the library documentation   or  [Sho92] for the meaning   of
guardian.)
</DL><P>
<pre>    gap> g := IrreducibleSolvableGroup( 3, 5, 12 );
    Group( [ [ 0*Z(5), Z(5)^2, 0*Z(5) ], [ Z(5)^2, 0*Z(5), 0*Z(5) ],
      [ 0*Z(5), 0*Z(5), Z(5)^2 ] ],
    [ [ 0*Z(5), Z(5)^0, 0*Z(5) ], [ 0*Z(5), 0*Z(5), Z(5)^0 ],
      [ Z(5)^0, 0*Z(5), 0*Z(5) ] ],
    [ [ Z(5)^2, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5) ],
      [ 0*Z(5), 0*Z(5), Z(5)^2 ] ],
    [ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^2, 0*Z(5) ],
      [ 0*Z(5), 0*Z(5), Z(5)^2 ] ],
    [ [ Z(5), 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5), 0*Z(5) ],
      [ 0*Z(5), 0*Z(5), Z(5) ] ] ) </pre>
<P>
Apart from the usual components described in  <a href="chap007.htm#SECT118">Group Records</a>, the  group
records returned by the above functions have the following components.
<P>
<DL><DT><code>size</code>:<DD> <BR> 
        size of <var>G</var>.
</DL><P>
<DL><DT><code>isLinearlyPrimitive</code>:<DD> <BR> 
        <code>false</code>  if  <var>G</var>  preserves  a  direct sum  decomposition  of the
        underlying vector space, and <code>true</code> otherwise.
</DL><P>
<DL><DT><code>minimalBlockDimension</code>:<DD> <BR> 
        not bound  if <var>G</var>  is linearly  primitive;  otherwise  equals the
        dimension of the blocks in an unrefinable system of imprimitivity
        for <var>G</var>.
</DL><P>
This library was computed  and brought into  <strong>GAP3</strong> format by Mark Short.
Descriptions of the algorithms used in computing  the library data can be
found in <A href="biblio.htm#Sho92"><cite>Sho92</cite></a>.
<P><A NAME="SECT011"><h2>38.11 The Library of Finite Perfect Groups</h2></a>
<P><P>
<A name = "I34"></a>

<P>
The <strong>GAP3</strong> library of finite  perfect groups provides, up to isomorphism,
a list of all perfect groups whose sizes are less than  <I>10<sup>6</sup></I>  excluding
the following:

<P>&bull; For <I>n = 61440</I>, 122880, 172032, 245760, 344064, 491520, 688128, or
      983040,  the perfect groups  of size  <I>n</I>  have not completely been
      determined yet.  The library  neither provides  the number of these
      groups nor the groups themselves. \vspace-1mm
<P>&bull; For  <I>n = 86016</I>,  368640,  or  737280,  the library  does not  yet
      contain  the perfect groups  of size  <I>n</I>,  it  only provides their
      their numbers which are 52, 46, or 54, respectively.  \vspace-2mm

<P>
Except for these eleven sizes, the list of altogether 1096 perfect groups
in the library is  complete.  It relies  on results of Derek F. Holt  and
Wilhelm  Plesken which are published  in  their book <I> Perfect Groups</I>
<A href="biblio.htm#HP89"><cite>HP89</cite></a>.  Moreover, they have supplied to us files with presentations
of  488 of the groups.  In terms of  these, the  remaining 607 nontrivial
groups in  the  library can  be   described as 276 direct   products, 107
central  products, and  224  subdirect    products.  They are    computed
automatically by suitable <strong>GAP3</strong> functions whenever they are needed.
<P>
We are grateful to Derek Holt and Wilhelm Plesken for making their groups
available to the <strong>GAP3</strong> community  by contributing their files. It should
be noted that  their book contains a  lot of further information for many
of the library groups.  So we would like  to recommend  it to any  <strong>GAP3</strong>
user who is interested in the groups.
<P>
The library has been brought into <strong>GAP3</strong> format by Volkmar Felsch.
<P>
Like most of  the other <strong>GAP3</strong>  libraries, the library of  finite perfect
groups provides  an  extraction function, <code>PerfectGroup</code>. It  returns the
specified group in form of a finitely presented group which, in its group
record, bears  some additional  information   that allows  you  to easily
construct an isomorphic permutation group  of some appropriate degree  by
just calling the <code>PermGroup</code> function.
<P>
Further, there is    a function <code>NumberPerfectGroups</code>  which  returns the
number of perfect groups of a given size.
<P>
The library  does not provide a selection  or an example function.  There
is, however,  a function <code>DisplayInformationPerfectGroups</code>  which  allows
the  display of some information  about arbitrary  library groups without
actually  loading the large  files  with their presentations, and without
constructing the groups themselves.
<P>
Moereover, there are  two functions which  allow  you to formulate  loops
over     selected    library    groups.    The   first    one    is   the
<code>NumberPerfectLibraryGroups</code> function which, for  any given size, returns
the number of groups in the library which are of that size.
<P>
The second one is the  <code>SizeNumbersPerfectGroups</code> function. It allows you
to ask for all library groups which  contain certain composition factors.
The answer is provided in form of a list of pairs [<I>size</I>,<I>n</I>] where each
such pair  characterizes the <I>n<sup><I>  th</I></sup></I> library group of  size <I>size</I>.
We will call such a pair [<I>size</I>,<I>n</I>] the <strong>size number</strong> of the respective
perfect group. As the size numbers are accepted as input arguments by the
<code>PerfectGroup</code> and  the  <code>DisplayInformationPerfectGroups</code>  function, you
may use their list to formulate a loop over the associated groups.
<P>
Now we shall give an individual description of each library function.
<P>
<P>
<code>NumberPerfectGroups( <var>size</var> )</code>
<A name = "I35"></a>

<P>
<code>NumberPerfectGroups</code> returns the number of non-isomorphic perfect groups
of size <I>size</I> for  each positive integer  <I>size</I> up to <I>10<sup>6</sup></I> except for
the eight  sizes listed at the beginning  of  this section for  which the
number is not yet known. For these values as well as for any argument out
of range it returns the value <I>-1</I>.
<P>
<P>
<code>NumberPerfectLibraryGroups( <var>size</var> )</code>
<A name = "I36"></a>

<P>
<code>NumberPerfectLibraryGroups</code> returns the number of perfect groups of size
<I>size</I> which are available in the library of finite perfect groups.
<P>
The purpose  of the  function  is  to  provide  a simple  way  to
formulate a loop over all library groups of a given size.
<P>
<P>
<code>SizeNumbersPerfectGroups( <var>factor1</var>, <var>factor2</var> ... )</code>
<A name = "I37"></a>

<P>
<code>SizeNumbersPerfectGroups</code> returns a list of  the <I> size numbers</I> (see
above) of all  library groups that contain   the specified factors  among
their composition  factors.  Each argument must either  be  the name of a
simple group or  an integer expression which  is the product of the sizes
of one or  more cyclic factors.  The function  ignores the order in which
the argmuments are given and, in fact, replaces any list of more than one
integer expression among the arguments by their product.
<P>
The following text strings are accepted as simple group names.
<P>

<P>&bull;[] <code>"A5"</code>, <code>"A6"</code>, <code>"A7"</code>, <code>"A8"</code>,  <code>"A9"</code>  or  <code>"A(5)"</code>,  <code>"A(6)"</code>,
      <code>"A(7)"</code>, <code>"A(8)"</code>, <code>"A(9)"</code>  for the alternating groups  <I>A<sub>n</sub></I>, <I>5
       &le; n  &le; 9</I>, \vspace-2mm
<P>&bull;[] <code>"L2(</code><I>q</I><code>)"</code>  or <code>"L(2,</code><I>q</I><code>)"</code> for <I>PSL(2,q)</I>, where <I>q</I> is any
      prime power with <I>4  &le; q  &le; 125</I>, \vspace-2mm
<P>&bull;[] <code>"L3(</code><I>q</I><code>)"</code>  or  <code>"L(3,</code><I>q</I><code>)"</code>  for <I>PSL(3,q)</I>  with <I>2  &le; q
       &le; 5</I>, \vspace-2mm
<P>&bull;[] <code>"U3(</code><I>q</I><code>)"</code>  or  <code>"U(3,</code><I>q</I><code>)"</code>  for <I>PSU(2,q)</I>  with <I>3  &le; q
       &le; 5</I>, \vspace-2mm
<P>&bull;[] <code>"U4(2)</code> or <code>"U(4,2)"</code> for <I>PSU(4,2)</I>, \vspace-2mm
<P>&bull;[] <code>"Sp4(4)"</code> or <code>"S(4,4)"</code> for the symplectic group <I>S(4,4)</I>,
<P>
<P>&bull;[] <code>"Sz(8)"</code> for the Suzuki group <I>Sz(8)</I>, \vspace-2mm
<P>&bull;[] <code>"M11"</code>, <code>"M12"</code>, <code>"M22"</code>  or <code>"M(11)"</code>, <code>"M(12)"</code>, <code>"M(22)"</code> for
      the Matthieu groups <I>M<sub>11</sub></I>, <I>M<sub>12</sub></I>, and <I>M<sub>22</sub></I>, and
<P>
<P>&bull;[] <code>"J1"</code>, <code>"J2"</code>  or  <code>"J(1)"</code>, <code>"J(2)"</code> for the Janko groups <I>J<sub>1</sub></I>
      and <I>J<sub>2</sub></I>. \vspace-2mm

<P>
Note that,    for most of  the  groups,  the preceding   list  offers two
different names in order  to  be consistent  with  the notation  used  in
<A href="biblio.htm#HP89"><cite>HP89</cite></a>       as  well  as   with    the    notation    used in   the
<code>DisplayCompositionSeries</code> command of <strong>GAP3</strong>. However,  as the names  are
compared as text strings,  you are restricted to  the above  choice. Even
expressions like <code>"L2(</code> <code>32</code> <code>)"</code> or <code>"L2(2^5)"</code> are not accepted.
<P>
As the use of the  term <I>PSU(n,q)</I> is  not  unique in the literature,  we
state that here  it denotes the factor  group of <I>SU(n,q)</I> by its centre,
where <I>SU(n,q)</I> is  the group of all <I>n  &times; n</I> unitary matrices  with
entries in <I>GF(q<sup>2</sup>)</I> and determinant 1.
<P>
The purpose  of the function is  to provide a  simple way to  formulate a
loop over all library groups which contain certain composition factors.
<P>
<P>
<code>DisplayInformationPerfectGroups( <var>size</var> )</code>
<A name = "I38"></a>
 <BR> 
<code>DisplayInformationPerfectGroups( <var>size</var>, <var>n</var> )</code> <BR> 
<code>DisplayInformationPerfectGroups( [ <var>size</var>, <var>n</var> ] )</code>
<P>
<code>DisplayInformationPerfectGroups</code> displays  some  information about   the
library group   <I>G</I>,  say,  which  is  specified    by the   size  number
[<var>size</var>,<var>n</var>] or by the two  arguments <I>size</I> and <I>n</I>.   If, in the second
case, <var>n</var> is omitted,  the function will  loop over all library groups of
size <var>size</var>.
<P>
The information provided for <I>G</I> includes the following items:
<P>

<P>&bull; a headline containing the size number <I>[size,n]</I> of <I>G</I> in the form
      <I>size.n</I> (the suffix <I>.n</I> will be suppressed if, up to isomorphism,
      <I>G</I> is the only perfect group of size <I>size</I>), \vspace-2mm
<P>&bull; a message  if <I>G</I> is  simple or quasisimple,  i.e., if the factor
      group of <I>G</I> by its centre is simple, \vspace-2mm
<P>&bull; the ``description''  of the  structure of <I>G</I>  as it is given by
      Holt and Plesken in <A href="biblio.htm#HP89"><cite>HP89</cite></a> (see below), \vspace-2mm
<P>&bull; the size of the centre of  <I>G</I>  (suppressed,  if  <I>G</I>  is  simple),
<P>
<P>&bull; the prime decomposition of the size of <I>G</I>, \vspace-2mm
<P>&bull; orbit sizes for a faithful permutation representation of <I>G</I>  which
      is provided by the library (see below), \vspace-2mm
<P>&bull; a reference to each occurrence of <I>G</I>  in the tables of section 5.3
      of <A href="biblio.htm#HP89"><cite>HP89</cite></a>. Each of these references consists of a class number
      and an internal number  <I>(i,j)</I>  under which <I>G</I>  is listed in that
      class.  For some groups,  there is more than one reference  because
      these groups  belong to more than one  of the classes  in the book.
<P>

Example:
<P>
<pre>    gap> DisplayInformationPerfectGroups( 30720, 3 );
    #I Perfect group 30720.3:  A5 ( 2^4 E N 2^1 E 2^4 ) A
    #I   centre = 1  size = 2^11*3*5  orbit size = 240
    #I   Holt-Plesken class 1 (9,3)
    gap> DisplayInformationPerfectGroups( 30720, 6 );
    #I Perfect group 30720.6:  A5 ( 2^4 x 2^4 ) C N 2^1
    #I   centre = 2  size = 2^11*3*5  orbit size = 384
    #I   Holt-Plesken class 1 (9,6)
    gap> DisplayInformationPerfectGroups( Factorial( 8 ) / 2 );
    #I Perfect group 20160.1:  A5 x L3(2) 2^1
    #I   centre = 2  size = 2^6*3^2*5*7  orbit sizes = 5 + 16
    #I   Holt-Plesken class 31 (1,1) (occurs also in class 32)
    #I Perfect group 20160.2:  A5 2^1 x L3(2)
    #I   centre = 2  size = 2^6*3^2*5*7  orbit sizes = 7 + 24
    #I   Holt-Plesken class 31 (1,2) (occurs also in class 32)
    #I Perfect group 20160.3:  ( A5 x L3(2) ) 2^1
    #I   centre = 2  size = 2^6*3^2*5*7  orbit size = 192
    #I   Holt-Plesken class 31 (1,3)
    #I Perfect group 20160.4:  simple group  A8
    #I   size = 2^6*3^2*5*7  orbit size = 8
    #I   Holt-Plesken class 26 (0,1)
    #I Perfect group 20160.5:  simple group  L3(4)
    #I   size = 2^6*3^2*5*7  orbit size = 21
    #I   Holt-Plesken class 27 (0,1) </pre>
<P>
For any library  group  <I>G</I>, the  library  files  do not  only  provide a
presentation, but,  in addition, a  list of  one or  more subgroups <I>S<sub>1</sub>,
...,  S<sub>r</sub></I>   of  <I>G</I>  such   that  there  is   a faithful  permutation
representation of <I>G</I> of degree <I>&sum;<sub>i=1</sub><sup>r</sup>  G \!:\! S<sub>i</sub></I> on the set
<I>{  S<sub>i</sub> g | 1  &le;  i  &le; r,   g  &isin; G  }</I>  of the cosets of the
<I>S<sub>i</sub></I>. The respective permutation group is  available via the <code>PermGroup</code>
function described below.  The <code>DisplayInformationPerfectGroups</code> function
displays only the available degree. The message
<P>
<code>    orbit size = 8 </code>
<P>
in the above example means  that the available permutation representation
is transitive and of degree 8, whereas the message
<P>
<code>    orbit sizes = 7 + 24 </code>
<P>
means that a nontransitive  permutation representation is available which
acts on two orbits of size 7 and 24 respectively.
<P>
The notation used in the  ``description'' of a  group is explained  in
section 5.1.2 of <A href="biblio.htm#HP89"><cite>HP89</cite></a>. We quote the respective page from there:
<P>
<I> `Within a class <I>Q</I>#<I>p</I>, an  isomorphism type of groups will be
denoted by an ordered pair of integers <I>(r,n)</I>, where <I>r  &ge; 0</I> and <I>n &gt;
0</I>. More precisely, the isomorphism  types in <I>Q</I>  #  <I>p</I> of order  <I>p<sup>r</sup>
\!\! | \!\! Q \!\! |</I> will be denoted by <I>(r,1)</I>, <I>(r,2)</I>, <I>(r,3)</I>,
<I>...</I>. Thus <I>Q</I> will always get the size number <I>(0,1)</I>.
<P>
In  addition to the symbol <I>(r,n)</I>,  the groups in <I>Q    <I> #</I>  p</I>
will  also be given a  more descriptive name.  The purpose of  this is to
provide a very rough idea of  the structure of  the group.  The names are
derived in the following manner. First of all, the isomorphism classes of
irreducible  <I>F<sub>p</sub>Q</I>-modules <I>M</I> with <I>| \!\!  Q  \!\! | | \!\! M
\!\! |    &le; 10<sup>6</sup></I>,  where <I>F<sub>p</sub></I> is   the field of  order <I>p</I>,  are
assigned symbols. These  will either  be simply <I>p<sup>x</sup></I>,  where <I>x</I>  is the
dimension of the module, or, if there is more  than one isomorphism class
of irreducible modules having the same dimension, they will be denoted by
<I>p<sup>x</sup></I>, <I>p<sup>x'</sup></I>,  etc.   The one-dimensional  module   with trivial
<I>Q</I>-action  will therefore be denoted  by  <I>p<sup>1</sup></I>. These  symbols will  be
listed under the description of <I>Q</I>.  The group name consists essentially
of a list  of the composition factors  working from the  top of the group
downwards; hence  it always  starts with the  name  of <I>Q</I> itself.  (This
convention is the most  convenient in our  context,  but it is  different
from that adopted  in the ATLAS (Conway  {\it et al</I>. 1985), for example,
where composition factors  are listed in the  reverse order. For example,
we denote a  group isomorphic to <I>SL(2,5)</I>  by  <I>A<sub>5</sub> 2<sup>1</sup></I> rather  than <I>2
. A<sub>5</sub></I>.)
<P>
Some  other symbols are used  in the name, in order  to give some idea of
the   relationship  between these    composition  factors, and  splitting
properties. We shall now list these additional symbols.
<P>

<P>&bull;[<I>&times;</I>]  between  two  factors   denotes   a  direct  product  of
      <I>F<sub>p</sub>Q</I>-modules or groups. \vspace-2mm
<P>&bull;[C] (for `commutator')  between two factors  means  that the second
      lies in the commutator subgroup of the first.  Similarly, a segment
      of the form  <I>(f<sub>1</sub> \! &times; \! f<sub>2</sub>) <I> C</I> f<sub>3</sub></I>  would mean  that
      the factors <I>f<sub>1</sub></I> and <I>f<sub>2</sub></I>  commute modulo <I>f<sub>3</sub></I> and <I>f<sub>3</sub></I> lies in
      <I>[f<sub>1</sub>,f<sub>2</sub>]</I>. \vspace-2mm
<P>&bull;[A] (for `abelian')  between two factors  indicates that the second
      is  in the  <I>p</I>th  power  (but not the commutator subgroup)  of the
      first.   `A'   may  also   follow  the  factors,   if  bracketed.
<P>
<P>&bull;[E] (for `elementary abelian')  between two factors  indicates that
      together   they  generate  an  elementary  abelian  group   (modulo
      subsequent factors), but that the resulting <I>F<sub>p</sub>Q</I>-module extension
      does not split. \vspace-2mm
<P>&bull;[N]  (for `nonsplit')  before  a  factor  indicates  that  <I>Q</I>  (or
      possibly its covering group)  splits down as far at this factor but
      not over the factor itself.  So  `<I>Q f<sub>1</sub> <I> N</I> f<sub>2</sub></I>' means that
      the normal subgroup  <I>f<sub>1</sub>f<sub>2</sub></I>  of the group  has no complement but,
      modulo <I>f<sub>2</sub></I>, <I>f<sub>1</sub></I>, does have a complement. \vspace-2mm

<DL><DT>Brackets have their obvious meaning. Summarizing, we have:<DD>
</DL><P>

<P>&bull;[<I>&times;</I>] = dirext product; \vspace-2mm
<P>&bull;[C] = commutator subgroup; \vspace-2mm
<P>&bull;[A] = abelian; \vspace-2mm
<P>&bull;[E] = elementary abelian; and \vspace-2mm
<P>&bull;[N] = nonsplit. \vspace-2mm

Here are some examples.
<P>

<P>&bull;[(i)]  <I>A<sub>5</sub> (2<sup>4</sup> <I> E</I> 2<sup>1</sup> <I> E</I> 2<sup>4</sup>) <I> A</I></I>  means  that  the
      pairs  <I>2<sup>4</sup> <I> E</I> 2<sup>1</sup></I>  and <I>2<sup>1</sup> <I> E</I> 2<sup>4</sup></I> are both elementary
      abelian of exponent 4. \vspace-1mm
<P>&bull;[(ii)]   <I>A<sub>5</sub> (2<sup>4</sup> <I> E</I> 2<sup>1</sup> <I> A</I>) <I> C</I> 2<sup>1</sup></I>    means   that
      <I>O<sub>2</sub>(G)</I>  is of  symplectic type  <I>2<sup>1+5</sup></I>,  with  Frattini factor
      group  of type   <I>2<sup>4</sup> <I> E</I> 2<sup>1</sup></I>.   The   `A'  after the  <I>2<sup>1</sup></I>
      indicates that <I>G</I> has a  central cyclic subgroup <I>2<sup>1</sup> <I> A</I> 2<sup>1</sup></I>
      of order 4. \vspace-1mm
<P>&bull;[(iii)]     <I>L<sub>3</sub>(2) ((2<sup>1</sup> <I> E</I>) \! &times; \! (<I> N</I> 2<sup>3</sup> <I> E</I>
      2<sup>3'</sup> <I> A</I>) <I> C</I>) 2<sup>3'</sup></I>    means   that    the
      <I>2<sup>3'</sup></I> factor at the bottom lies in the commutator subgroup
      of the pair <I>2<sup>3</sup> <I> E</I> 2<sup>3'</sup></I> in the middle, but the lower
      pair <I>2<sup>3'</sup> <I> A</I> 2<sup>3'</sup></I>  is abelian of exponent 4.
      There  is  also  a submodule  <I>2<sup>1</sup> <I> E</I> 2<sup>3'</sup></I>,  and  the
      covering group  <I>L<sub>3</sub>(2) 2<sup>1</sup></I>  of  <I>L<sub>3</sub>(2)</I>  does not split over the
      <I>2<sup>3</sup></I>  factor.  (Since <I>G</I> is perfect,  it goes without saying that
      the extension <I>L<sub>3</sub>(2) 2<sup>1</sup></I> cannot split itself.) \vspace-2mm

<P>
We  must  stress  that this  notation does   not  always succeed in being
precise  or even unambiguous, and the  reader is free to  ignore it if it
does not seem helpful.' }
<P>
If such a group description has  been given in  the book for <I>G</I> (and, in
fact, this is the case for  most of the library  groups), it is displayed
by the <code>DisplayInformationPerfectGroups</code> function. Otherwise the function
provides a less explicit  description  of  the  (in these cases   unique)
Holt-Plesken class to which <I>G</I> belongs, together with a serial number if
this is necessary to make it unique.
<P>
<P>
<code>PerfectGroup( <var>size</var> )</code>
<A name = "I39"></a>
 <BR> 
<code>PerfectGroup( <var>size</var>, <var>n</var> )</code> <BR> 
<code>PerfectGroup( [ <var>size</var>, <var>n</var> ] )</code>
<P>
<code>PerfectGroup</code> is the  essential extraction function  of the library.  It
returns  a finitely presented group, <I>G</I>  say, which is isomorphic to the
library  group specified  by the size  number  [<var>size</var>,<var>n</var>] or by the two
separate arguments  <I>size</I> and <I>n</I>. In the  second case, you may omit the
parameter <var>n</var>. Then the default value is <I>n = 1</I>.
<P>
<pre>    gap> G := PerfectGroup( 6048 );
    PerfectGroup(6048)
    gap> G.generators;
    [ a, b ]
    gap> G.relators;
    [ a^2, b^6, a*b*a*b*a*b*a*b*a*b*a*b*a*b,
      a*b^2*a*b^2*a*b^2*a*b^-2*a*b^-2*a*b^-2,
      a*b*a*b^-2*a*b*a*b^-2*a*b*a*b^-2*a*b*a*b^-1*a*b^-1 ]
    gap> G.size;
    6048
    gap> G.description;
    "U3(3)"
    gap> G.subgroups;
    [ Subgroup( PerfectGroup(6048), [ a, b*a*b*a*b*a*b^3 ] ) ] </pre>
<P>
The  generators and  relators   of  <var>G</var>  coincide  with  those  given  in
<A href="biblio.htm#HP89"><cite>HP89</cite></a>.
<P>
Note that,  besides the components  that are  usually initialized for any
finitely presented group, the group  record of <var>G</var> contains the following
components:
<P>
<DL><DT><code>size</code>:<DD> <BR> 
      the size of <var>G</var>,
</DL><P>
<DL><DT><code>isPerfect</code>:<DD> <BR> 
      always <code>true</code>,
</DL><P>
<DL><DT><code>description</code>:<DD> <BR> 
      the description of <var>G</var> as described with the
      <code>DisplayInformationPerfectGroups</code> function above,
</DL><P>
<DL><DT><code>source</code>:<DD> <BR> 
      some internal information used by the library functions,
</DL><P>
<DL><DT><code>subgroups</code>:<DD> <BR> 
      a list of subgroups <I>S<sub>1</sub>, ..., S<sub>r</sub></I> of <var>G</var>
      such that <var>G</var> acts faithfully on
      on the union of the sets of all cosets of the <I>S<sub>i</sub></I>.
</DL><P>
The  last of these components  exists   only if <var>G</var>  is   one of the  488
nontrivial library  groups which are given directly  by a presentation on
file, i.e., which are not constructed from other library groups in form
of a direct, central,  or subdirect product. It will  be required by  the
following function.
<P>
<P>
<code>PermGroup( <var>G</var> )</code>
<A name = "I40"></a>

<P>
<code>PermGroup</code> returns a permutation group, <I>P</I>  say, which is isomorphic to
the given group <var>G</var>  which is assumed  to be a finitely presented perfect
group  that  has been extracted from the library of finite perfect groups
via the <code>PerfectGroup</code> function.
<P>
Let <I>S<sub>1</sub>,   ...,  S<sub>r</sub></I> be    the subgroups   listed in the   component
<code><var>G</var>.subgroups</code> of the group record of  <var>G</var>. Then the resulting group <I>P</I>
is the permutation group of degree <I>&sum;<sub>i=1</sub><sup>r</sup> G \!:\! S<sub>i</sub></I> which is
induced by <var>G</var> on the set <I>{ S<sub>i</sub> g | 1  &le; i  &le;  r, g &isin; G }</I> of
all cosets of the <I>S<sub>i</sub></I>.
<P>
Example (continued):
<P>
<pre>    gap> P := PermGroup( G );
    PermGroup(PerfectGroup(6048))
    gap> P.size;
    6048
    gap> P.degree;
    28 </pre>
<P>
Note that some of the  library groups do not  have a faithful permutation
representation of  small  degree.  Computations in  these groups  may  be
rather time consuming.
<P>
Example:
<P>
<pre>    gap> P := PermGroup( PerfectGroup( 129024, 2 ) );
    PermGroup(PerfectGroup(129024,2))
    gap> P.degree;
    14336 </pre>
<P><A NAME="SECT012"><h2>38.12 Irreducible Maximal Finite Integral Matrix Groups</h2></a>
<P><P>
<A name = "I41"></a>

<P>
A   library of irreducible   maximal finite   integral  matrix groups  is
provided with <strong>GAP3</strong>. It  contains <I>&#x211A;</I>-class representatives for  all of
these groups of dimension at  most 24, and <I>&#x2124;</I>-class representatives for
those of dimension at most 11 or of dimension 13, 17, 19, or 23.
<P>
The  groups  provided  in this  library  have been  determined by Wilhelm
Plesken, partially as joint work with Michael Pohst, or by members of his
institute (Lehrstuhl B f&uuml;r    Mathematik, RWTH  Aachen).   In
particular, the data for the groups of dimensions  2 to 9 have been taken
from the output  of computer  calculations which  they performed in  1979
(see   <A href="biblio.htm#PP77"><cite>PP77</cite></a>, <A href="biblio.htm#PP80"><cite>PP80</cite></a>). The  <I>&#x2124;</I>-class  representatives of the
groups  of  dimension  10 have  been  determined and    computed by Bernd
Souvignier (<A href="biblio.htm#Sou94"><cite>Sou94</cite></a>),  and those of  dimensions 11, 13,  and 17 have
been  recomputed for this library from  the circulant Gram matrices given
in  <A href="biblio.htm#Ple85"><cite>Ple85</cite></a>, using the  stand-alone  programs for the computation of
short vectors and Bravais groups which have  been developed in Plesken's
institute. The <I>&#x2124;</I>-class representatives of  the groups of dimensions 19
and  23 had already been  determined in  <A href="biblio.htm#Ple85"><cite>Ple85</cite></a>.  Gabriele Nebe has
recomputed them  for us. Her  main contribution to this library, however,
is that she has determined and computed the <I>&#x211A;</I>-class representatives of
the groups  of non-prime dimensions  between 12 and  24 (see <A href="biblio.htm#PN95"><cite>PN95</cite></a>,
<A href="biblio.htm#NP95"><cite>NP95</cite></a>, <A href="biblio.htm#Neb95"><cite>Neb95</cite></a>).
<P>
The library has been brought into <strong>GAP3</strong> format by Volkmar Felsch. He has
applied several <strong>GAP3</strong> routines to check certain consistency of the data.
However, the  credit  and responsibility for  the lists   remain with the
authors. We are   grateful to Wilhelm Plesken,  Gabriele  Nebe, and Bernd
Souvignier for supplying their results to <strong>GAP3</strong>.
<P>
In the preceding  acknowledgement, we used  some notations that will also
be needed in the sequel. We first define these.
<P>
Any  integral matrix   group  <I>G</I>  of  dimension   <I>n</I> is a  subgroup  of
<I>GL<sub>n</sub>(&#x2124;)</I> as  well  as of  <I>GL<sub>n</sub>(&#x211A;)</I>  and hence lies in  some conjugacy
class of integral  matrix groups   under  <I>GL<sub>n</sub>(&#x2124;)</I>  and also in    some
conjugacy class of rational matrix  groups under <I>GL<sub>n</sub>(&#x211A;)</I>. As usual, we
call  these  classes    the  <I>&#x2124;</I>-class   and the   <I>&#x211A;</I>-class   of  <I>G</I>,
respectively.  Note that any conjugacy  class of subgroups of  <I>GL<sub>n</sub>(&#x211A;)</I>
contains at least one <I>&#x2124;</I>-class of subgroups of <I>GL<sub>n</sub>(&#x2124;)</I> and hence can
be considered as the <I>&#x211A;</I>-class of some integral matrix group.
<P>
In the context  of this library  we are only concerned  with <I>&#x2124;</I>-classes
and <I>&#x211A;</I>-classes of subgroups   of <I>GL<sub>n</sub>(&#x2124;)</I> which are irreducible   and
maximal    finite   in     <I>GL<sub>n</sub>(&#x2124;)</I>   (we   will    call   them    <em>
i.m.f.</em> subgroups  of <I>GL<sub>n</sub>(&#x2124;)</I>).  We can  distinguish  two types of
these groups:
<P>
First, there are those i.m.f. subgroups  of <I>GL<sub>n</sub>(&#x2124;)</I> which are also
maximal finite subgroups of <I>GL<sub>n</sub>(&#x211A;)</I>.  Let  us  denote the set of their
<I>&#x211A;</I>-classes by <I>Q<sub>1</sub>(n)</I>. It is clear from the above remark that <I>Q<sub>1</sub>(n)</I>
just consists of the <I>Q</I>-classes of i.m.f. subgroups of <I>GL<sub>n</sub>(&#x211A;)</I>.
<P>
Secondly, there is the set <I>Q<sub>2</sub>(n)</I> of the  <I>&#x211A;</I>-classes of the remaining
i.m.f. subgroups  of  <I>GL<sub>n</sub>(&#x2124;)</I>, i.e.,  of   those which  are  not
maximal finite  subgroups  of <I>GL<sub>n</sub>(&#x211A;)</I>. For any   such group <I>G</I>,  say,
there is at least  one class <I>C &isin;  Q<sub>1</sub>(n)</I> such  that <I>G</I> is  conjugate
under  <I>&#x211A;</I> to a proper subgroup  of some group  <I>H &isin; C</I>.  In fact, the
class  <I>C</I> is uniquely  determined  for any  group <I>G</I>  occurring in  the
library (though there seems to be no reason  to assume that this property
should hold  in  general). Hence  we may   call   <I>C</I> the <em>   rational
i.m.f. class</em>  of <I>G</I>. Finally, we  will denote the number of classes
in <I>Q<sub>1</sub>(n)</I> and <I>Q<sub>2</sub>(n)</I> by <I>q<sub>1</sub>(n)</I> and <I>q<sub>2</sub>(n)</I>, respectively.
<P>
As an example, let us consider the case <I>n = 4</I>. There are 6 <I>&#x2124;</I>-classes
of  i.m.f. subgroups of  <I>GL<sub>4</sub>(&#x2124;)</I> with  representative  subgroups
<I>G<sub>1</sub>,  ..., G<sub>6</sub></I> of isomorphsim  types  </i><I>G<sub>1</sub> &cong; W(F<sub>4</sub>)</I><i>,
</i><I>G<sub>2</sub>  &cong;  D<sub>12</sub>  \wr C<sub>2</sub></I><i>,  </i><I>G<sub>3</sub>  &cong;  G<sub>4</sub> &cong; C<sub>2</sub>
&times; S<sub>5</sub></I><i>, </i><I>G<sub>5</sub>  &cong;   W(B<sub>4</sub>)</I><i>, and  </i><I>G<sub>6</sub>   &cong;
(D<sub>12</sub> \sf Y D<sub>12</sub>)   \!:\! C<sub>2</sub></I><i>. The   corresponding <I>&#x211A;</I>-classes,
<I>R<sub>1</sub>,  ..., R<sub>6</sub></I>,  say,   are  pairwise different   except that  <I>R<sub>3</sub></I>
coincides with    <I>R<sub>4</sub></I>.  The  groups  <I>G<sub>1</sub></I>,   <I>G<sub>2</sub></I>,  and   <I>G<sub>3</sub></I>   are
i.m.f. subgroups  of <I>GL<sub>4</sub>(&#x211A;)</I>, but <I>G<sub>5</sub></I>  and <I>G<sub>6</sub></I> are not because
they are   conjugate under <I>GL<sub>4</sub>(&#x211A;)</I> to  proper  subgroups of  <I>G<sub>1</sub></I> and
<I>G<sub>2</sub></I>,  respectively.    So we  have <I>Q<sub>1</sub>(4) =   {  R<sub>1</sub>, R<sub>2</sub>, R<sub>3</sub> }</I>,
<I>Q<sub>2</sub>(4) = { R<sub>5</sub>, R<sub>6</sub> }</I>, <I>q<sub>1</sub>(4) = 3</I>, and <I>q<sub>2</sub>(4) = 2</I>.
<P>
The  <I>q<sub>1</sub>(n)</I> <I>&#x211A;</I>-classes  of i.m.f. subgroups  of <I>GL<sub>n</sub>(&#x211A;)</I> have
been   determined for  each  dimension  <I>n   &le; 24</I>.  The current <strong>GAP3</strong>
library provides integral representative   groups for all  these classes.
Moreover, all <I>&#x2124;</I>-classes of   i.m.f. subgroups of <I>GL<sub>n</sub>(&#x2124;)</I>  are
known  for  <I>n  &le;   11</I> and  for   <I>n &isin;  {13,17,19,23}</I>. For  these
dimensions,  the  library offers  integral  representative groups for all
<I>&#x211A;</I>-classes in  <I>Q<sub>1</sub>(n)</I>  and  <I>Q<sub>2</sub>(n)</I>  as well as for all <I>&#x2124;</I>-classes
of i.m.f. subgroups of <I>GL<sub>n</sub>(&#x2124;)</I>.
<P>
Any group <I>G</I> of dimension <I>n</I> given in the library is represented as the
automorphism group <I>G = <I> Aut</I>(F,L) = { g &isin; GL<sub>n</sub>(&#x2124;) | Lg = L  
<I> and</I>   g F g<sup><I> tr</I></sup> =  F }</I> of a  positive definite symmetric <I>n
&times; n</I> matrix <I>F &isin; &#x2124;<sup>n &times; n</sup></I> on an <I>n</I>-dimensional lattice <I>L
&cong; &#x2124;<sup>1 &times;  n</sup></I>   (for details see e.g.    <A href="biblio.htm#PN95"><cite>PN95</cite></a>). <strong>GAP3</strong>
provides for <I>G</I> a  list of matrix generators and  the <em>  Gram matrix</em>
<I>F</I>.
<P>
The positive definite quadratic form defined by  <I>F</I> defines a <em> norm</em>
<I>v F v<sup><I>  tr</I></sup></I> for each vector  <I>v &isin; L</I>,  and there is only a finite
set  of vectors of  minimal norm.  These vectors  are often simply called
the <em> ``short vectors''</em>.  Their  set splits into orbits under  <I>G</I>,
and  <I>G</I> being irreducible   acts faithfully on  each  of these orbits by
multiplication from the right.  <strong>GAP3</strong> provides for  each of these orbits
the orbit size and a representative vector.
<P>
Like    most   of  the   other   <strong>GAP3</strong>   libraries,   the  library  of
i.m.f. integral    matrix groups  supplies   an  extraction function,
<code>ImfMatGroup</code>.  However, as   the  library involves   only  423 different
groups, there is no need for a selection or an example function. Instead,
there   are  two functions, <code>ImfInvariants</code>  and  <code>DisplayImfInvariants</code>,
which provide  some <I>&#x2124;</I>-class invariants that can  be extracted from the
library   without actually   constructing   the   representative   groups
themselves. The difference between these two functions is that the latter
one displays  the resulting data in  some easily readable format, whereas
the first one returns them as record components  so that you can properly
access them.
<P>
We shall give an individual description of each of the library functions,
but first we would like to insert a short remark concerning their names:
  Any self-explaining  name   of  a function handling  <em>  irreducible
maximal finite integral matrix groups</em> would have to include this term in
full length  and hence would   grow extremely  long.  Therefore we   have
decided to use  the abbreviation <code>Imf</code> instead in  order  to restrict the
names to some reasonable length.
<P>
The  first  three  functions can   be  used to formulate  loops  over the
classes.
<P>
<P>
<code>ImfNumberQQClasses( <var>dim</var> )</code>
<A name = "I42"></a>
 <BR> 
<code>ImfNumberQClasses( <var>dim</var> )</code>
<A name = "I43"></a>
 <BR> 
<code>ImfNumberZClasses( <var>dim</var>, <var>q</var> )</code>
<A name = "I44"></a>

<P>
<code>ImfNumberQQClasses</code>  returns the  number  <I>q<sub>1</sub>(</I><var>dim</var><I>)</I> of <I>&#x211A;</I>-classes
of i.m.f. rational  matrix groups of  dimension <var>dim</var>. Valid values
of <var>dim</var> are all positive integers up to 24.
<P>
Note: In order to enable you to loop just over the classes belonging to
<I>Q<sub>1</sub>(</I><var>dim</var><I>)</I>, we have  arranged the list  of <I>&#x211A;</I>-classes of  dimension
<var>dim</var> for  any  dimension <var>dim</var>  in the library   such that, whenever the
classes of <I>Q<sub>2</sub>(</I><var>dim</var><I>)</I> are known, too,  i.e., in the cases <I>dim  &le;
11</I> or  <I>dim &isin; {13,17,19,23}</I>,  the classes of <I>Q<sub>1</sub>(</I><var>dim</var><I>)</I> precede
those of <I>Q<sub>2</sub>(</I><var>dim</var><I>)</I> and hence are numbered from 1 to <I>q<sub>1</sub>(</I><var>dim</var><I>)</I>.
<P>
<code>ImfNumberQClasses</code>  returns the  number   of <I>&#x211A;</I>-classes  of  groups of
dimension <var>dim</var> which are available in  the library. If  <I>dim  &le; 11</I> or
<I>dim  &isin;    {13,17,19,23}</I>, this   is   the number    <I>q<sub>1</sub>(</I><var>dim</var><I>)  +
q<sub>2</sub>(</I><var>dim</var><I>)</I>   of     <I>&#x211A;</I>-classes  of      i.m.f. subgroups    of
<I>GL<sub>dim</sub>(&#x2124;)</I>.   Otherwise, it  is   just the number   <I>q<sub>1</sub>(</I><var>dim</var><I>)</I> of
<I>&#x211A;</I>-classes of i.m.f. subgroups of <I>GL<sub>dim</sub>(&#x211A;)</I>. Valid values of
<var>dim</var> are all positive integers up to 24.
<P>
<code>ImfNumberZClasses</code> returns the number of  <I>&#x2124;</I>-classes in the  <var>q</var><I><sup><I>
th</I></sup></I>  <I>&#x211A;</I>-class   of i.m.f. integral matrix    groups of dimension
<var>dim</var>. Valid values of <var>dim</var> are  all positive integers up  to 11 and all
primes up to 23.
<P>
<P>
<code>DisplayImfInvariants( <var>dim</var>, <var>q</var> )</code>
<A name = "I45"></a>
 <BR> 
<code>DisplayImfInvariants( <var>dim</var>, <var>q</var>, <var>z</var> )</code>
<P>
<code>DisplayImfInvariants</code>  displays the  following <I>&#x2124;</I>-class invariants  of
the   groups in the  <var>z</var><I><sup><I>   th</I></sup></I>  <I>&#x2124;</I>-class  in the  <var>q</var><I><sup><I> th</I></sup></I>
<I>&#x211A;</I>-class of i.m.f. integral matrix groups of dimension <var>dim</var>:

<P>&bull; its  <I>&#x2124;</I>-class number  in the form  <var>dim</var>.<var>q</var>.<var>z</var>,  if <var>dim</var> is at
      most 11 or a prime, or its <I>&#x211A;</I>-class number in the form <var>dim</var>.<var>q</var>,
      else, \vspace-2mm
<P>&bull; a message if the group is solvable, \vspace-2mm
<P>&bull; the size of the group, \vspace-2mm
<P>&bull; the isomorphism type of the group, \vspace-2mm
<P>&bull; the   elementary  divisors   of  the   associated  quadratic  form,
<P>
<P>&bull; the sizes  of the  orbits  of short vectors  (these  sizes  are the
      degrees of the  faithful permutation representations  which you may
      construct using the  <code>PermGroup</code>  or  <code>PermGroupImfGroup</code>  commands
      below), \vspace-2mm
<P>&bull; the norm of the associated short vectors, \vspace-2mm
<P>&bull; only  in  case  that  the  group  is  not  an  i.m.f. group  in
      <I>GL<sub>n</sub>(&#x211A;)</I>:  an  appropriate  message,  including the  <I>&#x211A;</I>-class
      number    of   the    corresponding   rational    i.m.f. class.
<P>

If you specify the value 0 for any of  the parameters <var>dim</var>, <var>q</var>, or <var>z</var>,
the command will loop  over   all available dimensions, <I>&#x211A;</I>-classes   of
given   dimension,    or <I>&#x2124;</I>-classes    within  the  given   <I>&#x211A;</I>-class,
respectively. Otherwise, the values of the arguments must be in range.  A
value <var>z</var><I>  &ne;  1</I>  must not be specified  if  the <I>&#x2124;</I>-classes are  not
known  for the given dimension,  i.e., if <I>dim &gt; 11</I>  and <I>dim &notin;
{13,17,19,23}</I>. The default value  of <var>z</var> is 1. This  value of <var>z</var> will
be accepted even if the <I>&#x2124;</I>-classes are not known. Then it specifies the
only representative group  which   is available for the    <var>q</var><I><sup><I> th</I></sup></I>
<I>&#x211A;</I>-class. The greatest legal value of <var>dim</var> is 24.
<P>
<pre>    gap> DisplayImfInvariants( 3, 1, 0 );
    #I Z-class 3.1.1:  Solvable, size = 2^4*3
    #I   isomorphism type = C2 wr S3 = C2 x S4 = W(B3)
    #I   elementary divisors = 1^3
    #I   orbit size = 6, minimal norm = 1
    #I Z-class 3.1.2:  Solvable, size = 2^4*3
    #I   isomorphism type = C2 wr S3 = C2 x S4 = C2 x W(A3)
    #I   elementary divisors = 1*4^2
    #I   orbit size = 8, minimal norm = 3
    #I Z-class 3.1.3:  Solvable, size = 2^4*3
    #I   isomorphism type = C2 wr S3 = C2 x S4 = C2 x W(A3)
    #I   elementary divisors = 1^2*4
    #I   orbit size = 12, minimal norm = 2
    gap> DisplayImfInvariants( 8, 15, 1 );
    #I Z-class 8.15.1:  Solvable, size = 2^5*3^4
    #I   isomorphism type = C2 x (S3 wr S3)
    #I   elementary divisors = 1*3^3*9^3*27
    #I   orbit size = 54, minimal norm = 8
    #I   not maximal finite in GL(8,Q), rational imf class is 8.5
    gap> DisplayImfInvariants( 20, 23 );
    #I Q-class 20.23:  Size = 2^5*3^2*5*11
    #I   isomorphism type = (PSL(2,11) x D12).C2
    #I   elementary divisors = 1^18*11^2
    #I   orbit size = 3*660 + 2*1980 + 2640 + 3960, minimal norm = 4 </pre>
<P>
Note that the <code>DisplayImfInvariants</code> function uses a kind of shorthand to
display the elementary divisors.  E. g., the expression <code>1*3^3*9^3*27</code> in
the   preceding     example   stands   for   the   elementary    divisors
<I>1,3,3,3,9,9,9,27</I>.  (See also  the next  example  which  shows  that the
<code>ImfInvariants</code> function  provides the elementary  divisors in form of an
ordinary <strong>GAP3</strong> list.)
<P>
In  the description of the isomorphism  types the following notations are
used:
<P>

<P>&bull;[]
\beginitemize
<P>&bull;[]
\beginitemize
<P>&bull;[{\makebox[15mm][l]<I>A</i>x<i>B</I>}]  denotes a direct product of
      a group <I>A</I> by a group <I>B</I>, \vspace-1mm
<P>&bull;[{\makebox[15mm][l]<I>A</i>subd<i>B</I>}]   denotes   a   subdirect
      product of <I>A</I> by <I>B</I>, \vspace-1mm
<P>&bull;[{\makebox[15mm][l]<I>A</i>Y<i>B</I>}] denotes a central product of
      <I>A</I> by <I>B</I>, \vspace-1mm
<P>&bull;[{\makebox[15mm][l]<I>A</i>wr<i>B</I>}] denotes a wreath product of
      <I>A</I> by <I>B</I>, \vspace-1mm
<P>&bull;[{\makebox[15mm][l]<I>A:B</I>}]  denotes  a split extension  of <I>A</I> by
      <I>B</I>, \vspace-1mm
<P>&bull;[{\makebox[15mm][l]<I>A.B</I>}] denotes just an extension of <I>A</I> by
      <I>B</I> (split or nonsplit). \vspace-2mm

\enditemize
\enditemize
The groups involved are
<P>

<P>&bull; the  cyclic groups  <I>C<sub>n</sub></I>,  dihedral groups <I>D<sub>n</sub></I>,  and generalized
      quaternion groups  <I>Q<sub>n</sub></I> of order <I>n</I>,  denoted by <code>C</code><var>n</var>,  <code>D</code><var>n</var>,
      and <code>Q</code><var>n</var>, respectively, \vspace-2mm
<P>&bull; the alternating groups  <I>A<sub>n</sub></I>  and symmetric groups <I>S<sub>n</sub></I> of degree
      <I>n</I>,  denoted by  <code>A</code><var>n</var> and  <code>S</code><var>n</var>,  respectively,  \vspace-2mm
<P>&bull; the linear groups <I>GL<sub>n</sub>(q)</I>, <I>PGL<sub>n</sub>(q)</I>, <I>SL<sub>n</sub>(q)</I>, and <I>PSL<sub>n</sub>(q)</I>,
      denoted       by       <code>GL(</code><var>n</var><code>,</code><var>q</var><code>)</code>,       <code>PGL(</code><var>n</var><code>,</code><var>q</var><code>)</code>,
      <code>SL(</code><var>n</var><code>,</code><var>q</var><code>)</code>, and <code>PSL(</code><var>n</var><code>,</code><var>q</var><code>)</code>, respectively,
<P>
<P>&bull; the   unitary  groups   <I>SU<sub>n</sub>(q)</I>   and   <I>PSU<sub>n</sub>(q)</I>,   denoted  by
      <code>SU(</code><var>n</var><code>,</code><var>q</var><code>)</code>     and     <code>PSU(</code><var>n</var><code>,</code><var>q</var><code>)</code>,     respectively,
<P>
<P>&bull; the  symplectic  groups  <I>Sp(n,q)</I>,  denoted by  <code>Sp(</code><var>n</var><code>,</code><var>q</var><code>)</code>,
<P>
<P>&bull; the   orthogonal  group   <I>O<sub>8</sub><sup>+</sup>(2)</I>,   denoted  by  <code>O+(8,2)</code>,
<P>
<P>&bull; the    extraspecial    groups     <I>2<sub>+</sub><sup>1+8</sup></I>,     <I>3<sub>+</sub><sup>1+2</sup></I>,
      <I>3<sub>+</sub><sup>1+4</sup></I>,   and   <I>5<sub>+</sub><sup>1+2</sup></I>,    denoted   by   <code>2+^(1+8)</code>,
      <code>3+^(1+2)</code>, <code>3+^(1+4)</code>, and <code>5+^(1+2)</code>, respectively, \vspace-2mm
<P>&bull; the Chevalley group <I>G<sub>2</sub>(3)</I>, denoted by <code>G(2,3)</code>,
<P>
<P>&bull; the  Weyl  groups   <I>W(A<sub>n</sub>)</I>,  <I>W(B<sub>n</sub>)</I>,  <I>W(D<sub>n</sub>)</I>,  <I>W(E<sub>n</sub>)</I>,  and
      <I>W(F<sub>4</sub>)</I>,   denoted  by   <code>W(A</code><var>n</var><code>)</code>,   <code>W(B</code><var>n</var><code>)</code>,  <code>W(D</code><var>n</var><code>)</code>,
      <code>W(E</code><var>n</var><code>)</code>, and <code>W(F4)</code>, respectively, \vspace-2mm
<P>&bull; the sporadic simple groups  <I>Co<sub>1</sub></I>,  <I>Co<sub>2</sub></I>,  <I>Co<sub>3</sub></I>,  <I>HS</I>, <I>J<sub>2</sub></I>,
      <I>M<sub>12</sub></I>,  <I>M<sub>22</sub></I>,  <I>M<sub>23</sub></I>,  <I>M<sub>24</sub></I>,  and  <I>Mc</I>,  denoted  by
      <code>Co1</code>, <code>Co2</code>, <code>Co3</code>,  <code>HS</code>, <code>J2</code>,  <code>M12</code>, <code>M22</code>, <code>M23</code>, <code>M24</code>,  and
      <code>Mc</code>, respectively, \vspace-2mm
<P>&bull; a point  stabilizer  of index  11  in  <I>M<sub>11</sub></I>,  denoted by <code>M10</code>.
<P>

<P>
As  mentioned  above, the data  assembled  by  the <code>DisplayImfInvariants</code>
command are  ``cheap data'' in the sense  that they can be provided by
the  library without loading any of  its large matrix files or performing
any matrix calculations. The following  function allows you to get proper
access to these cheap data instead of just displaying them.
<P>
<P>
<code>ImfInvariants( <var>dim</var>, <var>q</var> )</code>
<A name = "I46"></a>
 <BR> 
<code>ImfInvariants( <var>dim</var>, <var>q</var>, <var>z</var> )</code>
<P>
<code>ImfInvariants</code> returns     a  record  which  provides   some  <I>&#x2124;</I>-class
invariants of   the   groups in  the  <var>z</var><I><sup><I>  th</I></sup></I>   <I>&#x2124;</I>-class in the
<var>q</var><I><sup><I>    th</I></sup></I> <I>&#x211A;</I>-class of    i.m.f. integral  matrix  groups of
dimension  <var>dim</var>.  A value  <var>z</var><I>  &ne;  1</I> must  not  be  specified if the
<I>&#x2124;</I>-classes are not known for the given dimension, i.e., if <I>dim &gt; 11</I>
and <I>dim &notin; {13,17,19,23}</I>. The default value of  <var>z</var> is 1.  This
value  of <var>z</var>   will  be  accepted even   if  the  <I>&#x2124;</I>-classes  are  not
known. Then it specifies the only representative group which is available
for the <var>q</var><I><sup><I> th</I></sup></I> <I>&#x211A;</I>-class.  The greatest legal  value of <var>dim</var> is
24.
<P>
The resulting record contains six or seven components:
<P>
<DL><DT><code>size</code>:<DD> <BR> 
      the size of any representative group <var>G</var>,
</DL><P>
<DL><DT><code>isSolvable</code>:<DD> <BR> 
      is <code>true</code> if <var>G</var> is solvable,
</DL><P>
<DL><DT><code>isomorphismType</code>:<DD> <BR> 
      a text string describing the isomorphism type of  <var>G</var>  (in the same
      notation as used by the <code>DisplayImfInvariants</code> command above),
</DL><P>
<DL><DT><code>elementaryDivisors</code>:<DD> <BR> 
      the elementary divisors of the associated Gram matrix  <var>F</var>  (in the
      same format as the result of the  <code>ElementaryDivisorsMat</code> function,
      see <a href="chap034.htm#SECT023">ElementaryDivisorsMat</a>),
</DL><P>
<DL><DT><code>minimalNorm</code>:<DD> <BR> 
      the norm of the associated short vectors,
</DL><P>
<DL><DT><code>sizesOrbitsShortVectors</code>:<DD> <BR> 
      the sizes of the orbits of short vectors under <var>F</var>,
</DL><P>
<DL><DT><code>maximalQClass</code>:<DD> <BR> 
      the  <I>&#x211A;</I>-class number  of an  i.m.f. group  in <I>GL<sub>n</sub>(&#x211A;)</I> that
      contains <var>G</var> as a subgroup  (only in case that not <var>G</var> itself is an
      i.m.f. subgroup of <I>GL<sub>n</sub>(&#x211A;)</I>).
</DL><P>
Note that four of these data, namely the group size, the solvability, the
isomorphism type,  and the  corresponding rational  i.m.f. class, are
not only <I>&#x2124;</I>-class invariants, but also <I>&#x211A;</I>-class invariants.
<P>
Note further that, though the isomorphism type is a <I>&#x211A;</I>-class invariant,
you will sometimes get  different descriptions for different <I>&#x2124;</I>-classes
of the  same <I>&#x211A;</I>-class (as, e.g., for  the classes 3.1.1 and  3.1.2 in
the last example above). The purpose of this behaviour is to provide some
more information about the underlying lattices.
<P>
<pre>    gap> ImfInvariants( 8, 15, 1 );
    rec(
      size := 2592,
      isSolvable := true,
      isomorphismType := "C2 x (S3 wr S3)",
      elementaryDivisors := [ 1, 3, 3, 3, 9, 9, 9, 27 ],
      minimalNorm := 8,
      sizesOrbitsShortVectors := [ 54 ],
      maximalQClass := 5 )
    gap> ImfInvariants( 24, 1 ).size;
    10409396852733332453861621760000
    gap> ImfInvariants( 23, 5, 2 ).sizesOrbitsShortVectors;
    [ 552, 53130 ]
    gap> for i in [ 1 .. ImfNumberQClasses( 22 ) ] do
    >    Print( ImfInvariants( 22, i ).isomorphismType, "\n" ); od;
    C2 wr S22 = W(B22)
    (C2 x PSU(6,2)).S3
    (C2 x S3) wr S11 = (C2 x W(A2)) wr S11
    (C2 x S12) wr C2 = (C2 x W(A11)) wr C2
    C2 x S3 x S12 = C2 x W(A2) x W(A11)
    (C2 x HS).C2
    (C2 x Mc).C2
    C2 x S23 = C2 x W(A22)
    C2 x PSL(2,23)
    C2 x PSL(2,23)
    C2 x PGL(2,23)
    C2 x PGL(2,23) </pre>
<P>
<P>
<code>ImfMatGroup( <var>dim</var>, <var>q</var> )</code>
<A name = "I47"></a>
 <BR> 
<code>ImfMatGroup( <var>dim</var>, <var>q</var>, <var>z</var> )</code>
<P>
<code>ImfMatGroup</code> is the essential extraction   function of this library.  It
returns a representative group, <var>G</var> say, of the <var>z</var><I><sup><I> th</I></sup></I> <I>&#x2124;</I>-class
in the <var>q</var><I><sup><I> th</I></sup></I> <I>&#x211A;</I>-class of  i.m.f. integral matrix groups of
dimension <var>dim</var>. A   value <var>z</var><I>  &ne;  1</I>  must  not be specified  if  the
<I>&#x2124;</I>-classes are not known for the given dimension, i.e., if <I>dim &gt; 11</I>
and <I>dim &notin; {13,17,19,23}</I>. The default  value of <var>z</var> is 1.  This
value  of  <var>z</var> will    be accepted even   if   the <I>&#x2124;</I>-classes  are  not
known. Then it specifies the only representative group which is available
for the <var>q</var><I><sup><I> th</I></sup></I>  <I>&#x211A;</I>-class. The greatest  legal value of <var>dim</var> is
24.
<P>
<pre>    gap> G := ImfMatGroup( 5, 1, 3 );
    ImfMatGroup(5,1,3)
    gap> for m in G.generators do PrintArray( m ); od;
    [ [  -1,   0,   0,   0,   0 ],
      [   0,   1,   0,   0,   0 ],
      [   0,   0,   0,   1,   0 ],
      [  -1,  -1,  -1,  -1,   2 ],
      [  -1,   0,   0,   0,   1 ] ]
    [ [  0,  1,  0,  0,  0 ],
      [  0,  0,  1,  0,  0 ],
      [  0,  0,  0,  1,  0 ],
      [  1,  0,  0,  0,  0 ],
      [  0,  0,  0,  0,  1 ] ] </pre>
<P>
The group record  of <var>G</var> contains the usual  components of a matrix group
record. In addition,  it includes  the same  six or seven  records as the
resulting record of the <code>ImfInvariants</code>  function described above, namely
the        components        <code>size</code>,   <code>isSolvable</code>,   <code>isomorphismType</code>,
<code>elementaryDivisors</code>, <code>minimalNorm</code>, and  <code>sizesOrbitsShortVectors</code>  and,
if <var>G</var> is not a   rational i.m.f. group, <code>maximalQClass</code>.   Moreover,
there are the two components
<P>
<DL><DT><code>form</code>:<DD> <BR> 
      the associated Gram matrix <var>F</var>,
</DL><P>
<DL><DT><code>repsOrbitsShortVectors</code>:<DD> <BR> 
      representatives of the orbits of short vectors under <var>F</var>.
</DL><P>
The last of these components will be required by the <code>PermGroup</code> function
below.
<P>
Example:
<P>
<pre>    gap> G.size;
    3840
    gap> G.isomorphismType;
    "C2 wr S5 = C2 x W(D5)"
    gap> PrintArray( G.form );
    [ [  4,  0,  0,  0,  2 ],
      [  0,  4,  0,  0,  2 ],
      [  0,  0,  4,  0,  2 ],
      [  0,  0,  0,  4,  2 ],
      [  2,  2,  2,  2,  5 ] ]
    gap> G.elementaryDivisors;
    [ 1, 4, 4, 4, 4 ]
    gap> G.minimalNorm;
    4 </pre>
<P>
If you want to perform calculations in such a matrix group <var>G</var> you should
be aware of the  fact that <strong>GAP3</strong> offers  much more efficient permutation
group routines than matrix group routines. Hence we recommend that you do
your computations, whenever it is possible, in the isomorphic permutation
group that is induced by  the action of  <var>G</var> on one  of the orbits of the
associated short vectors. You may call one  of the following functions to
get such a permutation group.
<P>
<P>
<code>PermGroup( <var>G</var> )</code>
<A name = "I48"></a>

<P>
<code>PermGroup</code> returns  the permutation group  which is induced by the given
i.m.f. integral matrix group  <var>G</var>  on an orbit of minimal size of <var>G</var>
on the set of short vectors (see also <code>PermGroupImfGroup</code> below).
<P>
The  permutation representation is   computed  by first  constructing the
specified  orbit, <I>S</I> say,    of short vectors   and  then computing  the
permutations which are induced on <I>S</I> by the generators  of <var>G</var>. We would
like to warn  you that in case  of a  large  orbit this procedure  may be
space  and time consuming. Fortunately, there  are only five <I>&#x211A;</I>-classes
in the library  for which  the smallest orbit of short vectors is of size
greater than 20000, the worst case being the orbit of size 196560 for the
Leech lattice (<I>dim = 24</I>, <I>q = 3</I>).
<P>
As mentioned  above,  <code>PermGroup</code>   constructs  the required  permutation
group,  <var>P</var> say, as  the image of  <var>G</var> under  the isomorphism between the
matrices in <var>G</var>  and their action   on <I>S</I>.  Moreover, it  constructs the
inverse isomorphism from <var>P</var> to <var>G</var>, <I>&phi;</I> say, and returns it in the
group record component <var>P</var>.<code>bijection</code>  of  <var>P</var>.  In fact,  <I>&phi;</I>  is
constructed by determining  a  <I>&#x211A;</I>-base <I>B &sub;  S</I>  of <I>&#x211A;<sup>1 &times;
dim</sup></I> in   <I>S</I> and, in  addition, the  associated base change  matrix <I>M</I>
which transforms <I>B</I> into the standard base  of <I>&#x2124;<sup>1 &times; dim</sup></I>. Then
the image <I>&phi;(p)</I>  of  any  permutation <I>p  &isin;  P</I> can   be  easily
computed: If, for <I>1  &le; i  &le; dim</I>,  <I>b<sub>i</sub></I> is the position number in
<I>S</I> of  the <I>i<sup><I> th</I></sup></I> base vector  in <I>B</I>, it  suffices to look up the
vector whose position number in  <I>S</I> is the  image of <I>b<sub>i</sub></I> under <I>p</I> and
to   multiply  this  vector by  <I>M</I>   to  get the   <I>i<sup><I>  th</I></sup></I>  row of
<I>&phi;(p)</I>.
<P>
You  may  use <I>&phi;</I> at  any   time to compute  the  images  in <var>G</var> of
permutations in  <var>P</var> or to  compute the  preimages in  <var>P</var> of matrices in
<var>G</var>.
<P>
The record  of  <var>P</var> contains,   in addition  to the usual   components of
permutation group records, some special components. The most important of
those are:
<P>
<DL><DT><code>isomorphismType</code>:<DD> <BR> 
      a text string describing the isomorphism type of  <var>P</var>  (in the same
      notation as used by the <code>DisplayImfInvariants</code> command above),
</DL><P>
<DL><DT><code>matGroup</code>:<DD> <BR> 
      the associated matrix group <var>G</var>,
</DL><P>
<DL><DT><code>bijection</code>:<DD> <BR> 
      the isomorphism <I>&phi;</I> from <var>P</var> to <var>G</var>,
</DL><P>
<DL><DT><code>orbitShortVectors</code>:<DD> <BR> 
      the orbit <I>S</I> of short vectors (needed for <I>&phi;</I>),
</DL><P>
<DL><DT><code>baseVectorPositions</code>:<DD> <BR> 
      the position numbers of the base vectors in <I>B</I> with respect to <I>S</I>
      (needed for <I>&phi;</I>),
</DL><P>
<DL><DT><code>baseChangeMatrix</code>:<DD> <BR> 
      the base change matrix <I>M</I> (needed for <I>&phi;</I>).
</DL><P>
As an example, let   us compute a set  <I>R</I>  of matrix generators  for the
solvable residuum  of  the group  <var>G</var>  that  we  have constructed in  the
preceding example.
<P>
<pre>    gap> # Perform the computations in an isomorphic permutation group.
    gap> P := PermGroup( G );
    PermGroup(ImfMatGroup(5,1,3))
    gap> P.generators;
    [ ( 1, 7, 6)( 2, 9)( 4, 5,10), ( 2, 3, 4, 5)( 6, 9, 8, 7) ]
    gap> D := DerivedSubgroup( P );
    Subgroup( PermGroup(ImfMatGroup(5,1,3)),
    [ ( 1, 2,10, 9)( 3, 8)( 4, 5)( 6, 7),
      ( 1, 6)( 2, 7, 9, 4)( 3, 8)( 5,10), ( 1, 5,10, 6)( 2, 8, 9, 3) ] )
    gap> Size( D );
    960
    gap> IsPerfect( D );
    true
    gap> # Now move the results back to the matrix group.
    gap> phi := P.bijection;;
    gap> R := List( D.generators, p -> Image( phi, p ) );;
    gap> for m in R do PrintArray( m ); od;
    [ [  -1,  -1,  -1,  -1,   2 ],
      [   0,  -1,   0,   0,   0 ],
      [   0,   0,   0,   1,   0 ],
      [   0,   0,   1,   0,   0 ],
      [  -1,  -1,   0,   0,   1 ] ]
    [ [   0,   0,  -1,   0,   0 ],
      [   0,  -1,   0,   0,   0 ],
      [   1,   0,   0,   0,   0 ],
      [  -1,  -1,  -1,  -1,   2 ],
      [   0,  -1,  -1,   0,   1 ] ]
    [ [   0,  -1,   0,   0,   0 ],
      [   1,   0,   0,   0,   0 ],
      [   0,   0,   1,   0,   0 ],
      [  -1,  -1,  -1,  -1,   2 ],
      [   0,  -1,   0,  -1,   1 ] ]
    gap> # The PreImage function allows us to use the inverse of phi.
    gap> PreImage( phi, R[1] ) = D.generators[1];
    true </pre>
<P>
<P>
<code>PermGroupImfGroup( <var>G</var>, <var>n</var> )</code>
<A name = "I49"></a>

<P>
<code>PermGroupImfGroup</code> returns the permutation group which is induced by the
given i.m.f. integral matrix group <var>G</var> on its <var>n</var><I><sup><I> th</I></sup></I> orbit of
short vectors.  The only difference  to the above <code>PermGroup</code> function is
that  you can specify the  orbit to be used.  In   fact, as the orbits of
short vectors  are sorted by  increasing sizes,  the function <code>PermGroup(
<var>G</var> )</code>  has   been   implemented   such   that   it  is   equivalent   to
<code>PermGroupImfGroup( <var>G</var>, 1 )</code>.
<P>
<pre>    gap> ImfInvariants( 12, 9 ).sizesOrbitsShortVectors;
    [ 120, 300 ]
    gap> G := ImfMatGroup( 12, 9 );
    ImfMatGroup(12,9)
    gap> P1 := PermGroupImfGroup( G, 1 );
    PermGroup(ImfMatGroup(12,9))
    gap> P1.degree;
    120
    gap> P2 := PermGroupImfGroup( G, 2 );
    PermGroupImfGroup(ImfMatGroup(12,9),2)
    gap> P2.degree;
    300 </pre>
<P><A NAME="SECT013"><h2>38.13 The Crystallographic Groups Library</h2></a>
<P><P>
<A name = "I50"></a>

<P>
<strong>GAP3</strong> provides a library of  crystallographic groups of dimensions 2, 3,
and 4  which covers many of the  data that have been  listed  in the book
``Crystallographic groups of four-dimensional space''  <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
It has been brought into <strong>GAP3</strong> format by Volkmar Felsch.
<P>
<P>
<strong>How to access the data of the book</strong>
<P>
Among others,  the library  offers functions  which provide access to the
data listed in the Tables 1, 5, and 6 of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>:

<P>&bull; The information  on the crystal families  listed in Table 1  can be
      reproduced using the <code>DisplayCrystalFamily</code> function.
<P>&bull; Similarly,  the  <code>DisplayCrystalSystem</code>  function  can  be  used to
      reproduce the information on the crystal systems  provided in Table
      1.
<P>&bull; The information  given in the <I>&#x211A;</I>-class  headlines  of Table 1 can
      be  displayed   by  the   <code>DisplayQClass</code>  function,   whereas  the
      <code>FpGroupQClass</code> function can be used to reproduce the presentations
      that are listed in Table 1 for the <I>&#x211A;</I>-class representatives.
<P>&bull; The information  given in the <I>&#x2124;</I>-class  headlines of Table 1 will
      be covered by the results of the <code>DisplayZClass</code> function,  and the
      matrix  generators   of  the  <I>&#x2124;</I>-class  representatives   can  be
      constructed by calling the <code>MatGroupZClass</code> function.
<P>&bull; The  <code>DisplaySpaceGroupType</code> and the  <code>DisplaySpaceGroupGenerators</code>
      functions  can be used  to reproduce  all of the information on the
      space-group types that is provided in Table 1.
<P>&bull; The normalizers  listed in Table 5 can be reproduced by calling the
      <code>NormalizerZClass</code> function.
<P>&bull; Finally,  the <code>CharTableQClass</code> function will compute the character
      tables  listed in Table 6,  whereas the  isomorphism types given in
      Table 6  may be obtained  by calling the  <code>DisplayQClass</code> function.
<P>

The display functions mentioned in the above list print their output with
different  indentation.  So, calling them in  a suitably nested loop, you
may produce a  listing  in which  the  information about  the objects  of
different type will be properly  indented as has been  done in Table 1 of
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<P>
<strong>Representation of space groups in {\GAP}</strong>
<P>
Probably the  most important function  in the library is the <code>SpaceGroup</code>
function which provides representatives of   the affine classes of  space
groups.      A space  group    of  dimension  <I>n</I> is   represented  by an
<I>(n+1)</I>-dimensional rational matrix group as follows.
<P>
If <I>S</I> is  an <I>n</I>-dimensional space  group, then each element <I>&alpha; &isin;
S</I>     is  an  affine mapping   <I>&alpha;\!:   V  &rarr;    V</I> of  an
<I>n</I>-dimensional <I>&#x211D;</I>-vector space <I>V</I> onto itself.  Hence <I>&alpha;</I> can be
written  as the    sum  of  an appropriate    invertible   linear mapping
<I>&phi;\!: V  &rarr;  V</I>  and  a translation by   some translation
vector <I>t &isin; V</I> such  that, if we write  mappings from the left, we have
<I>&alpha;(v) = &phi;(v) + t</I> for all <I>v &isin; V</I>.
<P>
If we fix a  basis of <I>V</I>  and then replace each <I>v  &isin; V</I> by the column
vector of  its coefficients with respect to  that basis (and hence <I>V</I> by
the isomorphic column  vector space <I>&#x211D;<sup>n  &times; 1</sup></I>),  we can describe
the linear mapping   <I>&phi;</I> involved in  <I>&alpha;</I>  by an <I>n &times;  n</I>
matrix <I>M<sub>&phi;</sub> &isin;  GL<sub>n</sub>(&#x211D;)</I>  which acts  by multiplication from  the
left on the column vectors  in <I>&#x211D;<sup>n &times; 1</sup></I>.   Hence, if we identify
<I>V</I> with <I>&#x211D;<sup>n &times;  1</sup></I>, we have <I>&alpha;(v)  = M<sub>&phi;</sub> . v + t</I>
for all <I>v &isin; &#x211D;<sup>n &times; 1</sup></I>.
<P>
Moreover,  if we extend each  column vector <I>v  &isin; &#x211D;<sup>n &times; 1</sup></I> to a
column <I>[ \! \! \catcode`|=12 \begintabularc \catcode`|=13 </I>v<I>
\cr 1 \endtabular \! \! ]</I> of length <I>n+1</I> by adding an entry 1 in
the  last  position and  if  we  define an   <I>(n+1) &times; (n+1)</I>  matrix
<I>M<sub>&alpha;</sub> =  [   \catcode`|=12 \begintabular{c<code>c}  \catcode`\</code>=13
</I>M_&phi;<I> & </I>t<I> \cr \hline 0 & 1 \endtabular ]</I>, we have <I>[
\! \! \catcode`|=12 \begintabularc  \catcode`|=13 </I>&alpha;(v)<I> \cr  1
\endtabular \! \! ] = M<sub>&alpha;</sub> .  [ \! \! \catcode`|=12
\begintabularc \catcode`|=13 </I>v<I>  \cr 1 \endtabular  \! \! ]</I>
for all <I>v  &isin; &#x211D;<sup>n &times; 1</sup></I>.  This  means that we can  represent the
space  group <I>S</I> by the isomorphic group <I>M(S)  = { M<sub>&alpha;</sub> | &alpha;
&isin; S }</I>.    The submatrices <I>M<sub>&phi;</sub></I>   occurring in the  elements of
<I>M(S)</I> form  an <I>n &times; n</I> matrix  group <I>P(S)</I>, the ``point group'' 
of <I>M(S)</I>.  In  fact, we can choose the  basis of <I>&#x211D;<sup>n &times;  1</sup></I> such
that <I>M<sub>&phi;</sub>  &isin; GL<sub>n</sub>(&#x2124;)</I> and  <I>t &isin;   &#x211A;<sup>n &times; 1</sup></I>  for  all
<I>M<sub>&alpha;</sub> &isin; M(S)</I>.  In particular, the space group representatives that
are normally used by the crystallographers are of this form, and the book
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a> uses the same convention.
<P>
Before we describe all available library  functions in detail, we have to
add three remarks.
<P>
<P>
<strong>Remark 1</strong>
<P>
The concepts  used  in  this section are   defined  in chapter 1   (Basic
definitions) of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.  However, note that the definition of the
concept of a crystal system given on page  16 of that  book relies on the
following statement about <I>&#x211A;</I>-classes:

<P>&bull;[] For a  <I>&#x211A;</I>-class  <I>C</I>  there is a unique holohedry <I>H</I> such that
        each  f.u. group in <I>C</I>  is a subgroup of some  f.u. group in
        <I>H</I>,  but is not  a subgroup of any  f.u. group  belonging to a
        holohedry of smaller order.
<P>

This  statement is correct for  dimensions 1, 2,  3, and 4, and hence the
definition of ``crystal system'' given on page 16 of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a> is
known  to   be unambiguous for   these  dimensions.  However, there  is a
counterexample to  this statement in seven-dimensional  space so that the
definition breaks down for some higher dimensions.
<P>
Therefore,  the authors of  the book have  since proposed to replace this
definition of ``crystal system''  by the  following much simpler  one,
which has been discussed in more detail in <A href="biblio.htm#NPW81"><cite>NPW81</cite></a>. To formulate it,
we use    the   intersections  of <I>&#x211A;</I>-classes    and  Bravais  flocks as
introduced on page 17 of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>, and we define the classification
of the set of all <I>&#x2124;</I>-classes into crystal systems as follows:
<P>

<P>&bull;[] <strong>Definition</strong>:  A crystal system  (introduced as an  equivalence
        class  of   <I>&#x2124;</I>-classes)   consists of  full  geometric  crystal
        classes.  The <I>&#x2124;</I>-classes  of  two  (geometric)  crystal classes
        belong to the same crystal system  if and only if these geometric
        crystal  classes  intersect  the same  set of  Bravais  flocks of
        <I>&#x2124;</I>-classes.
<P>

>From  this  definition  of  a  crystal system  of  <I>&#x2124;</I>-classes  one then
obtains  crystal systems of f.u.  groups,  of space-group types, and of
space groups in the same manner as with the  preceding definitions in the
book.
<P>
The new definition is unambiguous for all dimensions. Moreover, it can be
checked  from  the   tables   in the  book   that  it   defines  the same
classification as the old one for dimensions 1, 2, 3, and 4.
<P>
It should  be noted that  the concept of  crystal  family is well-defined
independently of the dimension if one uses the ``more natural'' second
definition of it at the end of page 17. Moreover, the first definition of
crystal family on page  17 defines the same concept  as the second one if
the now proposed definition of crystal system is used.
<P>
<P>
<strong>Remark 2</strong>
<P>
The second remark just concerns a  different terminology in the tables of
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a> and in the current library. In group theory, the number of
elements of a  finite group  usually is  called  the ``order'' of  the
group.   This notation has  been  used throughout   in  the book.   Here,
however,  we  will follow the    <strong>GAP3</strong>   conventions and use  the   term
``size'' instead.
<P>
<P>
<strong>Remark 3</strong>
<P>
The third remark  concerns a problem  in the use of the space groups that
should be well understood.
<P>
There is an alternative to the representation of the space group elements
by matrices    of the  form <I>[  \catcode`|=12  \begintabular{c<pre>c}
\catcode`\</pre>=13 </I>M_&phi;<I> &  </I>t<I> \cr \hline  0 & 1 \endtabular ]</I>
as described  above.  Instead of  considering  the coefficient vectors as
columns we may  consider them  as rows.  Then  we  can associate to  each
affine  mapping  <I>&alpha; &isin;    S</I>   an  <I>(n+1)  &times; (n+1)</I>     matrix
<I><span style="text-decoration: overline">M</span><sub>&alpha;</sub>   =   [    \catcode`|=12  \begintabular{c<pre>c}
\catcode`\</pre>=13  </I>\overlineM_{\overline&phi;}<I>     &  0 \cr    \hline
</I>\overlinet<I>     &        1        \endtabular    ]</I>       with
<I><span style="text-decoration: overline">M</span><sub><span style="text-decoration: overline">&phi;</span></sub>  &isin; GL<sub>n</sub>(&#x211D;)</I>   and <I><span style="text-decoration: overline">t</span> &isin;
&#x211D;<sup>1 &times;  n</sup></I> such that <I>[&alpha;(<span style="text-decoration: overline">v</span>),1]  = [<span style="text-decoration: overline">v</span>,1]
.  <span style="text-decoration: overline">M</span><sub>&alpha;</sub></I> for all   <I><span style="text-decoration: overline">v</span> &isin; &#x211D;<sup>1 &times; n</sup></I>,
and we  may represent <I>S</I>   by the matrix   group  <I><span style="text-decoration: overline">M</span>(S) =  {
<span style="text-decoration: overline">M</span><sub>&alpha;</sub> | &alpha; &isin;  S  }</I>.  Again,  we can choose   the
basis of  <I>&#x211D;<sup>1 &times; n</sup></I> such  that <I><span style="text-decoration: overline">M</span><sub><span style="text-decoration: overline">&phi;</span></sub>
&isin;   GL<sub>n</sub>(&#x2124;)</I> and    <I><span style="text-decoration: overline">t</span> &isin;   &#x211A;<sup>1  &times;   n</sup></I>  for   all
<I><span style="text-decoration: overline">M</span><sub>&alpha;</sub> &isin; <span style="text-decoration: overline">M</span>(S)</I>.
<P>
From the  mathematical point of  view, both approaches are equivalent. In
particular, <I>M(S)</I> and <I><span style="text-decoration: overline">M</span>(S)</I> are isomorphic, for instance via
the isomorphism <I>&tau;</I>  mapping  <I>M<sub>&alpha;</sub> &isin;  M(S)</I>  to <I>(M<sub>&alpha;</sub><sup><I>
tr</I></sup>)<sup>-1</sup></I>.  Unfortunately, however,  neither of the two is a good choice
for our <strong>GAP3</strong> library.
<P>
The first convention, using matrices which act on column vectors from the
left, is not consistent with the fact that  actions in <strong>GAP3</strong> are usually
from the right.
<P>
On the  other hand, if we choose  the second  convention,  we run  into a
problem  with  the  names   of  the space     groups   as introduced   in
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>. Any  such   name  does not  just  describe  the  abstract
isomorphism  type  of  the   respective space   group  <I>S</I>, but  reflects
properties of the  matrix group <I>M(S)</I>.  In particular,  it contains as a
leading part  the  name of the  <I>&#x2124;</I>-class of  the associated point group
<I>P(S)</I>.  Since  the classification of  space groups by affine equivalence
is   tantamount  to   their  classification   by  abstract   isomorphism,
<I><span style="text-decoration: overline">M</span>(S)</I>  lies in  the  same affine   class as <I>M(S)</I>  and hence
should get  the same name   as <I>M(S)</I>.  But  the  point group <I>P(S)</I> that
occurs  in  that name is  not always  <I>&#x2124;</I>-equivalent to the  point group
<I><span style="text-decoration: overline">P</span>(S)</I>  of <I><span style="text-decoration: overline">M</span>(S)</I>.   For example,  the  isomorphism
<I>&tau;\!\!:  M(S)  &rarr;  <span style="text-decoration: overline">M</span>(S)</I> defined  above  maps the
<I>&#x2124;</I>-class  representative    with  the parameters <I>[3,7,3,2]</I>    (in the
notation   described below)  to  the <I>&#x2124;</I>-class   representative with the
parameters <I>[3,7,3,3]</I>.  In    other  words: The space     group  names
introduced for  the  groups <I>M(S)</I> in  <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>   lead to confusing
inconsistencies if assigned to the groups <I><span style="text-decoration: overline">M</span>(S)</I>.
<P>
In order to avoid this confusion we  decided that the first convention is
the lesser evil.  So the <strong>GAP3</strong> library follows the book, and if you call
the  <code>SpaceGroup</code>  function    you   will  get  the  same     space group
representatives as given there.  This does not cause any problems as long
as  you do calculations within these  groups treating them just as matrix
groups  of  certain isomorphism  types.   However, if  it is  necesary to
consider the action  of a space group  as affine mappings on the  natural
lattice,  you  need to  use the   transposed representation of  the space
group.   For this purpose  the library  offers the <code>TransposedSpaceGroup</code>
function which   not  only transposes  the   matrices, but  also   adapts
appropriately the associated group presentation.
<P>
Both these functions are described in detail in the following.
<P>
<P>
<strong>The library functions</strong>
<P>
<P>
<code>NrCrystalFamilies( <var>dim</var> )</code>
<A name = "I51"></a>

<P>
<code>NrCrystalFamilies</code> returns  the number of   crystal families in  case of
dimension  <var>dim</var>.  It can  be used  to formulate  loops over  the crystal
families.
<P>
There  are 4, 6, and   23  crystal families of dimension    2, 3, and  4,
respectively.
<P>
<pre>    gap> n := NrCrystalFamilies( 4 );
    23 </pre>
<P>
<P>
<code>DisplayCrystalFamily( <var>dim</var>, <var>family</var> )</code>
<A name = "I52"></a>

<P>
<code>DisplayCrystalFamily</code>   displays  for    the specified  crystal   family
essentially the same information as is  provided for that family in Table
1 of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>, namely
<P>

<P>&bull; the family name,
<P>
<P>&bull; the number of parameters,
<P>
<P>&bull; the common rational decomposition pattern,
<P>
<P>&bull; the common real decomposition pattern,
<P>
<P>&bull; the number of crystal systems in the family, and
<P>
<P>&bull; the number of Bravais flocks in the family.
<P>

For details see <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<pre>    gap> DisplayCrystalFamily( 4, 17 );
    #I Family XVII: cubic orthogonal; 2 free parameters;
    #I  Q-decomposition pattern 1+3; R-decomposition pattern 1+3;
    #I  2 crystal systems; 6 Bravais flocks
    gap> DisplayCrystalFamily( 4, 18 );
    #I Family XVIII: octagonal; 2 free parameters;
    #I  Q-irreducible; R-decomposition pattern 2+2;
    #I  1 crystal system; 1 Bravais flock
    gap> DisplayCrystalFamily( 4, 21 );
    #I Family XXI: di-isohexagonal orthogonal; 1 free parameter;
    #I  R-irreducible; 2 crystal systems; 2 Bravais flocks </pre>
<P>
<P>
<code>NrCrystalSystems( <var>dim</var> )</code>
<A name = "I53"></a>

<P>
<code>NrCrystalSystems</code>  returns  the number  of  crystal  systems  in case of
dimension  <var>dim</var>. It  can  be  used  to  formulate loops over the crystal
systems.
<P>
There are 4,   7, and 33  crystal  systems of  dimension   2, 3,  and  4,
respectively.
<P>
<pre>    gap> n := NrCrystalSystems( 2 );
    4 </pre>
<P>
<P>
The following two functions are functions of crystal systems.
<P>
Each crystal system is characterized by a pair <code>(<var>dim</var>,\,<var>system</var>)</code> where
<var>dim</var>  is the associated dimension,  and  <var>system</var> is  the number of  the
crystal system.
<P>
<P>
<code>DisplayCrystalSystem( <var>dim</var>, <var>system</var> )</code>
<A name = "I54"></a>

<P>
<code>DisplayCrystalSystem</code>  displays    for  the  specified   crystal  system
essentially the same information as is  provided for that system in Table
1 of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>, namely
<P>

<P>&bull; the number of <I>&#x211A;</I>-classes in the crystal system and
<P>
<P>&bull; the     identification      number,      i.e.,     the     tripel
      <code>(<var>dim</var>,\,<var>system</var>,\,<var>q-class</var>)</code> described below, of the <I>&#x211A;</I>-class
      that is the holohedry of the crystal system.
<P>

For details see <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<pre>    gap> for sys in [ 1 .. 4 ] do  DisplayCrystalSystem( 2, sys );  od;
    #I  Crystal system 1: 2 Q-classes; holohedry (2,1,2)
    #I  Crystal system 2: 2 Q-classes; holohedry (2,2,2)
    #I  Crystal system 3: 2 Q-classes; holohedry (2,3,2)
    #I  Crystal system 4: 4 Q-classes; holohedry (2,4,4) </pre>
<P>
<P>
<code>NrQClassesCrystalSystem( <var>dim</var>, <var>system</var> )</code>
<A name = "I55"></a>

<P>
<code>NrQClassesCrystalSystem</code> returns the number  of <I>&#x211A;</I>-classes  within the
given  crystal  system.  It  can be  used  to  formulate  loops  over the
<I>&#x211A;</I>-classes.
<P>
<P>
The following five functions are functions of <I>&#x211A;</I>-classes.
<P>
In general,   the parameters characterizing  a  <I>&#x211A;</I>-class  will  form  a
triple  <code>(<var>dim</var>,\,<var>system</var>,\,<var>q-class</var>)</code>  where <var>dim</var>  is  the associated
dimension,  <var>system</var> is the number  of the associated crystal system, and
<var>q-class</var> is  the number of  the <I>&#x211A;</I>-class  within  the  crystal system.
However,  in case of  dimensions  2  or 3, a    <I>&#x211A;</I>-class  may  also  be
characterized by  a pair <code>(<var>dim</var>,  <var>IT-number</var>)</code> where <var>IT-number</var> is the
number in the International Tables   for Crystallography <A href="biblio.htm#Hah83"><cite>Hah83</cite></a>  of
any space-group type   lying in (a <I>&#x2124;</I>-class  of)  that  <I>&#x211A;</I>-class,  or
just by the  Hermann-Mauguin symbol of any  space-group type lying  in (a
<I>&#x2124;</I>-class of) that <I>&#x211A;</I>-class.
<P>
The Hermann-Mauguin symbols <A name = "I56"></a>
 which  we use
in  <strong>GAP3</strong> are  the short  Hermann-Mauguin symbols  defined  in the  1983
edition  of the International   Tables <A href="biblio.htm#Hah83"><cite>Hah83</cite></a>,   but any  occurring
indices  are expressed  by  ordinary integers,  and bars  are replaced by
minus    signs.     For    example,     the     Hermann-Mauguin    symbol
<var>P</var><I><span style="text-decoration: overline">4</span>2<sub>1</sub>m</I> will be represented by the string <code>"P-421m"</code>.
<P>
<P>
<code>DisplayQClass( <var>dim</var>, <var>system</var>, <var>q-class</var> )</code>
<A name = "I57"></a>
 <BR> 
<code>DisplayQClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>DisplayQClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>DisplayQClass</code> displays for   the specified <I>&#x211A;</I>-class  essentially  the
same  information as  is  provided  for  that  <I>&#x211A;</I>-class  in  Table 1 of
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a> (except for the defining relations given there), namely
<P>

<P>&bull; the size of the groups in the <I>&#x211A;</I>-class,
<P>
<P>&bull; the isomorphism type of the groups in the <I>&#x211A;</I>-class,
<P>
<P>&bull; the Hurley pattern,
<P>
<P>&bull; the rational constituents,
<P>
<P>&bull; the number of <I>&#x2124;</I>-classes in the <I>&#x211A;</I>-class, and
<P>
<P>&bull; the number of space-group types in the <I>&#x211A;</I>-class.
<P>

For details see <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<pre>    gap> DisplayQClass( "p2" );
    #I   Q-class H (2,1,2): size 2; isomorphism type 2.1 = C2;
    #I    Q-constituents 2*(2,1,2); cc; 1 Z-class; 1 space group
    gap> DisplayQClass( "R-3" );
    #I   Q-class (3,5,2): size 6; isomorphism type 6.1 = C6;
    #I    Q-constituents (3,1,2)+(3,4,3); ncc; 2 Z-classes; 2 space grps
    gap> DisplayQClass( 3, 195 );
    #I   Q-class (3,7,1): size 12; isomorphism type 12.5 = A4;
    #I    C-irreducible; 3 Z-classes; 5 space grps
    gap> DisplayQClass( 4, 27, 4 );
    #I   Q-class H (4,27,4): size 20; isomorphism type 20.3 = D10xC2;
    #I    Q-irreducible; 1 Z-class; 1 space group
    gap> DisplayQClass( 4, 29, 1 );
    #I  *Q-class (4,29,1): size 18; isomorphism type 18.3 = D6xC3;
    #I    R-irreducible; 3 Z-classes; 5 space grps </pre>
<P>
Note   in the preceding  examples  that, as pointed  out  above, the term
``size'' denotes the order of a representative  group of the specified
<I>&#x211A;</I>-class and, of course, not the (infinite) class length.
<P>
<P>
<code>FpGroupQClass( <var>dim</var>, <var>system</var>, <var>q-class</var> )</code>
<A name = "I58"></a>
 <BR> 
<code>FpGroupQClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>FpGroupQClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>FpGroupQClass</code> returns  a finitely presented group  <I>F</I>,  say, which  is
isomorphic to the groups in the specified <I>&#x211A;</I>-class.
<P>
The presentation  of   that  group  is the  same  as  the   corresponding
presentation given in Table 1 of  <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a> except for the fact that
its generators are listed  in reverse order.  The  reason for this change
is that,    whenever the group   in question  is solvable,  the resulting
generators form an AG system (as defined  in <strong>GAP3</strong>) if they are numbered
``from the  top to the bottom'',  and the  presentation is a polycyclic
power  commutator  presentation.  The  <code>AgGroupQClass</code> function described
next will  make use of  this  fact in  order   to construct an  ag  group
isomorphic to <I>F</I>.
<P>
Note that, for any <I>&#x2124;</I>-class  in the  specified <I>&#x211A;</I>-class,  the  matrix
group  returned by the <code>MatGroupZClass</code>  function (see below) not only is
isomorphic to <I>F</I>, but also its  generators satisfy the defining relators
of <I>F</I>.
<P>
Besides  of the usual components,  the group record  of  <I>F</I> will have an
additional component  <I>F</I><code>.crQClass</code> which saves a list of the parameters
that specify the given <I>&#x211A;</I>-class.
<P>
<pre>    gap> F := FpGroupQClass( 4, 20, 3 );
    FpGroupQClass( 4, 20, 3 )
    gap> F.generators;
    [ f.1, f.2 ]
    gap> F.relators;
    [ f.1^2*f.2^-3, f.2^6, f.2^-1*f.1^-1*f.2*f.1*f.2^-4 ]
    gap> F.size;
    12
    gap> F.crQClass;
    [ 4, 20, 3 ] </pre>
<P>
<P>
<code>AgGroupQClass( <var>dim</var>, <var>system</var>, <var>q-class</var> )</code>
<A name = "I59"></a>
 <BR> 
<code>AgGroupQClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>AgGroupQClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>AgGroupQClass</code> returns an ag group <I>A</I>, say, isomorphic to the groups in
the specified  <I>&#x211A;</I>-class,  if these  groups are  solvable,  or the value
<code>false</code> (together with an appropriate warning), otherwise.
<P>
<I>A</I>  is constructed by first  establishing a finitely presented group (as
it would be returned by the <code>FpGroupQClass</code> function described above) and
then  constructing  from it  an isomorphic  ag group.  If the  underlying
AG system is not yet a PAG system (see sections <a href="chap024.htm#SECT001">More about Ag Words</a> and
<a href="chap025.htm#SECT001">More about Ag Groups</a>),  it will be refined appropriately (and a warning
will be displayed).
<P>
Besides of the  usual components, the group   record of <I>A</I>  will have an
additional component  <I>A</I><code>.crQClass</code> which saves a list of the parameters
that specify the given <I>&#x211A;</I>-class.
<P>
<pre>    gap> A := AgGroupQClass( 4, 31, 3 );
    #I  Warning: a non-solvable group can't be represented as an ag group
    false
    gap> A := AgGroupQClass( 4, 20, 3 );
    #I  Warning: the presentation has been extended to get a PAG system
    AgGroupQClass( 4, 20, 3 )
    gap> A.generators;
    [ f.1, f.21, f.22 ]
    gap> A.size;
    12
    gap> A.crQClass;
    [ 4, 20, 3 ] </pre>
<P>
<P>
<code>CharTableQClass( <var>dim</var>, <var>system</var>, <var>q-class</var> )</code>
<A name = "I60"></a>
 <BR> 
<code>CharTableQClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>CharTableQClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>CharTableQClass</code>   returns   the   character    table   <I>T</I>,  say,  of a
representative group of (a <I>&#x2124;</I>-class of) the specified <I>&#x211A;</I>-class.
<P>
Although the set of characters  can be considered as  an invariant of the
specified <I>&#x211A;</I>-class,  the resulting  table  will depend on  the order in
which <strong>GAP3</strong> sorts the conjugacy classes of  elements and the irreducible
characters  and    hence,  in  general,   will  not   coincide  with  the
corresponding table presented in <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<code>CharTableQClass</code>    proceeds as follows.   If the    groups in the given
<I>&#x211A;</I>-class are  solvable,  then it first  calls the  <code>AgGroupQClass</code>  and
<code>RefinedAgSeries</code> functions to  get  an   isomorphic  ag group   with   a
PAG system,  and then it  calls  the <code>CharTable</code>  function to compute the
character table  of that ag  group.   In the  case   of one of  the  five
<I>&#x211A;</I>-classes of dimension 4 whose groups are not solvable, it first calls
the <code>FpGroupQClass</code> function    to get an  isomorphic  finitely presented
group, then    it  constructs a specially   chosen   faithful permutation
representation of  low degree for  that group,  and finally it determines
the character table  of the resulting  permutation group again by calling
the <code>CharTable</code> function.
<P>
In general,  the above  strategy will be   much  more efficient than  the
alternative  possibilities of   calling the <code>CharTable</code>    function for a
finitely presented group provided by  the <code>FpGroupQClass</code> function or for
a matrix group provided by the <code>MatGroupZClass</code> function.
<P>
<pre>    gap> T := CharTableQClass( 4, 20, 3 );;
    gap> DisplayCharTable( T );
    CharTableQClass( 4, 20, 3 )

         2  2  1  1  2  2  2
         3  1  1  1  1  .  .

           1a 3a 6a 2a 4a 4b
        2P 1a 3a 3a 1a 2a 2a
        3P 1a 1a 2a 2a 4b 4a
        5P 1a 3a 6a 2a 4a 4b

    X.1     1  1  1  1  1  1
    X.2     1  1  1  1 -1 -1
    X.3     1  1 -1 -1  A -A
    X.4     1  1 -1 -1 -A  A
    X.5     2 -1  1 -2  .  .
    X.6     2 -1 -1  2  .  .

    A = E(4)
      = ER(-1) = i </pre>
<P>
<P>
<code>NrZClassesQClass( <var>dim</var>, <var>system</var>, <var>q-class</var> )</code>
<A name = "I61"></a>
 <BR> 
<code>NrZClassesQClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>NrZClassesQClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>NrZClassesQClass</code> returns the number of  <I>&#x2124;</I>-classes  within  the given
<I>&#x211A;</I>-class. It can be used to formulate loops over the <I>&#x2124;</I>-classes.
<P>
<P>
The following functions are functions of <I>&#x2124;</I>-classes.
<P>
In  general,  the parameters  characterizing  a  <I>&#x2124;</I>-class  will  form a
quadruple  <code>(<var>dim</var>,\,<var>system</var>, \mbox{<var>q-class</var>},\,<var>z-class</var>)</code> where <var>dim</var>
is the  associated dimension, <var>system</var>  is the  number of the  associated
crystal system,  <var>q-class</var> is  the  number of the  associated  <I>&#x211A;</I>-class
within the crystal system, and <var>z-class</var> is the number  of the <I>&#x2124;</I>-class
within the  <I>&#x211A;</I>-class.  However, in   case   of dimensions   2 or 3,   a
<I>&#x2124;</I>-class  may also be characterized  by  a pair <code>(<var>dim</var>,  <var>IT-number</var>)</code>
where <var>IT-number</var> is the number  in the International Tables <A href="biblio.htm#Hah83"><cite>Hah83</cite></a>
of  any  space-group  type lying  in  that <I>&#x2124;</I>-class,  or   just  by the
Hermann-Mauguin symbol of any space-group  type lying in that <I>&#x2124;</I>-class.
<P>
<P>
<code>DisplayZClass( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var> )</code>
<A name = "I62"></a>
 <BR> 
<code>DisplayZClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>DisplayZClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>DisplayZClass</code>  displays for the  specified  <I>&#x2124;</I>-class  essentially the
same information  as  is provided  for  that  <I>&#x2124;</I>-class  in Table   1 of
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>  (except    for  the  generating    matrices   of a  class
representative group given there), namely
<P>

<P>&bull; for  dimensions  2  and  3,   the  Hermann-Mauguin   symbol   of  a
      representative space-group type  which belongs  to that <I>&#x2124;</I>-class,
<P>
<P>&bull; the Bravais type,
<P>
<P>&bull; some decomposability information,
<P>
<P>&bull; the number of space-group types belonging to the <I>&#x2124;</I>-class,
<P>
<P>&bull; the size of the associated cohomology group.
<P>

For details see <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<pre>    gap> DisplayZClass( 2, 3 );
    #I    Z-class (2,2,1,1) = Z(pm): Bravais type II/I; fully Z-reducible;
    #I     2 space groups; cohomology group size 2
    gap> DisplayZClass( "F-43m" );
    #I    Z-class (3,7,4,2) = Z(F-43m): Bravais type VI/II; Z-irreducible;
    #I     2 space groups; cohomology group size 2
    gap> DisplayZClass( 4, 2, 3, 2 );
    #I    Z-class B (4,2,3,2): Bravais type II/II; Z-decomposable;
    #I     2 space groups; cohomology group size 4
    gap> DisplayZClass( 4, 21, 3, 1 );
    #I   *Z-class (4,21,3,1): Bravais type XVI/I; Z-reducible;
    #I     1 space group; cohomology group size 1 </pre>
<P>
<P>
<code>MatGroupZClass( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var> )</code>
<A name = "I63"></a>
 <BR> 
<code>MatGroupZClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>MatGroupZClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>MatGroupZClass</code> returns a <I>dim &times; dim</I> matrix  group <I>M</I>, say, which
is a representative of  the specified <I>&#x2124;</I>-class.  Its generators satisfy
the  defining  relators  of the   finitely  presented group  which may be
computed  by  calling the  <code>FpGroupQClass</code> function  (see above)  for the
<I>&#x211A;</I>-class which contains the given <I>&#x2124;</I>-class.
<P>
The generators of <I>M</I> are the same matrices as those given  in Table 1 of
<A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>. Note, however, that they will  be listed in reverse order
to  keep them  in parallel  to  the abstract  generators provided by  the
<code>FpGroupQClass</code> function (see above).
<P>
Besides of  the usual components, the group  record  of <I>M</I> will  have an
additional component  <I>M</I><code>.crZClass</code> which saves a list of the parameters
that  specify  the given <I>&#x2124;</I>-class.  (In   fact,  in order  to  make the
resulting     group  record  consistent   with    those  returned  by the
<code>NormalizerZClass</code> or <code>ZClassRepsDadeGroup</code> functions described below, it
also will have an additional component <I>M</I>.<code>crConjugator</code> containing just
the identity element of <I>M</I>.)
<P>
<pre>    gap> M := MatGroupZClass( 4, 20, 3, 1 );
    MatGroupZClass( 4, 20, 3, 1 )
    gap> for g in M.generators do
    >  Print( "\n" ); PrintArray( g ); od; Print( "\n" );

    [ [   0,   1,   0,   0 ],
      [  -1,   0,   0,   0 ],
      [   0,   0,  -1,  -1 ],
      [   0,   0,   0,   1 ] ]

    [ [  -1,   0,   0,   0 ],
      [   0,  -1,   0,   0 ],
      [   0,   0,  -1,  -1 ],
      [   0,   0,   1,   0 ] ]

    gap> M.size;
    12
    gap> M.crZClass;
    [ 4, 20, 3, 1 ] </pre>
<P>
<P>
<code>NormalizerZClass( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var> )</code>
<A name = "I64"></a>
 <BR> 
<code>NormalizerZClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>NormalizerZClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>NormalizerZClass</code> returns the  normalizer <I>N</I>, say,  in <I>GL(dim,&#x2124;)</I>  of
the representative <I>dim &times; dim</I>  matrix group which is constructed by
the <code>MatGroupZClass</code> function (see above).
<P>
If the size of <I>N</I> is finite,  then <I>N</I> again lies in some <I>&#x2124;</I>-class. In
this case, the group record of <I>N</I> will contain two additional components
<I>N</I><code>.crZClass</code>  and <I>N</I>.<code>crConjugator</code>  which  provide the parameters  of
that  <I>&#x2124;</I>-class  and a  matrix <I>g  &isin;  GL(dim,&#x2124;)</I>,  respectively, such
that <I>N = g<sup>-1</sup>  R  g</I>, where <I>R</I> is   the representative group of  that
<I>&#x2124;</I>-class.
<P>
<pre>    gap> N := NormalizerZClass( 4, 20, 3, 1 );
    NormalizerZClass( 4, 20, 3, 1 )
    gap> for g in N.generators do
    >  Print( "\n" ); PrintArray( g ); od; Print( "\n" );

    [ [   1,   0,   0,   0 ],
      [   0,   1,   0,   0 ],
      [   0,   0,   1,   0 ],
      [   0,   0,  -1,  -1 ] ]

    [ [   1,   0,   0,   0 ],
      [   0,  -1,   0,   0 ],
      [   0,   0,  -1,  -1 ],
      [   0,   0,   1,   0 ] ]

    [ [   0,   1,   0,   0 ],
      [  -1,   0,   0,   0 ],
      [   0,   0,   1,   0 ],
      [   0,   0,   0,   1 ] ]

    [ [  -1,   0,   0,   0 ],
      [   0,  -1,   0,   0 ],
      [   0,   0,  -1,   0 ],
      [   0,   0,   0,  -1 ] ]

    gap> N.size;
    96
    gap> N.crZClass;
    [ 4, 20, 22, 1 ]
    gap> N.crConjugator = N.identity;
    true </pre>
<P>
<pre>    gap> L := NormalizerZClass( 3, 42 );
    NormalizerZClass( 3, 3, 2, 4 )
    gap> L.size;
    16
    gap> L.crZClass;
    [ 3, 4, 7, 2 ]
    gap> L.crConjugator;
    [ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, -1 ] ]
    gap> M := NormalizerZClass( "C2/m" );
    Group( [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ],
    [ [ 0, -1, 0 ], [ -1, 0, 0 ], [ 0, 0, -1 ] ],
    [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 0, 0, 1 ] ],
    [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ -1, -1, 1 ] ],
    [ [ 0, 1, -1 ], [ 1, 0, -1 ], [ 0, 0, -1 ] ] )
    gap> M.size;
    "infinity"
    gap> IsBound( M.crZClass );
    false </pre>
<P>
<code>NrSpaceGroupTypesZClass( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var> )</code>
<A name = "I65"></a>
 <BR> 
<code>NrSpaceGroupTypesZClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>NrSpaceGroupTypesZClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>NrSpaceGroupTypes</code>  returns the number  of  space-group types within the
given <I>&#x2124;</I>-class.  It can be used to formulate loops over the space-group
types.
<P>
<pre>    gap> N := NrSpaceGroupTypesZClass( 4, 4, 1, 1 );
    13 </pre>
<P>
<P>
Some of the <I>&#x2124;</I>-classes  of   dimension <I>d</I>, say, are ``maximal''  in
the sense  that the groups in these  classes are maximal finite subgroups
of <I>GL(d,&#x2124;)</I>.  Generalizing a term which is  being used for dimension 4,
we call the representatives   of these  maximal <I>&#x2124;</I>-classes  the ``<strong>Dade
groups</strong>'' of dimension <I>d</I>.
<P>
<P>
<code>NrDadeGroups( <var>dim</var> )</code>
<A name = "I66"></a>

<P>
<code>NrDadeGroups</code> returns the  number of Dade groups  of dimension <var>dim</var>. It
can be used to formulate loops over the Dade groups.
<P>
There are 2, 4, and 9 Dade groups of dimension 2, 3, and 4, respectively.
<P>
<pre>    gap> NrDadeGroups( 4 );
    9 </pre>
<P>
<P>
<code>DadeGroup( <var>dim</var>, <var>n</var> )</code>
<A name = "I67"></a>

<P>
<code>DadeGroup</code> returns the <I>n</I>th Dade group of dimension <I>dim</I>.
<P>
<pre>    gap> D := DadeGroup( 4, 7 );
    MatGroupZClass( 4, 31, 7, 2 ) </pre>
<P>
<P>
<code>DadeGroupNumbersZClass( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var> )</code>
<A name = "I68"></a>
 <BR> 
<code>DadeGroupNumbersZClass( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>DadeGroupNumbersZClass( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>DadeGroupNumbersZClass</code> returns the set of  all those integers <I>n<sub>i</sub></I> for
which the <I>n<sub>i</sub></I>th  Dade   group of dimension  <I>dim</I> contains   a subgroup
which, in  <I>GL(dim,&#x2124;)</I>,  is conjugate to the representative group of the
given <I>&#x2124;</I>-class.
<P>
<pre>    gap> dadeNums := DadeGroupNumbersZClass( 4, 4, 1, 2 );
    [ 1, 5, 8 ]
    gap> for d in dadeNums do
    >     D := DadeGroup( 4, d );
    >     Print( D, " of size ", Size( D ), "\n" );
    > od;
    MatGroupZClass( 4, 20, 22, 1 ) of size 96
    MatGroupZClass( 4, 30, 13, 1 ) of size 288
    MatGroupZClass( 4, 32, 21, 1 ) of size 384 </pre>
<P>
<P>
<code>ZClassRepsDadeGroup( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var>, <var>n</var> )</code>
<A name = "I69"></a>
 <BR> 
<code>ZClassRepsDadeGroup( <var>dim</var>, <var>IT-number</var>, <var>n</var> )</code> <BR> 
<code>ZClassRepsDadeGroup( <var>Hermann-Mauguin-symbol</var>, <var>n</var> )</code>
<P>
<code>ZClassRepsDadeGroup</code> determines in  the  <I>n</I>th Dade group  of  dimension
<I>dim</I> all  those  conjugacy classes  whose groups  are,  in <I>GL(dim,&#x2124;)</I>,
conjugate to the <I>&#x2124;</I>-class  representative group <I>R</I>,  say, of the given
<I>&#x2124;</I>-class.   It  returns  a  list  of  representative  groups of   these
conjugacy classes.
<P>
Let <I>M</I> be any group in the resulting list.  Then the group record of <I>M</I>
provides   two components  <I>M</I><code>.crZClass</code>   and <I>M</I><code>.crConjugator</code>  which
contain the list  of <I>&#x2124;</I>-class  parameters of <I>R</I>  and a suitable matrix
<I>g</I> from <I>GL(dim,&#x2124;)</I>,  respectively,  such that <I>M</I> equals <I>g<sup>-1</sup> R g</I>.
<P>
<pre>    gap> DadeGroupNumbersZClass( 2, 2, 1, 2 );
    [ 1, 2 ]
    gap> ZClassRepsDadeGroup( 2, 2, 1, 2, 1 );
    [ MatGroupZClass( 2, 2, 1, 2 )^[ [ 0, 1 ], [ -1, 0 ] ] ]
    gap> ZClassRepsDadeGroup( 2, 2, 1, 2, 2 );
    [ MatGroupZClass( 2, 2, 1, 2 )^[ [ 1, -1 ], [ 0, -1 ] ],
      MatGroupZClass( 2, 2, 1, 2 )^[ [ 1, 0 ], [ -1, 1 ] ] ]
    gap> R := last[2];;
    gap> R.crZClass;
    [ 2, 2, 1, 2 ]
    gap> R.crConjugator;
    [ [ 1, 0 ], [ -1, 1 ] ] </pre>
<P>
<P>
The following functions are functions of space-group types.
<P>
In general, the parameters characterizing a space-group  type will form a
quintuple <code>(<var>dim</var>,  <var>system</var>,\,<var>q-class</var>,\,<var>z-class</var>,\,<var>sg-type</var>)</code>  where
<var>dim</var>  is  the   associated dimension,  <var>system</var>  is the   number  of the
associated crystal system, <var>q-class</var> is    the number of the   associated
<I>&#x211A;</I>-class  within  the  crystal system, <var>z-class</var> is  the  number of the
<I>&#x2124;</I>-class  within the <I>&#x211A;</I>-class,  and <var>sg-type</var> is the space-group type
within  the <I>&#x2124;</I>-class.  However, in  case of dimensions  2 or 3, you may
instead specify a <I>&#x2124;</I>-class  by a pair  <code>(<var>dim</var>, <var>IT-number</var>)</code> or by its
Hermann-Mauguin  symbol (as  described  above).  Then  the  function will
handle the  first  space-group   type within that    <I>&#x2124;</I>-class,  i.e.,
<var>sg-type</var> <I>= 1</I>, that is, the corresponding symmorphic space group (split
extension).
<P>
<P>
<code>DisplaySpaceGroupType( <var>dim</var>,  <var>system</var>, <var>q-class</var>, <var>z-class</var>, <var>sg-type</var>
)</code>
<A name = "I70"></a>
 <BR> 
<code>DisplaySpaceGroupType( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>DisplaySpaceGroupType( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>DisplaySpaceGroupType</code> displays for  the specified space-group type some
of the information which is provided for that space-group type in Table 1
of <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>, namely
<P>

<P>&bull; the orbit size associated with that space-group type and,
<P>
<P>&bull; for dimensions  2 and 3,  the <var>IT-number</var>  and  the Hermann-Mauguin
      symbol.
<P>

For details see <A href="biblio.htm#BBNWZ78"><cite>BBNWZ78</cite></a>.
<P>
<pre>    gap> DisplaySpaceGroupType( 2, 17 );
    #I     Space-group type (2,4,4,1,1); IT(17) = p6mm; orbit size 1
    gap> DisplaySpaceGroupType( "Pm-3" );
    #I     Space-group type (3,7,2,1,1); IT(200) = Pm-3; orbit size 1
    gap> DisplaySpaceGroupType( 4, 32, 10, 2, 4 );
    #I    *Space-group type (4,32,10,2,4); orbit size 18
    gap> DisplaySpaceGroupType( 3, 6, 1, 1, 4 );
    #I    *Space-group type (3,6,1,1,4); IT(169) = P61, IT(170) = P65;
    #I      orbit size 2; fp-free </pre>
<P>
<P>
<code>DisplaySpaceGroupGenerators(   <var>dim</var>,  <var>system</var>,  <var>q-class</var>,  <var>z-class</var>,
<var>sg-type</var> )</code>
<A name = "I71"></a>
 <BR> 
<code>DisplaySpaceGroupGenerators( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>DisplaySpaceGroupGenerators( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>DisplaySpaceGroupGenerators</code>  displays the non-translation generators of
a representative  space group  of the specified space-group type  without
actually constructing that matrix group.
<P>
In more details:  Let <I>n  = dim</I> be  the given dimension, and let <I>M<sub>1</sub>,
..., M<sub>r</sub></I> be the generators of the representative  <I>n &times; n</I> matrix
group of the given  <I>&#x2124;</I>-class  (this is the  group which you will get if
you call the <code>MatGroupZClass</code> function (see above) for that  <I>&#x2124;</I>-class).
Then, for the given space-group type, the <code>SpaceGroup</code> function described
below will construct as representative of that space-group type an <I>(n+1)
&times; (n+1)</I>  matrix group  which is generated  by the <I>n</I>  translations
which are induced by the (standard) basis  vectors of the <I>n</I>-dimensional
Euclidian space,  and <I>r</I> additional matrices  <I>S<sub>1</sub>, ..., S<sub>r</sub></I>  of the
form <I>S<sub>i</sub>  = [  \catcode`|=12  \begintabular{c<code>c}  \catcode`\</code>=13
</I>M_i<I> & </I>t_i<I> \cr \hline 0 & 1 \endtabular ]</I>, where the <I>n &times;
n</I> submatrices <I>M<sub>i</sub></I> are as defined  above, and the <I>t<sub>i</sub></I> are <I>n</I>-columns
with rational entries.   The <code>DisplaySpaceGroupGenerators</code> function saves
time by not constructing the group, but  just displaying the <I>r</I> matrices
<I>S<sub>1</sub>,
..., S<sub>r</sub></I>.
<P>
<pre>    gap> DisplaySpaceGroupGenerators( "P61" );
    #I  The non-translation generators of SpaceGroup( 3, 6, 1, 1, 4 ) are

    [ [   -1,    0,    0,    0 ],
      [    0,   -1,    0,    0 ],
      [    0,    0,    1,  1/2 ],
      [    0,    0,    0,    1 ] ]

    [ [    0,   -1,    0,    0 ],
      [    1,   -1,    0,    0 ],
      [    0,    0,    1,  1/3 ],
      [    0,    0,    0,    1 ] ] </pre>
<P>
<P>
<code>SpaceGroup( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var>, <var>sg-type</var> )</code>
<A name = "I72"></a>
 <BR> 
<code>SpaceGroup( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>SpaceGroup( <var>Hermann-Mauguin-symbol</var> )</code>
<P>
<code>SpaceGroup</code> returns a  <I>(dim+1) &times; (dim+1  )</I> matrix group <I>S</I>, say,
which is a  representative of the given   space-group type (see also  the
description of the <code>DisplaySpaceGroupGenerators</code> function above).
<P>
<pre>    gap> S := SpaceGroup( "P61" );
    SpaceGroup( 3, 6, 1, 1, 4 )
    gap> for s in S.generators do
    >  Print( "\n" ); PrintArray( s ); od; Print( "\n" );

    [ [   -1,    0,    0,    0 ],
      [    0,   -1,    0,    0 ],
      [    0,    0,    1,  1/2 ],
      [    0,    0,    0,    1 ] ]

    [ [    0,   -1,    0,    0 ],
      [    1,   -1,    0,    0 ],
      [    0,    0,    1,  1/3 ],
      [    0,    0,    0,    1 ] ]

    [ [  1,  0,  0,  1 ],
      [  0,  1,  0,  0 ],
      [  0,  0,  1,  0 ],
      [  0,  0,  0,  1 ] ]

    [ [  1,  0,  0,  0 ],
      [  0,  1,  0,  1 ],
      [  0,  0,  1,  0 ],
      [  0,  0,  0,  1 ] ]

    [ [  1,  0,  0,  0 ],
      [  0,  1,  0,  0 ],
      [  0,  0,  1,  1 ],
      [  0,  0,  0,  1 ] ]

    gap> S.crSpaceGroupType;
    [ 3, 6, 1, 1, 4 ] </pre>
<P>
Besides  of  the usual components,   the  resulting group  record of  <I>S</I>
contains an additional component   <I>S</I><code>.crSpaceGroupType</code> which saves   a
list of the parameters that specify the given space-group type.
<P>
Moreover, it  contains,   in  form  of a  finitely  presented  group,   a
presentation of <I>S</I>  which is satisfied  by the matrix generators. If the
factor group  of <I>S</I> by its translation  normal subgroup is solvable then
this presentation is chosen such that it is a polycyclic power commutator
presentation. The proper way to  access this presentation  is to call the
following function.
<P>
<P>
<code>FpGroup( <var>S</var> )</code>
<A name = "I73"></a>

<P>
<code>FpGroup</code>    returns a  finitely  presented  group    <var>G</var>, say,  which is
isomorphic  to <var>S</var>,  where <var>S</var>  is  expected to  be  a space group. It is
chosen such that there is an  isomrphism from <var>G</var>  to <var>S</var> which maps each
generator of <var>G</var> onto the corresponding generator of <var>S</var>.  This means, in
particular, that the matrix generators   of <var>S</var> satisfy the relators   of
<var>G</var>.
<P>
<pre>    gap> G := FpGroup( S );
    Group( g1, g2, g3, g4, g5 )
    gap> for rel in G.relators do Print( rel, "\n" ); od;
    g1^2*g5^-1
    g2^3*g5^-1
    g2^-1*g1^-1*g2*g1
    g3^-1*g1^-1*g3*g1*g3^2
    g3^-1*g2^-1*g3*g2*g4*g3^2
    g4^-1*g1^-1*g4*g1*g4^2
    g4^-1*g2^-1*g4*g2*g4*g3^-1
    g4^-1*g3^-1*g4*g3
    g5^-1*g1^-1*g5*g1
    g5^-1*g2^-1*g5*g2
    g5^-1*g3^-1*g5*g3
    g5^-1*g4^-1*g5*g4
    gap> # Verify that the matrix generators of S satisfy the relators of G.
    gap> ForAll( G.relators,
    >  rel -> MappedWord( rel, G.generators, S.generators ) = S.identity );
    true </pre>
<P>
<P>
<code>TransposedSpaceGroup( <var>dim</var>, <var>system</var>, <var>q-class</var>, <var>z-class</var>, <var>sg-type</var> )</code>
<A name = "I74"></a>
 <BR> 
<code>TransposedSpaceGroup( <var>dim</var>, <var>IT-number</var> )</code> <BR> 
<code>TransposedSpaceGroup( <var>Hermann-Mauguin-symbol</var> )</code> <BR> 
<code>TransposedSpaceGroup( <var>S</var> )</code>
<P>
<code>TransposedSpaceGroup</code> returns a  matrix group <var>T</var>, say, whose generators
are  just the    transposed generators  (in    the  same order)  of   the
corresponding space group <var>S</var> specified by the arguments. As for <var>S</var>, you
may get a finite presentation for <var>T</var> via the <code>FpGroup</code> function.
<P>
The purpose of this function is explicitly  discussed in the introduction
to this section.
<P>
<pre>    gap> T := TransposedSpaceGroup( S );
    TransposedSpaceGroup( 3, 6, 1, 1, 4 )
    gap> for m in T.generators do
    >  Print( "\n" ); PrintArray( m ); od; Print( "\n" );
    
    [ [   -1,    0,    0,    0 ],
      [    0,   -1,    0,    0 ],
      [    0,    0,    1,    0 ],
      [    0,    0,  1/2,    1 ] ]
    
    [ [    0,    1,    0,    0 ],
      [   -1,   -1,    0,    0 ],
      [    0,    0,    1,    0 ],
      [    0,    0,  1/3,    1 ] ]
    
    [ [  1,  0,  0,  0 ],
      [  0,  1,  0,  0 ],
      [  0,  0,  1,  0 ],
      [  1,  0,  0,  1 ] ]
    
    [ [  1,  0,  0,  0 ],
      [  0,  1,  0,  0 ],
      [  0,  0,  1,  0 ],
      [  0,  1,  0,  1 ] ]
    
    [ [  1,  0,  0,  0 ],
      [  0,  1,  0,  0 ],
      [  0,  0,  1,  0 ],
      [  0,  0,  1,  1 ] ] </pre>
<P><A NAME="SECT014"><h2>38.14 The Small Groups Library</h2></a>
<P><P>
<A name = "I75"></a>

<P>
This library contains all groups of order at most 1000 except for
512 and 768 up to isomorphism.  There are a total of 174366 such groups.
<P>
<P>
<code>SmallGroup( <var>size</var>, <var>i</var> )</code>
<A name = "I76"></a>

<P>
The function <code>SmallGroup( <var>size</var>, <var>i</var> )</code> returns the <I>i</I>th  group of  order
<I>size</I> in the catalogue. It will return an AgGroup, if the group is soluble
and a PermGroup otherwise.
<P>
<P>
<code>NumberSmallGroups( <var>size</var> )</code>
<A name = "I77"></a>

<P>
The function <code>NumberSmallGroups( <var>size</var> )</code> returns the  number of groups of
the order <I>size</I>.
<P>
<P>
<code>AllSmallGroups( <var>size</var> )</code>
<A name = "I78"></a>

<P>
The function <code>AllSmallGroups( <var>size</var> )</code> returns the list  of all groups  of
the order <I>size</I>.
<P>
<P>
<code>UnloadSmallGroups( <var>list of sizes</var> )</code>
<A name = "I79"></a>

<P>
It  is possible to  work with the  catalogue of  groups of small order just
using the functions described above. However, the catalogue is rather large
even though  the groups are stored in a very compact  description.  Thus it
might be helpful  for a space efficient  usage of the catalogue,  to know a 
little bit about unloading parts of the catalogue by hand.
<P>
At the first call of one  of the  functions  described above, the groups of 
order <var>size</var> are loaded  and  stored in a compact description. GAP will not 
unload them itsself again. Thus if one calls one of the above functions for
a lot of different orders,  then all the groups of these orders are stored. 
Even though the  description of the groups  is space efficient,  this might
use a lot  of space.  For example,  if one uses the above functions to load 
the complete catalogue, then GAP will grow to about 12 MB of workspace.
<P>
Thus it might be interesting to  unload the groups of some orders again, if
they  are  not  used  anymore.  This  can  be  done by calling the function 
<code>UnloadSmallGroups( <var>list of sizes</var> )</code>
<P>
If the groups of order <var>size</var> are unloaded by hand, then GAP will of course
load them again at the next call of  <code>SmallGroup( <var>size</var>, <var>i</var> )</code>  or one of
the other functions described at the beginning of this section.
<P>
<P>
<code>IdGroup( <var>G</var> )</code>
<A name = "I80"></a>

<P>
Let <var>G</var> be a PermGroup or AgGroup of order at most 1000, but not  of  order
256, 512 or 768. Then the  function call  <code>IdGroup( <var>G</var> )</code>  returns a tuple
<I>[size, i]</I>  meaning  that  <I>G</I>  is  isomorphic  to the <I>i</I>-th group in the
catalogue of groups of order <I>size</I>.
<P>
Note that  this package calls and  uses the ANUPQ share library of GAP in a
few cases.
<P><a href ="chap037.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap039.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>