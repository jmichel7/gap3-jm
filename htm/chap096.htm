<html><head><title>GAP3 Manual: 96 Coxeter cosets</title></head>
<body bgcolor="ffffff">
<h1>96 Coxeter cosets</h1>
<P><P>
Let  <I>R</I> be a root system in the  real vector space <I>V</I> as in Chapter <a href="chap085.htm">Root
systems  and  finite  Coxeter  groups</a>.  We  say that <I>F<sub>0</sub>&isin; </I>GL<I>(V)</I> is an
<strong>automorphism  of <I>R</I></strong> if  it permutes <I>R</I>  and is of  finite order (finite
order  is automatic  if <I>R</I>  generates <I>V</I>).  It follows by <A href="biblio.htm#Bou68"><cite>Bou68</cite></a>, chap. VI,
\S1.1,  lemme 1 that the dual <I>F<sub>0</sub><sup>*</sup>&isin;</I>GL<I>(V<sup>&or;</sup>)</I> permutes the
coroots  <I>R<sup>&or;</sup>&sub; V<sup>&or;</sup></I>; thus <I>F<sub>0</sub></I> normalizes the reflection group
<I>W</I>  associated to <I>R</I>, that is  <I>w&rarr; F<sub>0</sub>wF<sub>0</sub><sup>-1</sup></I> is an automorphism
of  <I>W</I>. Thus (see  <a href="chap095.htm">Reflection cosets</a>) we  get a reflection coset <I>WF<sub>0</sub></I>,
called here a <strong>Coxeter coset</strong>.
<P>
The  motivation for introducing Coxeter  cosets comes from automorphisms of
algebraic  reductive groups, in particular  non-split reductive groups over
finite  fields. Let us,  as in <a href="chap086.htm">Algebraic  groups and semi-simple elements</a>
fix a connected reductive algebraic group <I><strong>G</strong></I>. We assume <I><strong>G</strong></I> is a group
over an algebraic closure <I><span style="text-decoration: overline">&#x1D53D;</span><sub>q</sub></I> of a finite field <I>&#x1D53D;<sub>q</sub></I>, defined
over  <I>&#x1D53D;<sub>q</sub></I>, which corresponds to be given a Frobenius endomorphism <I>F</I> so
that  the finite  group of  rational points  <I><strong>G</strong>(&#x1D53D;<sub>q</sub>)</I> identifies  to the
subgroup <I><strong>G</strong><sup>F</sup></I> of fixed points under <I>F</I>.
<P>
Let  <I><strong>T</strong></I> be a maximal  torus of <I><strong>G</strong></I>, and  <I>&Phi;</I> (resp. <I>&Phi;<sup>&or;</sup></I>) be
the  roots (resp. coroots)  of <I>G</I> with  respect to <I><strong>T</strong></I>  in the character
group  <I>X(<strong>T</strong>)</I> (resp. the  group of one-parameter  subgroups <I>Y(<strong>T</strong>)</I>). As
explained  in  <a href="chap086.htm">Algebraic  groups  and  semi-simple elements</a> then <I><strong>G</strong></I> is
determined  up  to  isomorphism  by <I>(X(<strong>T</strong>),&Phi;,Y(<strong>T</strong>),&Phi;<sup>&or;</sup>)</I> and in
<strong>CHEVIE</strong>   this   corresponds   to   give   a   rational  reflection  group
<I>W=N<sub><strong>G</strong></sub>(<strong>T</strong>)/<strong>T</strong></I> acting on the vector space <I>V=&#x211A;&otimes; X(<strong>T</strong>)</I> together
with a root system.
<P>
If  <I><strong>T</strong></I> is <I>F</I>-stable the Frobenius  endomorphism <I>F</I> acts also naturally
on  <I>X(T)</I> and defines thus an endomorphism of <I>V</I>, which is of the form <I>q
F<sub>0</sub></I>,  where <I>F<sub>0</sub>&isin;</I>GL<I>(V)</I> is  of finite order  and normalizes <I>W</I>. We get
thus  a Coxeter coset <I>WF<sub>0</sub>&sub;</I>GL<I>(V)</I>. The data <I>(X(<strong>T</strong>), &Phi;, Y(<strong>T</strong>),
&Phi;<sup>&or;</sup>,   F<sub>0</sub>)</I>,  and  the  integer   <I>q</I>  completely  determine  up  to
isomorphism  the associated  <strong>reductive finite  group</strong> <I><strong>G</strong><sup>F</sup></I>.  Thus these
data  is a way of representing  in <strong>CHEVIE</strong> the essential information which
determines  a finite reductive  group. Indeed, all  properties of Chevalley
groups  can be computed from that datum: symbols representing characters,
conjugacy classes, and finally the whole character table of <I><strong>G</strong><sup>F</sup></I>.
<P>
It turns out that an interesting part of the objects attached to this datum
depends  only on <I>(V,W, F<sub>0</sub>)</I>: the order  of the maximal tori, the ``fake
degrees", the order of <I><strong>G</strong><sup>F</sup></I>, symbols representing unipotent characters,
Deligne-Lusztig  induction in  terms of  ``almost characters", the Fourier
matrix  relating characters  and almost characters, etc<I>...</I> (see, e.g.,
<A href="biblio.htm#BMM93"><cite>BMM93</cite></a>).  It  is  thus  possible  to  extend  their  construction  to
non-crystallographic  groups (or  even to  more general  complex reflection
groups,  see <a href="chap095.htm#SECT002">Spets</a>); this is why we did  not include a root system in the
definition  of a reflection coset. However, unipotent conjugacy classes for
instance depend on the root system thus do not exist in general.
<P>
We  assume now that <I><strong>T</strong></I>  is contained in an  <I>F</I>-stable Borel subgroup of
<I><strong>G</strong></I>.  This defines an order  on the roots, and  there is a unique element
<I>&phi;&isin;  W F<sub>0</sub></I>, the  <strong>reduced element</strong> of  the coset, which preserves the
set of positive roots. It thus defines a <strong>diagram automorphism</strong>, that is an
automorphism  of the Coxeter system <I>(W,S)</I>.  This element is stored in the
component  <code>.phi</code> of the coset record. It may be defined without mentioning
the  roots,  as  follows:  <I>(W,F<sub>0</sub>(S))</I>  is  another  Coxeter system, thus
conjugate to <I>S</I> by a unique element of <I>W</I>, thus there is a unique element
<I>&phi;&isin; WF<sub>0</sub></I> which stabilizes <I>S</I> (a proof follows from <A href="biblio.htm#Bou68"><cite>Bou68</cite></a>, Theoreme 1,
chap.  V, \S 3). We  consider thus cosets of the form <I>W&phi;</I> where
<I>&phi;</I>  stabilizes <I>S</I>.  The coset  <I>W &phi;</I>  is completely  defined by the
permutation  <code>.phi</code> when <I><strong>G</strong></I> is  semi-simple --- equivalently when <I>&Phi;</I>
generates  <I>V</I>; in this  case we just  need to specify  <code>phi</code> to define the
coset.
<P>
There is a slight generalisation of the above setup, covering in particular
the  case of the Ree and Suzuki groups. We consider <I><strong>G</strong><sup>F</sup></I> where <I>F</I> not a
Frobenius  endomorphism, but  an isogeny  such that  some power  <I>F<sup>n</sup></I> is a
Frobenius endomorphism. Then <I>F</I> still defines an endomorphism of <I>V</I> which
normalizes  <I>W</I>; we define a real number <I>q</I> such that <I>F<sup>n</sup></I> is attached to
an  <I>&#x1D53D;<sub>q<sup>n</sup></sub></I>-structure. Then  we still  have <I>F=q  F<sub>0</sub></I> where <I>F<sub>0</sub></I> is of
finite  order but <I>q</I>  is no more  an integer. Thus <I>F<sub>0</sub>&isin;</I>GL<I>(V&otimes;&#x211D;)</I>
but  <I>F<sub>0</sub>&notin;</I>GL<I>(V)</I>. For instance, for the  Ree and Suzuki groups, <I>F<sub>0</sub></I>
is  an automorphism of order  <I>2</I> of <I>W</I>, which  is of type <I>G<sub>2</sub></I>, <I>B<sub>2</sub></I> or
<I>F<sub>4</sub></I>, and <I>q=&radic; 2</I> for <I>B<sub>2</sub></I> and <I>F<sub>4</sub></I> and <I>q=&radic; 3</I> for <I>G<sub>2</sub></I> To get
this,  we need to start  from root systems for  <I>G<sub>2</sub></I>, <I>B<sub>2</sub></I> or <I>F<sub>4</sub></I> where
all  the roots  have the  same length.  This kind  of root  system is <strong>not</strong>
crystallographic.  Such more general root systems also exist for all finite
Coxeter  groups such as  the dihedral groups  and <I>H<sub>3</sub></I> and  <I>H<sub>4</sub></I>. We will
call  here  <strong>Weyl  cosets</strong>  the  cosets  corresponding to rational forms of
algebraic  groups, which include  thus some non-rational  roots systems for
<I>B<sub>2</sub></I>, <I>G<sub>2</sub></I> and <I>F<sub>4</sub></I>.
<P>
Conjugacy  classes and irreducible characters of Coxeter cosets are defined
as  for  general  reflection  cosets.  For  irreducible  characters of Weyl
cosets,  in <strong>CHEVIE</strong> we  choose (following Lusztig)  for each <I>&phi;</I>-stable
character  of <I>W</I> a particular extension to a character of <I>W&#8906;&lang;
&phi; &rang;</I>, which we will call the <strong>preferred extension</strong>. The <strong>character
table</strong>  of the coset <I>W&phi;</I> is the table of the restrictions to <I>W&phi;</I> of
the preferred extensions (See also the section below <code>CharTable for Coxeter
cosets</code>). The question of finding the conjugacy classes and character table
of  a Coxeter coset can be reduced  to the case of irreducible root systems
<I>R</I>.
<P>

<P>&bull;  The automorphism <I>&phi;</I> permutes  the irreducible components of <I>W</I>,
and  <I>W&phi;</I> is a direct product of cosets where <I>&phi;</I> permutes cyclically
the irreducible components of <I>W</I>. The preferred extension is defined to be
the direct product of the preferred extension in each of these situations.
<P>
<P>&bull;  Assume  now  that  <I>W&phi;</I>  is  a  descent  of  scalars, that is the
decomposition  in irreducible components <I>W=W<sub>1</sub>&times; ... &times; W<sub>k</sub></I> is
cyclically  permuted by <I>&phi;</I>. Then there  are natural bijections from the
<I>&phi;</I>-conjugacy  classes of <I>W</I> to the <I>&phi;<sup>k</sup></I>-conjugacy classes of <I>W<sub>1</sub></I>
as  well as from the <I>&phi;</I>-stable characters of <I>W</I> to the <I>&phi;<sup>k</sup></I>-stable
characters of <I>W<sub>1</sub></I>, which reduce the definition of preferred extensions on
<I>W&phi;</I> to the definition for <I>W<sub>1</sub>&phi;<sup>k</sup></I>.
<P>
<P>&bull;  Assume now  that <I>W</I>  is the  Coxeter group  of an  irreducible root
system.   <I>&phi;</I>  permutes  the   simple  roots,  hence   induces  a  graph
automorphism   on  the  corresponding  Dynkin  diagram.  If  <I>&phi;=1</I>  then
conjugacy  classes and characters coincide with  those of the Coxeter group
<I>W</I>.
<P>
<P>&bull; The nontrivial cases for crystallographic roots systems are (the order
of  <I>&phi;</I> is  written as  left exponent  to the type): <I><sup>2</sup>A<sub>n</sub></I>, <I><sup>2</sup>D<sub>n</sub></I>,
<I><sup>3</sup>D<sub>4</sub></I>, <I><sup>2</sup>E<sub>6</sub></I>.
<P>
<P>&bull;  For non-crystallographic root  systems where all  the roots have the
same  length the additional cases  <I><sup>2</sup>B<sub>2</sub></I>, <I><sup>2</sup>G<sub>2</sub></I>, <I><sup>2</sup>F<sub>4</sub></I> and <I><sup>2</sup>I<sub>2</sub>(k)</I>
arise.
<P>
<P>&bull;  In  case  <I><sup>3</sup>D<sub>4</sub></I>  the  group  <I>W&#8906;&lang;  &phi;&rang;</I> can be
embedded into the Coxeter group of type <I>F<sub>4</sub></I>, which induces a labeling for
the  conjugacy classes of  the coset. The  preferred extension is chosen as
the (single) extension with rational values.
<P>
<P>&bull; In case <I><sup>2</sup>D<sub>n</sub></I> the group <I>W&#8906;&lang; &phi;&rang;</I> is isomorphic
to a Coxeter group of type <I>B<sub>n</sub></I>. This induces a canonical labeling for the
conjugacy classes of the coset and allows to define the preferred extension
in  a  combinatorial  way  using  the  labels (pairs of partitions) for the
characters of the Coxeter group of type <I>B<sub>n</sub></I>.
<P>
<P>&bull;  In the remaining crystallographic  cases <I>&phi;</I> identifies to <I>-w<sub>0</sub></I>
where  <I>w<sub>0</sub></I>  is  the  longest  element  of  <I>W</I>.  So, there is a canonical
labeling  of the conjugacy classes and characters  of the coset by those of
<I>W</I>.  The preferred extensions  are defined by  describing the signs of the
character values on <I>-w<sub>0</sub></I>.

<P>
In  <strong>GAP3</strong> the most general  construction of a Coxeter  coset is by starting
from  a  Coxeter  datum  specified  by  the  matrices  of <code>simpleRoots</code> and
<code>simpleCoroots</code>,  and  giving  in  addition  the  matrix <code>F0Mat</code> of the map
<I>F<sub>0</sub>:V&rarr; V</I> (see the commands <code>CoxeterCoset</code> and
<code>CoxeterSubCoset</code>).  As  for  Coxeter  groups,  the elements of <I>W&phi;</I> are
uniquely determined by the permutation they induce on the set of roots <I>R</I>.
We consider these permutations as <code>Elements</code> of the Coxeter coset.
<P>
Coxeter  cosets are  implemented in  <strong>GAP3</strong> by  a record  which points to a
Coxeter  datum record  and has  additional fields  holding <code>F0Mat</code>  and the
corresponding   element  <code>phi</code>.  Functions  on   the  coset  (for  example,
<code>ChevieClassInfo</code>)  are  about  properties  of  the  group coset <I>W &phi;</I> ;
however,  most definitions for  elements of untwisted  Coxeter groups apply
without  change to elements in <I>W &phi;</I>: e.g., if we define the length of
an  element <I>w&phi;&isin; W &phi;</I>  as the number of  positive roots it sends to
negative  ones, it  is the  same as  the length  of <I>w</I>, i.e., <I>&phi;</I> is of
length  <I>0</I>, since <I>&phi;</I> has  been chosen to preserve  the set of positive
roots.  Similarly, the <code>CoxeterWord</code> describing <I>w&phi;</I>  is the same as the
one for <I>w</I>, etc<I>...</I>
<P>
We  associate  to  a  Coxeter  coset  <I>W&phi;</I>  a  <strong>twisted Dynkin diagram</strong>,
consisting  of the Dynkin diagram of <I>W</I> and the graph automorphism induced
by  <I>&phi;</I>  on  this  diagram  (this  specifies  the group <I>W&#8906;&lang;
F&rang;</I>,   mentioned  above,  up  to   isomorphism).  See  the  functions
<code>ReflectionType</code>, <code>ReflectionName</code> and <code>PrintDiagram</code> for Coxeter cosets.
<P>
Below  is an example showing first how to <strong>not</strong> define, then how to define,
the Weyl coset for a Suzuki group:
<P>
<pre>    gap> 2B2:=CoxeterCoset(CoxeterGroup("B",2),(1,2));
    #I transposed of matrix for F0 must normalize set of coroots of parent.
    false
    gap> 2B2:=CoxeterCoset(CoxeterGroup("Bsym",2),(1,2));
    2Bsym2
    gap> Display(CharTable(2B2));
    2Bsym2

         2 1      2     2

                  1   121

    2.     1      1     1
    .11    1     -1    -1
    1.1    . -ER(2) ER(2)
    </pre>
<P>
A  <strong>subcoset</strong> <I>Hw&phi;</I> of <I>W&phi;</I> is given  by a reflection subgroup <I>H</I> of
<I>W</I>  and an element <I>w</I> of <I>W</I> such that <I>w&phi;</I> induces an automorphism of
the  root  system  of  <I>H</I>.  For  algebraic  groups,  this corresponds to a
rational  form of  a reductive  subgroup of  maximal rank.  For example, if
<I>W&phi;</I>  corresponds to  the algebraic  group <I><strong>G</strong></I>  and <I>H</I> is the trivial
subgroup, the coset <I>Hw&phi;</I> corresponds to a maximal torus <I><strong>T</strong><sub>w</sub></I> of type
<I>w</I>.
<P>
<pre>    gap> CoxeterSubCoset(2B2,[],Group(2B2).1);
    (q^2-ER(2)q+1)</pre>
<P>
A subgroup <I>H</I> which is a parabolic subgroup corresponds to a rational form
of  a Levi  subgroup of  <I><strong>G</strong></I>. The  command <code>Twistings</code>  gives all rational
forms of such a Levi.
<P>
<pre>    gap> W:=CoxeterGroup("B",2);
    CoxeterGroup("B",2)
    gap> Twistings(W,[1]);
    [ ~A1.(q-1), ~A1.(q+1) ]
    gap> Twistings(W,[2]);
    [ A1&lt;2>.(q-1), A1&lt;2>.(q+1) ]</pre>
<P>
Notice how we distinguish between subgroups generated by short roots and by
long  roots. A general  <I>H</I> corresponds to  a reductive subgroup of maximal
rank.  Here we consider the subgroup generated  by the long roots in <I>B<sub>2</sub></I>,
which  corresponds to a  subgroup of type  <I>SL<sub>2</sub>&times; SL<sub>2</sub></I> in <I>SP<sub>4</sub></I>, and
show its possible rational forms.
<P>
<pre>    gap> W:=CoxeterGroup("B",2);
    CoxeterGroup("B",2)
    gap> Twistings(W,[2,4]);
    [ A1&lt;2>xA1&lt;4>, (A1xA1)&lt;2,4> ]</pre>
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap096.htm#SECT001">CoxeterCoset</a>
<LI> <A HREF="chap096.htm#SECT002">CoxeterSubCoset</a>
<LI> <A HREF="chap096.htm#SECT003">Functions on Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT004">ReflectionType for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT005">ChevieClassInfo for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT006">CharTable for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT007">Frobenius</a>
<LI> <A HREF="chap096.htm#SECT008">Twistings for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT009">RootDatum for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT010">Torus for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT011">StructureRationalPointsConnectedCentre</a>
<LI> <A HREF="chap096.htm#SECT012">ClassTypes</a>
<LI> <A HREF="chap096.htm#SECT013">Quasi-Semisimple elements of non-connected reductive groups</a>
<LI> <A HREF="chap096.htm#SECT014">Centralizer for quasisemisimple elements</a>
<LI> <A HREF="chap096.htm#SECT015">QuasiIsolatedRepresentatives for Coxeter cosets</a>
<LI> <A HREF="chap096.htm#SECT016">IsIsolated for Coxeter cosets</a>
</ol>
<A NAME="SECT001"><h2>96.1 CoxeterCoset</h2></a>
<P><P>
<A name = "I0"></a>

<P>
<code>CoxeterCoset( <var>W</var>[, <var>FMat</var> ] )</code>
<P>
<code>CoxeterCoset( <var>W</var>[, <var>FPerm</var>] )</code>
<P>
This  function returns a Coxeter coset as  a <strong>GAP3</strong> object. The argument <var>W</var>
must be a Coxeter group (created by <code>CoxeterGroup</code> or
<code>ReflectionSubgroup</code>).  In the first  form the argument  <var>F0Mat</var> must be an
invertible  matrix of  dimension <code>Rank(<var>W</var>)</code>,  representing an automorphism
<I>F</I>  of the root system of the parent of <var>W</var>. In the second form <var>FPerm</var> is
a  permutation of the roots of the parent  group of <var>W</var>; it is assumed that
the corresponding <var>FMat</var> acts trivially on the orthogonal of these roots. A
shortcut  is accepted if <var>W</var>  has same rank as  semisimple rank and <var>FPerm</var>
preserves its simple roots: one need only give the induced permutation of
the simple roots.
<P>
If  there is  no second  argument the  default for  <var>F0Mat</var> is the identity
matrix.
<P>
<code>CoxeterCoset</code> returns a record  from   which we document the   following
components:
<P>
<DL><DT><code>isDomain</code>, <code>isFinite</code>:<DD><BR> 
        true
</DL><P>
<DL><DT><code>reflectionGroup</code>:<DD><BR> 
        the Coxeter group <var>W</var>
</DL><P>
<DL><DT><code>F0Mat</code>:<DD><BR> 
        the matrix acting on <I>V</I> which represents the unique element <I>&phi;</I>
in <I>WF<sub>0</sub></I> which preserves the positive roots.
</DL><P>
<DL><DT><code>phi</code>:<DD><BR> 
        the permutation of the roots of <var>W</var> induced by <code>F0Mat</code>
        (also the element of smallest length in the Coset <I>WF<sub>0</sub></I>).
</DL><P>
In  the  first example  we create a  Coxeter  coset corresponding  to the
general unitary groups <I>GU<sub>3</sub>(q)</I> over finite fields with <I>q</I> elements.
<P>
<pre>    gap> W := RootDatum("gl",3);;
    gap> gu3 := CoxeterCoset( W, -IdentityMat( 3 ) );
    2A2.(q+1)
    gap> F4 := CoxeterGroup( "F", 4 );;
    gap> D4 := ReflectionSubgroup( F4, [ 1, 2, 16, 48 ] );;
    gap> PrintDiagram( D4 );
    D4 9
        \ 
         1 - 16
        /
       2
    gap> CoxeterCoset( D4, MatXPerm(D4,(2,9,16)) );
    3D4&lt;9,16,1,2>
    gap> CoxeterCoset( D4, (2,9,16));
    3D4&lt;9,16,1,2></pre>
<P><A NAME="SECT002"><h2>96.2 CoxeterSubCoset</h2></a>
<P><P>
<A name = "I1"></a>

<P>
<code>CoxeterSubCoset( <var>WF</var>, <var>r</var>[, <var>w</var>])</code>
<P>
Returns the  reflection subcoset of  the Coxeter  coset <var>WF</var> generated by
the  reflections with roots  specified by <var>r</var>.  <var>r</var> is  a list of indices
specifying a subset  of the roots of <var>W</var>  where <var>W</var> is the  Coxeter group
<code>CoxeterGroup(<var>WF</var>)</code>.  If specified,  <var>w</var> must be  an element of <I>W</I> such
that <code>w*WF.phi</code>  normalizes the subroot system  generated by <var>r</var>.  If
absent,   the  default value   for  <var>w</var>  is <code>()</code>.   It    is an error, if
<code>w*WF.phi</code> does not normalize the subsystem.
<P>
<pre>    gap> CoxeterSubCoset( CoxeterCoset( CoxeterGroup( "A", 2 ), (1,2) ),
    >                                                              [ 1 ] );
    Error, must give w, such that w * WF.phi normalizes subroot system.
     in
    CoxeterSubCoset( CoxeterCoset( CoxeterGroup( "A", 2 ), (1,2) ), [ 1 ]
     ) called from
    main loop
    brk>
    gap> f4coset := CoxeterCoset( CoxeterGroup( "F", 4 ) );
    F4
    gap> w := RepresentativeOperation( CoxeterGroup( f4coset ),
    >                      [ 1, 2, 9, 16 ], [ 1, 9, 16, 2], OnTuples );;
    gap> 3d4again := CoxeterSubCoset( f4coset, [ 1, 2, 9, 16], w );
    3D4&lt;9,16,1,2>
    gap> PrintDiagram( 3d4again );
    phi acts as ( 2, 9,16) on the component below
    D4 9
        \ 
         1 - 2
        /
       16</pre>
<P><A NAME="SECT003"><h2>96.3 Functions on Coxeter cosets</h2></a>
<P><P><P>
All functions for reflection cosets are implemented for Coxeter cosets.
<P>
This includes <code>Group( <var>WF</var> )</code> which returns the Coxeter group of which <var>WF</var>
is  a coset; the functions  <code>Elements</code>, <code>Random</code>, <code>Representative</code>, <code>Size</code>,
<code>in</code>,  Rank,  SemisimpleRank,  which  use  the  corresponding functions for
<code>Group(   <var>WF</var>   )</code>;   <code>ConjugacyClasses(   <var>WF</var>   )</code>,  which  returns  the
<I>&phi;</I>-conjugacy  classes of <var>W</var>; the  corresponding <code>PositionClass( <var>WF</var> ,
<var>x</var>  )</code> and <code>FusionConjugacyClasses( <var>HF</var>,  <var>WF</var> )</code>, <code>InductionTable( <var>HF</var>,
<var>WF</var> )</code>.
<P>
For  Weyl  coset  associated  to  a  finite  reductive  group  <I><strong>G</strong><sup>F</sup></I>, the
characters of the coset correspond to unipotent Deligne-Lusztig characters,
and  the  induction  from  a  subcoset  corresponding  to  a  Levi subgroup
corresponds to the Lusztig induction of the Deligne-Lusztig characters (see
more details in the next chapter). Here are some examples: 
<P>
Harish-Chandra induction in the basis of almost characters:
<P>
<pre>    gap> WF := CoxeterCoset( CoxeterGroup( "A", 4 ), (1,4)(2,3) );
    2A4
    gap> Display( InductionTable( CoxeterSubCoset( WF, [ 2, 3 ] ), WF ) );
    Induction from 2A2&lt;2,3>.(q-1)(q+1) to 2A4
          |111 21 3
    ________________
    11111 |  1  . .
    2111  |  .  1 .
    221   |  1  . .
    311   |  1  . 1
    32    |  .  . 1
    41    |  .  1 .
    5     |  .  . 1</pre>
<P>
Lusztig induction from a diagonal Levi:
<P>
<pre>    gap> HF := CoxeterSubCoset( WF, [1, 2],
    >                LongestCoxeterElement( CoxeterGroup( WF ) ) );;
    gap> Display( InductionTable( HF, WF ) );
    Induction from 2A2.(q+1)^2 to 2A4
          |111 21  3
    _________________
    11111 | -1  .  .
    2111  | -2 -1  .
    221   | -1 -2  .
    311   |  1  2 -1
    32    |  . -2  1
    41    |  .  1 -2
    5     |  .  .  1</pre>
<P>
A descent of scalars:
<P>
<pre>    gap> W := CoxeterCoset( CoxeterGroup( "A", 2, "A", 2 ), (1,3)(2,4) );
    (A2xA2)
    gap> Display( InductionTable( CoxeterSubCoset( W, [ 1, 3 ] ), W ) );
    Induction from (A1xA1)&lt;1,3>.(q-1)(q+1) to (A2xA2)
        |11 2
    __________
    111 | 1 .
    21  | 1 1
    3   | . 1</pre>
<P>
<code>Print(  <var>WF</var> )</code>, <code>ReflectionName( <var>WF</var> )</code>  and <code>PrintDiagram( <var>WF</var> )</code> show
the   isomorphism  type  of  the  reductive  group  <I><strong>G</strong><sup>F</sup></I>.  An  orbit  of
<I>&phi;=</I><var>WF</var>.<code>phi</code>  on the  components is  put in  brackets if of length <I>k</I>
greater  than <I>1</I>, and is preceded by the  order of <I>&phi;<sup>k</sup></I> on it, if this
is  not <I>1</I>. For example <code>"2(A2xA2)"</code>  denotes 2 components of type <I>A<sub>2</sub></I>
permuted  by <I>&phi;</I>, and such that <I>&phi;<sup>2</sup></I> induces the non-trivial diagram
automorphism  on any of them,  while <code>3D4</code> denotes an  orbit of length 1 on
which <I>&phi;</I> is of order 3.
<P>
<pre>    gap> W := CoxeterCoset( CoxeterGroup( "A", 2, "G", 2, "A", 2 ),
    >                                                       (1,5,2,6) );
    2(A2xA2)&lt;1,2,5,6>xG2&lt;3,4>
    gap> ReflectionName( W );
    "2(A2xA2)&lt;1,2,5,6>xG2&lt;3,4>"
    gap> W := CoxeterCoset( CoxeterGroup( "A", 2, "A", 2 ), (1,3,2,4) );
    2(A2xA2)
    gap> PrintDiagram( W );
    phi permutes the next 2 components
    phi^2 acts as (1,2) on the component below
    A2 1 - 2
    A2 3 - 4</pre>
<P>
<code>ChevieClassInfo(   <var>WF</var>   )</code>,   see   the   explicit   description   in
<a href="chap096.htm#SECT005">ChevieClassInfo for Coxeter cosets</a>.
<P>
<A name = "I2"></a>

<code>ChevieCharInfo</code>   returns  additional   information  on   the  irreducible
characters, see <a href="chap095.htm#SECT006">ChevieCharInfo for reflection cosets</a>.
<P>
Finally,  some functions for elements of a Coxeter group work naturally for
elements  of a Coxeter  coset: <code>CoxeterWord</code>, <code>EltWord</code>, <code>CoxeterLength</code>,
<code>LeftDescentSet</code>,   <code>RightDescentSet</code>,  <code>ReducedInRightCoset</code>,  etc<I>...</I>
These  functions take the same value on  <I>w&phi;&isin; W&phi;</I> that they take on
<I>w&isin; W</I>.
<P><A NAME="SECT004"><h2>96.4 ReflectionType for Coxeter cosets</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>ReflectionType( <var>WF</var> )</code>
<P>
returns the type of the  Coxeter coset <var>WF</var>.   This consists of a list of
records, one for  each orbit of <code><var>WF</var>.phi</code>  on the irreducible components
of the Dynkin diagram of <code>CoxeterGroup(<var>WF</var>)</code>, which have two fields:<BR> 
<P>
<DL><DT><code>orbit</code>:<DD><BR> is a list of types of the irreducible components in the orbit.
   These  types are the  same as returned  by the function <code>ReflectionType</code>
   for  an  irreducible  untwisted  Coxeter  group (see <code>ReflectionType</code> in
   chapter   <a href="chap085.htm">Root  systems   and  finite   Coxeter  groups</a>):  a  couple
   <code>[<var>type</var>,<var>indices</var>]</code>  (a triple  for type  <I>I<sub>2</sub>(n)</I>). The components are
   ordered  according to the  action of <code><var>WF</var>.phi</code>,  so <code><var>WF</var>.phi</code> maps the
   generating permutations with indices in the first type to indices in the
   second  type in  the same  order as  stored in  the type, etc <I>...</I><BR> 
   <code>phi</code>:<BR>  if <I>k</I> is  the number of  irreducible components in the orbit,
   this  is the permutation which describes the action of <code><var>WF</var>.phi</code><I><sup>k</sup></I> on
   the simple roots of the first irreducible component in the orbit.
</DL><P>
<pre>    gap> W := CoxeterCoset( CoxeterGroup( "A", 2, "A", 2 ), (1,3,2,4) );
    2(A2xA2)
    gap> ReflectionType( W );
    [ rec(orbit := [ rec(rank    := 2,
          series  := "A",
          indices := [ 1, 2 ]), rec(rank    := 2,
          series  := "A",
          indices := [ 3, 4 ]) ],
          twist := (1,2)) ]</pre>
<P><A NAME="SECT005"><h2>96.5 ChevieClassInfo for Coxeter cosets</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>ChevieClassInfo( <var>WF</var> )</code>
<P>
returns  information  about the conjugacy  classes   of the Coxeter coset
<var>WF</var>.   The result is a   record   with three components:   <code>classtext</code>
contains   a list     of  reduced words    for the   representatives   in
<code>ConjugacyClasses(<var>WF</var>)</code>,  <code>classnames</code> contains corresponding names  for
the  classes, and <code>classparams</code>  gives  corresponding parameters  for the
classes.  Let <var>W</var> be the Coxeter group <code>CoxeterGroup(<var>WF</var>)</code>.  In the case
where <I>-1&notin; W</I>, i.e., <I>&phi;=-w<sub>0</sub></I>,  they are obtained by  multiplying
by <I>w<sub>0</sub></I> a set of representatives of <I>  maximal</I> length of the classes
of <I>W</I>.
<P>
<pre>    gap> W := CoxeterGroup( "D", 4 );;
    gap> ChevieClassInfo( CoxeterCoset( W, (1,2,4) ) );
    rec(
      classtext := [ [ 1 ], [  ], [ 1, 2, 3, 1, 2, 3 ], [ 3 ], [ 1, 3 ],
          [ 1, 2, 3, 1, 2, 4, 3, 2 ], [ 1, 2, 3, 2 ] ],
      classnames := [ "C_3", "\\tilde A_2", "C_3+A_1", "\\tilde A_2+A_1",
          "F_4", "\\tilde A_2+A_2", "F_4(a_1)" ],
      classparams :=
       [ [ "C_3" ], [ "\\tilde A_2" ], [ "C_3+A_1" ], [ "\\tilde A_2+A_1"
             ], [ "F_4" ], [ "\\tilde A_2+A_2" ], [ "F_4(a_1)" ] ] )</pre>
<P><A NAME="SECT006"><h2>96.6 CharTable for Coxeter cosets</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>CharTable(  <var>WF</var> )</code>
<P>
This  function returns the  character table of  the Coxeter coset <var>WF</var> (see
also  the introduction  of this  Chapter). We  call ``characters'' of the
Coxeter  coset <I>WF</I> with corresponding Coxeter group <I>W</I> the restriction to
<I>W  &phi;</I>  of  a  set  containing  one  extension  of each <I>&phi;</I>-invariant
character  of <I>W</I> to  the semidirect product  of <I>W</I> with  the cyclic group
generated  by  <I>&phi;</I>.  (We  choose,  following  Lusztig,  in each case one
non-canonical extension, called the preferred extension.)
<P>
The returned record contains almost all components present in the character
table  of a Coxeter group.  But if <I>&phi;</I> is  not trivial then there are no
components <code>powermap</code> (since powers of elements in the coset need not be in
the  coset)  and  <code>orders</code>  (if  you  really  need  them, use <code>MatXPerm</code> to
determine the order of elements in the coset).
<P>
<pre>    gap> W := CoxeterCoset( CoxeterGroup( "D", 4 ), (1,2,4) );
    3D4
    gap> Display( CharTable( W ) );
    3D4

           2  2   2     2      2  2      3      3
           3  1   1     1      .  .      1      1

             C3 ~A2 C3+A1 ~A2+A1 F4 ~A2+A2 F4(a1)

    .4        1   1     1      1  1      1      1
    .1111    -1   1     1     -1  1      1      1
    .22       .   2     2      . -1     -1     -1
    11.2      .   .     .      . -1      3      3
    1.3       1   1    -1     -1  .     -2      2
    1.111    -1   1    -1      1  .     -2      2
    1.21      .   2    -2      .  .      2     -2
    </pre>
<P><A NAME="SECT007"><h2>96.7 Frobenius</h2></a>
<P><P>
<A name = "I6"></a>

<P>
<code>Frobenius( <var>WF</var> )( <var>o</var> [, <var>i</var>])</code>
<P>
Given  a  Coxeter  coset  <var>WF</var>,  <code>Frobenius(<var>WF</var>)</code> returns a function which
makes  <code><var>WF</var>.phi</code> act on its  argument which is some  object for which this
action  has  been  defined.  If  <var>o</var>  is  a  list,  it  applies recursively
<code>Frobenius</code>  to each  element of  the list.  If it  is a  permutation or an
integer,  it  returns  <code><var>o</var>^(<var>WF</var>.phi^-1)</code>.  If  a second argument <var>i</var> is
given,  it  applies  <code>Frobenius</code>  raised  to  the  <var>i</var>-th  power  (this  is
convenient  for instance to apply the inverse of <code>Frobenius</code>). Finally, for
an   arbitrary  object  defined  by  a  record,  it  looks  if  the  method
<code><var>o</var>.operations.Frobenius</code>  is defined and  if so calls  this function with
arguments <var>WF</var>, <var>o</var> and <var>i</var> (with <code>i=1</code> if it was omitted).
<P>
Such  an action of the Frobenius is  defined for instance for braids, Hecke
elements and semisimple elements.
<P>
<pre>    gap> W:=CoxeterGroup("E",6);;WF:=CoxeterCoset(W,(1,6)(3,5));
    2E6
    gap> T:=Basis(Hecke(Group(WF)),"T");;Frobenius(WF)(T(1));
    T(6)
    gap> B:=Braid(W);; Frobenius(WF)(B(1,2,3));
    265
    gap> s:=SemisimpleElement(W,[1..6]/6);
    &lt;1/6,1/3,1/2,2/3,5/6,0>
    gap> Frobenius(WF)(s);
    &lt;0,1/3,5/6,2/3,1/2,1/6>
    gap> W:=CoxeterGroup("D",4);WF:=CoxeterCoset(W,(1,2,4));
    CoxeterGroup("D",4)
    3D4
    gap> B:=Braid(W);;b:=B(1,3);
    13
    gap> Frobenius(WF)(b);
    43
    gap> Frobenius(WF)(b,-1);
    23</pre>
<P><A NAME="SECT008"><h2>96.8 Twistings for Coxeter cosets</h2></a>
<P><P>
<A name = "I7"></a>

<P>
<code>Twistings( <var>W</var> )</code>
<P>
<var>W</var>  should be  a Coxeter  group record  which is  not a  proper reflection
subgroup   of   another   reflection   group.   The  function  returns  all
<code>CoxeterCosets</code> which have as group <var>W</var>.
<P>
<pre>    gap> Twistings(CoxeterGroup("A",3,"A",3));
    [ A3xA3, A3x2A3, 2A3xA3, 2A3x2A3, (A3xA3), 2(A3xA3),
      2(A3xA3)&lt;1,2,3,6,5,4>, (A3xA3)&lt;1,2,3,6,5,4> ]
    gap> Twistings(CoxeterGroup("D",4));
    [ D4, 2D4&lt;2,4,3,1>, 2D4, 3D4, 3'D4&lt;1,4,3,2>, 2D4&lt;1,4,3,2> ]</pre>
<P>
<code>Twistings( <var>W</var>, <var>L</var> )</code>
<P>
<var>W</var>  should be a  Coxeter group record  or a Coxeter  coset record, and <var>L</var>
should be a reflection subgroup of <var>W</var> (or of <code>Group(<var>W</var>)</code> for a coset), or
a sublist of the generating reflections of <var>W</var> (resp. <code>Group(W)</code>), in which
case  the call is  the same as <code>Twistings(<var>W</var>,ReflectionSubgroup(<var>W</var>,<var>L</var>))</code>
(resp.  <code>Twistings(<var>W</var>,ReflectionSubgroup(Group(<var>W</var>),<var>L</var>))</code>).
<P>
The  function returns the list, up  to <var>W</var>-conjugacy, of Coxeter sub-cosets
of  <var>W</var> whose  Coxeter group  is <var>L</var>  --- In  term of  algebraic groups, it
corresponds  to  representatives  of  the  possible  twisted  forms  of the
reductive  subgroup of maximal rank <var>L</var>. In  the case that <I>W</I> represents a
coset  <I>W&phi;</I>,  the  subgroup  <I>L</I>  must  be  conjugate to <I>&phi;(L)</I> for a
rational  form to exist. If <I>w&phi;</I> normalizes <I>L</I>, then the rational forms
are classified by the the <I>&phi;</I>-classes of <I>N<sub>W</sub>(L)/L</I>.
<P>
<pre>    gap> W:=CoxeterGroup("E",6);
    CoxeterGroup("E",6)
    gap> WF:=CoxeterCoset(W,(1,6)(3,5));
    2E6
    gap> L:=ReflectionSubgroup(W,[2..5]);
    ReflectionSubgroup(CoxeterGroup("E",6), [ 2, 3, 4, 5 ])
    gap> Twistings(W,L);
    [ D4&lt;2,3,4,5>.(q-1)^2, 3D4&lt;2,3,4,5>.(q^2+q+1),
      2D4&lt;2,3,4,5>.(q-1)(q+1) ]
    gap> Twistings(WF,L);
    [ 2D4&lt;2,5,4,3>.(q-1)(q+1), 3'D4&lt;2,5,4,3>.(q^2-q+1),
      D4&lt;2,3,4,5>.(q+1)^2 ]</pre>
<P><A NAME="SECT009"><h2>96.9 RootDatum for Coxeter cosets</h2></a>
<P><P>
<A name = "I8"></a>

<P>
<code>RootDatum(<var>type</var>[,<var>rank</var>])</code>
<P>
The function <code>RootDatum</code> can be used to get Coxeter cosets corresponding to
known  types of  algebraic groups.  The twisted  types known are <code>"2B2"</code>,
<code>"suzuki"</code>,  <code>"2E6"</code>,  <code>"2E6sc"</code>,  <code>"2F4"</code>,  <code>"2G2"</code>,  <code>"ree"</code>,
<code>"2I"</code>,  <code>"3D4"</code>,  <code>"triality"</code>,  <code>"3D4sc"</code>, <code>"pso-"</code>, <code>"so-"</code>,
<code>"spin-"</code>, <code>"psu"</code>, <code>"su"</code>, <code>"u"</code>.
<P>
<pre>    gap> RootDatum("su",4);
    2A3</pre>
<P>
The above call is same as <code>CoxeterCoset(CoxeterGroup("A",3,"sc"),(1,3))</code>.
<P><A NAME="SECT010"><h2>96.10 Torus for Coxeter cosets</h2></a>
<P><P>
<A name = "I9"></a>

<P>
<code>Torus(<var>M</var>)</code>
<P>
<var>M</var> should be an integral matrix of finite order. <code>Torus</code> returns the coset
<code>WF</code>   of  the  trivial  Coxeter   group  such  that  <code>WF.F0Mat=</code><var>M</var>.  This
corresponds  to  an  algebraic  torus  <I><strong>T</strong></I>  of  rank <code>Length(M)</code>, with an
isogeny which acts by <var>M</var> on <I>X(<strong>T</strong>)</I>.
<P>
<pre>    gap> m:=[[0,-1],[1,-1]];
    [ [ 0, -1 ], [ 1, -1 ] ]
    gap> Torus(m);
    (q^2+q+1)</pre>
<P>
<code>Torus(<var>W</var>,i)</code>
<P>
This  returns the Torus twisted  by the <var>i</var>-th conjugacy  class of <var>W</var>. For
Coxeter groups or cosets it is the same as <code>Twistings(W,[])[i]</code>.
<P>
<pre>    gap> W:=CoxeterGroup("A",3);
    CoxeterGroup("A",3)
    gap> Twistings(W,[]);
    [ (q-1)^3, (q-1)^2(q+1), (q-1)(q+1)^2, (q-1)(q^2+q+1), (q+1)(q^2+1) ]
    gap> Torus(W,2);
    (q-1)^2(q+1)
    gap> W:=CoxeterCoset(CoxeterGroup("A",3),(1,3));
    2A3
    gap> Twistings(W,[]);
    [ (q+1)^3, (q-1)(q+1)^2, (q-1)^2(q+1), (q+1)(q^2-q+1), (q-1)(q^2+1) ]
    gap> Torus(W,2);
    (q-1)(q+1)^2</pre>
<P><A NAME="SECT011"><h2>96.11 StructureRationalPointsConnectedCentre</h2></a>
<P><P>
<A name = "I10"></a>

<P>
<code>StructureRationalPointsConnectedCentre(<var>G</var>,q)</code>
<P>
<var>W</var>   should  be  a  Coxeter  group  record  or  a  Coxeter  coset  record,
representing  a finite reductive group <I><strong>G</strong><sup>F</sup></I>, and <var>q</var> should be the prime
power  associated  to  the  isogeny  <var>F</var>.  The function returns the abelian
invariants  of the finite  abelian group <I>  Z<sup>0</sup><strong>G</strong><sup>F</sup></I> where <I>Z<sup>0</sup><strong>G</strong></I> is the
connected center of <I><strong>G</strong></I>.
<P>
In  the  following  example  one  determines the structure of <I><strong>T</strong>(\mathbb
F<sub>3</sub>)</I> where <I><strong>T</strong></I> runs over all the maximal tori of SL<I><sub>4</sub></I>.
<P>
<pre>    gap> G:=RootDatum("sl",4);
    RootDatum("sl",4)
    gap> List(Twistings(G,[]),T->StructureRationalPointsConnectedCentre(T,3));
    [ [ 2, 2, 2 ], [ 2, 8 ], [ 4, 8 ], [ 26 ], [ 40 ] ]</pre>
<P><A NAME="SECT012"><h2>96.12 ClassTypes</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>ClassTypes(<var>G</var> [,<var>p</var>])</code>
<P>
<var>G</var>  should be a root  datum or a twisted  root datum representing a finite
reductive group <I><strong>G</strong><sup>F</sup></I> and <var>p</var> should be a prime. The function returns the
class  types of <var>G</var>. Two elements of <I><strong>G</strong><sup>F</sup></I> have the same <em> class type</em>
if their centralizers are conjugate. If <I>su</I> is the Jordan decomposition of
an  element <I>x</I>, the class  type of <I>x</I> is  determined by the class type of
its semisimple part <I>s</I> and the unipotent class of <I>u</I> in <I>C<sub><strong>G</strong></sub>(s)</I>.
<P>
The   function  <code>ClassTypes</code>  is  presently  only  implemented  for  simply
connected  groups, where  <I>C<sub><strong>G</strong></sub>(s)</I> is  connected. This  section is  a bit
experimental and may change in the future.
<P>
<code>ClassTypes</code>  returns  a  record  which  contains  a list of classtypes for
semisimple  elements,  which  are  represented  by  <code>CoxeterSubCoset</code>s  and
contain additionnaly information on the unipotent classes of <I>C<sub><strong>G</strong></sub>(s)</I>.
<P>
The list of class types is different in bad characteristic, so the argument
<var>p</var>  should give a characteristic.  If <var>p</var> is omitted  or equal to 0, then
good characteristic is assumed.
<P>
<DL><DT>Let us give some examples:<DD>
</DL><P>
<pre>    gap> t:=ClassTypes(RootDatum("sl",3));
    ClassTypes(CoxeterCoset(RootDatum("sl",3)),good characteristic)
    gap> Display(t);
    ClassTypes(CoxeterCoset(RootDatum("sl",3)),good characteristic)
          Type |Centralizer
    ________________________
    (q-1)^2    |       P1^2
    (q-1)(q+1) |       P1P2
    (q^2+q+1)  |         P3
    A1.(q-1)   |    qP1^2P2
    A2         |q^3P1^2P2P3</pre>
<P>
By   default,  only  information  about  semisimple  centralizer  types  is
returned: the type, and its generic order.
<P>
<pre>    gap> Display(t,rec(unip:=true));
    ClassTypes(CoxeterCoset(RootDatum("sl",3)),good characteristic)
          Type |     u Centralizer
    _______________________________
    (q-1)^2    |              P1^2
    (q-1)(q+1) |              P1P2
    (q^2+q+1)  |                P3
    A1.(q-1)   |    11     qP1^2P2
               |     2         qP1
    A2         |   111 q^3P1^2P2P3
               |    21       q^3P1
               |     3        3q^2
               |  3_E3        3q^2
               |3_E3^2        3q^2</pre>
<P>
Here  we  have  displayed  information  on  unipotent  classes,  with their
centralizer.
<P>
<pre>    gap> Display(t,rec(nrClasses:=true));
    ClassTypes(CoxeterCoset(RootDatum("sl",3)),good characteristic)
          Type |        nrClasses Centralizer
    __________________________________________
    (q-1)^2    |(4-5q+2q_3+q^2)/6        P1^2
    (q-1)(q+1) |       (-q+q^2)/2        P1P2
    (q^2+q+1)  |  (1+q-q_3+q^2)/3          P3
    A1.(q-1)   |         -1+q-q_3     qP1^2P2
    A2         |              q_3 q^3P1^2P2P3</pre>
<P>
Here  we have added information on how many semisimple conjugacy classes of
<I><strong>G</strong><sup>F</sup></I>  have a given type. The answer in general involves variables of the
form <code>q_d</code> which represent <I></I>gcd<I>(q-1,d)</I>.
<P>
<DL><DT>Finally an example in bad characteristic:<DD>
</DL><P>
<pre>    gap> t:=ClassTypes(CoxeterGroup("G",2),2);
    ClassTypes(CoxeterCoset(CoxeterGroup("G",2)),char. 2)
    gap> Display(t,rec(nrClasses:=true));
    ClassTypes(CoxeterCoset(CoxeterGroup("G",2)),char. 2)
            Type |          nrClasses     Centralizer
    __________________________________________________
    (q-1)^2      |(10-8q+2q_3+q^2)/12            P1^2
    (q-1)(q+1)   |        (-2q+q^2)/4            P1P2
    (q-1)(q+1)   |        (-2q+q^2)/4            P1P2
    (q^2-q+1)    |    (1-q-q_3+q^2)/6              P6
    (q^2+q+1)    |    (1+q-q_3+q^2)/6              P3
    (q+1)^2      |(-2-4q+2q_3+q^2)/12            P2^2
    A1.(q-1)     |       (-1+q-q_3)/2         qP1^2P2
    A1.(q+1)     |        (1+q-q_3)/2         qP1P2^2
    G2           |                  1 q^6P1^2P2^2P3P6
    A2&lt;1,5>      |         (-1+q_3)/2     q^3P1^2P2P3
    2A2&lt;1,5>     |         (-1+q_3)/2     q^3P1P2^2P6
    ~A1&lt;2>.(q-1) |           (-2+q)/2         qP1^2P2
    ~A1&lt;2>.(q+1) |                q/2         qP1P2^2</pre>
<P>
We  notice that if <I>q</I> is  a power of <I>2</I> such  that <I>q&equiv; 2(</i>mod<i> 3)</I>, so
that  <code>q_3=1</code>, some class  types do not  exist. We can  see what happens by
using the function <code>Value</code> to give a specific value to <code>q_3</code>:
<P>
<pre>    gap> Display(Value(t,["q_3",1]),rec(nrClasses:=true));
    ClassTypes(CoxeterCoset(CoxeterGroup("G",2)),char. 2) q_3=1
            Type |     nrClasses     Centralizer
    _____________________________________________
    (q-1)^2      |(12-8q+q^2)/12            P1^2
    (q-1)(q+1)   |   (-2q+q^2)/4            P1P2
    (q-1)(q+1)   |   (-2q+q^2)/4            P1P2
    (q^2-q+1)    |    (-q+q^2)/6              P6
    (q^2+q+1)    |     (q+q^2)/6              P3
    (q+1)^2      |  (-4q+q^2)/12            P2^2
    A1.(q-1)     |      (-2+q)/2         qP1^2P2
    A1.(q+1)     |           q/2         qP1P2^2
    G2           |             1 q^6P1^2P2^2P3P6
    ~A1&lt;2>.(q-1) |      (-2+q)/2         qP1^2P2
    ~A1&lt;2>.(q+1) |           q/2         qP1P2^2</pre>
<P><A NAME="SECT013"><h2>96.13 Quasi-Semisimple elements of non-connected reductive groups</h2></a>
<P><P><P>
We  may  also  use  Coxeter  cosets  to represented non-connected reductive
groups  of the form <I><strong>G</strong>&#8906;&sigma;</I> where <I><strong>G</strong></I> is a connected reductive
group   and  <I>&sigma;</I>  an   algebraic  automorphism  of   <I><strong>G</strong></I>,  and  more
specifically the coset <I><strong>G</strong>.&sigma;</I>. We may always choose
<I>&sigma;&isin;<strong>G</strong>.&sigma;</I>  <strong>quasi-semisimple</strong>,  which  means  that <I>&sigma;</I>
preserves a pair <I><strong>T</strong>&sub;<strong>B</strong></I> of a maximal torus and a Borel subgroup of
<I><strong>G</strong></I>.  If <I>&sigma;</I>  is of  finite order,  it then  defines an automorphism
<I>F<sub>0</sub></I> of the root datum <I>(X(<strong>T</strong>), &Phi;, Y(<strong>T</strong>), &Phi;<sup>&or;</sup>)</I>, thus a Coxeter
coset. We refer to <A href="biblio.htm#ss"><cite>ss</cite></a> for details.
<P>
We  have  extended  the  functions  for  semi-simple  elements to work with
quasi-semisimple   elements   <I>t&sigma;&isin;<strong>T</strong>.&sigma;</I>.   Here,   as   in
<A href="biblio.htm#ss"><cite>ss</cite></a>,  <I>&sigma;</I> is a quasi-central  automorphism uniquely defined by a
diagram  automorphism  of  <I>(W,S)</I>,  taking  <I>&sigma;</I>  symplectic  in  type
<I>A<sub>2n</sub></I>.  We  recall  that  a  quasi-central element is a quasi-semisimple
element such that the Weyl group of <I>C<sub><strong>G</strong></sub>(&sigma;)</I> is equal to <I>W<sup>&sigma;</sup></I>;
such an element always exists in the coset <I><strong>G</strong>.&sigma;</I>.
<P>
Here are some examples:
<P>
<pre>    gap> WF:=RootDatum("u",6);
    2A5.(q+1)</pre>
<P>
The above defines the coset <I></I>GL<I><sub>6</sub>.&sigma;</I> where <I>&sigma;</I> is the composed
of transpose, inverse and the longest element of <I>W</I>.
<P>
<pre>    gap> l:=QuasiIsolatedRepresentatives(WF);
    [ &lt;0,0,0,0,0,0>, &lt;1/4,0,0,0,0,3/4>, &lt;1/4,1/4,0,0,3/4,3/4>,
      &lt;1/4,1/4,1/4,3/4,3/4,3/4> ]</pre>
<P>
we define an element <I>t&sigma;&isin;<strong>T</strong>.&sigma;</I> to be quasi-isolated if the
Weyl  group of <I>C<sub><strong>G</strong></sub>(t&sigma;)</I> is not  in any proper parabolic subgroup of
<I>W<sup>&sigma;</sup></I>. This generalizes the definition for connected groups. The above
shows  the  elements  <I>t</I>  where  <I>t&sigma;</I>  runs  over  representatives of
quasi-isolated  quasi-semisimple  classes  of  <I><strong>G</strong>.&sigma;</I>.  The given
representatives have been chosen <I>&sigma;</I>-stable.
<P>
<pre>    gap> List(l,s->Centralizer(WF,s));
    [ C3&lt;3,2,1>, B2.(q+1), (A1xA1)&lt;1,3>xA1&lt;2>, 2A3&lt;3,1,2> ]</pre>
<P>
in  the above,  the groups  <I>C<sub><strong>G</strong></sub>(t&sigma;)</I> are  computed and displayed as
extended  Coxeter groups (following the same convention as for centralisers
in connected reductive groups).
<P>
We  define an element <I>t&sigma;&isin;<strong>T</strong>.&sigma;</I> to be isolated if the Weyl
group  of <I>C<sub><strong>G</strong></sub>(t&sigma;)<sup>0</sup></I>  is not  in any  proper parabolic  subgroup of
<I>W<sup>&sigma;</sup></I>. This generalizes the definition for connected groups.
<P>
<pre>    gap> List(l,s->IsIsolated(WF,s));
    [ true, false, true, true ]</pre>
<P><A NAME="SECT014"><h2>96.14 Centralizer for quasisemisimple elements</h2></a>
<P><P><P>
<code>Centralizer(<var>WF</var>, <var>t</var>)</code>
<P>
<var>WF</var>   should  be   a  Coxeter   coset  representing   an  algebraic  coset
<I><strong>G</strong>.&sigma;</I>,  where <I><strong>G</strong></I> is a  connected reductive group (represented
by  <code>W:=Group(WF)</code>), and <I>&sigma;</I> is a quasi-central automorphism of <I><strong>G</strong></I>
defined  by <var>WF</var>. The element <var>t</var> should  be a semisimple element of <I><strong>G</strong></I>.
The    function   returns   an   extended   reflection   group   describing
<I>C<sub><strong>G</strong></sub>(t&sigma;)</I>,    with   the   reflection    group   part   representing
<I>C<sub><strong>G</strong></sub><sup>0</sup>(t&sigma;)</I>,  and the diagram automorphism  part being those induced
by <I>C<sub><strong>G</strong></sub>(t&sigma;)/C<sub><strong>G</strong></sub>(t&sigma;)<sup>0</sup></I> on <I>C<sub><strong>G</strong></sub>(t&sigma;)<sup>0</sup></I>.
<P>
<pre>    gap> WF:=RootDatum("u",6);
    2A5.(q+1)
    gap> s:=SemisimpleElement(Group(WF),[1/4,0,0,0,0,3/4]);
    &lt;1/4,0,0,0,0,3/4>
    gap> Centralizer(WF,s);
    B2.(q+1)
    gap> Centralizer(WF,s^0);
    C3&lt;3,2,1></pre>
<A NAME="SECT015"><h2>96.15 QuasiIsolatedRepresentatives for Coxeter cosets</h2></a>
<P><P><P>
<code>QuasiIsolatedRepresentatives(<var>WF</var>[, <var>p</var>])</code>
<P>
<var>WF</var>   should  be   a  Coxeter   coset  representing   an  algebraic  coset
<I><strong>G</strong>.&sigma;</I>,  where <I><strong>G</strong></I> is a  connected reductive group (represented
by  <code>W:=Group(WF)</code>), and <I>&sigma;</I> is  a quasi-central automorphism of <I><strong>G</strong></I>
defined  by <var>WF</var>.  The function  returns a  list of  semisimple elements of
<I><strong>G</strong></I>   such  that   <I>t&sigma;</I>,  when   <I>t</I>  runs   over  this   list,  are
representatives  of the conjugacy classes of quasi-isolated quasisemisimple
elements  of  <I><strong>G</strong>.&sigma;</I>  (an  element  <I>t&sigma;&isin;<strong>T</strong>.&sigma;</I> is
quasi-isolated  if the Weyl group of  <I>C<sub><strong>G</strong></sub>(t&sigma;)</I> is not in any proper
parabolic  subgroup of <I>W<sup>&sigma;</sup></I>).  If a second  argument <var>p</var> is given, it
lists only those representatives which exist in characteristic <var>p</var>.
<P>
<pre>    gap> QuasiIsolatedRepresentatives(RootDatum("2E6sc"));
    [ &lt;0,0,0,0,0,0>, &lt;0,0,0,1/2,0,0>, &lt;0,1/2,1/4,0,1/4,0>,
      &lt;0,2/3,0,1/3,0,0>, &lt;0,3/4,0,1/2,0,0> ]
    gap> QuasiIsolatedRepresentatives(RootDatum("2E6sc"),2);
    [ &lt;0,0,0,0,0,0>, &lt;0,2/3,0,1/3,0,0> ]
    gap> QuasiIsolatedRepresentatives(RootDatum("2E6sc"),3);
    [ &lt;0,0,0,0,0,0>, &lt;0,0,0,1/2,0,0>, &lt;0,1/2,1/4,0,1/4,0>,
      &lt;0,3/4,0,1/2,0,0> ]</pre>
<A NAME="SECT016"><h2>96.16 IsIsolated for Coxeter cosets</h2></a>
<P><P><P>
<code>IsIsolated(<var>WF</var>, <var>t</var>)</code>
<P>
<var>WF</var>   should  be   a  Coxeter   coset  representing   an  algebraic  coset
<I><strong>G</strong>.&sigma;</I>,  where <I><strong>G</strong></I> is a  connected reductive group (represented
by  <code>W:=Group(WF)</code>), and <I>&sigma;</I> is  a quasi-central automorphism of <I><strong>G</strong></I>
defined  by <var>WF</var>. The element <var>t</var> should  be a semisimple element of <I><strong>G</strong></I>.
The  function returns a  boolean describing whether  <I>t&sigma;</I> is isolated,
that  is whether the Weyl group of  <I>C<sub><strong>G</strong></sub>(t&sigma;)<sup>0</sup></I> is not in any proper
parabolic subgroup of <I>W<sup>&sigma;</sup></I>.
<P>
<pre>    gap> WF:=RootDatum("u",6);
    2A5.(q+1)
    gap> l:=QuasiIsolatedRepresentatives(WF);
    [ &lt;0,0,0,0,0,0>, &lt;1/4,0,0,0,0,3/4>, &lt;1/4,1/4,0,0,3/4,3/4>,
      &lt;1/4,1/4,1/4,3/4,3/4,3/4> ]
    gap> List(l,s->IsIsolated(WF,s));
    [ true, false, true, true ]</pre>
<P><a href ="chap095.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap097.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>