<html><head><title>GAP3 Manual: 84 Finite Reflection Groups</title></head>
<body bgcolor="ffffff">
<h1>84 Finite Reflection Groups</h1>
<P><P><P>
Let  <var>W</var>  be  a  finite  reflection  group  on  the vector space <var>V</var> over a
subfield  <I>k</I> of the  complex numbers. An  efficient representation that we
use  in  <strong>CHEVIE</strong>  for  computing  with  such  group  is, is a permutation
representation  on  a  <var>W</var>-invariant  set  of  root  and coroot vectors for
reflections  of <var>W</var>;  that is,  a set  <I>R</I> of  pairs <I>(r,r<sup>&or;</sup>)&isin; V&times;
V<sup>*</sup> </I>  invariant by  <I>W</I> and  such each  distinguished reflection in <I>W</I> is
defined  by some pair in <I>R</I> (see <a href="chap082.htm#SECT001">Reflection</a>). There may be several pairs
for  each reflection,  differing by  roots of  unity. This  generalizes the
usual  construction  for  Coxeter  groups  (the  case <I>k=&#x211D;</I>) where to each
reflection  of <var>W</var> is associated two roots,  a positive and a negative one.
For  complex reflection groups, we  need at least as  many roots on a given
line  as the order of the center of  <var>W</var>. 
<P>
The  finite  irreducible  complex  reflection  groups  have been completely
classified  by Shepard and Todd. They contain one infinite family depending
on  3 parameters, and 34 ``exceptional''  groups which have been given by
Shephard  and Todd names which range from <I>G<sub>4</sub></I> to <I>G<sub>37</sub></I>. They cover the
exceptional  Coxeter groups,  e.g., <code>CoxeterGroup("E",8)</code>  is the same as
<I>G<sub>37</sub></I>.
<P>
<strong>CHEVIE</strong>  provides functions to build  any finite reflection group, either
by  giving a list of roots and corrots defining the generating reflections,
or in terms of the classification. The output is a permutation group on set
of roots (see <code>ComplexReflectionGroup</code> and <code>PermRootGroup</code>). In the context
e.g.  of  Weyl  groups,  one  wants  to describe the particular root system
chosen  in term of the  traditional classification of crystallographic root
systems.  This is  done via  calls to  the function <code>CoxeterGroup</code> (see the
chapter on finite Coxeter groups). There is not yet a general theory on how
to construct a nice set of roots for a non-real reflection group; the roots
chosen  in  <strong>CHEVIE</strong>  where  obtained  case-by-case; however, they satisfy
several important properties:
<P>

<P>&bull;  The generating reflections satisfy braid relations which present the
braid group associated to <I>W</I> (see <a href="chap084.htm#SECT017">PrintDiagram</a>).
<P>&bull;
The  <strong>field of definition</strong> of <I>W</I> is  the field <I>k</I> generated by the traces
of  the elements  of <I>W</I>  acting on  <I>V</I>. It  is a  theorem that <I>W</I> may be
realized as a reflection group over <I>k</I>. For almost all irreducible complex
reflection  groups, the generating matrices for  <I>W</I> given by <strong>CHEVIE</strong> have
coefficients  in <I>k</I>. Further, the set of  matrices for all elements of <var>W</var>
is  globally invariant  under the  Galois group  of <I>k/&#x211A;</I>, thus the Galois
action  induces automorphisms of  <I>W</I>. The exceptions  are <I>G<sub>22</sub>, G<sub>27</sub></I>
where  the matrices are in a degree two extension of <I>k</I> (this is needed to
have  a  globally  invariant  model,  see  <A href="biblio.htm#MarinMichel10"><cite>MarinMichel10</cite></a>)  and  some
dihedral  groups as well as <I>H<sub>3</sub></I> and  <I>H<sub>4</sub></I>, where the matrices given (the
usual   Coxeter  reflection  representation  over  <I>k</I>)  are  not  globally
invariant. 
<P>
It turns out that all representations of a complex reflection group <I>W</I> are
defined over the field of definition of <I>W</I> (cf. <A href="biblio.htm#Ben76"><cite>Ben76</cite></a> and D. Bessis
thesis).  This has been known for a long  time in the case <I>k=&#x211A;</I>, the case
of Weyl groups: their representations are defined over the rationals.
<P>&bull;  The Cartan matrix (see <a href="chap082.htm#SECT003">CartanMat</a>)  for the generating roots (those
which  correspond to  the generating  reflections) has  entries in the ring
<I>&#x2124;<sub>k</sub></I>  of  integers  of  <I>k</I>,  and  the  roots  (resp. coroots) are linear
combination with coefficients in <I>&#x2124;<sub>k</sub></I> of a linearly independent subset of
them.

<P>
The  finite reflection  groups are  reflection groups  as described  in the
chapter  "Reflections, and reflection groups", so in addition to the fields
for  permutation  groups  they  have the fields <code>.nbGeneratingReflections</code>,
<code>.OrdersGeneratingReflections</code>  and  <code>.reflections</code>.  They  also  have  the
following additional fields:
<P>
<DL><DT><code>roots</code>:<DD><BR>  a  set  of  complex  roots  in  <I>V</I>,  given  as a list of lists
       (vectors), on which <I>W</I> has a faithful permutation representation.
</DL><P>
<DL><DT><code>simpleCoroots</code>:<DD><BR> the  coroots for the  first <code>.nbGeneratingReflections</code>
       roots.
</DL><P>
In  this  chapter  we  describe  functions  available for finite reflection
groups  <var>W</var>  represented  as  permutation  groups  on a set of roots. These
functions  make use of the classification of  <var>W</var> whenever it is known, but
work even if it is not known.
<P>
Let <I>SV</I> be the symmetric algebra of <I>V</I>. The invariants of <I>W</I> in <I>SV</I> are
called  the  <strong>polynomial  invariants</strong>  of  <I>W</I>.  They  are  generated  as a
polynomial   ring  by   <I></I>dim<I>  V</I>   homogeneous  algebraically  independent
polynomials <I>f<sub>1</sub>,...,f<sub></I>dim<I> V</sub></I>. The polynomials <I>f<sub>i</sub></I> are not uniquely
determined  but  their  degrees  are.  The  <I>f<sub>i</sub></I>  are  called  the  <strong>basic
invariants</strong>  of <I>W</I>, and their degrees the <strong>reflection degrees</strong> of <I>W</I>. Let
<I>I</I> be the ideal generated by the homogeneous invariants of positive degree
in  <I>SV</I>. Then <I>SV/I</I> is isomorphic to the regular representation of <I>W</I> as
a  <I>W</I>-module. It  is thus  a graded  (by the  degree of  elements of <I>SV</I>)
version  of the regular  representation of <I>W</I>.  The polynomial which gives
the  graded multiplicity of a character <I>&chi;</I>  of <I>W</I> in the graded module
<I>SV/I</I> is called the <strong>fake degree</strong> of <I>&chi;</I>.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap084.htm#SECT001">Functions for finite reflection groups</a>
<LI> <A HREF="chap084.htm#SECT002">PermRootGroup</a>
<LI> <A HREF="chap084.htm#SECT003">ReflectionType</a>
<LI> <A HREF="chap084.htm#SECT004">ReflectionName</a>
<LI> <A HREF="chap084.htm#SECT005">IsomorphismType</a>
<LI> <A HREF="chap084.htm#SECT006">ComplexReflectionGroup</a>
<LI> <A HREF="chap084.htm#SECT007">Reflections</a>
<LI> <A HREF="chap084.htm#SECT008">MatXPerm</a>
<LI> <A HREF="chap084.htm#SECT009">PermMatX</a>
<LI> <A HREF="chap084.htm#SECT010">MatYPerm</a>
<LI> <A HREF="chap084.htm#SECT011">InvariantForm for finite reflection groups</a>
<LI> <A HREF="chap084.htm#SECT012">ReflectionEigenvalues</a>
<LI> <A HREF="chap084.htm#SECT013">ReflectionLength</a>
<LI> <A HREF="chap084.htm#SECT014">ReflectionWord</a>
<LI> <A HREF="chap084.htm#SECT015">HyperplaneOrbits</a>
<LI> <A HREF="chap084.htm#SECT016">BraidRelations</a>
<LI> <A HREF="chap084.htm#SECT017">PrintDiagram</a>
<LI> <A HREF="chap084.htm#SECT018">ReflectionCharValue</a>
<LI> <A HREF="chap084.htm#SECT019">ReflectionCharacter</a>
<LI> <A HREF="chap084.htm#SECT020">ReflectionDegrees</a>
<LI> <A HREF="chap084.htm#SECT021">ReflectionCoDegrees</a>
<LI> <A HREF="chap084.htm#SECT022">GenericOrder</a>
<LI> <A HREF="chap084.htm#SECT023">TorusOrder</a>
<LI> <A HREF="chap084.htm#SECT024">ParabolicRepresentatives for reflection groups</a>
<LI> <A HREF="chap084.htm#SECT025">Invariants</a>
<LI> <A HREF="chap084.htm#SECT026">Discriminant</a>
<LI> <A HREF="chap084.htm#SECT027">Catalan</a>
</ol>
<A NAME="SECT001"><h2>84.1 Functions for finite reflection groups</h2></a>
<P><P><P>
They are permutation groups, so all functions for permutation groups apply,
although  some are  replaced by  faster methods  when available.  A typical
example  is the function <code>Size</code>, which is obtained simply by the product of
the  reflection  degrees,  when  they  are  known.  Appropriate methods for
<code>String</code> and <code>Print</code> are also defined.
<P>
<A name = "I0"></a>

<DL><DT><code>EltWord</code>:<DD><BR>  Works  like  for  Coxeter  groups;  in addition, as a special
convention,  if  all  <code>.reflectionsLabels</code>  of  <var>W</var>  are positive integers,
negative   integers  are  accepted   and  represent  the   inverse  of  the
corresponding generator.
</DL><P>
<DL><DT><code>*</code>:<DD><BR>  <code>A*B</code> returns the product of the two reflection groups <code>A</code> and <code>B</code>
 as a reflection group.
</DL><P><A NAME="SECT002"><h2>84.2 PermRootGroup</h2></a>
<P><P>
<A name = "I1"></a>

<A name = "I2"></a>

<P>
<code>PermRootGroupNC( <var>roots</var> [,<var>eigenvalues</var>])</code>
<code>PermRootGroup( <var>roots</var> [,<var>eigenvalues</var>])</code>
<P>
<code>PermRootGroupNC( <var>roots</var>, <var>coroots</var>)</code>
<code>PermRootGroup( <var>roots</var>, <var>coroots</var>)</code>
<P>
<var>roots</var>  is  a  list  of  roots,  that  is of vectors in some vector space.
<code>PermRootGroup</code>  returns the reflection group  generated by the reflections
with respect to these roots (if this group is not finite, the function will
never  return). The precise way the reflections are constructed as matrices
is  specified  by  the  second  argument.  In  the  second  form the <code>i</code>-th
reflection  is computed as <code>Reflection(roots[i], coroots[i])</code>. In the first
form <var>eigenvalues</var> represents non-trivial eigenvalues of the reflections to
construct,  represented as a list of fractions <code>n/d</code>, where such a fraction
represents   the  eigenvalue  <code>E(d)^n</code>  (the   reason  for  using  such  a
representation  instead of  <code>E(d)^n</code> is  that in  <strong>GAP3</strong> it  is trivial to
compute  <code>E(d)^n</code> given <var>d/n</var>, but the converse is hard). In this form the
<code>i</code>-th  reflection  is  computed  as  <code>Reflection(roots[i], E(d)^n)</code> where
<code>eigenvalues[i]=n/d</code>.  If in the first form <code>eigenvalues</code> are omitted, they
are  all assumed to  be <code>1/2</code> (which  represents the number  <code>-1</code>, i.e. all
reflections are true reflections).
<P>
In  the (faster) variant with  <code>NC</code>, the group is  not classified (thus for
instance <code>PrintDiagram</code> will not work).
<P>
<pre>    gap> W:=PermRootGroupNC(IdentityMat(3),CartanMat("A",3));
    PermRootGroup([ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
      [ [ 2, -1, 0 ], [ -1, 2, -1 ], [ 0, -1, 2 ] ])
    gap> PrintDiagram(W);
    Error, PermRootGroup([ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
      [ [ 2, -1, 0 ], [ -1, 2, -1 ], [ 0, -1, 2 ] ]) has no method 
    for PrintDiagram in
    Dispatcher( "PrintDiagram" )( W ) called from
    PrintDiagram( W ) called from
    main loop
    brk> 
    gap> ReflectionType(W);
    [ rec(rank    := 3,
          series  := "A",
          indices := [ 1, 2, 3 ]) ]
    gap> PrintDiagram(W);
    A3 1 - 2 - 3</pre>
<P>
In the above, the call  to <code>ReflectionType</code> makes <strong>CHEVIE</strong> identify the
classification  of <code>W</code>,  after which  functions like  <code>PrintDiagram</code> can
work. Below is another way to build a group of type <I>A<sub>3</sub></I>.
<P>
<pre>    gap> W:=PermRootGroup([[1,0,-1],[-1,1,0],[1,0,1]]);
    PermRootGroup([[1,0,-1],[-1,1,0],[1,0,1]])
    gap> ReflectionDegrees(W);
    [ 2, 3, 4 ]</pre>
<P><A NAME="SECT003"><h2>84.3 ReflectionType</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>ReflectionType( <var>W</var> )</code>
<P>
This function returns the type of <var>W</var>, which is a list each element of which
describes an irreducible  component of <var>W</var>; the  elements of the list  are
objects of type <code>Reflection Type</code>, on which some functions can be called
to obtain data on groups of that type, like <code>ReflectionDegrees</code>, etc...
<P>
Such  an  object  is  a  record  with  a field <code>series</code>, the type (<code>"A"</code>,
<code>"B"</code>,  <code>"D"</code>, etc<I>...</I>)  of the  component, a  field <code>indices</code>, the
indices in the list of generating reflections of <var>W</var> where it sits, a field
<code>rank</code>  (equal to  <code>Length(indices)</code> for  well-generated complex reflection
groups such as Coxeter groups, and to <code>Length(indices)+1</code> for the others).
<P>
For dihedral groups there is in addition a field <code>bond</code> giving the order of
the braid relation between the two generators.
<P>
For  complex reflection  groups which  are not  real, the field <code>series</code> is
equal  to <code>"ST"</code>, and there is an  additional field <code>ST</code>, equal either to
an  integer  <I>n</I>  (for  exceptional  reflection  groups <I>G<sub>n</sub></I>), or a triple
<I>(p,q,r)</I> of integers (for imprimitive reflection groups <I>G(p,q,r)</I>).
<P>
This  function  is  called  automatically  upon  construction  of  a finite
reflection group via <code>PermRootGroup</code>, or upon constructing a finite Coxeter
group  by  <code>CoxeterGroup</code>.  But  since  it  is sometimes costly in time (it
identifies  the type of the group based on the order, the degree, the order
of  the generators and the Cartan matrix;  sometimes it needs to search for
another  set of generators than the given one), a version <code>PermRootGroupNC</code>
is given which does not call it.
<P>
This  function  is  called  automatically  prior  to  calling  any function
depending  on the classification, such as <code>PrintDiagram</code>, <code>ReflectionName</code>,
<code>ChevieClassInfo</code>,      <code>BraidRelations</code>,     <code>CharName</code>,     <code>CharParams</code>,
<code>Representations</code>, <code>Invariants</code>.
<P>
<pre>    gap> W:=ComplexReflectionGroup(4)*CoxeterGroup("A",2);;
    gap> ReflectionType(W);
    [ rec(series  := "ST",
          ST      := 4,
          rank    := 2,
          indices := [ 1, 2 ]), rec(rank    := 2,
          series  := "A",
          indices := [ 3, 4 ]) ]</pre>
<P>
<code>ReflectionType( <var>C</var> )</code>
<P>
<var>C</var>  should be a Cartan  matrix. This function determines  the type of each
irreducible component of <var>C</var> which is the Cartan matrix of a finite Coxeter
group; the result is a list of Reflection types. The corresponding field is
set  to <code>false</code>  if the  corresponding submatrix  of <var>C</var>  is not the Cartan
matrix of a finite Coxeter group. Going from the above example:
<P>
<pre>    gap> C:=CartanMat(W);
    [ [ -2*E(3)-E(3)^2, E(3)^2, 0, 0 ], [ -E(3)^2, -2*E(3)-E(3)^2, 0, 0 ],
      [ 0, 0, 2, -1 ], [ 0, 0, -1, 2 ] ]
    gap> ReflectionType(C);
    [ false, rec(rank    := 2,
          series  := "A",
          indices := [ 3, 4 ]) ]</pre>
<P>
Note  that a  Cartan matrix  for a  finite Coxeter  group is conjugate by a
diagonal  matrix  of  the  matrices  for  the  root  systems  given  in the
introduction  of the chapter on  root systems. This conjugation corresponds
to  changing the  ratio of  the length  between long  and short  roots; for
example  one could construct a root system  for type <code>B</code> where the quotient
of the two root lengths is any cyclotomic number.
<P>
<pre>    gap> M:=[ [ 2, -E(7)^3-E(7)^5-E(7)^6 ], [ -E(7)-E(7)^2-E(7)^4, 2 ] ];;
    gap> ReflectionType(M);
    [ rec(rank       := 2,
          series     := "B",
          cartanType := E(7)^3+E(7)^5+E(7)^6,
          indices    := [ 1, 2 ]) ]</pre>
<P>
In  the  above  example,  the  <code>cartanType</code>  field  shows that the two root
lengths for <code>B2</code> have a ratio which is <I>(1+&radic;-7)/(2)</I>.
<P><A NAME="SECT004"><h2>84.4 ReflectionName</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>ReflectionName( <var>type</var> )</code>
<P>
takes  as argument a  type <var>type</var> as  returned by <code>ReflectionType</code>. Returns
the  name of the group system with  that type, which is the concatenation of
the names of its irreducible components, with <code>x</code> added in between. For
reflection subgroups, it gives an indication about embedding in the parent
<P>
<pre>    gap> C := [ [ 2, 0, -1 ], [ 0, 2, 0 ], [ -1, 0, 2 ] ];;
    gap> ReflectionName( ReflectionType( C ) );
    "A2xA1"
    gap> ReflectionName( ReflectionType( CartanMat( "I", 2, 7 ) ) );
    "I2(7)"
    gap> ReflectionName(ReflectionSubgroup(CoxeterGroup("E",8),[2,3,6,7]));
    "A1&lt;2>xA1&lt;3>xA2&lt;6,7>.(q-1)^4"</pre>
<P>
<code>ReflectionName( <var>D</var> )</code>
<P>
The  argument  to  <code>ReflectionType</code>  can  also  be  a  record  with a field
<code>operations.ReflectionType</code>, and that function is then called with <var>rec</var> as
argument --- this works for reflection groups and reflection cosets.
<P><A NAME="SECT005"><h2>84.5 IsomorphismType</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>IsomorphismType( <var>W</var> )</code>
<P>
takes  as  argument  a  reflection  group  or a reflection coset. Returns a
description of the isomorphism type of the argument.
<P>
<pre>    gap> IsomorphismType(ReflectionSubgroup(CoxeterGroup("E",8),[2,3,6,7]));
    "A2+2A1"</pre>
<P><A NAME="SECT006"><h2>84.6 ComplexReflectionGroup</h2></a>
<P><P>
<A name = "I6"></a>

<P>
<code>ComplexReflectionGroup( <var>STnumber</var> )</code>
<P>
<code>ComplexReflectionGroup( <var>p</var>, <var>q</var>, <var>r</var> )</code>
<P>
The first form of <code>ComplexReflectionGroup</code> returns the complex reflection
group  which has Shephard-Todd  number  <var>STnumber</var>, see <A href="biblio.htm#ST54"><cite>ST54</cite></a>.  The
second form returns the imprimitive complex reflection group <I>G(p,q,r)</I>.
<P>
<pre>    gap> G := ComplexReflectionGroup( 4 );
    ComplexReflectionGroup(4)
    gap> ReflectionDegrees( G );
    [ 4, 6 ]
    gap> Size( G );
    24
    gap> q := X( Cyclotomics );; q.name := "q";;
    gap> FakeDegrees( G, q );
    [ q^0, q^4, q^8, q^7 + q^5, q^5 + q^3, q^3 + q, q^6 + q^4 + q^2 ]
    gap> ComplexReflectionGroup(2,1,6);
    CoxeterGroup("B",6)</pre>
<P><A NAME="SECT007"><h2>84.7 Reflections</h2></a>
<P><P>
<A name = "I7"></a>

<P>
<code>Reflections( <var>W</var> )</code>
<P>
returns  the list of distinguished reflections  of <var>W</var>, as elements of <var>W</var>.
We  recall  that  a  reflection  is  distinguished  (see  "Reflections, and
reflection   groups")  if  it  has  eigenvalue  <code>E(e)</code>  where  <code>e</code>  is  the
cardinality of the cyclic subgroup <I>C<sub>W</sub>(H)</I>, where <I>H</I> is the hyperplane of
fixed points of the reflection (all reflections are distinguished if <var>W</var> is
generated by reflections of order 2). The generating reflections of <var>W</var> are
<code>Reflections(W){W.generatingReflections}</code>.
<P>
<pre>    gap> W := CoxeterGroup( "B", 2 );;
    gap> Reflections( W );
    [ (1,5)(2,4)(6,8), (1,3)(2,6)(5,7), (2,8)(3,7)(4,6), (1,7)(3,5)(4,8) ]</pre>
<P>
the  code needed to obtain in general  all reflections of <var>W</var> (not only the
distinguished ones) is:
<P>
<pre>    gap> l:=Reflections(W);;
    gap> l:=Concatenation(List(l,s->List([1..Order(W,s)-1],i->s^i)));;</pre>
<P>
for  finite Coxeter groups,  <code>Reflections(W)</code> are in  the same order as the
positive roots. For general complex reflection groups the relationship with
roots   is  only  guaranteed  for   the  generating  reflections,  that  is
<code>Reflections(W){W.generatingReflections}</code>  are the reflections with respect
to <code>W.roots{W.generatingReflections}</code>. The other reflections are not in the
same order as the roots.
<P><A NAME="SECT008"><h2>84.8 MatXPerm</h2></a>
<P><P>
<A name = "I8"></a>

<P>
<code>MatXPerm( <var>W</var>, <var>w</var> )</code>
<P>
Let  <var>w</var> be a permutation  of the roots of  the finite reflection group <var>W</var>
with  reflection representation  <var>V</var>. The  function <code>MatXPerm</code>  returns the
matrix of <var>w</var> acting on <var>V</var>. This is the linear transformation of <var>V</var> which
acts  trivially on the orthogonal of the coroots and has same effect as <var>w</var>
on the simple roots. The function makes sense more generally for an element
of the normalizer of <var>W</var> in the whole permutation group of the roots.
<P>
<pre>    gap> W := CoxeterGroup(
    > [ [ 2, 0,-1, 0, 0, 0, 1 ], [ 0, 2, 0,-1, 0, 0, 0 ],
    >   [-1, 0, 2,-1, 0, 0,-1 ], [ 0,-1,-1, 2,-1, 0, 0 ],
    >   [ 0, 0, 0,-1, 2,-1, 0 ], [ 0, 0, 0, 0,-1, 2, 0 ] ],
    > [ [ 1, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0 ],
    >   [ 0, 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0, 0 ],
    >   [ 0, 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0 ] ] );;
    gap> w0 := LongestCoxeterElement( W );;
    gap> mx := MatXPerm( W, w0 );
    [ [ 0, 0, 0, 0, 0, -1, 1 ], [ 0, -1, 0, 0, 0, 0, 2 ],
      [ 0, 0, 0, 0, -1, 0, 3 ], [ 0, 0, 0, -1, 0, 0, 4 ],
      [ 0, 0, -1, 0, 0, 0, 3 ], [ -1, 0, 0, 0, 0, 0, 1 ],
      [ 0, 0, 0, 0, 0, 0, 1 ] ]</pre>
<P><A NAME="SECT009"><h2>84.9 PermMatX</h2></a>
<P><P>
<A name = "I9"></a>

<P>
<code>PermMatX( <var>W</var>, <var>M</var> )</code>
<P>
Let <var>M</var> be  a linear transformation of reflection  representation of <var>W</var>
which  preserves the  set of  roots, and  thus normalizes  <var>W</var> (remember
that  matrices  act on  the  right in  <strong>GAP3</strong>). <code>PermMatX</code>  returns  the
corresponding permutation of  the roots; it returns <code>false</code>  if <var>M</var> does
not normalize the set of roots.
<P>
We continue the example from <code>MatXPerm</code> and obtain:
<P>
<pre>    gap> PermMatX( W, mx ) = w0;
    true</pre>
<P><A NAME="SECT010"><h2>84.10 MatYPerm</h2></a>
<P><P>
<A name = "I10"></a>

<P>
<code>MatYPerm( <var>W</var>, <var>w</var> )</code>
<P>
Let  <var>w</var> be a permutation  of the roots of  the finite reflection group <var>W</var>
with  reflection representation  <var>V</var>. The  function <code>MatYPerm</code>  returns the
matrix  of <var>w</var> acting on the dual vector space <I>V<sup>&or;</sup></I>. This is the linear
transformation  of <I>V<sup>&or;</sup></I> which  acts trivially on  the orthogonal of the
roots  and has same effect as <var>w</var> on the simple coroots. The function makes
sense  more generally for an element of  the normalizer of <var>W</var> in the whole
permutation group of the roots.
<P>
<pre>    gap>  W:=ReflectionSubgroup(CoxeterGroup("E",7),[1..6]);
    ReflectionSubgroup(CoxeterGroup("E",7), [ 1, 2, 3, 4, 5, 6 ])
    gap>  w0:=LongestCoxeterElement(W);;
    gap> my:=MatYPerm(W,w0);
    [ [ 0, 0, 0, 0, 0, -1, 2 ], [ 0, -1, 0, 0, 0, 0, 2 ],
      [ 0, 0, 0, 0, -1, 0, 3 ], [ 0, 0, 0, -1, 0, 0, 4 ],
      [ 0, 0, -1, 0, 0, 0, 3 ], [ -1, 0, 0, 0, 0, 0, 2 ],
      [ 0, 0, 0, 0, 0, 0, 1 ] ]</pre>
<P><A NAME="SECT011"><h2>84.11 InvariantForm for finite reflection groups</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>InvariantForm( <var>W</var> )</code>
<P>
This  function returns the matrix <code>F</code>  of an Hermitian form invariant under
the action of the reflection group <var>W</var>. That is, if <code>M</code> is the matrix of an
element of <var>W</var>, then <code>M*F*Transpose(ComplexConjugate(M))=F</code>.
<P>
<pre>    gap> W:=ComplexReflectionGroup(4);
    ComplexReflectionGroup(4)
    gap> F:=InvariantForm(W);
    [ [ 1, 0 ], [ 0, 2 ] ]
    gap> List(W.matgens,m->m*F*ComplexConjugate(TransposedMat(m))=F);
    [ true, true ]</pre>
<P><A NAME="SECT012"><h2>84.12 ReflectionEigenvalues</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>ReflectionEigenvalues( <var>W</var> [, <var>c</var>])</code>
<P>
Let <var>W</var> be a reflection group on the vector space <var>V</var>.
<code>ReflectionEigenvalues(  <var>W</var>)</code> returns the list  for each conjugacy classes
of  the eigenvalues  of an  element of  that class  acting on  <var>V</var>. This is
returned as a list of fractions <code>i/n</code>, where such a fraction represents the
eigenvalue  <code>E(n)^i</code>  (the  reason  for  returning  such  a representation
instead  of <code>E(n)^i</code> is that in <strong>GAP3</strong>  it is trivial to compute <code>E(n)^i</code>
given  <var>i/n</var>, but the converse is more expensive). If a second argument <var>c</var>
is  given, returns only the list of  eigenvalues of an element of the <var>c</var>th
conjugacy class.
<P>
<pre>    gap> W:=CoxeterGroup("A",2);
    CoxeterGroup("A",2)
    gap> ReflectionEigenvalues(W,3);
    [ 1/3, 2/3 ]
    gap> ReflectionEigenvalues(CoxeterGroup("B",2));
    [ [ 0, 0 ], [ 1/2, 0 ], [ 1/2, 1/2 ], [ 1/2, 0 ], [ 1/4, 3/4 ] ]</pre>
<P><A NAME="SECT013"><h2>84.13 ReflectionLength</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>ReflectionLength( <var>W</var>, <var>w</var> )</code>
<P>
This  function returns the  number of eigenvalues  of <var>w</var> in the reflection
representation  which are not equal to 1.  For a finite Coxeter group, this
is  equal to the minimum  number of reflections of  which <var>w</var> is a product.
This  also holds in general in a well-generated complex reflection group if
<var>w</var> divides a Coxeter element for the reflection length.
<P>
<pre>    gap> W:=CoxeterGroup("A",4);
    CoxeterGroup("A",4)
    gap> ReflectionLength(W,LongestCoxeterElement(W));
    2
    gap> ReflectionLength(W,EltWord(W,[1,2,3,4]));
    4</pre>
<P><A NAME="SECT014"><h2>84.14 ReflectionWord</h2></a>
<P><P>
<A name = "I14"></a>

<P>
<code>ReflectionWord( <var>W</var>, <var>w</var> [, <var>refs</var>])</code>
<P>
This  function return a list of minimal  length of reflections of which <var>w</var>
is  the product. The reflections are represented as their index in the list
of  reflections (which is  the index of  the corresponding positive root in
the  list of roots).  If a third  argument is given,  it must be  a list of
reflections  and only  these reflections  are tried,  and the index is with
respect  to this list of reflections.  This function works for all elements
of  a Coxeter group when no third argument is given, or for <var>w</var> a simple of
the  dual braid monoid if <var>W</var>  is a well-generated complex reflection group
and <var>refs</var> is the list of atoms of this monoid.
<P>
<pre>    gap> W:=CoxeterGroup("A",4);
    CoxeterGroup("A",4)
    gap> ReflectionWord(W,LongestCoxeterElement(W));
    [ 6, 10 ]
    gap> ReflectionWord(W,EltWord(W,[1,2,3,4]));
    [ 1, 2, 3, 4 ]</pre>
<P><A NAME="SECT015"><h2>84.15 HyperplaneOrbits</h2></a>
<P><P>
<A name = "I15"></a>

<P>
<code>HyperplaneOrbits( <var>W</var> )</code>
<P>
returns a list of records, one for each hyperplane orbit of <var>W</var>,
containing the following fields for each orbit:
<P>
<DL><DT> <code>.s</code>:<DD><BR>      index of first generator in orbit
</DL><P>
<DL><DT> <code>.e_s</code>:<DD><BR>    order of s
</DL><P>
<DL><DT> <code>.classno</code>:<DD><BR> if <code>w=W.generators[.s]</code> returns
   <code>List([1..e_s-1],i->PositionClass(W,w^i)</code>
</DL><P>
<DL><DT> <code>.N_s</code>:<DD><BR>    Size of orbit
</DL><P>
<DL><DT> <code>.det_s</code>:<DD><BR>  for i in <code>[1..e_s-1]</code>, position in CharTable of <code>(det_s)^i</code>
</DL><P>
<pre>    gap> W:=CoxeterGroup("B",2);
    CoxeterGroup("B",2)
    gap> HyperplaneOrbits(W);
    [ rec(
          s := 1,
          e_s := 2,
          classno := [ 2 ],
          N_s := 2,
          det_s := [ 5 ] ), rec(
          s := 2,
          e_s := 2,
          classno := [ 4 ],
          N_s := 2,
          det_s := [ 1 ] ) ]</pre>
<P><A NAME="SECT016"><h2>84.16 BraidRelations</h2></a>
<P><P>
<A name = "I16"></a>

<P>
<code>BraidRelations( <var>W</var> )</code>
<P>
this function  returns the  relations which present  the braid  group of
<var>W</var>. These  are homogeneous  (both sides of  the same  length) relations
between generators in bijection with  the generating reflections of <var>W</var>.
A presentation  of <var>W</var>  is obtained by  adding relations  specifying the
order of the generators.
<P>
<pre>    gap> W:=ComplexReflectionGroup(29);
    ComplexReflectionGroup(29)
    gap> BraidRelations(W);
    [ [ [ 1, 2, 1 ], [ 2, 1, 2 ] ], [ [ 2, 4, 2 ], [ 4, 2, 4 ] ],
      [ [ 3, 4, 3 ], [ 4, 3, 4 ] ], [ [ 2, 3, 2, 3 ], [ 3, 2, 3, 2 ] ],
      [ [ 1, 3 ], [ 3, 1 ] ], [ [ 1, 4 ], [ 4, 1 ] ],
      [ [ 4, 3, 2, 4, 3, 2 ], [ 3, 2, 4, 3, 2, 4 ] ] ]</pre>
<P>
each relation  is represented as  a pair  of lists, specifying  that the
product of the  generators according to the indices on  the left side is
equal to  the product according  to the indices  on the right  side. See
also <a href="chap084.htm#SECT017">PrintDiagram</a>.
<P><A NAME="SECT017"><h2>84.17 PrintDiagram</h2></a>
<P><P>
<A name = "I17"></a>

<P>
<code>PrintDiagram( <var>W</var> )</code>
<code>PrintDiagram( <var>type</var> )</code>
<P>
This is a purely descriptive routine, which, by printing a diagram as in
<A href="biblio.htm#BMR98"><cite>BMR98</cite></a> for  <var>W</var> or the  given reflection <var>type</var> (a  Dynkin diagram
for Weyl  groups) shows  how the  generators of <var>W</var>  are labeled  in the
<strong>CHEVIE</strong> presentation.
<P>
<pre>    gap> PrintDiagram(ComplexReflectionGroup(31));
    G31 4 - 2 - 5
         \ /3\ /
          1 - 3     i.e. A_5 on 14253 plus 123=231=312</pre>
<P><A NAME="SECT018"><h2>84.18 ReflectionCharValue</h2></a>
<P><P>
<A name = "I18"></a>

<P>
<code>ReflectionCharValue( <var>W</var>, <var>w</var> )</code>
<P>
Returns the trace of  the element <var>w</var> of the reflection  group <var>W</var> as an
endomorphism of the vector space <var>V</var>  on which <var>W</var> acts. This could also
be obtained (less efficiently) by <code>TraceMat(MatXPerm(W,w))</code>.
<P>
<pre>    gap> W := CoxeterGroup( "A", 3 );
    CoxeterGroup("A",3)
    gap> List( Elements( W ), x -> ReflectionCharValue( W, x ) );
    [ 3, 1, 1, 1, 0, 0, 0, -1, 0, -1, -1, 1, 1, -1, -1, -1, 0, 0, 0, 0,
      -1, -1, 1, -1 ]</pre>
<P><A NAME="SECT019"><h2>84.19 ReflectionCharacter</h2></a>
<P><P>
<A name = "I19"></a>

<P>
<code>ReflectionCharacter( <var>W</var> )</code>
<P>
Returns  the reflection character  of the reflection  group <var>W</var>. This could
also be obtained (less efficiently) by
<code>List(ConjugacyClasses(W),c->ReflectionCharValue(W,c))</code>.    When   <var>W</var>   is
irreducible, it can also be written
<code>CharTable(W).irreducibles[ChevieCharInfo(W).extRefl[2]]</code>
<P>
<pre>    gap> W := CoxeterGroup( "A", 3 );
    CoxeterGroup("A",3)
    gap> ReflectionCharacter(W);
    [ 3, 1, -1, 0, -1 ]</pre>
<P><A NAME="SECT020"><h2>84.20 ReflectionDegrees</h2></a>
<P><P>
<A name = "I20"></a>

<P>
<code>ReflectionDegrees( <var>W</var> )</code>
<P>
returns  a list  holding the  degrees of  <I>W</I> as  a reflection group on the
vector  space <I>V</I> on  which it acts.  These are the degrees <I>d<sub>1</sub>,...,d<sub>
</I>dim<I>  V</sub></I> of  the basic  invariants of  <I>W</I> in  <I>SV</I>. They  reflect various
properties of <I>W</I>; in particular, their product is the size of <I>W</I>.
<P>
<pre>    gap> W := ComplexReflectionGroup(30);
    CoxeterGroup("H",4)
    gap> ReflectionDegrees( W );
    [ 2, 12, 20, 30 ]
    gap> Size( W );
    14400</pre>
<P><A NAME="SECT021"><h2>84.21 ReflectionCoDegrees</h2></a>
<P><P>
<A name = "I21"></a>

<P>
<code>ReflectionCoDegrees( <var>W</var> )</code>
<P>
returns a list holding the codegrees of <I>W</I> as a reflection group on the
vector  space <I>V</I> on which it acts.  These are one less than the degrees
<I>d<sup>*</sup> <sub>1</sub>,...,d<sup>*</sup> <sub></I>dim<I>  V</sub></I>  of  the  basic  derivations  of  <I>W</I>  on
<I>SV&otimes; V<sup>&or;</sup></I>.
<P>
<pre>    gap> W := ComplexReflectionGroup(4);;
    gap> ReflectionCoDegrees( W );
    [ 0, 2 ]</pre>
<P><A NAME="SECT022"><h2>84.22 GenericOrder</h2></a>
<P><P>
<A name = "I22"></a>

<P>
<code>GenericOrder(W,q)</code>
<P>
returns  the "compact" generic order of <code>W</code>  as a polynomial in <code>q</code>. This
is  <I>q<sup>N<sub>h</sub></sup>&prod;<sub>i</sub>(q<sup>d<sub>i</sub></sup>-1)</I> where <I>d<sub>i</sub></I> are  the reflection degrees and
<I>N<sub>h</sub></I>  the number of  reflecting hyperplanes. For  a Weyl group,  it is the
order  of the associated  semisimple finite reductive  group over the field
with <I>q</I> elements.
<P>
<pre>    gap> q:=X(Rationals);;q.name:="q";;
    gap> GenericOrder(ComplexReflectionGroup(4),q);
    q^14 - q^10 - q^8 + q^4</pre>
<P><A NAME="SECT023"><h2>84.23 TorusOrder</h2></a>
<P><P>
<A name = "I23"></a>

<P>
<code>TorusOrder(W,i,q)</code>
<P>
returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy
class  of <code>W</code>. This is the characteristic  polynomial of an element of that
class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the
generic  order of the reflection subcoset  of <code>W</code> determined by the trivial
subgroup and a representative of the <code>i</code>-th conjugacy class.
<P>
<pre>    gap> W:=ComplexReflectionGroup(4);;
    gap> q:=X(Cyclotomics);;q.name:="q";;
    gap> List([1..NrConjugacyClasses(W)],i->TorusOrder(W,i,q));
    [ q^2 - 2*q + 1, q^2 + 2*q + 1, q^2 + 1, q^2 + (-E(3))*q + (E(3)^2),
      q^2 + (E(3))*q + (E(3)^2), q^2 + (E(3)^2)*q + (E(3)),
      q^2 + (-E(3)^2)*q + (E(3)) ]</pre>
<P><A NAME="SECT024"><h2>84.24 ParabolicRepresentatives for reflection groups</h2></a>
<P><P>
<A name = "I24"></a>

<P>
<code>ParabolicRepresentatives(<var>W</var> [, <var>r</var>])</code>
<P>
Returns   a   list   of   subsets   of   <code>W.reflectionsLabels</code>   describing
representatives  of orbits of parabolic subgroups under conjugation by <I>W</I>.
If  a second  argument <var>r</var>  is given,  returns only  representatives of the
parabolic subgroups of semisimple rank <var>r</var>.
Contrary  to the case of Coxeter groups, it may happen that for some orbits
no  representative  can  be  chosen  all  of  whose  elements  are standard
generators.
<P>
<pre>    gap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3));
    [ [  ], [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ], [ 1, 2, 3 ] ]
    gap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3),2);
    [ [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ] ]</pre>
<P><A NAME="SECT025"><h2>84.25 Invariants</h2></a>
<P><P>
<A name = "I25"></a>

<P>
<code>Invariants( <var>W</var> )</code>
<P>
returns  the fundamental invariants of <var>W</var> in its reflection representation
<var>V</var>.  That is, returns  a set of  algebraically independent elements of the
symmetric  algebra  of  the  dual  of  <I>V</I> which generate the <I>W</I>-invariant
polynomial  functions on <I>V</I>. Each such invariant function is returned as a
<strong>GAP3</strong>  function: if <I>e<sub>1</sub>,...,e<sub>n</sub></I>  is a basis  of <I>V</I> and  <code>f</code> is the
<strong>GAP3</strong>   function,   then   the   value   of  the  polynomial  function  on
<I>a<sub>1</sub>e<sub>1</sub>+...+a<sub>n</sub>  e<sub>n</sub></I> is  obtained by  calling <I>f(a<sub>1</sub>,...,a<sub>n</sub>)</I>. This
function  depends  on  the  classification,  and  is dependent on the exact
reflection  representation of <var>W</var>. So for the moment it is only implemented
when  the reflection representation for  the irreducible components has the
same  Cartan matrix as the one  provided by <strong>CHEVIE</strong> for the corresponding
irreducible  group. The polynomials are invariant for the natural action of
the group elements as matrices; that is, if <I>m</I> is <code>MatXPerm(W,w)</code> for some
<I>w</I>   in  <I>W</I>,   then  an   invariant  <I>f</I>   satisfies  <I>f(a<sub>1</sub>,...,a<sub>n</sub>)=
f(v<sub>1</sub>,...,v<sub>n</sub>)</I>  where <I>[v<sub>1</sub>,...,v<sub>n</sub>]=[a<sub>1</sub>,...,a<sub>n</sub>]&times; m</I>. This
action  is  implemented  on  <code>Mvp</code>s  by  the  function <code>OnPolynomials</code> (see
<a href="chap112.htm#SECT007">OnPolynomials</a>).
<P>
<pre>    gap> W:=CoxeterGroup("A",2);
    CoxeterGroup("A",2)
    gap> i:=Invariants(W);
    [ function ( arg ) ... end, function ( arg ) ... end ]
    gap> x:=X(Rationals);;x.name:="x";;
    gap> y:=X(RationalsPolynomials);;y.name:="y";;
    gap> i[1](x,y);
    (-2*x^0)*y^2 + (2*x)*y + (-2*x^2)
    gap> i[2](x,y);
    (-6*x)*y^2 + (6*x^2)*y</pre>
<P>
Another example using <code>Mvp</code> from the package VKCURVE.
<P>
<pre>    gap> W:=ComplexReflectionGroup(24);;
    gap> i:=Invariants(W);;
    gap> v:=List([1..3],i->Mvp(SPrint("x",i)));
    [ x1, x2, x3 ]
    gap> ApplyFunc(i[1],v);
    -42x1^2x2x3-12x1^2x2^2+21/2x1^2x3^2-9/2x2^2x3^2-6x2^3x3+14x1^4+18/7x2^\ 
    4-21/8x3^4
    gap> OnPolynomials(W.matgens[1],last)-last;
    0</pre>
<P><A NAME="SECT026"><h2>84.26 Discriminant</h2></a>
<P><P>
<A name = "I26"></a>

<P>
<code>Discriminant( <var>W</var> )</code>
<P>
returns  the  discriminant  of  the  complex  reflection  group  <var>W</var>,  as a
polynomial in the fundamental invariants. The discriminant is the invariant
obtained  by  taking  the  product  of  the  linear  forms  describing  the
reflecting   hyperplanes  of  <var>W</var>,   each  raised  to   the  order  of  the
corresponding reflection. The discriminant is returned as a <strong>GAP3</strong> function
<code>f</code>  such  that  the  discriminant  in  the  variables  <I>a<sub>1</sub>,...,a<sub>n</sub></I> is
obtained  by calling <I>f(a<sub>1</sub>,...,a<sub>n</sub>)</I>. For  the moment, this function is
implemented  only for  the exceptional  complex reflection  groups <I>G<sub>4</sub></I> to
<I>G<sub>33</sub></I>.
<P>
<pre>    gap> W:=ComplexReflectionGroup(4);
    ComplexReflectionGroup(4)
    gap> Discriminant(W)(x,y);
    -y^2+x^3</pre>
<P><A NAME="SECT027"><h2>84.27 Catalan</h2></a>
<P><P>
<A name = "I27"></a>

<P>
<code>Catalan( <var>n</var> )</code>
<P>
returns  the <var>n</var>-th Catalan number.
<P>
<pre>    gap> Catalan(8);
    1430</pre>
<P>
<code>Catalan( <var>W</var> )</code>
<P>
returns the Catalan Number of the irreducible complex reflection group <var>W</var>.
For well-generated groups, this number is equal to the number of simples in
the  dual  Braid  monoid.  For  other  groups  it was defined by Gordon and
Griffeth  (<A href="biblio.htm#gg12"><cite>gg12</cite></a>).  For  Weyl  groups,  it  also counts the number of
antichains of roots.
<P>
<pre>    gap> Catalan(CoxeterGroup("A",7));
    1430</pre>
<P>
<code>Catalan( <var>W</var>, <var>i</var>)</code>
<P>
returns   the  <var>i</var>-th  Fuss-Catalan  Number   of  the  irreducible  complex
reflection  group <var>W</var>. For  well-generated groups, this  number is equal to
the  number of chains <I>s<sub>1</sub>,...,s<sub>i</sub></I> of  simples in the dual monoid where
<I>s<sub>j</sub></I>   divides  <I>s<sub>j+1</sub></I>.  For   these  groups,  it   is  also  equal  to
<I>&prod;<sub>j</sub>(ih+d<sub>j</sub>)/d<sub>j</sub></I> where the product runs over the reflection degrees of
<var>W</var>,  and where <var>h</var>  is the Coxeter  number of <var>W</var>.  For non-well generated
groups, the definition is in <A href="biblio.htm#gg12"><cite>gg12</cite></a>.
<P>
<pre>    gap> Catalan(ComplexReflectionGroup(7),2);
    16</pre>
<P>
<code>Catalan( <var>W</var>, <var>q</var>)</code>, resp. <code>Catalan( <var>W</var>, <var>i</var>, <var>q</var>)</code>
<P>
where  <var>q</var>  is  a  variable  (an  indeterminate  or  an  <code>Mvp</code>) returns the
<var>q</var>-Catalan number (resp. the <var>i</var>-th <var>q</var>-Fuss Catalan number) of <var>W</var>. Again
the definitions in general are in <A href="biblio.htm#gg12"><cite>gg12</cite></a>.
<P>
<pre>    gap> Catalan(ComplexReflectionGroup(7),2,x);
    1+2x^12+3x^24+4x^36+3x^48+2x^60+x^72</pre>
<a href ="chap083.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap085.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>