<html><head><title>GAP3 Manual: 47 Combinatorics</title></head>
<body bgcolor="ffffff">
<h1>47 Combinatorics</h1>
<P><P>
<A name = "I0"></a>
<A name = "I1"></a>

<P>
This chapter  describes the functions that   deal with combinatorics.  We
mainly concentrate on two areas.  One  is about <strong>selections</strong>, that is the
ways one   can  select   elements from  a   set.    The  other  is  about
<strong>partitions</strong>, that is the ways one can partition a set  into the union of
pairwise disjoint subsets.
<P>
First  this package contains  various  functions that are related  to the
number of  selections from a set  (see <a href="chap047.htm#SECT001">Factorial</a>, <a href="chap047.htm#SECT002">Binomial</a>) or to the
number  of  partitions of a  set  (see <a href="chap047.htm#SECT003">Bell</a>, <a href="chap047.htm#SECT004">Stirling1</a>, <a href="chap047.htm#SECT005">Stirling2</a>).
Those numbers satisfy literally thousands of identities,  which  we do no
mention in this document, for a thorough treatment see <A href="biblio.htm#GKP90"><cite>GKP90</cite></a>.
<P>
Then this package contains functions to compute the selections from a set
(see <a href="chap047.htm#SECT006">Combinations</a>),  ordered selections, i.e.,   selections where   the
order in which you select the elements is important (see <a href="chap047.htm#SECT007">Arrangements</a>),
selections with repetitions,  i.e., you  are allowed to   select the same
element more than once  (see  <a href="chap047.htm#SECT008">UnorderedTuples</a>) and  ordered  selections
with repetitions (see <a href="chap047.htm#SECT009">Tuples</a>).
<P>
As special  cases of ordered  combinations there are functions to compute
all permutations (see <a href="chap047.htm#SECT010">PermutationsList</a>),  all fixpointfree permutations
(see <a href="chap047.htm#SECT011">Derangements</a>) of a list.
<P>
This package also contains functions to  compute partitions of a set (see
<a href="chap047.htm#SECT012">PartitionsSet</a>), partitions of  an integer  into   the sum of   positive
integers      (see    <a href="chap047.htm#SECT013">Partitions</a>,  <a href="chap047.htm#SECT015">RestrictedPartitions</a>) and  ordered
partitions of  an  integer  into   the  sum  of positive integers    (see
<a href="chap047.htm#SECT014">OrderedPartitions</a>).
<P>
Moreover,  it provides three  functions to compute Fibonacci numbers (see
<a href="chap047.htm#SECT022">Fibonacci</a>), Lucas sequences  (see  <a href="chap047.htm#SECT023">Lucas</a>), or Bernoulli  numbers (see
<a href="chap047.htm#SECT024">Bernoulli</a>).
<P>
Finally, there  is a function to  compute the number of permutations that
fit a given 1-0 matrix (see <a href="chap047.htm#SECT025">Permanent</a>).
<P>
All these functions are in the file <code>"LIBNAME/combinat.g"</code>.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap047.htm#SECT001">Factorial</a>
<LI> <A HREF="chap047.htm#SECT002">Binomial</a>
<LI> <A HREF="chap047.htm#SECT003">Bell</a>
<LI> <A HREF="chap047.htm#SECT004">Stirling1</a>
<LI> <A HREF="chap047.htm#SECT005">Stirling2</a>
<LI> <A HREF="chap047.htm#SECT006">Combinations</a>
<LI> <A HREF="chap047.htm#SECT007">Arrangements</a>
<LI> <A HREF="chap047.htm#SECT008">UnorderedTuples</a>
<LI> <A HREF="chap047.htm#SECT009">Tuples</a>
<LI> <A HREF="chap047.htm#SECT010">PermutationsList</a>
<LI> <A HREF="chap047.htm#SECT011">Derangements</a>
<LI> <A HREF="chap047.htm#SECT012">PartitionsSet</a>
<LI> <A HREF="chap047.htm#SECT013">Partitions</a>
<LI> <A HREF="chap047.htm#SECT014">OrderedPartitions</a>
<LI> <A HREF="chap047.htm#SECT015">RestrictedPartitions</a>
<LI> <A HREF="chap047.htm#SECT016">SignPartition</a>
<LI> <A HREF="chap047.htm#SECT017">AssociatedPartition</a>
<LI> <A HREF="chap047.htm#SECT018">BetaSet</a>
<LI> <A HREF="chap047.htm#SECT019">Dominates</a>
<LI> <A HREF="chap047.htm#SECT020">PowerPartition</a>
<LI> <A HREF="chap047.htm#SECT021">PartitionTuples</a>
<LI> <A HREF="chap047.htm#SECT022">Fibonacci</a>
<LI> <A HREF="chap047.htm#SECT023">Lucas</a>
<LI> <A HREF="chap047.htm#SECT024">Bernoulli</a>
<LI> <A HREF="chap047.htm#SECT025">Permanent</a>
</ol>
<A NAME="SECT001"><h2>47.1 Factorial</h2></a>
<P><P><P>
<code>Factorial( <var>n</var> )</code>
<P>
<code>Factorial</code>  returns the <strong>factorial</strong>  <I>n!</I>  of the positive  integer <var>n</var>,
which is defined as the product <I>1 * 2 * 3 * .. * n</I>.
<P>
<I>n!</I> is the  number of permutations of a set of <I>n</I> elements.  <I>1/n!</I>  is
the coefficient  of  <I>x<sup>n</sup></I>  in  the  formal series  <I>e<sup>x</sup></I>, which  is  the
generating function for factorial.
<P>
<pre>    gap> List( [0..10], Factorial );
    [ 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 ]
    gap> Factorial( 30 );
    265252859812191058636308480000000 </pre>
<P>
<code>PermutationsList</code>  (see   <a href="chap047.htm#SECT010">PermutationsList</a>) computes  the  set  of all
permutations of a list.
<P><A NAME="SECT002"><h2>47.2 Binomial</h2></a>
<P><P>
<A name = "I2"></a>
<A name = "I3"></a>

<P>
<code>Binomial( <var>n</var>, <var>k</var> )</code>
<P>
<code>Binomial</code> returns the <strong>binomial coefficient</strong> <I>n \choose k</I> of integers
<var>n</var> and <var>k</var>, which  is defined as <I>n!  / (k!  (n-k)!)</I> (see <a href="chap047.htm#SECT001">Factorial</a>).
We define <I>0 \choose 0 = 1</I>, <I>n \choose  k = 0</I>  if <I>k&lt;0</I> or <I>n&lt;k</I>,
and <I>n \choose k = (-1)<sup>k</sup> -n+k-1  \choose  k</I> if  <I>n &lt;  0</I>, which is
consistent with <I>n \choose k = n-1 \choose k + n-1 \choose k-1</I>.
<P>
<I>n \choose k</I> is the number of combinations with  <I>k</I>  elements,  i.e.,
the number of subsets with <I>k</I> elements, of  a  set  with  <I>n</I>  elements.
<I>n \choose k</I>  is the coefficient of the  term <I>x<sup>k</sup></I> of the  polynomial
<I>(x + 1)<sup>n</sup></I>, which is the generating function for <I>n \choose *</I>, hence
the name.
<P>
<pre>    gap> List( [0..4], k->Binomial( 4, k ) );
    [ 1, 4, 6, 4, 1 ]    # Knuth calls this the trademark of Binomial
    gap> List( [0..6], n->List( [0..6], k->Binomial( n, k ) ) );;
    gap> PrintArray( last );
    [ [   1,   0,   0,   0,   0,   0,   0 ],    # the lower triangle is
      [   1,   1,   0,   0,   0,   0,   0 ],    # called Pascal's triangle
      [   1,   2,   1,   0,   0,   0,   0 ],
      [   1,   3,   3,   1,   0,   0,   0 ],
      [   1,   4,   6,   4,   1,   0,   0 ],
      [   1,   5,  10,  10,   5,   1,   0 ],
      [   1,   6,  15,  20,  15,   6,   1 ] ]
    gap> Binomial( 50, 10 );
    10272278170 </pre>
<P>
<code>NrCombinations</code> (see <a href="chap047.htm#SECT006">Combinations</a>) is the generalization of <code>Binomial</code>
for multisets.  <code>Combinations</code> (see <a href="chap047.htm#SECT006">Combinations</a>)  computes the set  of
all combinations of a multiset.
<P><A NAME="SECT003"><h2>47.3 Bell</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>Bell( <var>n</var> )</code>
<P>
<code>Bell</code> returns the <strong>Bell number</strong> <I>B(n)</I>.  The Bell numbers are defined by
<I>B(0)=1</I> and the recurrence <I>B(n+1) = &sum;<sub>k=0</sub><sup>n</sup>{n \choose kB(k)}</I>.
<P>
<I>B(n)</I> is the  number of ways to  partition a  set of <var>n</var>   elements into
pairwise disjoint  nonempty subsets  (see <a href="chap047.htm#SECT012">PartitionsSet</a>).  This implies
of  course that   <I>B(n) =  &sum;<sub>k=0</sub><sup>n</sup>S<sub>2</sub>(n,k)</I>  (see  <a href="chap047.htm#SECT005">Stirling2</a>).
<I>B(n)/n!</I> is the coefficient of  <I>x<sup>n</sup></I> in the formal series  <I>e<sup>e<sup>x</sup>-1</sup></I>,
which is the generating function for <I>B(n)</I>.
<P>
<pre>    gap> List( [0..6], n -> Bell( n ) );
    [ 1, 1, 2, 5, 15, 52, 203 ]
    gap> Bell( 14 );
    190899322 </pre>
<P><A NAME="SECT004"><h2>47.4 Stirling1</h2></a>
<P><P>
<A name = "I5"></a>

<A name = "I6"></a>

<P>
<code>Stirling1( <var>n</var>, <var>k</var> )</code>
<P>
<code>Stirling1</code> returns the <strong>Stirling number of the first kind</strong> <I>S<sub>1</sub>(n,k)</I> of
the integers <var>n</var> and <var>k</var>.  Stirling numbers of the first kind are defined
by <I>S<sub>1</sub>(0,0)  = 1</I>, <I>S<sub>1</sub>(n,0) =  S<sub>1</sub>(0,k) = 0</I>  if  <I>n, k &lt;&gt; 0</I>  and the
recurrence <I>S<sub>1</sub>(n,k) = (n-1) S<sub>1</sub>(n-1,k) + S<sub>1</sub>(n-1,k-1)</I>.
<P>
<I>S<sub>1</sub>(n,k)</I> is the number  of permutations of  <var>n</var> points with <var>k</var> cycles.
Stirling numbers of  the first kind  appear as coefficients in the series
<I>n! x \choose n = &sum;<sub>k=0</sub><sup>n</sup>S<sub>1</sub>(n,k) x<sup>k</sup></I> which is the generating
function for Stirling numbers of the first kind.  Note  the similarity to
<I>x<sup>n</sup> =  &sum;<sub>k=0</sub><sup>n</sup>{S<sub>2</sub>(n,k) k!  x  \choose k}</I>  (see  <a href="chap047.htm#SECT005">Stirling2</a>).
Also the definition of <I>S<sub>1</sub></I> implies <I>S<sub>1</sub>(n,k) = S<sub>2</sub>(-k,-n)</I> if <I>n,k&lt;0</I>.
There are  many  formulae relating Stirling numbers of  the first kind to
Stirling numbers of the second kind, Bell numbers, and Binomial numbers.
<P>
<pre>    gap> List( [0..4], k->Stirling1( 4, k ) );
    [ 0, 6, 11, 6, 1 ]    # Knuth calls this the trademark of <I>S<sub>1</sub></I>
    gap> List( [0..6], n->List( [0..6], k->Stirling1( n, k ) ) );;
    gap> PrintArray( last );
    [ [    1,    0,    0,    0,    0,    0,    0 ],    # Note the similarity
      [    0,    1,    0,    0,    0,    0,    0 ],    # with Pascal's
      [    0,    1,    1,    0,    0,    0,    0 ],    # triangle for the
      [    0,    2,    3,    1,    0,    0,    0 ],    # Binomial numbers
      [    0,    6,   11,    6,    1,    0,    0 ],
      [    0,   24,   50,   35,   10,    1,    0 ],
      [    0,  120,  274,  225,   85,   15,    1 ] ]
    gap> Stirling1(50,10);
    101623020926367490059043797119309944043405505380503665627365376 </pre>
<P><A NAME="SECT005"><h2>47.5 Stirling2</h2></a>
<P><P>
<A name = "I7"></a>

<A name = "I8"></a>

<P>
<code>Stirling2( <var>n</var>, <var>k</var> )</code>
<P>
<code>Stirling2</code> returns the <strong>Stirling number of  the  second kind</strong> <I>S<sub>2</sub>(n,k)</I>
of the integers <var>n</var>  and <var>k</var>.  Stirling  numbers  of the second  kind are
defined by <I>S<sub>2</sub>(0,0) = 1</I>, <I>S<sub>2</sub>(n,0) = S<sub>2</sub>(0,k) = 0</I> if <I>n,  k &lt;&gt; 0</I> and
the recurrence <I>S<sub>2</sub>(n,k) = k S<sub>2</sub>(n-1,k) + S<sub>2</sub>(n-1,k-1)</I>.
<P>
<I>S<sub>2</sub>(n,k)</I> is the number of ways to partition a set of <var>n</var>  elements into
<var>k</var> pairwise disjoint nonempty  subsets  (see <a href="chap047.htm#SECT012">PartitionsSet</a>).  Stirling
numbers of the second kind  appear as  coefficients  in the  expansion of
<I>x<sup>n</sup> = &sum;<sub>k=0</sub><sup>n</sup>{S<sub>2</sub>(n,k) k!  x  \choose k}</I>.  Note the similarity
to <I>n! x \choose  n = &sum;<sub>k=0</sub><sup>n</sup>S<sub>1</sub>(n,k) x<sup>k</sup></I> (see  <a href="chap047.htm#SECT004">Stirling1</a>).
Also the definition of <I>S<sub>2</sub></I> implies <I>S<sub>2</sub>(n,k) = S<sub>1</sub>(-k,-n)</I> if <I>n,k&lt;0</I>.
There are many formulae relating  Stirling numbers of  the second kind to
Stirling numbers of the first kind, Bell numbers, and Binomial numbers.
<P>
<pre>    gap> List( [0..4], k->Stirling2( 4, k ) );
    [ 0, 1, 7, 6, 1 ]    # Knuth calls this the trademark of <I>S<sub>2</sub></I>
    gap> List( [0..6], n->List( [0..6], k->Stirling2( n, k ) ) );;
    gap> PrintArray( last );
    [ [   1,   0,   0,   0,   0,   0,   0 ],    # Note the similarity with
      [   0,   1,   0,   0,   0,   0,   0 ],    # Pascal's triangle for
      [   0,   1,   1,   0,   0,   0,   0 ],    # the Binomial numbers
      [   0,   1,   3,   1,   0,   0,   0 ],
      [   0,   1,   7,   6,   1,   0,   0 ],
      [   0,   1,  15,  25,  10,   1,   0 ],
      [   0,   1,  31,  90,  65,  15,   1 ] ]
    gap> Stirling2( 50, 10 );
    26154716515862881292012777396577993781727011 </pre>
<P><A NAME="SECT006"><h2>47.6 Combinations</h2></a>
<P><P>
<A name = "I9"></a>
<A name = "I10"></a>
<A name = "I11"></a>

<P>
<code>Combinations( <var>mset</var> )</code> <BR> 
<code>Combinations( <var>mset</var>, <var>k</var> )</code>
<P>
<code>NrCombinations( <var>mset</var> )</code> <BR> 
<code>NrCombinations( <var>mset</var>, <var>k</var> )</code>
<P>
In the  first form <code>Combinations</code> returns the  set of all combinations of
the multiset  <var>mset</var>.  In the  second form <code>Combinations</code> returns the set
of all combinations of the multiset <var>mset</var> with <var>k</var> elements.
<P>
In the first form <code>NrCombinations</code>  returns the number of combinations of
the multiset  <var>mset</var>.   In the  second form  <code>NrCombinations</code> returns the
number of combinations of the multiset <var>mset</var> with <var>k</var> elements.
<P>
A <strong>combination</strong> of  <var>mset</var> is an  unordered selection without repetitions
and is represented by a sorted sublist of <var>mset</var>.   If <var>mset</var> is a proper
set, there  are  <I>|mset| \choose  k</I>  (see  <a href="chap047.htm#SECT002">Binomial</a>)  combinations
with <var>k</var> elements, and the set of all combinations is just the <strong>powerset</strong>
of <var>mset</var>, which contains all   <strong>subsets</strong> of <var>mset</var>  and has  cardinality
<I>2<sup>|mset|</sup></I>.
<P>
<pre>    gap> Combinations( [1,2,2,3] );
    [ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ],
      [ 1, 3 ], [ 2 ], [ 2, 2 ], [ 2, 2, 3 ], [ 2, 3 ], [ 3 ] ]
    gap> NrCombinations( [1..52], 5 );
    2598960    # number of different hands in a game of poker </pre>
<P>
The   function <code>Arrangements</code>   (see  <a href="chap047.htm#SECT007">Arrangements</a>)   computes  ordered
selections without repetitions, <code>UnorderedTuples</code> (see <a href="chap047.htm#SECT008">UnorderedTuples</a>)
computes  unordered  selections  with   repetitions  and <code>Tuples</code>    (see
<a href="chap047.htm#SECT009">Tuples</a>) computes ordered selections with repetitions.
<P><A NAME="SECT007"><h2>47.7 Arrangements</h2></a>
<P><P><P>
<code>Arrangements( <var>mset</var> )</code> <BR> 
<code>Arrangements( <var>mset</var>, <var>k</var> )</code>
<P>
<code>NrArrangements( <var>mset</var> )</code> <BR> 
<code>NrArrangements( <var>mset</var>, <var>k</var> )</code>
<P>
In the first form  <code>Arrangements</code> returns the  set of arrangements of the
multiset  <var>mset</var>.   In the second  form <code>Arrangements</code> returns the set of
all arrangements with <var>k</var> elements of the multiset <var>mset</var>.
<P>
In the first form <code>NrArrangements</code> returns the  number of arrangements of
the  multiset <var>mset</var>.   In  the second form  <code>NrArrangements</code> returns the
number of arrangements with <var>k</var> elements of the multiset <var>mset</var>.
<P>
An  <strong>arrangement</strong> of <var>mset</var>  is an ordered selection  without repetitions
and is represented by a list that contains only elements from <var>mset</var>, but
maybe  in a different  order.   If <var>mset</var>  is  a proper  set   there  are
<I>|mset|!  /  (|mset|-k)!</I> (see  <a href="chap047.htm#SECT001">Factorial</a>)  arrangements  with  <var>k</var>
elements.
<P>
As an example of arrangements of a multiset, think  of the game Scrabble.
Suppose you have the six characters of the word <code>settle</code>  and you have to
make a four letter word.  Then the possibilities are given by
<P>
<pre>    gap> Arrangements( ["s","e","t","t","l","e"], 4 );
    [ [ "e", "e", "l", "s" ], [ "e", "e", "l", "t" ],
      [ "e", "e", "s", "l" ], [ "e", "e", "s", "t" ],
      # 96 more possibilities
      [ "t", "t", "s", "e" ], [ "t", "t", "s", "l" ] ] </pre>
<P>
Can you find the five proper English words, where <code>lets</code> does  not count?
Note that the fact that the  list  returned by <code>Arrangements</code> is a proper
set means in this example that the possibilities are  listed in  the same
order as they appear in the dictionary.
<P>
<pre>    gap> NrArrangements( ["s","e","t","t","l","e"] );
    523 </pre>
<P>
The   function  <code>Combinations</code>  (see  <a href="chap047.htm#SECT006">Combinations</a>)  computes unordered
selections without repetitions, <code>UnorderedTuples</code> (see <a href="chap047.htm#SECT008">UnorderedTuples</a>)
computes  unordered   selections  with   repetitions  and  <code>Tuples</code>  (see
<a href="chap047.htm#SECT009">Tuples</a>) computes ordered selections with repetitions.
<P><A NAME="SECT008"><h2>47.8 UnorderedTuples</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>UnorderedTuples( <var>set</var>, <var>k</var> )</code>
<P>
<code>NrUnorderedTuples( <var>set</var>, <var>k</var> )</code>
<P>
<code>UnorderedTuples</code> returns the  set of all  unordered tuples of length <var>k</var>
of the set <var>set</var>.
<P>
<code>NrUnorderedTuples</code> returns the number of unordered  tuples of length <var>k</var>
of the set <var>set</var>.
<P>
An <strong>unordered tuple</strong> of length <var>k</var> of <var>set</var> is a unordered selection with
repetitions  of <var>set</var> and  is represented by a sorted  list of length <var>k</var>
containing  elements  from  <var>set</var>.   There  are <I>|set|+k-1 \choose k</I>
(see <a href="chap047.htm#SECT002">Binomial</a>) such unordered tuples.
<P>
Note that the fact that <code>UnOrderedTuples</code> returns a set  implies that the
last  index runs   fastest.   That means the   first  tuple  contains the
smallest element from <var>set</var>   <var>k</var> times,  the  second tuple  contains the
smallest element of <var>set</var> at all  positions except at the last positions,
where it contains the second smallest element from <var>set</var> and so on.
<P>
As an example for unordered tuples think of a poker-like game played with
5  dice.  Then each possible hand corresponds to an  unordered five-tuple
from the set [1..6]
<P>
<pre>    gap> NrUnorderedTuples( [1..6], 5 );
    252
    gap> UnorderedTuples( [1..6], 5 );
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 2 ], [ 1, 1, 1, 1, 3 ],
      [ 1, 1, 1, 1, 4 ], [ 1, 1, 1, 1, 5 ], [ 1, 1, 1, 1, 6 ],
      # 99 more tuples
      [ 1, 3, 4, 5, 6 ], [ 1, 3, 4, 6, 6 ], [ 1, 3, 5, 5, 5 ],
      # 99 more tuples
      [ 3, 3, 4, 4, 5 ], [ 3, 3, 4, 4, 6 ], [ 3, 3, 4, 5, 5 ],
      # 39 more tuples
      [ 5, 5, 6, 6, 6 ], [ 5, 6, 6, 6, 6 ], [ 6, 6, 6, 6, 6 ] ] </pre>
<P>
The function  <code>Combinations</code>  (see  <a href="chap047.htm#SECT006">Combinations</a>)   computes  unordered
selections  without  repetitions,    <code>Arrangements</code> (see  <a href="chap047.htm#SECT007">Arrangements</a>)
computes ordered   selections without  repetitions   and   <code>Tuples</code>  (see
<a href="chap047.htm#SECT009">Tuples</a>) computes ordered selections with repetitions.
<P><A NAME="SECT009"><h2>47.9 Tuples</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>Tuples( <var>set</var>, <var>k</var> )</code>
<P>
<code>NrTuples( <var>set</var>, <var>k</var> )</code>
<P>
<code>Tuples</code> returns the set of all ordered tuples  of length <var>k</var> of  the set
<var>set</var>.
<P>
<code>NrTuples</code> returns the number of all ordered tuples  of length <var>k</var> of the
set <var>set</var>.
<P>
An <strong>ordered tuple</strong> of  length <var>k</var> of <var>set</var> is  an ordered selection  with
repetition and is represented by a list of length <var>k</var> containing elements
of <var>set</var>.  There are <I>|set|<sup>k</sup></I> such ordered tuples.
<P>
Note that the fact  that <code>Tuples</code> returns  a  set implies that   the last
index runs  fastest.  That means  the first tuple   contains the smallest
element from <var>set</var> <var>k</var>  times,  the  second tuple  contains the  smallest
element of <var>set</var> at all positions except at the  last positions, where it
contains the second smallest element from <var>set</var> and so on.
<P>
<pre>    gap> Tuples( [1,2,3], 2 );
    [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
      [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ]
    gap> NrTuples( [1..10], 5 );
    100000 </pre>
<P>
<code>Tuples(<var>set</var>,<var>k</var>)</code> can also be viewed  as the <var>k</var>-fold cartesian product
of <var>set</var> (see <a href="chap027.htm#SECT026">Cartesian</a>).
<P>
The  function  <code>Combinations</code>  (see  <a href="chap047.htm#SECT006">Combinations</a>)  computes  unordered
selections  without   repetitions,  <code>Arrangements</code>  (see  <a href="chap047.htm#SECT007">Arrangements</a>)
computes ordered selections without repetitions, and finally the function
<code>UnorderedTuples</code> (see <a href="chap047.htm#SECT008">UnorderedTuples</a>)  computes unordered  selections
with repetitions.
<P><A NAME="SECT010"><h2>47.10 PermutationsList</h2></a>
<P><P>
<A name = "I14"></a>
<A name = "I15"></a>

<P>
<code>PermutationsList( <var>mset</var> )</code>
<P>
<code>NrPermutationsList( <var>mset</var> )</code>
<P>
<code>PermutationsList</code> returns the   set   of permutations of    the multiset
<var>mset</var>.
<P>
<code>NrPermutationsList</code> returns the  number of permutations  of the multiset
<var>mset</var>.
<P>
A <strong>permutation</strong> is represented by a  list  that contains exactly the same
elements as  <var>mset</var>,  but possibly in   different order.  If <var>mset</var>  is a
proper  set there are <I>|mset| !</I> (see <a href="chap047.htm#SECT001">Factorial</a>)  such  permutations.
Otherwise if the  first elements appears <I>k<sub>1</sub></I>  times, the second element
appears  <I>k<sub>2</sub></I>  times   and   so  on,  the  number   of   permutations is
<I>|mset|! /  (k<sub>1</sub>! k<sub>2</sub>! ..)</I>,  which  is  sometimes  called  multinomial
coefficient.
<P>
<pre>    gap> PermutationsList( [1,2,3] );
    [ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ],
      [ 3, 2, 1 ] ]
    gap> PermutationsList( [1,1,2,2] );
    [ [ 1, 1, 2, 2 ], [ 1, 2, 1, 2 ], [ 1, 2, 2, 1 ], [ 2, 1, 1, 2 ],
      [ 2, 1, 2, 1 ], [ 2, 2, 1, 1 ] ]
    gap> NrPermutationsList( [1,2,2,3,3,3,4,4,4,4] );
    12600 </pre>
<P>
The function <code>Arrangements</code> (see <a href="chap047.htm#SECT007">Arrangements</a>) is the generalization of
<code>PermutationsList</code>   that  allows  you  to specify   the  size   of   the
permutations.  <code>Derangements</code> (see <a href="chap047.htm#SECT011">Derangements</a>) computes  permutations
that have no fixpoints.
<P><A NAME="SECT011"><h2>47.11 Derangements</h2></a>
<P><P>
<A name = "I16"></a>
<A name = "I17"></a>

<P>
<code>Derangements( <var>list</var> )</code>
<P>
<code>NrDerangements( <var>list</var> )</code>
<P>
<code>Derangements</code> returns the set of all derangements of the list <var>list</var>.
<P>
<code>NrDerangements</code> returns the number of derangements of the list <var>list</var>.
<P>
A   <strong>derangement</strong> is  a   fixpointfree  permutation  of   <var>list</var>   and is
represented by a list that contains exactly the  same elements as <var>list</var>,
but in such  an order  that the  derangement has at  no position the same
element as  <var>list</var>.  If the  list  <var>list</var> contains no element twice there
are  exactly  <I>|list|!  (1/2!   -  1/3!    +  1/4!  -  ..   (-1)<sup>n</sup>/n!)</I>
derangements.
<P>
Note that the  ratio <code>NrPermutationsList([1..n])/NrDerangements([1..n])</code>,
which  is  <I>n!  /  (n!   (1/2!  -  1/3!  + 1/4!  - .. (-1)<sup>n</sup>/n!))</I>  is an
approximation for the base of the natural logarithm  <I>e =  2.7182818285</I>,
which is correct to about <I>n</I> digits.
<P>
As an  example of  derangements suppose    that  you have  to  send  four
different letters  to   four  different  people.    Then  a   derangement
corresponds  to a way  to send those letters such  that no letter reaches
the intended person.
<P>
<pre>    gap> Derangements( [1,2,3,4] );
    [ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ],
      [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ],
      [ 4, 3, 2, 1 ] ]
    gap> NrDerangements( [1..10] );
    1334961
    gap> Int( 10^7*NrPermutationsList([1..10])/last );
    27182816
    gap> Derangements( [1,1,2,2,3,3] );
    [ [ 2, 2, 3, 3, 1, 1 ], [ 2, 3, 1, 3, 1, 2 ], [ 2, 3, 1, 3, 2, 1 ],
      [ 2, 3, 3, 1, 1, 2 ], [ 2, 3, 3, 1, 2, 1 ], [ 3, 2, 1, 3, 1, 2 ],
      [ 3, 2, 1, 3, 2, 1 ], [ 3, 2, 3, 1, 1, 2 ], [ 3, 2, 3, 1, 2, 1 ],
      [ 3, 3, 1, 1, 2, 2 ] ]
    gap> NrDerangements( [1,2,2,3,3,3,4,4,4,4] );
    338 </pre>
<P>
The function  <code>PermutationsList</code>  (see  <a href="chap047.htm#SECT010">PermutationsList</a>)  computes all
permutations of a list.
<P><A NAME="SECT012"><h2>47.12 PartitionsSet</h2></a>
<P><P>
<A name = "I18"></a>
<A name = "I19"></a>

<P>
<code>PartitionsSet( <var>set</var> )</code> <BR> 
<code>PartitionsSet( <var>set</var>, <var>k</var> )</code>
<P>
<code>NrPartitionsSet( <var>set</var> )</code> <BR> 
<code>NrPartitionsSet( <var>set</var>, <var>k</var> )</code>
<P>
In  the first  form  <code>PartitionsSet</code>  returns the  set  of  all unordered
partitions of the set <var>set</var>.   In the second form <code>PartitionsSet</code> returns
the set of  all unordered partitions of the  set <var>set</var> into  <var>k</var> pairwise
disjoint nonempty sets.
<P>
In  the first  form  <code>NrPartitionsSet</code> returns   the number of  unordered
partitions of   the  set <var>set</var>.   In  the  second  form <code>NrPartitionsSet</code>
returns  the number of  unordered  partitions of  the  set <var>set</var> into <var>k</var>
pairwise disjoint nonempty sets.
<P>
An <strong>unordered partition</strong> of <var>set</var> is  a set of pairwise disjoint nonempty
sets with union <var>set</var>  and is represented by  a sorted list of such sets.
There are <I>B( |set| )</I> (see <a href="chap047.htm#SECT003">Bell</a>) partitions of  the  set  <var>set</var>  and
<I>S<sub>2</sub>( |set|, k )</I> (see <a href="chap047.htm#SECT005">Stirling2</a>) partitions with <var>k</var> elements.
<P>
<pre>    gap> PartitionsSet( [1,2,3] );
    [ [ [ 1 ], [ 2 ], [ 3 ] ], [ [ 1 ], [ 2, 3 ] ], [ [ 1, 2 ], [ 3 ] ],
      [ [ 1, 2, 3 ] ], [ [ 1, 3 ], [ 2 ] ] ]
    gap> PartitionsSet( [1,2,3,4], 2 );
    [ [ [ 1 ], [ 2, 3, 4 ] ], [ [ 1, 2 ], [ 3, 4 ] ],
      [ [ 1, 2, 3 ], [ 4 ] ], [ [ 1, 2, 4 ], [ 3 ] ],
      [ [ 1, 3 ], [ 2, 4 ] ], [ [ 1, 3, 4 ], [ 2 ] ],
      [ [ 1, 4 ], [ 2, 3 ] ] ]
    gap> NrPartitionsSet( [1..6] );
    203
    gap> NrPartitionsSet( [1..10], 3 );
    9330 </pre>
<P>
Note  that <code>PartitionsSet</code> does currently  not support multisets and that
there is currently no ordered counterpart.
<P><A NAME="SECT013"><h2>47.13 Partitions</h2></a>
<P><P>
<A name = "I20"></a>
<A name = "I21"></a>

<P>
<code>Partitions( <var>n</var> )</code> <BR> 
<code>Partitions( <var>n</var>, <var>k</var> )</code>
<P>
<code>NrPartitions( <var>n</var> )</code> <BR> 
<code>NrPartitions( <var>n</var>, <var>k</var> )</code>
<P>
In  the  first  form <code>Partitions</code>   returns  the set  of all  (unordered)
partitions of the positive integer  <var>n</var>.  In the second form <code>Partitions</code>
returns the set of all (unordered) partitions of the positive integer <var>n</var>
into sums with <var>k</var> summands.
<P>
In   the first form  <code>NrPartitions</code>  returns   the number of  (unordered)
partitions    of  the   positive integer   <var>n</var>.     In   the second  form
<code>NrPartitions</code> returns the     number of (unordered) partitions  of   the
positive integer <var>n</var> into sums with <var>k</var> summands.
<P>
An <strong>unordered partition</strong> is an  unordered sum <I>n =  p<sub>1</sub>+p<sub>2</sub> +..+ p<sub>k</sub></I>  of
positive integers and is represented by the list  <I>p = [p<sub>1</sub>,p<sub>2</sub>,..,p<sub>k</sub>]</I>,
in nonincreasing order, i.e., <I>p<sub>1</sub>&gt;=p<sub>2</sub>&gt;=..&gt;=p<sub>k</sub></I>.  We write <I>p\vdash n</I>.
There   are approximately <I>E<sup>{&pi; &radic;2/3 n}</sup>    / {4 &radic;3 n}</I> such
partitions.
<P>
It  is possible to  associate with every partition  of the integer  <var>n</var> a
conjugacy class of permutations in the symmetric group on <var>n</var>  points and
vice  versa.   Therefore <I>p(n) :=   NrPartitions(n)</I>  is  the  number of
conjugacy classes of the symmetric group on <var>n</var> points.
<P>
Ramanujan found the identities <I>p(5i+4) = 0</I> mod 5, <I>p(7i+5) = 0</I>  mod  7
and  <I>p(11i+6) = 0</I> mod 11 and many  other  fascinating  things about the
number of partitions.
<P>
Do not call <code>Partitions</code> with an <var>n</var> much larger than 40, in  which  case
there are 37338 partitions, since the list will simply become too large.
<P>
<pre>    gap> Partitions( 7 );
    [ [ 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1 ],
      [ 2, 2, 2, 1 ], [ 3, 1, 1, 1, 1 ], [ 3, 2, 1, 1 ], [ 3, 2, 2 ],
      [ 3, 3, 1 ], [ 4, 1, 1, 1 ], [ 4, 2, 1 ], [ 4, 3 ], [ 5, 1, 1 ],
      [ 5, 2 ], [ 6, 1 ], [ 7 ] ]
    gap> Partitions( 8, 3 );
    [ [ 3, 3, 2 ], [ 4, 2, 2 ], [ 4, 3, 1 ], [ 5, 2, 1 ], [ 6, 1, 1 ] ]
    gap> NrPartitions( 7 );
    15
    gap> NrPartitions( 100 );
    190569292 </pre>
<P>
The function <code>OrderedPartitions</code> (see <a href="chap047.htm#SECT014">OrderedPartitions</a>) is the ordered
counterpart of <code>Partitions</code>.
<P><A NAME="SECT014"><h2>47.14 OrderedPartitions</h2></a>
<P><P>
<A name = "I22"></a>

<A name = "I23"></a>

<A name = "I24"></a>

<P>
<code>OrderedPartitions( <var>n</var> )</code> <BR> 
<code>OrderedPartitions( <var>n</var>, <var>k</var> )</code>
<P>
<code>NrOrderedPartitions( <var>n</var> )</code> <BR> 
<code>NrOrderedPartitions( <var>n</var>, <var>k</var> )</code>
<P>
In the  first  form <code>OrderedPartitions</code>  returns the  set  of all ordered
partitions  of  the  positive    integer  <var>n</var>.    In  the   second   form
<code>OrderedPartitions</code> returns the  set  of  all ordered partitions  of  the
positive integer <var>n</var> into sums with <var>k</var> summands.
<P>
In the first form  <code>NrOrderedPartitions</code>  returns the number of   ordered
partitions  of  the   positive   integer   <var>n</var>.   In the    second   form
<code>NrOrderedPartitions</code> returns  the number  of ordered  partitions  of the
positive integer <var>n</var> into sums with <var>k</var> summands.
<P>
An <strong>ordered partition</strong> is an ordered sum <I>n = p<sub>1</sub> + p<sub>2</sub> + ..   +  p<sub>k</sub></I> of
positive integers and is represented by the list <I>[ p<sub>1</sub>, p<sub>2</sub>, .., p<sub>k</sub> ]</I>.
There are  totally <I>2<sup>n-1</sup></I> ordered  partitions  and <I>n-1 \choose k-1</I>
(see <a href="chap047.htm#SECT002">Binomial</a>) partitions with <var>k</var> summands.
<P>
Do not call <code>OrderedPartitions</code> with an <var>n</var>  larger  than  15,  the  list
will simply become too large.
<P>
<pre>    gap> OrderedPartitions( 5 );
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 1, 3 ],
      [ 1, 2, 1, 1 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 1, 4 ], [ 2, 1, 1, 1 ],
      [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 3 ], [ 3, 1, 1 ], [ 3, 2 ], 
      [ 4, 1 ], [ 5 ] ]
    gap> OrderedPartitions( 6, 3 );
    [ [ 1, 1, 4 ], [ 1, 2, 3 ], [ 1, 3, 2 ], [ 1, 4, 1 ], [ 2, 1, 3 ],
      [ 2, 2, 2 ], [ 2, 3, 1 ], [ 3, 1, 2 ], [ 3, 2, 1 ], [ 4, 1, 1 ] ]
    gap> NrOrderedPartitions(20);
    524288 </pre>
<P>
The function <code>Partitions</code> (see <a href="chap047.htm#SECT013">Partitions</a>) is the unordered counterpart
of <code>OrderedPartitions</code>.
<P><A NAME="SECT015"><h2>47.15 RestrictedPartitions</h2></a>
<P><P>
<A name = "I25"></a>

<A name = "I26"></a>

<P>
<code>RestrictedPartitions( <var>n</var>, <var>set</var> )</code> <BR> 
<code>RestrictedPartitions( <var>n</var>, <var>set</var>, <var>k</var> )</code>
<P>
<code>NrRestrictedPartitions( <var>n</var>, <var>set</var> )</code> <BR> 
<code>NrRestrictedPartitions( <var>n</var>, <var>set</var>, <var>k</var> )</code>
<P>
In the   first  form  <code>RestrictedPartitions</code>   returns   the set   of all
restricted  partitions of the positive integer  <var>n</var>  with the summands of
the   partition  coming  from the    set  <var>set</var>.   In    the second  form
<code>RestrictedPartitions</code> returns the set of all  partitions of the positive
integer <var>n</var> into   sums  with <var>k</var>  summands   with the summands  of   the
partition coming from the set <var>set</var>.
<P>
In  the first  form    <code>NrRestrictedPartitions</code>  returns the  number   of
restricted partitions of  the   positive integer <var>n</var>  with  the  summands
coming from the  set <var>set</var>.  In  the second form <code>NrRestrictedPartitions</code>
returns the number of restricted  partitions of the positive integer  <var>n</var>
into sums  with <var>k</var> summands  with the  summands  of the partition coming
from the set <var>set</var>.
<P>
A <strong>restricted partition</strong> is like an ordinary partition (see <a href="chap047.htm#SECT013">Partitions</a>)
an  unordered  sum <I>n =  p<sub>1</sub>+p<sub>2</sub> +..+  p<sub>k</sub></I> of  positive  integers and is
represented by the list  <I>p =  [p<sub>1</sub>,p<sub>2</sub>,..,p<sub>k</sub>]</I>, in nonincreasing order.
The difference is that  here  the <I>p<sub>i</sub></I> must   be elements from the   set
<var>set</var>, while for ordinary partitions they may be elements from <code>[1..n]</code>.
<P>
<pre>    gap> RestrictedPartitions( 8, [1,3,5,7] );
    [ [ 1, 1, 1, 1, 1, 1, 1, 1 ], [ 3, 1, 1, 1, 1, 1 ], [ 3, 3, 1, 1 ],
      [ 5, 1, 1, 1 ], [ 5, 3 ], [ 7, 1 ] ]
    gap> NrRestrictedPartitions( 50, [1,5,10,25,50] );
    50 </pre>
<P>
The last example tells us that there are 50 ways to return 50 cent change
using 1, 5, 10 cent coins, quarters and halfdollars.
<P><A NAME="SECT016"><h2>47.16 SignPartition</h2></a>
<P><P><P>
<code>SignPartition( <var>pi</var> )</code>
<P>
returns the sign of a permutation with cycle structure <var>pi</var>.
<P>
<pre>    gap> SignPartition([6,5,4,3,2,1]);
    -1</pre>
<P>
This function actually describes  a homomorphism of  the  symmetric group
<I>S<sub>n</sub></I> into  the  cyclic group of order  2,  whose  kernel  is exactly the
alternating  group <I>A<sub>n</sub></I>  (see <a href="chap020.htm#SECT006">SignPerm</a>).  Partitions  of  sign  1  are
called <strong>even</strong> partitions while partitions of sign <I>-1</I> are called <strong>odd</strong>.
<P><A NAME="SECT017"><h2>47.17 AssociatedPartition</h2></a>
<P><P><P>
<code>AssociatedPartition( <var>pi</var> )</code>
<P>
returns the associated partition of the partition <var>pi</var>.
<P>
<pre>    gap> AssociatedPartition([4,2,1]);
    [ 3, 2, 1, 1 ]
    gap> AssociatedPartition([6]);
    [ 1, 1, 1, 1, 1, 1 ]</pre>
<P>
The  <strong>associated  partition</strong>  of a  partition  <var>pi</var> is  defined to be the
partition belonging to the transposed of the Young diagram of <var>pi</var>.
<P><A NAME="SECT018"><h2>47.18 BetaSet</h2></a>
<P><P><P>
<code>BetaSet( <var>p</var> )</code>
<P>
Here  <var>p</var>  is  a  partition  (a  non-increasing list of positive integers).
<code>BetaSet</code> returns the corresponding nomalized Beta set.
<P>
<pre>    gap> BetaSet([3,3,1]);
      [ 1, 4, 5 ]</pre>
<P>
A  beta-set is a  set of positive  integers, up to  the <strong>shift</strong> equivalence
relation.  This  equivalence  relation  is  the  transitive  closure of the
elementary  equivalence of <I>[s<sub>1</sub>,...,s<sub>n</sub>]</I> and <I>[0,1+s<sub>1</sub>,...,1+s<sub>n</sub>]</I>.
An equivalence class has exactly one member which does not contain <I>0</I>: it
is  called the normalized beta-set.  To a partition <I>p<sub>1</sub> &ge; p<sub>2</sub> &ge;... &ge;
p<sub>n</sub>&gt;0</I>  is  associated  a  beta-set,  whose  normalized  representative  is
<I>p<sub>n</sub>,p<sub>n-1</sub>+1,...,p<sub>1</sub>+n-1</I>.
<P><A NAME="SECT019"><h2>47.19 Dominates</h2></a>
<P><P><P>
<code>Dominates(<var><I>&mu;</I></var>, <var><I>&nu;</I></var>)</code>
<P>
The  dominance  ordering  is  an  important partial order in representation
theory.    <code>Dominates(<var><I>&mu;</I></var>,   <var><I>&nu;</I></var>)</code>   returns   <code>true</code>   if   either
<var><I>&mu;</I></var>=<var><I>&nu;</I></var> or for all <I>i &ge; 1</I>,
<I>&sum;<sub>j=1</sub><sup>i</sup>&mu;<sub>j</sub> &ge;&sum;<sub>j=1</sub><sup>i</sup>&nu;<sub>j</sub></I>, and <code>false</code> otherwise.
<P>
<pre>gap> Dominates([5,4],[4,4,1]);
true</pre>
<P><A NAME="SECT020"><h2>47.20 PowerPartition</h2></a>
<P><A name = "I27"></a>

<P>
<code>PowerPartition( <var>pi</var>, <var>k</var> )</code>
<P>
returns the  partition corresponding to the <var>k</var>-th power of a permutation
with cycle structure <var>pi</var>.
<P>
<pre>    gap> PowerPartition([6,5,4,3,2,1], 3);
    [ 5, 4, 2, 2, 2, 2, 1, 1, 1, 1 ]</pre>
<P>
Each part <I>l</I> of <var>pi</var> is replaced by <I>d = </I>gcd<I>(l, k)</I> parts <I>l/d</I>.  So if
<var>pi</var> is a partition of <I>n</I> then <I>&lt;pi&gt;<sup><var>k</var></sup></I> also is a partition of  <I>n</I>.
<code>PowerPartition</code>  describes  the  powermap  of  symmetric   groups.
<P><A NAME="SECT021"><h2>47.21 PartitionTuples</h2></a>
<P><P>
<A name = "I28"></a>

<A name = "I29"></a>

<P>
<code>PartitionTuples( <var>n</var>, <var>r</var> )</code>
<P>
<code>NrPartitionTuples( <var>n</var>, <var>r</var> )</code>
<P>
<code>PartitionTuples(  <var>n</var>,  <var>r</var>  )</code>  returns  the  list  of all <var>r</var>--tuples of
partitions  that together  partition <var>n</var>.  <code>NrPartitionTuples</code> just returns
their number.
<P>
<pre>    gap> PartitionTuples(3, 2);
    [ [ [ 1, 1, 1 ], [  ] ], [ [ 1, 1 ], [ 1 ] ], [ [ 1 ], [ 1, 1 ] ],
      [ [  ], [ 1, 1, 1 ] ], [ [ 2, 1 ], [  ] ], [ [ 1 ], [ 2 ] ],
      [ [ 2 ], [ 1 ] ], [ [  ], [ 2, 1 ] ], [ [ 3 ], [  ] ],
      [ [  ], [ 3 ] ] ]
    gap> NrPartitionTuples(3,2);
    10</pre>
<P>
<var>r</var>--tuples  of partitions describe the  classes  and  the  characters of
wreath products of groups with  <var>r</var> conjugacy classes with the  symmetric
group <I>S<sub>n</sub></I>.
<P><A NAME="SECT022"><h2>47.22 Fibonacci</h2></a>
<P><P>
<A name = "I30"></a>

<P>
<code>Fibonacci( <var>n</var> )</code>
<P>
<code>Fibonacci</code>  returns  the <var>n</var>th number  of the <strong>Fibonacci sequence</strong>.  The
Fibonacci sequence <I>F<sub>n</sub></I> is defined by the initial conditions <I>F<sub>1</sub>=F<sub>2</sub>=1</I>
and  the recurrence relation  <I>F<sub>n+2</sub> = F<sub>n+1</sub>  + F<sub>n</sub></I>.  For negative
<I>n</I>  we  define <I>F<sub>n</sub> = (-1)<sup>n+1</sup>  F<sub>-n</sub></I>, which  is consistent with the
recurrence relation.
<P>
Using generating functions one can prove that <I>F<sub>n</sub> = &phi;<sup>n</sup>  - 1/&phi;<sup>n</sup></I>,
where  <I>&phi;</I> is <I>(&radic;5 + 1)/2</I>, i.e., one root of <I>x<sup>2</sup> - x - 1 = 0</I>.
Fibonacci  numbers have  the  property <I>Gcd( F<sub>m</sub>,  F<sub>n</sub> ) = F<sub>Gcd(m,n)</sub></I>.
But a pair of Fibonacci numbers requires more division steps in Euclid's
algorithm (see <a href="chap005.htm#SECT026">Gcd</a>) than any  other  pair of integers of the same size.
<code>Fibonnaci(<var>k</var>)</code> is the special case <code>Lucas(1,-1,<var>k</var>)[1]</code> (see <a href="chap047.htm#SECT023">Lucas</a>).
<P>
<pre>    gap> Fibonacci( 10 );
    55
    gap> Fibonacci( 35 );
    9227465
    gap> Fibonacci( -10 );
    -55 </pre>
<P><A NAME="SECT023"><h2>47.23 Lucas</h2></a>
<P><P>
<A name = "I31"></a>

<P>
<code>Lucas( <var>P</var>, <var>Q</var>, <var>k</var> )</code>
<P>
<code>Lucas</code> returns the <var>k</var>-th values of the <strong>Lucas sequence</strong> with parameters
<var>P</var> and <var>Q</var>, which must be integers, as a list of three integers.
<P>
Let <I>&alpha;, &beta;</I> be the two roots of  <I>x<sup>2</sup> - P x + Q</I>  then we  define<BR> 
<I>Lucas( P, Q, k )[1] = U<sub>k</sub> = (&alpha;<sup>k</sup> - &beta;<sup>k</sup>) / (&alpha; - &beta;)</I> and<BR> 
<I>Lucas( P, Q, k )[2] = V<sub>k</sub> = (&alpha;<sup>k</sup> + &beta;<sup>k</sup>)</I>  and as  a convenience<BR> 
<I>Lucas( P, Q, k )[3] = Q<sup>k</sup></I>.
<P>
The following recurrence relations are easily derived from the definition<BR> 
<I>U<sub>0</sub> = 0, U<sub>1</sub> = 1, U<sub>k</sub> = P U<sub>k-1</sub> - Q U<sub>k-2</sub></I> and <BR> 
<I>V<sub>0</sub> = 2, V<sub>1</sub> = P, V<sub>k</sub> = P V<sub>k-1</sub> - Q V<sub>k-2</sub></I>. <BR> 
Those relations are actually used to define <code>Lucas</code> if <I>&alpha; = &beta;</I>.
<P>
Also the more complex relations used in <code>Lucas</code> can be easily derived<BR> 
<I>U<sub>2k</sub> = U<sub>k</sub> V<sub>k</sub>,        U<sub>2k+1</sub> = (P U<sub>2k</sub> + V<sub>2k</sub>) / 2</I> and <BR> 
<I>V<sub>2k</sub> = V<sub>k</sub><sup>2</sup> - 2 Q<sup>k</sup>,  V<sub>2k+1</sub> = ((P<sup>2</sup>-4Q) U<sub>2k</sub> + P V<sub>2k</sub>) / 2</I>.
<P>
<code>Fibonnaci(<var>k</var>)</code> (see <a href="chap047.htm#SECT022">Fibonacci</a>) is simply <code>Lucas(1,-1,<var>k</var>)[1]</code>.  In an
abuse of notation, the sequence  <code>Lucas(1,-1,<var>k</var>)[2]</code> is sometimes called
the Lucas sequence.
<P>
<pre>    gap> List( [0..10], i->Lucas(1,-2,i)[1] );
    [ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341 ]    # <I>2<sup>k</sup> - (-1)<sup>k</sup>)/3</I>
    gap> List( [0..10], i->Lucas(1,-2,i)[2] );
    [ 2, 1, 5, 7, 17, 31, 65, 127, 257, 511, 1025 ]    # <I>2<sup>k</sup> + (-1)<sup>k</sup></I>
    gap> List( [0..10], i->Lucas(1,-1,i)[1] );
    [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]    # Fibonacci sequence
    gap> List( [0..10], i->Lucas(2,1,i)[1] );
    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]    # the roots are equal </pre>
<P><A NAME="SECT024"><h2>47.24 Bernoulli</h2></a>
<P><P>
<A name = "I32"></a>

<P>
<code>Bernoulli( <var>n</var> )</code>
<P>
<code>Bernoulli</code> returns the <var>n</var>-th <strong>Bernoulli number</strong> <I>B<sub>n</sub></I>, which is defined
by <I>B<sub>0</sub> = 1</I> and <I>B<sub>n</sub> = -&sum;<sub>k=0</sub><sup>n-1</sup>{n+1 \choose k B<sub>k</sub>}/(n+1)</I>.
<P>
<I>B<sub>n</sub>/n!</I> is the coefficient of <I>x<sup>n</sup></I>  in the power series of <I>x/e<sup>x</sup>-1</I>.
Except for <I>B<sub>1</sub>=-1/2</I> the Bernoulli numbers for odd indices <I>m</I> are zero.
<P>
<pre>    gap> Bernoulli( 4 );
    -1/30
    gap> Bernoulli( 10 );
    5/66
    gap> Bernoulli( 12 );
    -691/2730    # there is no simple pattern in Bernoulli numbers
    gap> Bernoulli( 50 );
    495057205241079648212477525/66    # and they grow fairly fast </pre>
<P><A NAME="SECT025"><h2>47.25 Permanent</h2></a>
<P><P><P>
<code>Permanent( <var>mat</var> )</code>
<P>
<code>Permanent</code> returns the <strong>permanent</strong> of the matrix  <var>mat</var>.  The  permanent
is defined by <I>&sum;<sub>p &isin; Symm(n)</sub>{&prod;<sub>i=1</sub><sup>n</sup>mat[i][i<sup>p</sup>]}</I>.
<P>
Note the similarity of the definition of  the permanent to the definition
of the determinant.  In  fact the only  difference is the missing sign of
the permutation.  However the  permanent is quite unlike the determinant,
for example   it is  not  multilinear or  alternating.  It   has  however
important combinatorical properties.
<P>
<pre>    gap> Permanent( [[0,1,1,1],
    >                [1,0,1,1],
    >                [1,1,0,1],
    >                [1,1,1,0]] );
    9    # inefficient way to compute <code>NrDerangements([1..4])</code>
    gap> Permanent( [[1,1,0,1,0,0,0],
    >                [0,1,1,0,1,0,0],
    >                [0,0,1,1,0,1,0],
    >                [0,0,0,1,1,0,1],
    >                [1,0,0,0,1,1,0],
    >                [0,1,0,0,0,1,1],
    >                [1,0,1,0,0,0,1]] );
    24    # 24 permutations fit the projective plane of order 2 </pre>
<P><a href ="chap046.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap048.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>