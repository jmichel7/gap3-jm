<html><head><title>GAP3 Manual: 93 Kazhdan-Lusztig polynomials and bases</title></head>
<body bgcolor="ffffff">
<h1>93 Kazhdan-Lusztig polynomials and bases</h1>
<P><P><P>
Let  <I><span style="font-family: cursive">H</span></I> be the  Iwahori-Hecke algebra of  a Coxeter system <I>(W,S)</I>, with
quadratic   relations  <I>(T<sub>s</sub>-u<sub>s,0</sub>)(T<sub>s</sub>-u<sub>s,1</sub>)=0</I>  for   <I>s&isin;  S</I>.  If
<I>-u<sub>s,0</sub>u<sub>s,1</sub></I>  has  a  square  root,  we  can  scale the basis <I>T<sub>s</sub></I> to
<I>-T<sub>s</sub>/&radic;-u<sub>s,0</sub>u<sub>s,1</sub></I>  to  get  a  new  basis  <I>t<sub>s</sub></I> with quadratic
relations <I>(t<sub>s</sub>-v<sub>s</sub>) (t<sub>s</sub>+v<sub>s</sub><sup>-1</sup>)=0</I> where <I>v<sub>s</sub>=&radic;-u<sub>s,0</sub>/u<sub>s,1</sub></I>.
The  most general  case when  Kazhdan-Lusztig bases  and polynomials can be
defined  is when the  parameters <I>v<sub>s</sub></I> belong  to a totally ordered abelian
group  <I>&Gamma;</I> (where the group law  is multiplication of parameters), see
<A href="biblio.htm#Lus83"><cite>Lus83</cite></a>.  We  set  <I>&Gamma;<sup>+</sup>=  {&gamma;&isin;&Gamma;|  &gamma;&gt;0}</I> and
<I>&Gamma;<sup>-</sup>=   {&gamma;<sup>-1</sup>  |&gamma;&isin;&Gamma;<sup>+</sup>}  ={&gamma;&isin;&Gamma;|
&gamma;&lt;0}</I>.
<P>
Thus  we assume <I><span style="font-family: cursive">H</span></I> defined over the ring <I>&#x2124;[&Gamma;]</I>, the group algebra
of  <I>&Gamma;</I> over <I>&#x2124;</I>,  and the quadratic  relations of <I><span style="font-family: cursive">H</span></I> associate to
each  <I>s&isin; S</I> a <I>v<sub>s</sub>&isin;&Gamma;<sup>+</sup></I> such that <I>(t<sub>s</sub>-v<sub>s</sub>)(t<sub>s</sub>+v<sub>s</sub><sup>-1</sup>)=0</I>. We
also  set  <I>q<sub>s</sub>=v<sub>s</sub><sup>2</sup></I>  and  define the basis  <I>T<sub>s</sub>=v<sub>s</sub> t<sub>s</sub></I> with quadratic
relations <I>(T<sub>s</sub>-q<sub>s</sub>)(T<sub>s</sub>+1)=0</I>; we extend the notation to define an element
<I>q<sub>w</sub>&isin;&Gamma;<sub>+</sub></I>  by  setting  <I>q<sub>w</sub>=q<sub>s<sub>1</sub></sub>...  q<sub>s<sub>n</sub></sub></I> if <I>w=s<sub>1</sub>...
s<sub>n</sub></I> is a reduced expression for some <I>w&isin; W</I>, and denote
<I>q<sub>w</sub><sup>(1/2)</sup>=v<sub>s<sub>1</sub></sub>...    v<sub>s<sub>n</sub></sub></I>.
<P>
We  define the  bar involution  on <I><span style="font-family: cursive">H</span></I>  by linearity: on <I>&#x2124;[&Gamma;]</I> we
define      it     by     <I><span style="text-decoration: overline">&sum;<sub>&gamma;&isin;&Gamma;</sub>a<sub>&gamma;</sub>&gamma;</span>=
&sum;<sub>&gamma;&isin;&Gamma;</sub>  a<sub>&gamma;</sub> &gamma;<sup>-1</sup></I> and we  extend it to <I><span style="font-family: cursive">H</span></I> by
<I><span style="text-decoration: overline">T</span><sub>s</sub>=T<sub>s</sub><sup>-1</sup></I>. Then  the Kazhdan-Lusztig  basis <I>C'<sub>w</sub></I> is
defined  as  the  only  basis  of  <I><span style="font-family: cursive">H</span></I>  stable  by the bar involution and
congruent to <I>t<sub>w</sub></I> modulo <I>&sum;<sub>w&isin; W</sub>&Gamma;<sub>-</sub> t<sub>w</sub></I>.
<P>
The  basis  <I>C'<sub>w</sub></I>  can  be  computed  as follows. We define elements
<I>R<sub>x,y</sub></I>   of  <I>&#x2124;[&Gamma;]</I>  by  <I>T<sub>y</sub><sup>-1</sup>=&sum;<sub>x</sub>  <span style="text-decoration: overline">R<sub>x,y<sup>-1</sup></sub></span>
q<sub>x</sub><sup>-1</sup>T<sub>x</sub></I>.  We then  define inductively  the Kazhdan-Lusztig polynomials
(in  this general  context we  should say  the Kazhdan-Lusztig  elements of
<I>&#x2124;[&Gamma;]</I>,  which belong to the  subalgebra of <I>&#x2124;[&Gamma;]</I> generated by
the    <I>q<sub>s</sub></I>)    by    <I>P<sub>x,w</sub>=&tau;<sub> &le;(q<sub>w</sub>/q<sub>x</sub>)<sup>1/2</sup></sub>    (&sum;<sub>x&lt;y &le;
w</sub>R<sub>x,y</sub>P<sub>y,w</sub>)</I>  where  <I>&tau;</I>  is  the  truncation  :  <I>&tau;<sub> &le;&nu;</sub>
&sum;<sub>&gamma;&isin;&Gamma;</sub>  a<sub>&gamma;</sub>&gamma;= &sum;<sub>&gamma; &le;&nu;</sub>a<sub>&gamma;</sub>&gamma;</I>;
the induction is thus on decreasing <I>x</I> for the Bruhat order and starts at
<I>P<sub>w,w</sub>=1</I>. We have then <I>C'<sub>w</sub>=&sum;<sub>y</sub> q<sub>w</sub><sup>-1/2</sup> P<sub>y,w</sub>T<sub>y</sub></I>.
<P>
<strong>CHEVIE</strong>  can  compute  Kazhdan-Lusztig  polynomials,  left cells, and the
various  Kazhdan-Lusztig bases of Iwahori-Hecke algebras (see <A href="biblio.htm#KL79"><cite>KL79</cite></a>).
More  facilities are implemented for the  one-parameter case when all <I>v<sub>s</sub></I>
have a common value <I>v</I>.
<P>
There  is  a  separate  function  to  compute one-parameter kazhdan-Lusztig
polynomials.  From a computational point of view, even this case is quite a
challenge.  It seems that the best approach still is by using the recursion
formula   in  the  original  article  <A href="biblio.htm#KL79"><cite>KL79</cite></a>  (which  deals  with  the
one-parameter  case, where the  above recursion simplifies).  One can first
run  a number of standard checks on a  given pair of elements to see if the
computation  of the  corresponding polynomial  can be  reduced to a similar
computation  for elements  of smaller  length, for  example. One such check
involves  the notion of critical pairs  (cf. <A href="biblio.htm#Alv87"><cite>Alv87</cite></a>): We say that a
pair of elements <I>w<sub>1</sub> &le; w<sub>2</sub> &isin; W</I> is critical if <I><span style="font-family: cursive"> L</span>(w<sub>2</sub>) &sube;
<span style="font-family: cursive">  L</span>(w<sub>1</sub>)</I> and <I><span style="font-family: cursive">  R</span>(w<sub>2</sub>) &sube; <span style="font-family: cursive">  R</span>(w<sub>1</sub>)</I>, where <I><span style="font-family: cursive">
L</span></I> and <I><span style="font-family: cursive"> R</span></I> denote the left and right descent set, respectively. Now
if  <I>y &le;  w  &isin;  W</I>  are  arbitrary  elements  then there always exists a
critical  pair <I>(z,w)</I> with <I>y &le; z &le; w</I> and then <I>P<sub>y,w</sub>=P<sub>z,w</sub></I>. Given
two  elements <I>y</I> and  <I>w</I>, such a  critical pair is  found by the function
<code>CriticalPair</code>. Whenever the polynomial corresponding to a critical pair is
computed then this pair and the polynomial are stored in the field <code>.klpol</code>
of the record of the underlying Coxeter group.
<P>
A  good example to see how long  the programs will take for computations in
big Coxeter groups is the following:
<P>
<pre>    gap> W:=CoxeterGroup("D",5);;
    gap> LeftCells(W);;</pre>
<P>
which  takes <I>10</I> seconds cpu time on 3Ghz computer. The computation of all
Kazhdan-Lusztig  polynomials  for  type  <I>F<sub>4</sub></I>  takes  a  bit more than <I>1</I>
minute.  Computing the Bruhat order is a bottleneck for these computations;
they can be speeded up by a factor of two if one does:
<P>
<pre>    gap> ReadChv("contr/brbase");
    gap> BaseBruhat(W);;</pre>
<P>
after  which the computation  of the Bruhat  order will be  speeded up by a
large factor.
<P>
However,  Alvis' computation  of the  Kazhdan--Lusztig polynomials of the
Coxeter  group of type <I>H<sub>4</sub></I> in a  computer algebra system like <strong>GAP3</strong> would
still take many hours. For such applications, it is probably more efficient
to  use a  special purpose  program like  the one  provided by  F. DuCloux
<A href="biblio.htm#DuC91"><cite>DuC91</cite></a>.
<P>
The  code for the Kazhdan-Lusztig bases  <code>C</code>, <code>D</code> and their primed versions
has  been written by Andrew Mathas around 1994, who also contributed to the
initial  implementation  and  to  the  design  of the programs dealing with
Kazhdan-Lusztig  bases. He also  implemented some other  bases, such as the
Murphy  basis which can  be found in  the contributions directory (see also
his  <code>Specht</code> package).  The extension  to the  unequal parameters case has
been written by F.Digne and J.Michel around 1999.
<P>
The  other Kazhdan-Lusztig bases  are computed in  <strong>CHEVIE</strong> in terms of the
<I>C'</I> basis.
<P>
<strong>CHEVIE</strong>  is able to define automatically the bar and truncation operations
on  <I>&#x2124;(&Gamma;)</I> when all  parameters are powers  of the same indeterminate
<I>q</I>,  with  total  order  on  <I>&Gamma;</I>  by  the  power  of <I>q</I>, or when the
parameters  are monomials in some <code>Mvp</code>s, with the lexicographic order. The
bar  involution is  evaluating a  Laurent polynomial  at the inverse of the
variables,  and truncation is keeping terms  of smaller degree than that of
<I>&nu;</I>.  It  is  possible  to  use  arbitrary  groups  <I>&Gamma;</I> by doing the
following  steps:  first,  define  the  Hecke  algebra  <code>H</code>. Then, before
defining  any  of  the  Kazhdan-Lusztig  bases, write functions <code>H.Bar(p)</code>,
<code>H.PositivePart(p)</code>  and <code>H.NegativePart(p)</code>  which perform  the operations
respectively <I>&sum;<sub>&gamma;&isin;&Gamma;</sub> a<sub>&gamma;</sub>&gamma;&rarr;
&sum;<sub>&gamma;&isin;&Gamma;</sub>     a<sub>&gamma;</sub>&gamma;<sup>-1</sup></I>,    <I>&sum;<sub>&gamma;&isin;&Gamma;</sub>
a<sub>&gamma;</sub>&gamma;&rarr;     &sum;<sub>&gamma; &ge;     1</sub>     a<sub>&gamma;</sub>&gamma;</I>    and
<I>&sum;<sub>&gamma;&isin;&Gamma;</sub>     a<sub>&gamma;</sub>&gamma;&rarr;     &sum;<sub>&gamma; &le;    1</sub>
a<sub>&gamma;</sub>&gamma;</I>  on elements  <code>p</code> of  <I>&#x2124;[&Gamma;]</I>. It  is then possible to
define  Kahzdan-Lusztig  bases  and  the  operations  above  will  be  used
internally by <strong>CHEVIE</strong> to compute them.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap093.htm#SECT001">KazhdanLusztigPolynomial</a>
<LI> <A HREF="chap093.htm#SECT002">CriticalPair</a>
<LI> <A HREF="chap093.htm#SECT003">KazhdanLusztigCoefficient</a>
<LI> <A HREF="chap093.htm#SECT004">KazhdanLusztigMue</a>
<LI> <A HREF="chap093.htm#SECT005">LeftCells</a>
<LI> <A HREF="chap093.htm#SECT006">LeftCell</a>
<LI> <A HREF="chap093.htm#SECT007">Functions for LeftCells</a>
<LI> <A HREF="chap093.htm#SECT008">W-Graphs</a>
<LI> <A HREF="chap093.htm#SECT009">WGraph</a>
<LI> <A HREF="chap093.htm#SECT010">WGraphToRepresentation</a>
<LI> <A HREF="chap093.htm#SECT011">Hecke elements of the <I>C</I> basis</a>
<LI> <A HREF="chap093.htm#SECT012">Hecke elements of the primed <I>C</I> basis</a>
<LI> <A HREF="chap093.htm#SECT013">Hecke elements of the <I>D</I> basis</a>
<LI> <A HREF="chap093.htm#SECT014">Hecke elements of the primed <I>D</I> basis</a>
<LI> <A HREF="chap093.htm#SECT015">Asymptotic algebra</a>
<LI> <A HREF="chap093.htm#SECT017">Lusztigaw</a>
<LI> <A HREF="chap093.htm#SECT017">LusztigAw</a>
</ol>
<A NAME="SECT001"><h2>93.1 KazhdanLusztigPolynomial</h2></a>
<P><P>
<A name = "I0"></a>

<P>
<code>KazhdanLusztigPolynomial( <var>W</var>, <var>y</var>, <var>w</var>)</code>
<P>
returns  the  coefficients  of  the Kazhdan-Lusztig polynomial <I>P<sub>y,w</sub>(q)</I>
attached  to  the  elements  <var>y</var>  and  <var>w</var>  of the Coxeter group <var>W</var> and to
<code>Hecke(W,q)</code>.  If one prefers to give as  input just two Coxeter words, one
can define a new function as follows (for example):
<P>
<pre>    gap> klpol := function( W, x, y)
    >   return KazhdanLusztigPolynomial(W, EltWord(W, x), EltWord(W, y));
    >   end;
    function ( W, x, y ) ... end</pre>
<P>
We  use  this  function in the   following example  where  we compute the
polynomials <I>P<sub>1,w</sub></I>  for all elements <I>w</I> in  the Coxeter group of type
<I>A<sub>3</sub></I>.
<P>
<pre>    gap> q := X( Rationals );; q.name := "q";;
    gap> W := CoxeterGroup( "B", 3 );;
    gap> el := CoxeterWords( W );
    [ [  ], [ 3 ], [ 2 ], [ 1 ], [ 3, 2 ], [ 2, 1 ], [ 2, 3 ], [ 1, 3 ],
      [ 1, 2 ], [ 2, 1, 2 ], [ 3, 2, 1 ], [ 2, 3, 2 ], [ 2, 1, 3 ],
      [ 1, 2, 1 ], [ 1, 3, 2 ], [ 1, 2, 3 ], [ 3, 2, 1, 2 ],
      [ 2, 1, 2, 3 ], [ 2, 3, 2, 1 ], [ 2, 1, 3, 2 ], [ 1, 2, 1, 2 ],
      [ 1, 3, 2, 1 ], [ 1, 2, 1, 3 ], [ 1, 2, 3, 2 ], [ 3, 2, 1, 2, 3 ],
      [ 2, 1, 2, 3, 2 ], [ 2, 3, 2, 1, 2 ], [ 2, 1, 3, 2, 1 ],
      [ 1, 3, 2, 1, 2 ], [ 1, 2, 1, 2, 3 ], [ 1, 2, 1, 3, 2 ],
      [ 1, 2, 3, 2, 1 ], [ 2, 3, 2, 1, 2, 3 ], [ 2, 1, 2, 3, 2, 1 ],
      [ 2, 1, 3, 2, 1, 2 ], [ 1, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2 ],
      [ 1, 2, 1, 3, 2, 1 ], [ 1, 2, 3, 2, 1, 2 ], [ 2, 1, 2, 3, 2, 1, 2 ],
      [ 2, 1, 3, 2, 1, 2, 3 ], [ 1, 2, 3, 2, 1, 2, 3 ],
      [ 1, 2, 1, 2, 3, 2, 1 ], [ 1, 2, 1, 3, 2, 1, 2 ],
      [ 2, 1, 2, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2, 1, 2 ],
      [ 1, 2, 1, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2, 1, 2, 3 ] ]
    gap> List( el, w -> Polynomial(Rationals,klpol( W, [], w )));
    [ q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0,
      q^0, q^0, q^0, q^0, q^0, q^0, q + 1, q^0, q^0, q^0, q^0, q + 1,
      q^0, q^0, q + 1, q^0, q^0, q + 1, q + 1, q^0, q + 1, q^0, q + 1,
      q^0, q^2 + 1, q + 1, q^2 + q + 1, q + 1, q + 1, q^0, q^0, q^2 + 1,
      q^0, q + 1, q^0 ]</pre>
<P>
Kazhdan--Lusztig  polynomials for critical  pairs are stored  in the record
component  <code>klpol</code> of  <I>W</I>, which  allows the  function to work much faster
after the first time it is called.
<P><A NAME="SECT002"><h2>93.2 CriticalPair</h2></a>
<P><P>
<A name = "I1"></a>

<P>
<code>CriticalPair( <var>W</var>, <var>y</var>, <var>w</var> )</code>
<P>
Given  elements  <var>y</var>  and  <var>w</var>  in  the  Coxeter  group  <var>W</var>  the  function
<code>CriticalPair</code>  returns the longest  element in the  double coset <I>W<sub><span style="font-family: cursive">
L</span>(w)</sub>y  W<sub><span style="font-family: cursive"> R</span>(w)</sub></I>; it is such that the Kazhdan--Lusztig polynomials
<I>P<sub>z,w</sub></I> and <I>P<sub>y,w</sub></I> are equal.
<P>
<pre>    gap> W := CoxeterGroup( "F", 4 );
    CoxeterGroup("F",4)
    gap> w := LongestCoxeterElement( W ) * W.generators[1];;
    gap> CoxeterLength( W, w );
    23
    gap> y := EltWord( W, [ 1, 2, 3, 4 ] );;
    gap> cr := CriticalPair( W, y, w );;
    gap> CoxeterWord( W, cr);
    [ 2, 3, 2, 1, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 3 ]
    gap> KazhdanLusztigPolynomial( W, y, w);
    [ 1, 0, 0, 1 ]
    gap> KazhdanLusztigPolynomial( W, cr, w);
    [ 1, 0, 0, 1 ]</pre>
<P><A NAME="SECT003"><h2>93.3 KazhdanLusztigCoefficient</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>KazhdanLusztigCoefficient( <var>W</var>, <var>y</var>, <var>w</var>, <var>k</var> )</code>
<P>
returns   the  coefficient  of  <I>q<sup>k</sup></I>  in  the  Kazhdan-Lusztig  polynomial
<I>P<sub>y,w</sub></I> attached to the elements <var>y</var> and <var>w</var> of the Coxeter group <var>W</var> and
to <code>Hecke(W,q)</code>.
<P>
<pre>    gap> W := CoxeterGroup( "B", 4 );;
    gap> y := [ 1, 2, 3, 4, 3, 2, 1 ];;
    gap> py := EltWord( W, y );
    ( 1,28)( 2,15)( 4,27)( 6,16)( 7,24)( 8,23)(11,20)(12,17)(14,30)(18,31)
    (22,32)
    gap> x := [ 1 ];;
    gap> px := EltWord( W, x );
    ( 1,17)( 2, 8)( 6,11)(10,14)(18,24)(22,27)(26,30)
    gap> Bruhat( W, px, py );
    true
    gap> List([0..3],i->KazhdanLusztigCoefficient( W, px, py, i ) );
    [ 1, 2, 1, 0 ]</pre>
<P>
So  the  Kazhdan-Lusztig polynomial  corresponding  to  <I>x</I>  and  <I>y</I>  is
<I>1+2q+q<sup>2</sup></I>.
<P><A NAME="SECT004"><h2>93.4 KazhdanLusztigMue</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>KazhdanLusztigMue( <var>W</var>, <var>y</var>, <var>w</var> )</code>
<P>
given  elements <var>y</var> and <var>w</var> in the Coxeter group <var>W</var>, this function returns
the   coefficient  of  degree   <I>(l(w)-l(y)-1)/2</I>  of  the  Kazhdan-Lusztig
polynomial <I>P<sub>y,w</sub></I>.
<P>
Of course, the result of this function could also be obtained by
<P>
<code>KazhdanLusztigCoefficient(W,y,w,(CoxeterLength(W,w)-CoxeterLength(W,y)-1)/2)</code>
<P>
but there are some speed-ups compared to this general function.
<P><A NAME="SECT005"><h2>93.5 LeftCells</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>LeftCells( <var>W</var> [, <var>i</var>])</code>
<P>
returns  a list of  records describing left  cells of <var>W</var> for <code>Hecke(W,q)</code>.
The  program uses  precomputed data(see  <A href="biblio.htm#GH14"><cite>GH14</cite></a>) for exceptional types
and  for type <I>A</I>, so is quite fast for these types (it takes 32 seconds to
compute  the 101796 left cells for type <I>E<sub>8</sub></I>). For other types, left cells
are  computed from  first principles,  thus computing  many Kazhdan-Lusztig
polynomials.  It takes 10 seconds  to compute the left  cells of <I>D<sub>5</sub></I>, for
example.
<P>
<pre>    gap> W := CoxeterGroup( "G", 2 );;
    gap> LeftCells(W);
    [ LeftCell&lt;G2: duflo= character=phi{1,0}>,
      LeftCell&lt;G2: duflo=2 character=phi{2,1}+phi{1,3}'+phi{2,2}>,
      LeftCell&lt;G2: duflo=1 character=phi{2,1}+phi{1,3}''+phi{2,2}>,
      LeftCell&lt;G2: duflo=1,2 character=phi{1,6}> ]</pre>
<P>
Printing such a record displays the character afforded by the left cell and
its  Duflo involution; the Duflo involution <I>r</I>  is printed as a subset <code>I</code>
of <code>[1..W.N]</code> such that <code>r=LongestCoxeterElement(ReflectionSubgroup(W,I))</code>,
see <a href="chap085.htm#SECT009">DescribeInvolution</a>.
<P>
If  a second argument <var>i</var> is given, the program returns only the left cells
which  are in the <var>i</var>-th two-sided cell,  that is whose character is in the
<var>i</var>-th family of <var>W</var> (see <a href="chap098.htm#SECT013">Families of unipotent characters</a>).
<P>
<pre>    gap> LeftCells(W,1);
    [ LeftCell&lt;G2: duflo=2 character=phi{2,1}+phi{1,3}'+phi{2,2}>,
      LeftCell&lt;G2: duflo=1 character=phi{2,1}+phi{1,3}''+phi{2,2}> ]</pre>
<P><A NAME="SECT006"><h2>93.6 LeftCell</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>LeftCell( <var>W</var>, <var>x</var>)</code>
<P>
returns  a  record  describing  the  left  cell  of  <var>W</var>  for  <code>Hecke(W,q)</code>
containing element <var>x</var>.
<P>
<pre>    gap> W := CoxeterGroup( "E", 8 );;
    gap> LeftCell(W, Random(W));
    LeftCell&lt;E8: duflo=6,11,82,120 character=phi{2268,30}+phi{1296,33}></pre>
<P><A NAME="SECT007"><h2>93.7 Functions for LeftCells</h2></a>
<P><P><P>
<code>Size( <var>cell</var>)</code>
<P>
Returns the number of elements of the cell.
<P>
<pre>    gap> W:=CoxeterGroup( "H", 3);;
    gap> c := LeftCells( W );;
    gap> List( c, Size);
    [ 1, 6, 5, 8, 5, 6, 1, 5, 8, 5, 5, 6, 6, 5, 8, 5, 5, 8, 5, 6, 6, 5 ]</pre>
<P>
<code>Elements( <var>cell</var>)</code>
<P>
Returns the list of elements of the cell.
<P>
The operations <code>in</code> and <code>=</code> are defined for left cells.
<P>
<A name = "I6"></a>

<code>Representation( <var>cell</var>, <var>H</var> )</code>
<P>
returns a list of matrices giving the representation of <code>Hecke(W,v^2,v)</code> on
the left cell <var>c</var>.
<P>
<pre>    gap> v := X( Cyclotomics ) ;; v.name := "v";;
    gap> H := Hecke(W, v^2, v );
    Hecke(H3,v^2,v)
    gap> Representation(c[3],H);
    [ [ [ -v^0, 0*v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, -v^0, 0*v^0, 0*v^0, v ],
        [ 0*v^0, 0*v^0, -v^0, v, v ],
        [ 0*v^0, 0*v^0, 0*v^0, v^2, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, 0*v^0, v^2 ] ],
      [ [ -v^0, v, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, v^2, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, v^2, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, v, -v^0, 0*v^0 ],
        [ 0*v^0, v, v, 0*v^0, -v^0 ] ],
      [ [ v^2, 0*v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ v, -v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, -v^0, v, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, v^2, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, 0*v^0, -v^0 ] ] ]</pre>
<P>
<A name = "I7"></a>

<code>Character(c)</code>
<P>
Returns a list <var>l</var> such that the character of <var>W</var> afforded by the left cell
<var>c</var> is <code>Sum(CharTable(W).irreducibles{l})</code>.
<P>
<pre>    gap> Character(c[13]);
    [ 6, 5 ]</pre>
<P>
See  also <code>WGraph</code> below. When <code>Character(c)</code> has been computed, then <code>c.a</code>
also has been bound which holds the common value of Lusztig's <I>a</I>-function
(see <a href="chap087.htm#SECT010">LowestPowerGenericDegrees</a>) for

<P>&bull; The elements of <code>c</code>.
<P>&bull; The irreducible constituents of <code>Character(c)</code>.

<P><A NAME="SECT008"><h2>93.8 W-Graphs</h2></a>
<P><P><P>
Let  <I>H</I> be the 1-parameter Hecke  algebra with parameter <I>q</I> associated to
the  Coxeter system <I>(W,S)</I>. A <I>W</I>-graph encodes a representation of <I>H</I> of
the  kind which is constructed by  Kazhdan-Lusztig theory. It consists of a
basis  <I>V</I>  (the  vertices  of  the  graph)  of  a real vector space with a
function  <I>x&rarr; I(x)</I>  from <I>V</I>  to the  subsets of  <I>S</I> and a function
<I>&mu;:  V<sup>2</sup>&rarr;&#x211D;</I> (the nonzero values are thus  labels for the edges of the
graph).  This defines the representation  of <I>H</I> given in  the basis <I>V</I> by
the formulae
<center><table><tr><td><I> T<sub>s</sub>(x)={ </td><td><table style="display:inline-table;"><tr><td><I>
  -x</I></td><td><I></i> if <I>s&isin; I(x)</I><i></I></td></tr><tr><td><I> 
  q x+&sum;<sub>{y&isin; V| s&isin; I(y)}</sub> &radic; q&mu;(y,x)y</I></td><td><I></i> otherwise.<i>
</I></td></tr></table style="display:inline-table;"></td><td> .</I></td></tr></table></center>
<P>
There  are two  points to  <I>W</I>-graphs. First,  they describe  nice, sparse,
integral representations of <I>H</I> (and thus of <I>W</I> also). Second, they can be
stored  very compactly;  for example,  for the  representation of dimension
7168  of the Hecke algebra of type <I>E<sub>8</sub></I>, a naive implementation would take
more than a gigabyte. The corresponding <I>W</I>-graph takes 500KB.
<P>
<I>W</I>-graphs are represented  in <strong>CHEVIE</strong> as a  pair.

<P>&bull;
The  first element is a list describing C; its elements are either a set
I(x),  or an integer n  specifying to repeat the  previous element n more
times.
<P>&bull;
The  second element is a list which  specifies <I>&mu;</I>. We first describe the
<I>&mu;</I>-list  for symmetric  <I>W</I>-graphs (when  <I>&mu;(x,y)=&mu;(y,x)</I>). There is
one  element of the <I>&mu;</I>-list for each  non-zero value <I>m</I> taken by <I>&mu;</I>,
which  consists  of  a  pair  whose  first  element is <I>m</I> and whose second
element  is  a  list  of  lists;  if  <code>l</code>  is  one of these lists each pair
<code>[l[1],l[i]]</code> represents an edge <code>x=l[1],y=l[i]</code> such that
<I>&mu;(x,y)=&mu;(y,x)=m</I>.  For non-symmetric <I>W</I>-graphs,  the first element of
each  pair  in  the  <I>&mu;</I>-list  is  a  pair  <code>[m,n]</code> and each edge <code>[x,y]</code>
obtained  from the  lists in  the second  element has  to be interpreted as
<I>&mu;(x,y)=m</I> and <I>&mu;(y,x)=n</I>.

<P>
Here  is an  example of  graph for  a Coxeter  group, and the corresponding
representation. Here <code>v</code> is a variable representing the square root of <code>q</code>.
<P>
<pre>    gap> W:=CoxeterGroup("H",3);;
    gap> WGraph(W,3);
    [ [ [ 2 ], [ 1, 2 ], [ 1, 3 ], [ 1, 3 ], [ 2, 3 ] ],
      [ [ -1, [ [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 5 ] ] ] ] ]
    gap> WGraphToRepresentation(3,last,Mvp("v"));
    [ [ [ v^2, 0, 0, 0, 0 ], [ 0, -1, 0, 0, 0 ], [ -v, 0, -1, 0, -v ],
          [ 0, 0, 0, -1, -v ], [ 0, 0, 0, 0, v^2 ] ],
      [ [ -1, 0, -v, 0, 0 ], [ 0, -1, 0, -v, 0 ], [ 0, 0, v^2, 0, 0 ],
          [ 0, 0, 0, v^2, 0 ], [ 0, 0, -v, -v, -1 ] ],
      [ [ v^2, 0, 0, 0, 0 ], [ 0, v^2, 0, 0, 0 ], [ -v, 0, -1, 0, 0 ],
          [ 0, -v, 0, -1, 0 ], [ 0, 0, 0, 0, -1 ] ] ]</pre>
<P><A NAME="SECT009"><h2>93.9 WGraph</h2></a>
<P><P>
<A name = "I8"></a>

<P>
<code>WGraph( <var>W</var>, <var>i</var> )</code>
<P>
<I>W</I>  should be a finite Coxeter group. Returns the <I>W</I>-graph for the <I>i</I>-th
representation  of the  one-parameter Hecke  algebra of  <I>W</I> (or the <I>i</I>-th
representation  of  <I>W</I>).  For  the  moment  this  is  only implemented for
irreducible groups of exceptional type <I>E, F, G, H</I>.
<P>
<code>WGraph( <var>c</var> )</code>
<P>
<I>c</I>  should be a left cell for  the one-parameter Hecke algebra of a finite
Coxeter group <I>W</I>. Returns the corresponding <I>W</I>-graph.
<P><A NAME="SECT010"><h2>93.10 WGraphToRepresentation</h2></a>
<P><P>
<A name = "I9"></a>

<P>
<code>WGraphToRepresentation (<var>r</var>, <var>graph</var>, <var>v</var>)</code>
<P>
<var>graph</var>  should  be  a  <I>W</I>-graph  for  some  finite  Coxeter  group <I>W</I> of
semisimple  rank <var>r</var>.  The function  returns the  <var>r</var> matrices defining the
representation  defined  by  <var>graph</var>  of  the  Hecke  algebra  for <I>W</I> with
parameters <I>-1</I> and <I>v<sup>2</sup></I>.
<P>
<pre>    gap> W:=CoxeterGroup("H",3);;
    gap> g:=WGraph(W,3);
    [ [ [ 2 ], [ 1, 2 ], [ 1, 3 ], [ 1, 3 ], [ 2, 3 ] ],
      [ [ -1, [ [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 5 ] ] ] ] ]
    gap> WGraphToRepresentation(3,g,Mvp("v"));
    [ [ [ v^2, 0, 0, 0, 0 ], [ 0, -1, 0, 0, 0 ], [ -v, 0, -1, 0, -v ],
          [ 0, 0, 0, -1, -v ], [ 0, 0, 0, 0, v^2 ] ],
      [ [ -1, 0, -v, 0, 0 ], [ 0, -1, 0, -v, 0 ], [ 0, 0, v^2, 0, 0 ],
          [ 0, 0, 0, v^2, 0 ], [ 0, 0, -v, -v, -1 ] ],
      [ [ v^2, 0, 0, 0, 0 ], [ 0, v^2, 0, 0, 0 ], [ -v, 0, -1, 0, 0 ],
          [ 0, -v, 0, -1, 0 ], [ 0, 0, 0, 0, -1 ] ] ]</pre>
<P>
<code>WGraphToRepresentation(<var>H</var>, <var>graph</var>)</code>
<P>
<var>H</var> should be a one-parameter Hecke algebra for a finite Coxeter group. The
function  returns the matrices of the  representation defined by <var>graph</var> of
<I>H</I>.
<P>
<pre>    gap> H:=Hecke(W,[[Mvp("v"),-Mvp("v")^-1]]);
    Hecke(H3,[[v,-v^-1]])
    gap> WGraphToRepresentation(H,g);
    [ [ [ v, 0, 0, 0, 0 ], [ 0, -v^-1, 0, 0, 0 ], [ -1, 0, -v^-1, 0, -1 ],
          [ 0, 0, 0, -v^-1, -1 ], [ 0, 0, 0, 0, v ] ],
      [ [ -v^-1, 0, -1, 0, 0 ], [ 0, -v^-1, 0, -1, 0 ], [ 0, 0, v, 0, 0 ],
          [ 0, 0, 0, v, 0 ], [ 0, 0, -1, -1, -v^-1 ] ],
      [ [ v, 0, 0, 0, 0 ], [ 0, v, 0, 0, 0 ], [ -1, 0, -v^-1, 0, 0 ],
          [ 0, -1, 0, -v^-1, 0 ], [ 0, 0, 0, 0, -v^-1 ] ] ]</pre>
<P><A NAME="SECT011"><h2>93.11 Hecke elements of the <I>C</I> basis</h2></a>
<P><P><P>
<A name = "I10"></a>

<code>Basis( <var>H</var>, "C" )</code>
<P>
returns  a function which gives the  <I>C</I>-basis of the Iwahori-Hecke algebra
<var>H</var>.  The parameters of <var>H</var>  should be powers of  a single indeterminate or
<code>Mvp</code>s  (see the introduction). This basis  is defined as follows (see e.g.
<A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, (5.1)). Let <I>W</I> be the underlying Coxeter group. For <I>x,y &isin;
W</I>  let  <I>P<sub>x,y</sub></I>  be  the  corresponding  Kazhdan--Lusztig polynomial. If
<I>{T<sub>w</sub>  | w&isin; W}</I> denotes the usual <I>T</I>-basis, then <I>C<sub>x</sub>:=&sum;<sub>y  &le;
x</sub> (-1)<sup>l(x)-l(y)</sup>P<sub>y,x</sub>(q<sup>-1</sup>)q<sub>x</sub><sup>1/2</sup>q<sub>y</sub><sup>-1</sup> T<sub>y</sub></I> for <I>x &isin; W</I>. For
example,  we have <I>C<sub>s</sub>=q<sub>s</sub><sup>-1/2</sup>T<sub>s</sub>-q<sub>s</sub><sup>1/2</sup>T<sub>1</sub></I> for <I>s &isin; S</I>. Thus, the
transformation  matrix  between  the  <I>T</I>-basis  and the <I>C</I>-basis is lower
unitriangular,  with powers of <I>v</I> along the diagonal. In the one-parameter
case  (all <I>q<sub>s</sub></I> are equal  to <I>v<sup>2</sup></I>) the multiplication  rules for the <I>C</I>
basis   are  given  by:  <center><table><tr><td><I>   C<sub>s</sub>  .  C<sub>x</sub>  ={  </td><td><table style="display:inline-table;"><tr><td><I>
-(v+v<sup>-1</sup>)C<sub>x</sub>  </I></td><td><I>  </i>,  if  <I>sx&lt;x</I><i></I></td></tr><tr><td><I>  C<sub>sx</sub>+&sum;<sub>y</sub>  &mu;(y,x)C<sub>y</sub>  </I></td><td><I>
</i>,  if <I>sx&gt;x</I><i></I></td></tr></table style="display:inline-table;"></td><td>.</I></td></tr></table></center> where the sum  is over all <I>y</I> such
that  <I>y&lt;x</I>, <I>l(y)  &#8802; l(x)</I> mod <I>2</I>  and <I>sy&lt;y</I>. The coefficient
<I>&mu;(y,x)</I>   is  the   coefficient  of   degree  <I>(l(x)-l(y)-1)/2</I>  in  the
Kazhdan--Lusztig polynomial <I>P<sub>x,y</sub></I>.
<P>
<pre>    gap> W := CoxeterGroup( "B", 3 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B3,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> C := Basis( H, "C" );
    function ( arg ) ... end
    gap> T( C( 1 ) );
    -vT()+v^-1T(1)
    gap> C( T( 1 ) );
    v^2C()+vC(1)</pre>
<P>
We can  also  compute character values  on elements  in the <I>C</I>-basis  as
follows:
<P>
<pre>    gap> ref := HeckeReflectionRepresentation( H );;
    gap> c := CharRepresentationWords(ref, ChevieClassInfo(W).classtext);
    [ 3*v^0, 2*v^2 - 1, v^8 - 2*v^4, -3*v^12, 2*v^2 - 1, v^4,
      v^4 - 2*v^2, -v^6, v^4 - v^2, 0*v^0 ]
    gap> List(ChevieClassInfo(W).classtext, i->HeckeCharValues(C(i),c));
    [ 3*v^0, -v - v^(-1), 0*v^0, 0*v^0, -v - v^(-1), 2*v^0, 0*v^0, 0*v^0,
      v^0, 0*v^0 ]</pre>
<P><A NAME="SECT012"><h2>93.12 Hecke elements of the primed <I>C</I> basis</h2></a>
<P><P><P>
<code>Basis( <var>H</var>, "C'" )</code>
<P>
returns  a function which  gives the <I>C'</I>-basis  of the Iwahori-Hecke
algebra  <var>H</var>  (see  <A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, (5.1))  The  parameters  of <var>H</var> should be
powers  of  a  single  indeterminate  or  monomials  in  <code>Mvp</code>'s  (see the
introduction).  This  basis  is  defined  by  <center><table><tr><td><I> C<sub>x</sub>' := &sum;<sub>y  &le;
x</sub>P<sub>y,x</sub>q<sub>x</sub><sup>-1/2</sup>  T<sub>y</sub>  &emsp;  </i>  for  <I>x &isin; W</I><i>.</I></td></tr></table></center> We have
<I>C<sub>x</sub>'=(-1)<sup>l(x)</sup></i>Alt<i>(C<sub>x</sub>)</I>    for   all   <I>x   &isin;   W</I>   (see
<code>AltInvolution</code>  in  section  "Operations  for  Hecke  elements  of the <I>T</I>
basis").
<P>
<pre>    gap>  v := X( Rationals );; v.name := "v";;
    gap>  H := Hecke( CoxeterGroup( "B", 2 ), [v ^4, v^2] );;
    gap>  h := Basis( H, "C'" )( 1 );
    #warning: C' basis: v\^2 chosen as 2nd root of v\^4
    C'(1)
    gap>  h2 := h * h;
    (v^2+v^-2)C'(1)
    gap>  Basis( H, "T" )( h2 );
    (1+v^-4)T()+(1+v^-4)T(1)
    gap> Basis(H,"C'")(last);
    (v^2+v^-2)C'(1)</pre>
<P><A NAME="SECT013"><h2>93.13 Hecke elements of the <I>D</I> basis</h2></a>
<P><P><P>
<code>Basis( <var>H</var>, "D" )</code>
<P>
returns a function which gives the <I>D</I>-basis of the (one parameter generic)
Iwahori-Hecke  algebra <var>H</var> (see <A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, (5.1))  of the finite Coxeter
group  <var>W</var>. This can be defined by <center><table><tr><td><I> D<sub>x</sub> := v<sup>-N</sup>C<sub>xw<sub>0</sub></sub>' T<sub>w<sub>0</sub></sub>
</i>  for every <I>x &isin;  W</I><i>, </I></td></tr></table></center> where <I>N</I>  denotes the number of positive
roots  in the root system  of <I>W</I> and <I>w<sub>0</sub></I>  is the longest element of <I>W</I>.
The  <I>D</I>-basis is dual to the  <I>C</I>-basis with respect to the non-degenerate
form  <I>H &times;  H &rarr;  &#x2124;[v,v<sup>-1</sup>]</I>, <I>(h<sub>1</sub>,h<sub>2</sub>)  &rarr; &tau;(h<sub>1</sub>
.  h<sub>2</sub>)</I> where <I>&tau;  : H &rarr;  &#x2124;[v,v<sup>-1</sup>]</I> is the linear
form  such  that  <I>&tau;(T<sub>1</sub>)=1</I>  and  <I>&tau;(T<sub>x</sub>)=0</I>  for <I>x  &ne; 1</I>. We have
<I>D<sub>x</sub>=&beta;(C<sub>w<sub>0</sub>x</sub>')</I>  for all  <I>x &isin;  W</I> (see  <code>BetaInvolution</code> in
section "Operations for Hecke elements of the <I>T</I> basis").
<P>
<pre>    gap> W := CoxeterGroup( "B", 2 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B2,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> D := Basis( H, "D" );
    function ( arg ) ... end
    gap> D( T( 1 ) );
    vD(1)-v^2D(1,2)-v^2D(2,1)+v^3D(1,2,1)+v^3D(2,1,2)-v^4D(1,2,1,2)
    gap> BetaInvolution( D( 1 ) );
    C'(2,1,2)</pre>
<P><A NAME="SECT014"><h2>93.14 Hecke elements of the primed <I>D</I> basis</h2></a>
<P><P><P>
<code>Basis( <var>H</var>, "D'" )</code>
<P>
returns  a function which gives the  <I>D'</I>-basis of the (one parameter
generic)  Iwahori-Hecke algebra  <var>H</var> of  the finite  Coxeter group <var>W</var> (see
<A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, (5.1)).   This   can   be   defined   by  <center><table><tr><td><I>  D<sub>x</sub>'  :=
v<sup>-N</sup>C<sub>xw<sub>0</sub></sub>  T<sub>w<sub>0</sub></sub> </i> for  every <I>x &isin;  W</I><i>, </I></td></tr></table></center> where <I>N</I> denotes
the  number of positive  roots in the  root system of  <I>W</I> and <I>w<sub>0</sub></I> is the
longest  element  of  <I>W</I>.  The  <I>D'</I>-basis  is  basis  dual  to  the
<I>C'</I>-basis  with  respect  to  the  non-degenerate  form  <I>H &times; H
&rarr;  &#x2124;[v,v<sup>-1</sup>]</I>, <I>(h<sub>1</sub>,h<sub>2</sub>)  &rarr; &tau;(h<sub>1</sub>  . h<sub>2</sub>)</I> where
<I>&tau;  :  H  &rarr;  &#x2124;[v,v<sup>-1</sup>]</I>  is  the linear form such that
<I>&tau;(T<sub>1</sub>)=1</I> and <I>&tau;(T<sub>x</sub>)=0</I> for <I>x  &ne; 1</I>. We have
<I>D<sub>x</sub>'=</i>Alt<i>(D<sub>x</sub>)</I>  for  all  <I>x  &isin;  W</I> (see <code>AltInvolution</code> in
section "Operations for Hecke elements of the <I>T</I> basis").
<P>
<pre>    gap> W := CoxeterGroup( "B", 2 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B2,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> Dp := Basis( H, "D'" );
    function ( arg ) ... end
    gap> AltInvolution( Dp( 1 ) );
    D(1)
    gap> Dp( 1 )^3;
    (v+2v^-1-5v^-5-9v^-7-8v^-9-4v^-11-v^-13)D'()+(v^2+2+v^-2)D'(1)</pre>
<P><A NAME="SECT015"><h2>93.15 Asymptotic algebra</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>AsymptoticAlgebra( <var>W</var>, <var>i</var>)</code>
<P>
The  asymptotic algebra <I>A</I> associated to the algebra <I><span style="font-family: cursive">H</span>=</I><code>Hecke(W,q)</code> is
an   algebra  with   basis  <I>{t<sub>x</sub>}<sub>x&isin;   W</sub></I>  and  structure  constants
<I>t<sub>x</sub>t<sub>y</sub>=&sum;<sub>z</sub>&gamma;<sub>x,y,z</sub>   t<sub>z</sub></I>  given  by:  let  <I>h<sub>x,y,z</sub></I>  be  the
coefficient  of  <I>C<sub>x</sub>  C<sub>y</sub></I>  on  <I>C<sub>z</sub></I>. Then <I>h<sub>x,y,z</sub>=&gamma;<sub>x,y,z<sup>-1</sup></sub>
q<sup>a(z)/2</sup>+</I>lower  terms, where <I>q<sup>a(z)/2</sup></I>  is the maximum  over <I>x,y</I> of
the degree of <I>h<sub>x,y,z</sub></I>.
<P>
The  algebra <I>A</I> is the direct product of the subalgebras <I>A<sub><span style="font-family: cursive">C</span></sub></I> generated
by  the elements <I>{t<sub>x</sub>}<sub>x&isin;<span style="font-family: cursive">C</span></sub></I>,  where <I><span style="font-family: cursive">C</span></I> runs  over the two-sided
cells  of <I>W</I>. If  <I><span style="font-family: cursive">C</span></I> is the  <I>i</I>-th two-sided cell  of <I>W</I>, the command
<code>AsymptoticAlgebra(W,i)</code>   returns  the  algebra  <I>A<sub><span style="font-family: cursive">C</span></sub></I>.  Note  that  the
function  <code>a(z)</code> is  constant over  a two-sided  cell, equal  to the common
value  of the <code>a</code>-function attached to the characters of the two-sided cell
(see <code>Character</code> for left cells).
<P>
<pre>    gap> W:=CoxeterGroup("G",2);;
    gap> A:=AsymptoticAlgebra(W,1);
    Asymptotic algebra dim.10
    gap> b:=A.basis;
    [ t(2), t(12), t(212), t(1212), t(21212), t(1), t(21), t(121),
      t(2121), t(12121) ]
    gap> List(b,x->b*x);
    [ [ t(2), t(21), t(212), t(2121), t(21212), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(21), t(2)+t(212), t(21)+t(2121), t(212)+t(21212),
          t(2121) ],
      [ t(212), t(21)+t(2121), t(2)+t(212)+t(21212), t(21)+t(2121),
          t(212), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(2121), t(212)+t(21212), t(21)+t(2121),
          t(2)+t(212), t(21) ],
      [ t(21212), t(2121), t(212), t(21), t(2), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(1), t(12), t(121), t(1212), t(12121) ],
      [ t(12), t(1)+t(121), t(12)+t(1212), t(121)+t(12121), t(1212), 0,
          0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(121), t(12)+t(1212), t(1)+t(121)+t(12121),
          t(12)+t(1212), t(121) ],
      [ t(1212), t(121)+t(12121), t(12)+t(1212), t(1)+t(121), t(12), 0,
          0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(12121), t(1212), t(121), t(12), t(1) ] ]</pre>
<P><A NAME="SECT016"><h2>93.16 Lusztigaw</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>Lusztigaw( <var>W</var>, <var>w</var>)</code>
<P>
For  <var>w</var> an element  of the Coxeter  groups <var>W</var>, this  function returns the
coefficients on the irreducible characters of the virtual Character <I><span style="font-family: cursive">a</span><sub>w</sub></I>
defined  in <A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, 5.10.2. This character  has the property that the
corresponding almost character is integral and positive.
<P>
<pre>    gap> W:=CoxeterGroup("G",2);
    CoxeterGroup("G",2)
    gap> Lusztigaw(W,Reflection(W,1));
    [ 0, 0, 1, 0, 1, 1 ]
    gap> last*List([1..NrConjugacyClasses(W)],i->AlmostCharacter(W,i));
    [G2]=&lt;phi{1,3}'>+&lt;phi{2,1}>+&lt;phi{2,2}></pre>
<P><A NAME="SECT017"><h2>93.17 LusztigAw</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>LusztigAw( <var>W</var>, <var>w</var>)</code>
<P>
For  <var>w</var> an element  of the Coxeter  groups <var>W</var>, this  function returns the
coefficients on the irreducible characters of the virtual Character <I><span style="font-family: cursive">A</span><sub>w</sub></I>
defined  in <A href="biblio.htm#Lus85"><cite>Lus85</cite></a>, 5.10.2. This character  has the property that the
corresponding almost character is integral and positive.
<P>
<pre>    gap> W:=CoxeterGroup("G",2);
    CoxeterGroup("G",2)
    gap> LusztigAw(W,Reflection(W,1));
    [ 0, 0, 0, 1, 1, 1 ]
    gap> last*List([1..NrConjugacyClasses(W)],i->AlmostCharacter(W,i));
    [G2]=&lt;phi{1,3}''>+&lt;phi{2,1}>+&lt;phi{2,2}></pre>
<a href ="chap092.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap094.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>