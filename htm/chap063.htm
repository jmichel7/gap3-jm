<html><head><title>GAP3 Manual: 63 GLISSANDO</title></head>
<body bgcolor="ffffff">
<h1>63 GLISSANDO</h1>
<P><P><P>
\GLISSANDO (version 1.0) is a share library package that implements a 
<strong>GAP3</strong> library of small semigroups and near-rings. 
The library files can be systematically searched for near-rings
and semigroups with certain properties.
<P>
The \GLISSANDO package (version 1.0) was written by
<P>
Christof N&ouml;bauer<BR> 
Institut f&uuml;r Mathematik<BR> 
Johannes Kepler Universit&auml;t Linz<BR> 
4040 Linz, Austria
<P>
e-mail noebsi@bruckner.stoch.uni-linz.ac.at
<P>
and supported by the
<P>
Austrian <I> Fonds zur F{&ouml;</I>rderung der wissenschaftlichen 
Forschung}, Project P11486-TEC.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap063.htm#SECT001">Installing the Glissando Package</a>
<LI> <A HREF="chap077.htm">Transformations</a>
<LI> <A HREF="chap077.htm#SECT002">Transformation</a>
<LI> <A HREF="chap063.htm#SECT004">AsTransformation</a>
<LI> <A HREF="chap077.htm#SECT006">IsTransformation</a>
<LI> <A HREF="chap063.htm#SECT006">IsSetTransformation</a>
<LI> <A HREF="chap063.htm#SECT007">IsGroupTransformation</a>
<LI> <A HREF="chap077.htm#SECT003">IdentityTransformation</a>
<LI> <A HREF="chap063.htm#SECT009">Kernel for transformations</a>
<LI> <A HREF="chap063.htm#SECT010">Rank for transformations</a>
<LI> <A HREF="chap077.htm#SECT005">Operations for transformations</a>
<LI> <A HREF="chap063.htm#SECT012">DisplayTransformation</a>
<LI> <A HREF="chap063.htm#SECT013">Transformation records</a>
<LI> <A HREF="chap063.htm#SECT014">Transformation Semigroups</a>
<LI> <A HREF="chap063.htm#SECT015">TransformationSemigroup</a>
<LI> <A HREF="chap075.htm#SECT005">IsSemigroup</a>
<LI> <A HREF="chap063.htm#SECT017">IsTransformationSemigroup</a>
<LI> <A HREF="chap063.htm#SECT018">Elements for semigroups</a>
<LI> <A HREF="chap063.htm#SECT019">Size for semigroups</a>
<LI> <A HREF="chap063.htm#SECT020">DisplayCayleyTable for semigroups</a>
<LI> <A HREF="chap063.htm#SECT021">IdempotentElements for semigroups</a>
<LI> <A HREF="chap063.htm#SECT022">IsCommutative for semigroups</a>
<LI> <A HREF="chap063.htm#SECT023">Identity for semigroups</a>
<LI> <A HREF="chap063.htm#SECT024">SmallestIdeal</a>
<LI> <A HREF="chap063.htm#SECT025">IsSimple for semigroups</a>
<LI> <A HREF="chap063.htm#SECT026">Green</a>
<LI> <A HREF="chap063.htm#SECT027">Rank for semigroups</a>
<LI> <A HREF="chap063.htm#SECT028">LibrarySemigroup</a>
<LI> <A HREF="chap063.htm#SECT029">Transformation semigroup records</a>
<LI> <A HREF="chap063.htm#SECT030">Near-rings</a>
<LI> <A HREF="chap063.htm#SECT031">IsNrMultiplication</a>
<LI> <A HREF="chap063.htm#SECT032">Nearring</a>
<LI> <A HREF="chap063.htm#SECT033">IsNearring</a>
<LI> <A HREF="chap063.htm#SECT034">IsTransformationNearring</a>
<LI> <A HREF="chap063.htm#SECT035">LibraryNearring</a>
<LI> <A HREF="chap063.htm#SECT036">DisplayCayleyTable for near-rings</a>
<LI> <A HREF="chap063.htm#SECT037">Elements for near-rings</a>
<LI> <A HREF="chap063.htm#SECT038">Size for near-rings</a>
<LI> <A HREF="chap063.htm#SECT039">Endomorphisms for near-rings</a>
<LI> <A HREF="chap063.htm#SECT040">Automorphisms for near-rings</a>
<LI> <A HREF="chap063.htm#SECT041">FindGroup</a>
<LI> <A HREF="chap063.htm#SECT042">NearringIdeals</a>
<LI> <A HREF="chap063.htm#SECT043">InvariantSubnearrings</a>
<LI> <A HREF="chap063.htm#SECT044">Subnearrings</a>
<LI> <A HREF="chap063.htm#SECT045">Identity for near-rings</a>
<LI> <A HREF="chap063.htm#SECT046">Distributors</a>
<LI> <A HREF="chap063.htm#SECT047">DistributiveElements</a>
<LI> <A HREF="chap063.htm#SECT048">IsDistributiveNearring</a>
<LI> <A HREF="chap063.htm#SECT049">ZeroSymmetricElements</a>
<LI> <A HREF="chap063.htm#SECT050">IsAbstractAffineNearring</a>
<LI> <A HREF="chap063.htm#SECT051">IdempotentElements for near-rings</a>
<LI> <A HREF="chap063.htm#SECT052">IsBooleanNearring</a>
<LI> <A HREF="chap063.htm#SECT053">NilpotentElements</a>
<LI> <A HREF="chap063.htm#SECT054">IsNilNearring</a>
<LI> <A HREF="chap063.htm#SECT055">IsNilpotentNearring</a>
<LI> <A HREF="chap063.htm#SECT056">IsNilpotentFreeNearring</a>
<LI> <A HREF="chap063.htm#SECT057">IsCommutative for near-rings</a>
<LI> <A HREF="chap063.htm#SECT058">IsDgNearring</a>
<LI> <A HREF="chap063.htm#SECT059">IsIntegralNearring</a>
<LI> <A HREF="chap063.htm#SECT060">IsPrimeNearring</a>
<LI> <A HREF="chap063.htm#SECT061">QuasiregularElements</a>
<LI> <A HREF="chap063.htm#SECT062">IsQuasiregularNearring</a>
<LI> <A HREF="chap063.htm#SECT063">RegularElements</a>
<LI> <A HREF="chap063.htm#SECT064">IsRegularNearring</a>
<LI> <A HREF="chap063.htm#SECT065">IsPlanarNearring</a>
<LI> <A HREF="chap063.htm#SECT066">IsNearfield</a>
<LI> <A HREF="chap063.htm#SECT067">LibraryNearringInfo</a>
<LI> <A HREF="chap063.htm#SECT068">Nearring records</a>
<LI> <A HREF="chap063.htm#SECT069">Supportive Functions for Groups</a>
<LI> <A HREF="chap063.htm#SECT070">DisplayCayleyTable for groups</a>
<LI> <A HREF="chap063.htm#SECT071">Endomorphisms for groups</a>
<LI> <A HREF="chap063.htm#SECT072">Automorphisms for groups</a>
<LI> <A HREF="chap063.htm#SECT073">InnerAutomorphisms</a>
<LI> <A HREF="chap063.htm#SECT074">SmallestGeneratingSystem</a>
<LI> <A HREF="chap063.htm#SECT075">IsIsomorphicGroup</a>
<LI> <A HREF="chap063.htm#SECT076">Predefined groups</a>
<LI> <A HREF="chap063.htm#SECT077">How to find near-rings with certain properties</a>
<LI> <A HREF="chap063.htm#SECT078">Defining near-rings with known multiplication table</a>
</ol>
<A NAME="SECT001"><h2>63.1 Installing the Glissando Package</h2></a>
<P><P><P>
The \GLISSANDO package is completely written in the <strong>GAP3</strong> language, 
it does not require any additional programs and/or compilations. It will 
run on any computer that runs <strong>GAP3</strong>. To access \GLISSANDO, use 
<code>RequirePackage( "gliss" );</code> (see <a href="chap057.htm#SECT001">RequirePackage</a>).
<P><A NAME="SECT002"><h2>63.2 Transformations</h2></a>
<P><P>
A <strong>transformation</strong> is a mapping with equal source and range, say <var>X</var>.
For example, <var>X</var> may be a set or a group. A transformation on <var>X</var> then acts
on <var>X</var> by transforming each element of <var>X</var> into (precisely one) 
element of <var>X</var>.
<P>
Note that a transformation is just a special case of a mapping. So all <strong>GAP3</strong>  
functions that work for 
mappings will also work for transformations. 
<P>
For the following, it is important to keep 
in mind that in <strong>GAP3</strong> sets are represented by <strong>sorted</strong> lists without 
holes and duplicates. Throughout this section, let <var>X</var> be a set or a group 
with <var>n</var> elements. 
A transformation on <var>X</var> is uniquely determined by a list of length <var>n</var> 
without holes and with entries which are integers between 1 and <var>n</var>. 
<P>
For example, 
for the set <code>X := [1,2,3]</code>, the list <code>[1,1,2]</code> determines the 
transformation on <var>X</var> which transforms 1 into 1, 2 
into 1, and 3 into 2. 
<P>
Analogously, for the cyclic group of order 3: <code>C3</code>, with 
(the uniquely ordered) set of elements 
<code>[(),(1,2,3),(1,3,2)]</code>, the list <code>[2,3,3]</code> determines the 
transformation on <code>C3</code> 
which transforms <code>()</code> into <code>(1,2,3)</code>, <code>(1,2,3)</code> into 
<code>(1,3,2)</code>, and <code>(1,3,2)</code> into <code>(1,3,2)</code>. 
<P>
Such a list which 
on a given set or group uniquely determines a transformation
will be called <strong>transformation list</strong> (short <strong>tfl</strong>).
<P>
Transformations are created by the constructor functions 
<code>Trans\-for\-ma\-tion</code> 
or <code>As\-Trans\-for\-ma\-tion</code> and they are represented by records that 
contain all the information about the transformations.  
<P><A NAME="SECT003"><h2>63.3 Transformation</h2></a>
<P><P>
<code>Transformation( <var>obj</var>, <var>tfl</var> )</code>
<P>
The constructor function <code>Transformation</code> returns the transformation 
determined by the transformation list <var>tfl</var> on <var>obj</var> where 
<var>obj</var> must be a group or a set.
<pre>   
  gap> t1:=Transformation([1..3],[1,1,2]);
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  gap> g:=Group((1,2),(3,4));
  Group( (1,2), (3,4) )
  gap> gt := Transformation(g,[1,1,2,5]);
  Error, Usage: Transformation( &lt;obj>, &lt;tfl> ) where &lt;obj> must be a set
  or a group and &lt;tfl> must be a valid transformation list for &lt;obj> in
  Transformation( g, [ 1, 1, 2, 5 ] ) called from
  main loop
  brk>
  gap> gt := Transformation( g, [4,2,2,1] );
  Transformation( Group( (1,2), (3,4) ), [ 4, 2, 2, 1 ] )
</pre>
<P><A NAME="SECT004"><h2>63.4 AsTransformation</h2></a>
<P><P>
<code>AsTransformation( <var>map</var> )</code>
<P>
The constructor function <code>AsTransformation</code> returns the mapping <var>map</var> 
as transformation. Of course, this function can only be applied to mappings 
with equal source and range, otherwise an error will be signaled.
<P>
<pre>  gap> s3:=Group((1,2),(1,2,3));             
  Group( (1,2), (1,2,3) )
  gap> i:=InnerAutomorphism(s3,(2,3));
  InnerAutomorphism( Group( (1,2), (1,2,3) ), (2,3) )
  gap> AsTransformation(i);
  Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 6, 5, 4, 3 ] )  
</pre>
<P><A NAME="SECT005"><h2>63.5 IsTransformation</h2></a>
<P><P>
<code>IsTransformation( <var>obj</var> )</code>
<P>
<code>IsTransformation</code> returns <code>true</code> if the object <var>obj</var> is a 
transformation and <code>false</code> otherwise.
<P>
<pre>  gap> IsTransformation( [1,1,2] );
  false                             # a list is not a transformation
  gap> IsTransformation( (1,2,3) );
  false                             # a permutation is not a transformation
  gap> IsTransformation( t1 );
  true
</pre>
<P><A NAME="SECT006"><h2>63.6 IsSetTransformation</h2></a>
<P><P>
<code>IsSetTransformation( <var>obj</var> )</code>
<P>
<code>IsSetTransformation</code> returns <code>true</code> if the object <var>obj</var> is a 
set transformation and <code>false</code> otherwise.
<P>
<pre>  gap> IsSetTransformation( t1 );
  true
  gap> g:= Group((1,2),(3,4));
  Group( (1,2), (3,4) )
  gap> gt:=Transformation(g,[4,2,2,1]);
  [ 4, 2, 2, 1 ] 
  gap> IsSetTransformation( gt );
  false
</pre>
<P><A NAME="SECT007"><h2>63.7 IsGroupTransformation</h2></a>
<P><P>
<code>IsGroupTransformation( <var>obj</var> )</code>
<P>
<code>IsGroupTransformation</code> returns <code>true</code> if the object <var>obj</var> is a 
group transformation and <code>false</code> otherwise.
<P>
<pre>  gap> IsGroupTransformation( t1 );
  false
  gap> IsGroupTransformation( gt );
  true
</pre>
<P>
Note that transformations are defined to be either a set transformation or a 
group transformation.
<P><A NAME="SECT008"><h2>63.8 IdentityTransformation</h2></a>
<P><P>
<code>IdentityTransformation( <var>obj</var> )</code>
<P>
<code>Identity\-Trans\-for\-ma\-tion</code> is the counterpart to the <strong>GAP3</strong> standard
 library function 
<code>Iden\-ti\-ty\-Mapping</code>. It returns the identity transformation on 
<var>obj</var> 
where <var>obj</var> must be a group or a set.
<P>
<pre>  gap> IdentityTransformation( [1..3] );
  Transformation( [ 1, 2, 3 ], [ 1, 2, 3 ] )
  gap> IdentityTransformation( s3 );
  Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 3, 4, 5, 6 ] )
</pre>
<P><A NAME="SECT009"><h2>63.9 Kernel for transformations</h2></a>
<P><P>
<code>Kernel( <var>t</var> )</code>
<P>
For a transformation <var>t</var> on <var>X</var>, the <strong>kernel</strong> of <var>t</var> is defined as an 
equivalence relation <I>Kernel(t)</I> as: <I>&forall; x,y &isin; X: (x,y) &isin; 
Kernel(t) <I> if\/f</I> t(x) = t(y)</I>.
<P>
<code>Kernel</code> returns the kernel of the transformation <var>t</var> as a list <code>l</code> 
of lists where each sublist of <code>l</code> represents an equivalence class of the 
equivalence relation <var>Kernel(t)</var>. 
<pre> 
  gap> t:=Transformation( [1..5], [2,3,2,4,4] );
  Transformation( [ 1, 2, 3, 4, 5 ], [ 2, 3, 2, 4, 4 ] )
  gap> Kernel( t );
  [ [ 1, 3 ], [ 2 ], [ 4, 5 ] ] 
</pre>
<P><A NAME="SECT010"><h2>63.10 Rank for transformations</h2></a>
<P><P>
<code>Rank( <var>t</var> )</code>
<P>
For a transformation <var>t</var> on <var>X</var>, the <strong>rank</strong> of <var>t</var> is defined as  
the size of the image of <var>t</var>, i.e. 
<I>| {t(x) |  x &isin; X} |</I>,
or, in <strong>GAP3</strong> 
language: <code>Length( Image( t ) )</code>.
<P>
<code>Rank</code> returns the rank of the transformation <var>t</var>. 
<P>
<pre>  gap> t1;
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  gap> Rank( t1 );
  2
  gap>
  gap> gt;
  Transformation( Group( (1,2), (3,4) ), [ 4, 2, 2, 1 ] )
  gap> Rank(gt);
  3
</pre>
<P><A NAME="SECT011"><h2>63.11 Operations for transformations</h2></a>
<P><P>
<code><var>t1</var> * <var>t2</var></code>
<P>
The product operator * returns the transformation which is obtained 
from the transformations <var>t1</var> and <var>t2</var>, by composition of <var>t1</var> 
and <var>t2</var> (i.e. performing <var>t2</var> <strong>after</strong> <var>t1</var>). This function 
works for both set transformations as well as group transformations.
<pre> 
  gap> t1:=Transformation( [1..3], [1,1,2] );
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  gap> t2:=Transformation( [1..3], [2,3,3] );
  Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] )
  gap> t1*t2;
  Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] )
  gap> t2*t1;
  Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] )
</pre>
<P>
<code><var>t1</var> + <var>t2</var></code>
<P>
The add operator <code>+</code> returns the group transformation which is obtained 
from the group transformations <var>t1</var> and <var>t2</var> by pointwise addition 
of <var>t1</var> and <var>t2</var>. (Note that in this context addition means 
performing the <strong>GAP3</strong> operation <code>p * q</code> for the corresponding 
permutations <code>p</code> and <code>q</code>).
<P>
<code><var>t1</var> - <var>t2</var></code>
<P>
The subtract operator <code>-</code> returns the group transformation which is 
obtained from the group transformations <var>t1</var> and <var>t2</var> by pointwise 
subtraction of <var>t1</var> and <var>t2</var>. (Note that in this context subtraction 
means performing the <strong>GAP3</strong> operation <code>p * q^{}-1</code> for the corresponding 
permutations <code>p</code> and <code>q</code>).
<P>
Of course, those two functions <code>+</code> and <code>-</code> work only for group 
transformations.
<P>
<pre>  gap> g:=Group( (1,2,3) );
  Group( (1,2,3) )
  gap> gt1:=Transformation( g, [2,3,3] );
  Transformation( Group( (1,2,3) ), [ 2, 3, 3 ] )
  gap> gt2:=Transformation( g, [1,3,2] );
  Transformation( Group( (1,2,3) ), [ 1, 3, 2 ] )
  gap> gt1+gt2;
  Transformation( Group( (1,2,3) ), [ 2, 2, 1 ] )
  gap> gt1-gt2;
  Transformation( Group( (1,2,3) ), [ 2, 1, 2 ] )
</pre>
<P><A NAME="SECT012"><h2>63.12 DisplayTransformation</h2></a>
<P><P>
<code>DisplayTransformation( <var>t</var> )</code>
<P>
<code>DisplayTransformation</code> nicely displays a transformation <var>t</var>.
<P>
<pre>  gap> t:=Transformation( [1..5], [3,3,2,1,4] );
  Transformation( [ 1, 2, 3, 4, 5 ], [ 3, 3, 2, 1, 4 ] )
  gap> DisplayTransformation( t );
  Transformation on [ 1, 2, 3, 4, 5 ]:
    1 -> 3
    2 -> 3
    3 -> 2
    4 -> 1
    5 -> 4
  gap>
</pre>  
<P><A NAME="SECT013"><h2>63.13 Transformation records</h2></a>
<P><P>
As almost all objects in <strong>GAP3</strong>, transformations, too, are representend by 
records. Such a transformation record has the following components:
<P>
<DL><DT><code>isGeneralMapping</code>:<DD> <BR> 
  this is always <code>true</code>, since in particular, any transformation is a 
  general mapping. 
</DL><P>
<DL><DT><code>domain</code>:<DD> <BR>               
  the entry of this record field is <code>Mappings</code>.
</DL><P>
<DL><DT><code>isMapping</code>:<DD> <BR> 
  this is always <code>true</code> since a transformation is in particular a single
  valued mapping.
</DL><P>
<DL><DT><code>isTransformation</code>:<DD> <BR>    
  always <code>true</code> for a transformation.
</DL><P>
<DL><DT><code>isSetTransformation</code>:<DD> <BR>  
  this exists and is set to <code>true</code> for set transformations exclusively.
</DL><P>
<DL><DT><code>isGroupTransformation</code>, <code>isGroupElement</code>:<DD> <BR> 
  these two exist and are set to <code>true</code> for group transformations 
  exclusively.
</DL><P>
<DL><DT><code>elements</code>:<DD> <BR> 
  this record field holds a list of the elements of the source.
</DL><P>
<DL><DT><code>source</code>, <code>range</code>:<DD> <BR> 
  both entries contain the same set in case of a set transformation, resp.
  the same group in case of a group transformation.
</DL><P>
<DL><DT><code>tfl</code>:<DD> <BR>                   
  this contains the transformation list which uniquely determines the 
  transformation.
</DL><P>
<DL><DT><code>operations</code>:<DD> <BR> 
  the operations record of the transformation. E.g. * or <code>=</code>, etc.
  can be found here.
</DL><P>
<DL><DT><code>image</code>, <code>rank</code>, <code>ker</code>:<DD> <BR> 
  these are bound and contain image, rank, kernel in case they have 
  already been computed for the transformation.
</DL><P><A NAME="SECT014"><h2>63.14 Transformation Semigroups</h2></a>
<P><P><P>
Having established transformations and being able to perform the associative 
operation <strong>composition</strong> (which in <strong>GAP3</strong> is denoted as <code>*</code> with 
them, the next step is to consider <strong>transformation semigroups</strong>.
<P>
All functions described in this section are intended for <strong>finite</strong>
transformation semigroups, in particular transformation semigroups
on a finite set or group <I>X</I>.
A transformation semigroup is created by the constructor function 
<code>Trans\-for\-ma\-tion\-Semi\-group</code> and it is represented by a record 
that contains all the information about the transformation semigroup. 
<P><A NAME="SECT015"><h2>63.15 TransformationSemigroup</h2></a>
<P><P><P>
<code>TransformationSemigroup( <var><I>t<sub>1</sub></I></var>, ..., <var><I>t<sub>n</sub></I></var> )</code> <BR> 
<code>TransformationSemigroup( [ <var><I>t<sub>1</sub></I></var>, ..., <var><I>t<sub>n</sub></I></var> ] )</code> 
<P>
When called in this form, the constructor function 
<code>Trans\-for\-mation\-Semi\-group</code> returns the 
transformation semigroup generated by the transformations 
<var><I>t<sub>1</sub></I></var>, ..., <var><I>t<sub>n</sub></I></var>. There is another way to call this function: 
<P>
<code>TransformationSemigroup( <var>n</var> )</code> 
<P>
If the argument is a positive integer <I>n</I>, 
<code>Trans\-for\-mation\-Semi\-group</code> returns the semigroup of all 
transformations on the set <I>{1,2, ... , n}</I>.
<P>
<pre>  gap> t1 := Transformation( [1..3], [1,1,2] );
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  gap> t2 := Transformation( [1..3], [2,3,3] );
  Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] )
  gap> s:=TransformationSemigroup( t1, t2 );
  TransformationSemigroup( Transformation( [ 1, 2, 3 ],
  [ 1, 1, 2 ], Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) )
  gap> s27 := TransformationSemigroup( 3 );
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 2, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 2, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 2, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 3, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 3, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 1, 3, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 1, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 1, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 1, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 2, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 2, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 2, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 3, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 3, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 2, 3, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 1, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 1, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 1, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 2, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 2, 2 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 2, 3 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 3, 1 ] ), Transformation( [ 1, 2, 3 ], 
  [ 3, 3, 2 ] ), Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ) 
</pre>
<P><A NAME="SECT016"><h2>63.16 IsSemigroup</h2></a>
<P><P><P>
<code>IsSemigroup( <var> obj</var> )</code> 
<P>
<code>IsSemigroup</code> returns <code>true</code> if the object <var>obj</var> is a semigroup
and <code>false</code> otherwise. This function simply checks whether the record 
component <code><var>obj</var>.isSemigroup</code> is bound and is <code>true</code>.
<P>
<pre>  gap> IsSemigroup( t1 );      
  false                         # a transformation is not a semigroup  
  gap> IsSemigroup( Group( (1,2,3) ) );
  false                         # a group is not a semigroup
  gap> IsSemigroup( s27 );
  true
</pre>
<P><A NAME="SECT017"><h2>63.17 IsTransformationSemigroup</h2></a>
<P><P><P>
<code>IsTransformationSemigroup( <var>obj</var> )</code> 
<P>
<code>IsTransformationSemigroup</code> returns <code>true</code> if the object <var>obj</var> 
is a transformation semigroup and <code>false</code> otherwise. 
<P>
<pre>  gap> IsTransformationSemigroup( s27 );
  true
</pre>
<P><A NAME="SECT018"><h2>63.18 Elements for semigroups</h2></a>
<P><P><P>
<code>Elements( <var>sg</var> )</code> 
<P>
<code>Elements</code> computes the elements of the semigroup <var>sg</var>. Note: the 
<strong>GAP3</strong> standard library dispatcher function <code>Elements</code> calls the function 
<code><var>sg</var>.operations.Elements</code> which performs a simple closure 
algorithm.
<P>
<pre>  gap> t1 := Transformation( [1..3], [1,1,2] );
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  gap> t2 := Transformation( [1..3], [2,3,3] );
  Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] )
  gap> s := TransformationSemigroup( t1, t2 );
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 2 ] ), Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ) 
  gap> Elements( s );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ]
</pre>
<P><A NAME="SECT019"><h2>63.19 Size for semigroups</h2></a>
<P><P><P>
<code>Size( <var>sg</var> )</code> 
<P>
<code>Size</code> returns the number of elements in <var>sg</var>.
<P>
<pre>  gap> Size( s );
  7
</pre>
<P><A NAME="SECT020"><h2>63.20 DisplayCayleyTable for semigroups</h2></a>
<P><P><P>
<code>DisplayCayleyTable( <var>sg</var> )</code>  
<P>
<code>DisplayCayleyTable</code> prints the Cayley table of the semigroup <var>sg</var>. Note: 
The dispatcher function <code>DisplayCayleyTable</code> calls the function 
<code><var>sg</var>.operations.DisplayTable</code> which performs the actual printing. 
<code>Display\-Cayley\-Table</code> has no return value.
<P>
<pre>  gap> DisplayCayleyTable( s );
  Let:
  s0 := Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] )
  s1 := Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
  s2 := Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] )
  s3 := Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] )
  s4 := Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] )
  s5 := Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] )
  s6 := Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] )


    *  | s0 s1 s2 s3 s4 s5 s6 
   ---------------------------
    s0 | s0 s0 s0 s3 s3 s3 s6 
    s1 | s0 s0 s1 s3 s3 s4 s6 
    s2 | s0 s0 s2 s3 s3 s5 s6 
    s3 | s0 s0 s3 s3 s3 s6 s6 
    s4 | s0 s1 s3 s3 s4 s6 s6 
    s5 | s0 s2 s3 s3 s5 s6 s6 
    s6 | s0 s3 s3 s3 s6 s6 s6 
</pre>
<P><A NAME="SECT021"><h2>63.21 IdempotentElements for semigroups</h2></a>
<P><P><P>
<code>IdempotentElements( <var>sg</var> )</code>  
<P>
An element <I>i</I> of a semigroup <I>(S,.)</I> is called an <strong>idempotent</strong> 
(element) if\/f <I>i . i = i</I>.  
<P>
The function <code>IdempotentElements</code> returns a list of those elements of 
the semigroup <var>sg</var> that are idempotent. (Note that for a finite
semigroup this can never be the empty list).
<P>
<pre>  gap> IdempotentElements( s );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ]
</pre>
<P><A NAME="SECT022"><h2>63.22 IsCommutative for semigroups</h2></a>
<P><P><P>
<code>IsCommutative( <var>sg</var> )</code>  
<P>
A semigroup <I>(S,.)</I> is called <strong>commutative</strong> if 
<I>&forall; a, b &isin; S: a . b = b . a</I>.  
<P>
The function <code>IsCommutative</code> returns 
the according value <code>true</code> or <code>false</code> for a semigroup <var>sg</var>.
<P>
<pre>  gap> IsCommutative( s );
  false
</pre>
<P><A NAME="SECT023"><h2>63.23 Identity for semigroups</h2></a>
<P><P><P>
<code>Identity( <var>sg</var> )</code>  
<P>
An element <I>i</I> of a semigroup <I>(S,.)</I> is called an <strong>identity</strong> if\/f
<I>&forall; s &isin; S: s . i = i . s = s</I>. Since for two identities, 
<I>i,j</I>: <I>i = i . j = j</I>, an identity is unique if it exists.  
<P>
The function <code>Identity</code> returns a list containing as single entry the 
identity of the semigroup <var>sg</var> 
if it exists or the empty list <code>[  ]</code> otherwise.
<P>
<pre>  gap> Identity( s );
  [  ]
  gap> tr1 := Transformation( [1..3], [1,1,1] );
  Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] )
  gap> tr2 := Transformation( [1..3], [1,2,2] );
  Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] )
  gap> sg := TransformationSemigroup( tr1, tr2 );
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 1 ] ), Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ) ) 
  gap> Elements( sg );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ) ]
  gap> Identity( sg );
  [ Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ) ]
</pre>
<P>
The last example shows that the identity element of a transformation 
semigroup on a set <I>X</I> needs not necessarily be the identity transformation
on <I>X</I>.
<P><A NAME="SECT024"><h2>63.24 SmallestIdeal</h2></a>
<P><P><P>
<code>SmallestIdeal( <var>sg</var> )</code>  
<P>
A subset <I>I</I> of a semigroup <I>(S,.)</I> is defined as an <strong>ideal</strong> of <I>S</I> 
if <I>&forall; i &isin; I, s &isin; S: i . s &isin; I \& s . i &isin; I</I>. An  
ideal <I>I</I> is called <strong>minimal</strong>, if for any ideal <I>J</I>, <I>J &sube; I</I>
implies <I>J = I</I>. If a minimal ideal exists, then it is unique and therefore
the <strong>smallest</strong> ideal of <I>S</I>.
<P>
The function <code>SmallestIdeal</code> returns the smallest ideal of the 
transformation semigroup <var>sg</var>. Note that for a finite semigroup the 
smallest ideal always exists. (Which is not necessarily true for an 
arbitrary semigroup).
<P>
<pre>  gap> SmallestIdeal( s );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ]
</pre>
<P><A NAME="SECT025"><h2>63.25 IsSimple for semigroups</h2></a>
<P><P><P>
<code>IsSimple( <var>sg</var> )</code>  
<P>
A semigroup <I>S</I> is called <strong>simple</strong> if it has no honest ideals, i.e.
in case that <I>S</I> is finite the smallest ideal of <I>S</I> equals <I>S</I> itself. 
<P>
The <strong>GAP3</strong> standard library dispatcher function <code>IsSimple</code> calls the 
function 
<code>sg.\-op\-er\-a\-tions.\-Is\-Simple</code> which checks if the semigroup 
<var>sg</var> equals its smallest ideal and if so, returns <code>true</code> and 
otherwise <code>false</code>.
<P>
<pre>  gap> IsSimple( s );                                                    
  false
  gap> c3 := TransformationSemigroup( Transformation( [1..3],            
  >                                   [2,3,1] ) );
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], [ 2, 3, 1 ] ) ) 
  gap> IsSimple( c3 );
  true
</pre>
<P><A NAME="SECT026"><h2>63.26 Green</h2></a>
<P><P><P>
<code>Green( <var>sg</var>, <var>string</var> )</code>  
<P>
Let <I>(S,.)</I> be a semigroup and <I>a &isin; S</I>. The set <I>a . S<sup>1</sup> := 
a . S &cup; {a}</I> is called the principal right ideal generated by <I>a</I>.
Analogously, <I>S<sup>1</sup> . a := 
S . a &cup; {a}</I> is called the principal left ideal generated by <I>a</I>
and  <I>S<sup>1</sup> . a . S<sup>1</sup> := 
S . a . S &cup; S . a &cup; a . S &cup; {a}</I> is called 
the principal ideal generated by <I>a</I>.
<P>
Now, Green's equivalence relation <I><span style="font-family: cursive"> L</span></I> on <I>S</I> is defined as: 
<I>(a,b) &isin; <span style="font-family: cursive"> L</span>: &hArr; S<sup>1</sup> . a = S<sup>1</sup> . b</I> i.e. 
<I>a</I> and <I>b</I> generate the same principal left ideal. Similarly: 
<I>(a,b) &isin; <span style="font-family: cursive"> R</span>: &hArr; a . S<sup>1</sup> = b . S<sup>1</sup></I> i.e. 
<I>a</I> and <I>b</I> generate the same principal right ideal and
<I>(a,b) &isin; <span style="font-family: cursive"> J</span>: &hArr; S<sup>1</sup> . a . S<sup>1</sup> = 
S<sup>1</sup> . b . S<sup>1</sup></I> i.e. 
<I>a</I> and <I>b</I> generate the same principal ideal. 
<I><span style="font-family: cursive"> H</span></I> is defined as the intersection of <I><span style="font-family: cursive"> L</span></I> and <I><span style="font-family: cursive"> R</span></I>
and <I><span style="font-family: cursive"> D</span></I> is defined as the join of <I><span style="font-family: cursive"> L</span></I> and <I><span style="font-family: cursive"> R</span></I>.
<P>
In a finite semigroup, <I><span style="font-family: cursive"> D</span> = <span style="font-family: cursive"> J</span></I>.
<P>
The arguments of the function <code>Green</code> are a finite transformation
semigroup <var>sg</var> and a one character string <var>string</var> where  
<var>string</var> must be one of the following: <code>"L"</code>, <code>"R"</code>, 
<code>"D"</code>, <code>"J"</code>, <code>"H"</code>. The return value of <code>Green</code> is
a list of lists of elements of <var>sg</var> representing the equivalence
classes of the according Green's relation. 
<P>
<pre>  gap> s;
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], 
  [ 1, 1, 2 ] ), Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ) 
  gap> Elements( s );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ]
  gap> Green( s, "L" );
  [ [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ] ]
  gap> Green( s, "R" );
  [ [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ] ]
  gap> Green( s, "H" );
  [ [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ] ]
  gap> Green( s, "D" );
  [ [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ], 
    [ Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
        Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ) ] ]
</pre>
<P><A NAME="SECT027"><h2>63.27 Rank for semigroups</h2></a>
<P><P><P>
<code>Rank( <var>sg</var> )</code>  
<P>
The <strong>rank</strong> of a transformation semigroup <I>S</I> is defined as the minimal
rank of the elements of <I>S</I>, i.e. <I>\min{ rank(s) | s &isin; S }</I>.
<P>
The function <code>Rank</code> returns the rank of the semigroup <var>sg</var>.
<P>
<pre>  gap> Rank( s );
  1
  gap> c3;
  TransformationSemigroup( Transformation( [ 1, 2, 3 ], [ 2, 3, 1 ] ) ) 
  gap> Rank( c3 );
  3
</pre>
<P><A NAME="SECT028"><h2>63.28 LibrarySemigroup</h2></a>
<P><P><P>
<code>LibrarySemigroup( <var>size</var>, <var>num</var> )</code>  
<P>
The semigroup library contains all semigroups of sizes <I>1</I> up to <I>5</I>,
classified into classes of isomorphic semigroups.
<code>LibrarySemigroup</code> retrieves a representative of an isomorphism class 
from the semigroup library and returns it as a transformation semigroup.
The parameters of <code>LibrarySemigroup</code> are two positive integers: 
<var>size</var> must be in <I>{1,2,3,4,5}</I> and indicates the size of the semigroup 
to be retrieved, <var>num</var> indicates the number of an isomorphism class.
<P>
<pre>  gap> ls := LibrarySemigroup( 4, 123 );
  TransformationSemigroup( Transformation( [ 1, 2, 3, 4 ], 
  [ 1, 1, 3, 3 ] ), Transformation( [ 1, 2, 3, 4 ], 
  [ 1, 2, 3, 4 ] ), Transformation( [ 1, 2, 3, 4 ], 
  [ 1, 3, 3, 1 ] ), Transformation( [ 1, 2, 3, 4 ], [ 1, 4, 3, 2 ] ) ) 
  gap> DisplayCayleyTable( ls );
  Let:
  s0 := Transformation( [ 1, 2, 3, 4 ], [ 1, 1, 3, 3 ] )
  s1 := Transformation( [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] )
  s2 := Transformation( [ 1, 2, 3, 4 ], [ 1, 3, 3, 1 ] )
  s3 := Transformation( [ 1, 2, 3, 4 ], [ 1, 4, 3, 2 ] )


    *  |  s0 s1 s2 s3 
   ------------------
    s0 | s0 s0 s0 s0 
    s1 | s0 s1 s2 s3 
    s2 | s2 s2 s2 s2 
    s3 | s2 s3 s0 s1 

</pre>
<P><A NAME="SECT029"><h2>63.29 Transformation semigroup records</h2></a>
<P><P><P>
Transformation Semigroups are implemented as records.  
Such a transformation semigroup record has the following components:
<P>
<DL><DT><code>isDomain</code>, <code>isSemigroup</code>:<DD> <BR> 
  these two are always <code>true</code> for a transformation semigroup.  
</DL><P>
<DL><DT><code>isTransformationSemigroup</code>:<DD> <BR> 
  this is bound and <code>true</code> only for transformation semigroups. 
</DL><P>
<DL><DT><code>generators</code>:<DD> <BR> 
  this holds the set of generators of a transformation semigroup.
</DL><P>
<DL><DT><code>multiplication</code>:<DD> <BR> 
  this record field contains a function that represents the binary operation 
  of the semigroup that can be performed on the elements of the semigroup. 
  For transformation semigroups this equals of course, composition.
  Example: 
</DL><P>
<pre>  gap> elms := Elements( s );
  [ Transformation( [ 1, 2, 3 ], [ 1, 1, 1 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 1, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 2 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 2, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 2, 3, 3 ] ), 
    Transformation( [ 1, 2, 3 ], [ 3, 3, 3 ] ) ]
  gap> s.multiplication( elms[5], elms[2] );
  Transformation( [ 1, 2, 3 ], [ 1, 1, 2 ] )
</pre>
<P>
<DL><DT><code>operations</code>:<DD> <BR> 
  this is the operations record of the semigroup.
</DL><P>
<code>size</code>, <code>elements</code>, <code>rank</code>, <code>smallestIdeal</code>, 
<DL><DT>      <code>IsFinite</code>, <code>identity</code>:<DD> <BR> 
  these entries become bound if the according functions have been performed
  on the semigroup.
</DL><P>
<code>GreenL</code>, <code>GreenR</code>, <code>GreenD</code>, 
<DL><DT>      <code>GreenJ</code>, <code>GreenH</code>:<DD> <BR> 
  these are entries according to calls of the function <code> Green</code> with
  the corresponding parameters.
</DL><P><A NAME="SECT030"><h2>63.30 Near-rings</h2></a>
<P><P>
In section <a href="chap077.htm">Transformations</a> we introduced transformations on sets and groups. 
We used set transformations together with composition <code>*</code> to construct
transformation semigroups in section <a href="chap063.htm#SECT014">Transformation Semigroups</a>.
In section <a href="chap077.htm">Transformations</a>
we also introduced the operation of pointwise addition <code>+</code> for group
transformations. Now we are able to use these group transformations
together with pointwise addition <code>+</code> and composition <code>*</code> to
construct (right) near-rings.
<P>
A <strong>(right) near-ring</strong> is a nonempty set <I>N</I> together with two binary 
operations on <I>N</I>, <I>+</I> and <I>.</I> s.t. <I>(N,+)</I> is a group, <I>(N,.)</I> is 
a semigroup, and <I>.</I> is right distributive over <I>+</I>, i.e. 
<I>&forall; n<sub>1</sub>,n<sub>2</sub>,n<sub>3</sub> &isin; N: (n<sub>1</sub>+n<sub>2</sub>). n<sub>3</sub> = n<sub>1</sub>. n<sub>3</sub>+n<sub>2</sub>. n<sub>3</sub></I>.
<P>
Here we have to make a <strong>remark</strong>: we let transformations act from the
right; yet in order to get a right transformation near-ring transformations
must act from the left, hence we define a near-ring multiplication
<I>.</I> of two transformations, <I>t<sub>1</sub></I>, <I>t<sub>2</sub></I> as <I>t<sub>1</sub> . t<sub>2</sub> :=
t<sub>2</sub> * t<sub>1</sub></I>.
<P>
There are three possibilities to get a near-ring in <strong>GAP3</strong>: the
constructor function <code>Nearring</code> can be used in two different ways or a 
near-ring can be extracted from the near-rings library by using the function 
<code>LibraryNearring</code>. All functions described here were programmed for
permutation groups and they also work fine with them; other types of groups
(such as AG groups) are not supported.
<P>
Near-rings are represented by records that contain the necessary information
to identify them and to do computations with them. 
<P><A NAME="SECT031"><h2>63.31 IsNrMultiplication</h2></a>
<P><P>
<code>IsNrMultiplication( <var>G</var>, <var>mul</var> )</code>  
<P>
The arguments of the function <code>Is\-Nr\-Mul\-ti\-pli\-ca\-tion</code> are a 
permutation group <var>G</var> and a <strong>GAP3</strong> function <var>mul</var> which has two 
arguments <code>x</code> and <code>y</code> which must both be elements of the group 
<var>G</var> and returns an element <code>z</code> of <var>G</var> s.t. <var>mul</var> defines a 
binary operation on <var>G</var>.
<P>
<code>IsNrMultiplication</code> returns <code>true</code> (<code>false</code>) if <var>mul</var> is 
(is not) a near-ring multiplication on <var>G</var> i.e. it checks whether it is 
well-defined, associative and right distributive over the group operation of 
<var>G</var>.
<P>
<pre>  gap> g := Group( (1,2), (1,2,3) );        
  Group( (1,2), (1,2,3) )
  gap> mul_r := function(x,y) return x; end;
  function ( x, y ) ... end
  gap> IsNrMultiplication( g, mul_r );
  true
  gap> mul_l := function(x,y) return y; end;
  function ( x, y ) ... end
  gap> IsNrMultiplication( g, mul_l );      
  specified multiplication is not right distributive.
  false
</pre>
<P><A NAME="SECT032"><h2>63.32 Nearring</h2></a>
<P><P>
<code>Nearring( <var>G</var>, <var>mul</var> )</code> 
<P>
In this form the constructor function <code>Nearring</code> returns the near-ring 
defined by the permutation 
group <var>G</var> and the near-ring multiplication <var>mul</var>. (For a detailed
explanation of <var>mul</var> see <a href="chap063.htm#SECT031">IsNrMultiplication</a>). <code>Near\-ring</code> calls 
<code>Is\-Nr\-Mul\-ti\-pli\-ca\-tion</code> 
in order to make sure that <var>mul</var> is really a near-ring multiplication.
<P>
<pre>  gap> g := Group( (1,2,3) );
  Group( (1,2,3) )
  gap> mul_r := function(x,y) return x; end;
  function ( x, y ) ... end
  gap> n := Nearring( g, mul_r );
  Nearring( Group( (1,2,3) ), function ( x, y )
      return x;
  end )
  gap> DisplayCayleyTable( n );
  Let:
  n0 := ()
  n1 := (1,2,3)
  n2 := (1,3,2)

    +  | n0 n1 n2 
   ---------------
    n0 | n0 n1 n2 
    n1 | n1 n2 n0 
    n2 | n2 n0 n1 

    *  | n0 n1 n2 
   ---------------
    n0 | n0 n0 n0 
    n1 | n1 n1 n1 
    n2 | n2 n2 n2 

</pre>
<P><P>
<code>Nearring( <var><I>t<sub>1</sub></I></var>, ..., <var><I>t<sub>n</sub></I></var> )</code> <BR> 
<code>Nearring( [<var><I>t<sub>1</sub></I></var>, ..., <var><I>t<sub>n</sub></I></var>] )</code> 
<P>
In this form the constructor function <code>Near\-ring</code> returns the near-ring 
generated by the group 
transformations <var><I>t<sub>1</sub>,...,t<sub>n</sub></I></var>. All of them must be transformations
on the same permutation group.
<P>
Note that <code>Near\-ring</code> allows also a list of group transformations as 
argument, which makes it possible to call
<code>Nearring</code> e.g. with a list of endomorphisms generated by the function
<code>Endo\-mor\-phisms</code> (see <a href="chap063.htm#SECT071">Endomorphisms for groups</a>), which for a group 
<I>G</I>
allows to compute <I>E(G)</I>; <code>Near\-ring</code> called with the list of all
inner automorphisms of a group <I>G</I> would return <I>I(G)</I>.
<P>
<pre>  gap> t := Transformation( Group( (1,2) ), [2,1] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
  gap> n := Nearring( t );
  Nearring( Transformation( Group( (1,2) ), [ 2, 1 ] ) ) 
  gap> DisplayCayleyTable( n );
  Let:
  n0 := Transformation( Group( (1,2) ), [ 1, 1 ] )
  n1 := Transformation( Group( (1,2) ), [ 1, 2 ] )
  n2 := Transformation( Group( (1,2) ), [ 2, 1 ] )
  n3 := Transformation( Group( (1,2) ), [ 2, 2 ] )

    +  | n0 n1 n2 n3 
   ------------------
    n0 | n0 n1 n2 n3 
    n1 | n1 n0 n3 n2 
    n2 | n2 n3 n0 n1 
    n3 | n3 n2 n1 n0 

    *  | n0 n1 n2 n3 
   ------------------
    n0 | n0 n0 n0 n0 
    n1 | n0 n1 n2 n3 
    n2 | n3 n2 n1 n0 
    n3 | n3 n3 n3 n3 

  gap> g := Group( (1,2), (1,2,3) );
  Group( (1,2), (1,2,3) )
  gap> e := Endomorphisms( g );
  [ Transformation( Group( (1,2), (1,2,3) ), [ 1, 1, 1, 1, 1, 1 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 2, 1, 1, 2 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 6, 5, 4, 3 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 2, 5, 4, 6 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 3, 1, 1, 3 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 6, 4, 5, 2 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 2, 4, 5, 3 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 3, 5, 4, 2 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 6, 1, 1, 6 ] ), 
    Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 3, 4, 5, 6 ] ) ]
  gap> nr := Nearring( e );     # the endomorphisms near-ring on S3
  Nearring( Transformation( Group( (1,2), (1,2,3) ), [ 1, 1, 1, 1, 1, 1 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 2, 1, 1, 2 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 3, 4, 5, 6 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 2, 6, 5, 4, 3 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 2, 5, 4, 6 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 3, 1, 1, 3 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 3, 6, 4, 5, 2 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 2, 4, 5, 3 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 3, 5, 4, 2 
   ] ), Transformation( Group( (1,2), (1,2,3) ), [ 1, 6, 6, 1, 1, 6 ] ) ) 
  gap> Size( nr );
  54
</pre>
<P><A NAME="SECT033"><h2>63.33 IsNearring</h2></a>
<P><P>
<code>IsNearring( <var>obj</var> )</code>  
<P>
<code>IsNearring</code> returns <code>true</code> if the object <var>obj</var> is a near-ring 
and <code>false</code> otherwise. This function simply checks if the record 
component <code><var>obj</var>.isNear-ring</code> is bound to the value <code>true</code>.
<P>
<pre>  gap> n := LibraryNearring( "C3", 4 );
  LibraryNearring( "C3", 4 )
  gap> IsNearring( n );
  true
  gap> IsNearring( nr );
  true
  gap> IsNearring( Integers );
  false           # Integers is a ring record, not a near-ring record
</pre>
<P><A NAME="SECT034"><h2>63.34 IsTransformationNearring</h2></a>
<P><P>
<code>IsTransformationNearring( <var>obj</var> )</code>  
<P>
<code>IsTransformationNearring</code> returns <code>true</code> if the object <var>obj</var> is 
a transformation near-ring and <code>false</code> otherwise. 
<code>Is\-Trans\-for\-ma\-tion\-Near\-ring</code> 
simply checks if the record component 
<code><var>obj</var>.is\-Trans\-for\-ma\-tion\-Near\-ring</code> is 
bound to <code>true</code>. 
<P>
<pre>  gap> IsTransformationNearring( nr );
  true
  gap> IsTransformationNearring( n );
  false
</pre>
<P><A NAME="SECT035"><h2>63.35 LibraryNearring</h2></a>
<P><P>
<code>LibraryNearring( <var>grp\_name</var>, <var>num</var> )</code>  
<P>
<code>LibraryNearring</code> retrieves a near-ring from the near-rings library files. 
<var>grp\_name</var> must be one of the following strings  
indicating the name of the according group: <code>"C2"</code>, <code>"C3"</code>, 
<code>"C4"</code>, <code>"V4"</code>, <code>"C5"</code>, <code>"C6"</code>, <code>"S3"</code>, <code>"C7"</code>,
<code>"C8"</code>, <code>"C2xC4"</code>, <code>"C2xC2xC2"</code>, <code>"D8"</code>, <code>"Q8"</code>, 
<code>"C9"</code>, <code>"C3xC3"</code>, <code>"C10"</code>, <code>"D10"</code>, <code>"C11"</code>, 
<code>"C12"</code>, <code>"C2xC6"</code>, <code>"D12"</code>, <code>"A4"</code>, <code>"T"</code>, 
<code>"C13"</code>, <code>"C14"</code>, <code>"D14"</code>, <code>"C15"</code>, 
<var>num</var> must be an integer which indicates the number of the class of 
near-rings on the specified group. 
<P>
<pre>  gap> n := LibraryNearring( "V4", 13 );
  LibraryNearring( "V4", 13 )
</pre>
<P><A NAME="SECT036"><h2>63.36 DisplayCayleyTable for near-rings</h2></a>
<P><P>
<code>DisplayCayleyTable( <var>nr</var> )</code>  
<P>
<code>DisplayCayleyTable</code> prints the additive and multiplicative Cayley tables 
of the near-ring <var>nr</var>. This function  
works the same way as for semigroups; the dispatcher function 
<code>Display\-Cayley\-Table</code> calls
<code><var>nr</var>.op\-e\-ra\-tions.Display\-Ta\-ble</code> which performs the actual printing.
<P>
<pre>  gap> DisplayCayleyTable( LibraryNearring( "V4", 22 ) );
  Let:
  n0 := ()
  n1 := (3,4)
  n2 := (1,2)
  n3 := (1,2)(3,4)

    +  | n0 n1 n2 n3 
   ------------------
    n0 | n0 n1 n2 n3 
    n1 | n1 n0 n3 n2 
    n2 | n2 n3 n0 n1 
    n3 | n3 n2 n1 n0 

    *  | n0 n1 n2 n3 
   ------------------
    n0 | n0 n0 n0 n0 
    n1 | n0 n1 n2 n3 
    n2 | n2 n2 n2 n2 
    n3 | n2 n3 n0 n1 

</pre>
<P><A NAME="SECT037"><h2>63.37 Elements for near-rings</h2></a>
<P><P>
<code>Elements( <var>nr</var> )</code>  
<P>
The function <code>Elements</code> computes the elements of the near-ring <var>nr</var>. 
As for semigroups the 
<strong>GAP3</strong> standard library dispatcher function <code>Elements</code> calls 
<code><var>nr</var>.op\-er\-a\-tions.El\-e\-ments</code> which
simply returns the elements of <code><var>nr</var>.\-group</code> if <var>nr</var> is not a 
transformation near-ring or -- if <var>nr</var> is a transformation near-ring -- 
performs a simple closure algorithm and returns a set of transformations
which are the elements of <var>nr</var>.
<P>
<pre>  gap> t := Transformation( Group( (1,2) ), [2,1] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
  gap> Elements( Nearring( t ) );
  [ Transformation( Group( (1,2) ), [ 1, 1 ] ), 
    Transformation( Group( (1,2) ), [ 1, 2 ] ), 
    Transformation( Group( (1,2) ), [ 2, 1 ] ), 
    Transformation( Group( (1,2) ), [ 2, 2 ] ) ]
  gap> Elements( LibraryNearring( "C3", 4 ) );
  [ (), (1,2,3), (1,3,2) ]
</pre>
<P><A NAME="SECT038"><h2>63.38 Size for near-rings</h2></a>
<P><P>
<code>Size( <var>nr</var> )</code>  
<P>
<code>Size</code> returns the number of elements in the near-ring <var>nr</var>.
<P>
<pre>  gap> Size( LibraryNearring( "C3", 4 ) );
  3
</pre>
<P><A NAME="SECT039"><h2>63.39 Endomorphisms for near-rings</h2></a>
<P><P>
<code>Endomorphisms( <var>nr</var> )</code>  
<P>
<code>Endomorphisms</code> computes all the endomorphisms of the near-ring <var>nr</var>. 
The endomorphisms are returned as a list of transformations. In fact, the
returned list contains those endomorphisms of <code><var>nr</var>.group</code> which are 
also endomorphisms of the near-ring <var>nr</var>.
<P>
<pre>  gap> t := Transformation( Group( (1,2) ), [2,1] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
  gap> nr := Nearring( t );
  Nearring( Transformation( Group( (1,2) ), [ 2, 1 ] ) ) 
  gap> Endomorphisms( nr );
  [ Transformation( Group( (1,2)(3,4), (1,3)(2,4) ), [ 1, 1, 1, 1 ] ), 
    Transformation( Group( (1,2)(3,4), (1,3)(2,4) ), [ 1, 2, 2, 1 ] ), 
    Transformation( Group( (1,2)(3,4), (1,3)(2,4) ), [ 1, 2, 3, 4 ] ) ]
</pre>
<P><A NAME="SECT040"><h2>63.40 Automorphisms for near-rings</h2></a>
<P><P>
<code>Automorphisms( <var>nr</var> )</code>  
<P>
<code>Automorphisms</code> computes all the automorphisms of the near-ring <var>nr</var>. 
The automorphisms are returned as a list of transformations. In fact, the
returned list contains those automorphisms of <code><var>nr</var>.group</code> which are 
also automorphisms of the near-ring <var>nr</var>.
<P>
<pre>  gap> t := Transformation( Group( (1,2) ), [2,1] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
  gap> nr := Nearring( t );                         
  Nearring( Transformation( Group( (1,2) ), [ 2, 1 ] ) ) 
  gap> Automorphisms( nr );
  [ Transformation( Group( (1,2)(3,4), (1,3)(2,4) ), [ 1, 2, 3, 4 ] ) ]
</pre>
<P><A NAME="SECT041"><h2>63.41 FindGroup</h2></a>
<P><P>
<code>FindGroup( <var>nr</var> )</code>  
<P>
For a transformation near-ring <var>nr</var>, this function computes the additive
group of <var>nr</var> as a  <strong>GAP3</strong> permutation group and stores it in the record
component <code><var>nr</var>.group</code>. 
<P><P>
<pre>  gap> t := Transformation( Group( (1,2) ), [2,1] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
  gap> n := Nearring( t );                          
  Nearring( Transformation( Group( (1,2) ), [ 2, 1 ] ) ) 
  gap> g := FindGroup( n );                         
  Group( (1,2)(3,4), (1,3)(2,4) )
  gap> Elements( g );
  [ (), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ]
  gap> Elements( n );
  [ Transformation( Group( (1,2) ), [ 1, 1 ] ), 
    Transformation( Group( (1,2) ), [ 1, 2 ] ), 
    Transformation( Group( (1,2) ), [ 2, 1 ] ), 
    Transformation( Group( (1,2) ), [ 2, 2 ] ) ]
</pre>
<P><A NAME="SECT042"><h2>63.42 NearringIdeals</h2></a>
<P><P>
<code>NearringIdeals( <var>nr</var> )</code> <BR> 
<code>NearringIdeals( <var>nr</var>, </code>"l"<code> )</code> <BR> 
<code>NearringIdeals( <var>nr</var>, </code>"r"<code> )</code> 
<P>
<code>NearringIdeals</code>  computes all (left) (right) ideals of the near-ring 
<var>nr</var>. The return value is a list of subgroups 
of the additive group of <var>nr</var> representing the according ideals.
In case that <var>nr</var> is a transformation near-ring, <code>FindGroup</code> is used 
to determine the additive group of <var>nr</var> as a permutation group.
If the optional parameters <code>"l"</code> or <code>"r"</code> are passed, all left
resp. right ideals are computed.
<P>
<pre>  gap> n := LibraryNearring( "V4", 11 );
  LibraryNearring( "V4", 11 )
  gap> NearringIdeals( n );
  [ Subgroup( V4, [  ] ), Subgroup( V4, [ (3,4) ] ), V4 ]
  gap> NearringIdeals( n, "r" );
  [ Subgroup( V4, [  ] ), Subgroup( V4, [ (3,4) ] ), V4 ]
  gap> NearringIdeals( n, "l" );
  [ Subgroup( V4, [  ] ), Subgroup( V4, [ (3,4) ] ), 
    Subgroup( V4, [ (1,2) ] ), Subgroup( V4, [ (1,2)(3,4) ] ), V4 ]
</pre>
<P><A NAME="SECT043"><h2>63.43 InvariantSubnearrings</h2></a>
<P><P>
<code>InvariantSubnearrings( <var>nr</var> )</code>  
<P>
A subnear-ring <I>(M,+,.)</I> of a near-ring <I>(N,+,.)</I> is called an 
<strong>invariant subnear-ring</strong> if both, <I>M . N &sube; M</I> and
<I>N . M &sube; M</I>.
<P>
The function <code>InvariantSubnearrings</code>  computes all invariant 
subnear-rings of the near-ring <var>nr</var>.
The function returns a list of near-rings representing the according 
invariant subnear-rings.
In case that <var>nr</var> is a transformation near-ring, <code>FindGroup</code> is used 
to determine the additive group of <var>nr</var> as a permutation group.
<P>
<pre>  gap> InvariantSubnearrings( LibraryNearring( "V4", 22 ) );
  [ Nearring( Subgroup( V4, [ (1,2) ] ), function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ), Nearring( V4, function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ) ]
</pre>
<P><A NAME="SECT044"><h2>63.44 Subnearrings</h2></a>
<P><P>
<code>Subnearrings( <var>nr</var> )</code>  
<P>
The function <code>Subnearrings</code>  computes all subnear-rings of the near-ring 
<var>nr</var>. The function returns a list of near-rings representing the 
according subnear-rings.
In case that <var>nr</var> is a transformation near-ring, <code>FindGroup</code> is used 
to determine the additive group of <var>nr</var> as a permutation group.
<P>
<pre>  gap> Subnearrings( LibraryNearring( "V4", 22 ) );
  [ Nearring( Subgroup( V4, [  ] ), function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ), Nearring( Subgroup( V4, [ (3,4) ] ), function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ), Nearring( Subgroup( V4, [ (1,2) ] ), function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ), Nearring( V4, function ( x, y )
          return elms[tfle.(f[Position( elms, y )])[Position( elms, x )]
             ];
      end ) ]
</pre>
<P><A NAME="SECT045"><h2>63.45 Identity for near-rings</h2></a>
<P><P>
<code>Identity( <var>nr</var> )</code>  
<P>
The function <code>Identity</code> returns a list containing the identity of the 
multiplicative semigroup of the near-ring <var>nr</var> 
if it exists and the empty list <code>[  ]</code> otherwise.
<P>
<pre>  gap> Identity( LibraryNearring( "V4", 22 ) );    
  [ (3,4) ]
</pre>
<P><A NAME="SECT046"><h2>63.46 Distributors</h2></a>
<P><P>
<code>Distributors( <var>nr</var> )</code>  
<P>
An element <I>x</I> of a near-ring <I>(N,+,.)</I> is called a <strong>distributor</strong>
if <I>x = n<sub>1</sub> . (n<sub>2</sub> + n<sub>3</sub> ) - (n<sub>1</sub> . n<sub>2</sub> + n<sub>1</sub> . n<sub>3</sub> )</I> for 
some elements <I>n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub></I> of <I>N</I>.
<P>
The function <code>Distributors</code> returns a list containing the distributors 
of the near-ring <var>nr</var>.
<P>
<pre>  gap> Distributors( LibraryNearring( "S3", 19 ) );
  [ (), (1,2,3), (1,3,2) ]
</pre>
<P><A NAME="SECT047"><h2>63.47 DistributiveElements</h2></a>
<P><P>
<code>DistributiveElements( <var>nr</var> )</code>  
<P>
An element <I>d</I> of a right near-ring <I>(N,+,.)</I> is called a 
<strong>distributive element</strong> if it is also left distributive over all elements,
i.e. 
<I>&forall; n<sub>1</sub>, n<sub>2</sub> &isin; N: d . (n<sub>1</sub> + n<sub>2</sub> ) = d . n<sub>1</sub> + d . n<sub>2</sub></I>. 
<P>
The function <code>DistributiveElements</code> returns a list containing the 
distributive elements of the near-ring <var>nr</var>. 
<P>
<pre>  gap> DistributiveElements( LibraryNearring( "S3", 25 ) );
  [ (), (1,2,3), (1,3,2) ]
</pre>
<P><A NAME="SECT048"><h2>63.48 IsDistributiveNearring</h2></a>
<P><P>
<code>IsDistributiveNearring( <var>nr</var> )</code>  
<P>
A right near-ring <I>N</I> is called <strong>distributive near-ring</strong> if its
multiplication is also left distributive.
<P>
The function <code>IsDistributiveNearring</code> simply checks if all elements
are distributive and returns the according boolean value 
<code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsDistributiveNearring( LibraryNearring( "S3", 25 ) );
  false
</pre>
<P><A NAME="SECT049"><h2>63.49 ZeroSymmetricElements</h2></a>
<P><P>
<code>ZeroSymmetricElements( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a right near-ring and denote by <I>0</I> the neutral element 
of <I>(N,+)</I>. 
An element <I>n</I> of <I>N</I> is called a 
<strong>zero-symmetric element</strong> if <I>n . 0 = 0</I>. 
<P>
<strong>Remark\:</strong> note that in a <strong>right</strong> near-ring <I>0 . n = 0</I> is true
for all elements <I>n</I>.
<P>
The function <code>ZeroSymmetricElements</code> returns a list containing the 
zero-symmetric elements of the near-ring <var>nr</var>. 
<P>
<pre>  gap> ZeroSymmetricElements( LibraryNearring( "S3", 25 ) ); 
  [ (), (1,2,3), (1,3,2) ]
</pre>
<P><A NAME="SECT050"><h2>63.50 IsAbstractAffineNearring</h2></a>
<P><P>
<code>IsAbstractAffineNearring( <var>nr</var> )</code>  
<P>
A right near-ring <I>N</I> is called <strong>abstract affine</strong> if its
additive group is abelian and its zero-symmetric elements are exactly
its distributive elements.
<P>
The function <code>IsAbstractAffineNear-ring</code> returns the according boolean 
value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsAbstractAffineNearring( LibraryNearring( "S3", 25 ) );
  false
</pre>
<P><A NAME="SECT051"><h2>63.51 IdempotentElements for near-rings</h2></a>
<P><P>
<code>IdempotentElements( <var>nr</var> )</code>  
<P>
The function <code>IdempotentElements</code> returns a list containing the 
idempotent elements of the multiplicative semigroup of the near-ring <var>nr</var>. 
<P>
<pre>  gap> IdempotentElements( LibraryNearring( "S3", 25 ) );      
  [ (), (2,3) ]
</pre>
<P><A NAME="SECT052"><h2>63.52 IsBooleanNearring</h2></a>
<P><P>
<code>IsBooleanNearring( <var>nr</var> )</code>  
<P>
A right near-ring <I>N</I> is called <strong>boolean</strong> if all its elements are
idempotent with respect to multiplication.
<P>
The function <code>IsBooleanNearring</code> simply checks if all elements
are idempotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsBooleanNearring( LibraryNearring( "S3", 25 ) ); 
  false
</pre>
<P><A NAME="SECT053"><h2>63.53 NilpotentElements</h2></a>
<P><P>
<code>NilpotentElements( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a near-ring with zero <I>0</I>. An element <I>n</I> of <I>N</I> is 
called <strong>nilpotent</strong> if there is a positive integer <I>k</I> such that
<I>n<sup>k</sup> = 0</I>.
<P>
The function <code>NilpotentElements</code> returns a list of sublists of length 
<I>2</I> where the first entry is a nilpotent element <I>n</I> and the second
entry is the smallest <I>k</I> such that <I>n<sup>k</sup> = 0</I>.
<P>
<pre>  gap> NilpotentElements( LibraryNearring( "V4", 4 ) ); 
  [ [ (), 1 ], [ (3,4), 2 ], [ (1,2), 3 ], [ (1,2)(3,4), 3 ] ]
</pre>
<P><A NAME="SECT054"><h2>63.54 IsNilNearring</h2></a>
<P><P>
<code>IsNilNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>N</I> is called <strong>nil</strong> if all its elements are
nilpotent.
<P>
The function <code>IsNilNearring</code> checks if all elements
are nilpotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsNilNearring( LibraryNearring( "V4", 4 ) );    
  true
</pre>
<P><A NAME="SECT055"><h2>63.55 IsNilpotentNearring</h2></a>
<P><P>
<code>IsNilpotentNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>N</I> is called <strong>nilpotent</strong> if there is a positive integer
<I>k</I>, s.t. <I>N<sup>k</sup> = {0}</I>.
<P>
The function <code>IsNilpotentNearring</code> tests if
the near-ring <var>nr</var> is nilpotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsNilpotentNearring( LibraryNearring( "V4", 4 ) );
  true
</pre>
<P><A NAME="SECT056"><h2>63.56 IsNilpotentFreeNearring</h2></a>
<P><P>
<code>IsNilpotentFreeNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>N</I> is called <strong>nilpotent free</strong> if its only nilpotent
element is <I>0</I>.
<P>
The function <code>IsNilpotentFreeNearring</code> checks if 
<I>0</I> is the only nilpotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsNilpotentFreeNearring( LibraryNearring( "V4", 22 ) );       
  true
</pre>
<P><A NAME="SECT057"><h2>63.57 IsCommutative for near-rings</h2></a>
<P><P>
<code>IsCommutative( <var>nr</var> )</code>  
<P>
A near-ring <I>(N,+,.)</I> is called <strong>commutative</strong> if 
its multiplicative semigroup is commutative.
<P>
The function <code>IsCommutative</code> returns 
the according value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsCommutative( LibraryNearring( "C15", 1235 ) );       
  false
  gap> IsCommutative( LibraryNearring( "V4", 13 ) );   
  true
</pre>
<P><A NAME="SECT058"><h2>63.58 IsDgNearring</h2></a>
<P><P>
<code>IsDgNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>(N,+,.)</I> is called <strong>distributively generated (d.g.)</strong> if 
<I>(N,+)</I> is generated additively by the distributive elements of the
near-ring.
<P>
The function <code>IsDgNearring</code> returns 
the according value <code>true</code> or <code>false</code> for a near-ring <var>nr</var>.
<P>
<pre>  gap> IsDgNearring( LibraryNearring( "S3", 25 ) ); 
  false
  gap> IsDgNearring( LibraryNearring( "S3", 1 ) ); 
  true
</pre>
<P><A NAME="SECT059"><h2>63.59 IsIntegralNearring</h2></a>
<P><P>
<code>IsIntegralNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>(N,+,.)</I> with zero element <I>0</I> is called <strong>integral</strong> if 
it has no zero divisors, i.e. the condition <I>&forall; n<sub>1</sub>,n<sub>2</sub>: 
n<sub>1</sub> . n<sub>2</sub> = 0 &rArr; n<sub>1</sub> = 0 \lor n<sub>2</sub> = 0</I> holds.
<P>
The function <code>IsIntegralNearring</code> returns 
the according value <code>true</code> or <code>false</code> for a near-ring <var>nr</var>.
<P>
<pre>  gap> IsIntegralNearring( LibraryNearring( "S3", 24 ) );
  true
  gap> IsIntegralNearring( LibraryNearring( "S3", 25 ) );
  false
</pre>
<P><A NAME="SECT060"><h2>63.60 IsPrimeNearring</h2></a>
<P><P>
<code>IsPrimeNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>(N,+,.)</I> with zero element <I>0</I> is called <strong>prime</strong> if 
the ideal <I>{ 0 }</I> is a prime ideal.
<P>
The function <code>IsPrimeNearring</code> checks if <var>nr</var> is a prime near-ring
by using the condition <var>for all non-zero ideals</var> <I>I,J: I . J  &ne; 
{ 0 }</I> and returns the according value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsPrimeNearring( LibraryNearring( "V4", 11 ) );   
  false
</pre>
<P><A NAME="SECT061"><h2>63.61 QuasiregularElements</h2></a>
<P><P>
<code>QuasiregularElements( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a right near-ring. For an element <I>z &isin; N</I>, 
denote the left ideal generated by the set <I>{n - n. z | n &isin; N}</I>
by <I>L<sub>z</sub></I>.
An element <I>z</I> of <I>N</I> is 
called <strong>quasiregular</strong> if <I>z &isin; L<sub>z</sub></I>.
<P>
The function <code>QuasiregularElements</code> returns a list of all 
quasiregular elements of a near-ring <var>nr</var>.
<P>
<pre>  gap> QuasiregularElements( LibraryNearring( "V4", 4 ) ); 
  [ (), (3,4), (1,2), (1,2)(3,4) ]
</pre>
<P><A NAME="SECT062"><h2>63.62 IsQuasiregularNearring</h2></a>
<P><P>
<code>IsQuasiregularNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>N</I> is called <strong>quasiregular</strong> if all its elements are
quasiregular.
<P>
The function <code>IsQuasiregularNearring</code> simply checks if all elements
of the near-ring <var>nr</var> are quasiregular and returns the according 
boolean value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsQuasiregularNearring( LibraryNearring( "V4", 4 ) );
  true
</pre>
<P><A NAME="SECT063"><h2>63.63 RegularElements</h2></a>
<P><P>
<code>RegularElements( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a near-ring. An element <I>n</I> of <I>N</I> is 
called <strong>regular</strong> if there is an element <I>x</I> such that 
<I>n. x. n = n</I>.
<P>
The function <code>RegularElements</code> returns a list of all 
regular elements of a near-ring <var>nr</var>.
<P>
<pre>  gap> RegularElements( LibraryNearring( "V4", 4 ) );       
  [ () ]
</pre>
<P><A NAME="SECT064"><h2>63.64 IsRegularNearring</h2></a>
<P><P>
<code>IsRegularNearring( <var>nr</var> )</code>  
<P>
A near-ring <I>N</I> is called <strong>regular</strong> if all its elements are regular.
<P>
The function <code>IsRegularNearring</code> simply checks if all elements
of the near-ring <var>nr</var> are regular and returns the according 
boolean value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsRegularNearring( LibraryNearring( "V4", 4 ) );
  false
</pre>
<P><A NAME="SECT065"><h2>63.65 IsPlanarNearring</h2></a>
<P><P>
<code>IsPlanarNearring( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a right near-ring. For <I>a,b &isin; N</I> define the 
equivalence relation <I>&equiv;</I> by <I>a &equiv; b: &hArr;
&forall; n &isin; N: n. a = n. b</I>. If <I>a &equiv; b</I> then <I>a</I> and <I>b</I>
are called <strong>equivalent multipliers</strong>.
A near-ring <I>N</I> is called <strong>planar</strong> if 
<I>| N/<sub>&equiv;</sub> |  &ge; 3</I> and if every equation of the form
<I>x. a = x. b + c</I> has a unique solution for two non equivalent
multipliers <I>a</I> and <I>b</I>.
<P>
The function <code>IsPlanarNearring</code> returns 
the according value <code>true</code> or <code>false</code> for a near-ring <var>nr</var>.
<P>
<strong>Remark\:</strong> 
this function works only for library near-rings, i.e. near-rings which are
constructed by using the function <code>LibraryNearring</code>.
<P>
<pre>  gap> IsPlanarNearring( LibraryNearring( "V4", 22 ) );
  false
</pre>
<P><A NAME="SECT066"><h2>63.66 IsNearfield</h2></a>
<P><P>
<code>IsNearfield( <var>nr</var> )</code>  
<P>
Let <I>(N,+,.)</I> be a near-ring with zero <I>0</I> and denote by <I>N<sup>*</sup></I> 
the set <I>N - {0}</I>. N is a <strong>nearfield</strong> if
<I>(N<sup>*</sup>,.)</I> is a group.
<P>
The function <code>IsNearfield</code> tests if <var>nr</var> has an identity and 
if every non-zero element has a multiplicative inverse and returns
the according value <code>true</code> or <code>false</code>.
<P>
<pre>  gap> IsNearfield( LibraryNearring( "V4", 16 ) );     
  true
</pre>
<P><A NAME="SECT067"><h2>63.67 LibraryNearringInfo</h2></a>
<P><P>
<code>LibraryNearringInfo( <var>group\_name</var>, <var>list</var>, <var>string</var> )</code>  
<P>
This function provides information about the specified library near-rings
in a way similar to how near-rings are presented in the appendix of
<A href="biblio.htm#Pil83"><cite>Pil83</cite></a>.
The parameter <var>group\_name</var> specifies the name of a group; valid
names are exactly those which are also valid for the function
<code>Library\-Near\-rings</code> (cf. section <a href="chap063.htm#SECT035">LibraryNearring</a>). 
<P>
The parameter <var>list</var> must be a non-empty list of integers defining the 
classes of near-rings to be printed. Naturally, these integers must all fit 
into the ranges described in section <a href="chap063.htm#SECT035">LibraryNearring</a> for the according 
groups.
<P>
The third parameter <var>string</var> is optional. <var>string</var> must be a string
consisting of one or more (or all) of the following characters: 
<code>l</code>, <code>m</code>, <code>i</code>, <code>v</code>, <code>s</code>, <code>e</code>, <code>a</code>.
Per default, (i.e. if this parameter is not specified), the output is 
minimal. According to each specified character, the following is added: 
<P>
<DL><DT>  <code>c</code>:<DD> <BR> 
       print the meaning of the letters used in the output.
</DL><P>
<DL><DT>  <code>m</code>:<DD> <BR> 
       print the multiplication tables.
</DL><P>
<DL><DT>  <code>i</code>:<DD> <BR> 
       list the ideals.
</DL><P>
<DL><DT>  <code>l</code>:<DD> <BR> 
       list the left ideals.
</DL><P>
<DL><DT>  <code>r</code>:<DD> <BR> 
       list the right ideals.
</DL><P>
<DL><DT>  <code>v</code>:<DD> <BR> 
       list the invariant subnear-rings.
</DL><P>
<DL><DT>  <code>s</code>:<DD> <BR> 
       list the subnear-rings.
</DL><P>
<DL><DT>  <code>e</code>:<DD> <BR> 
       list the near-ring endomorphisms.
</DL><P>
<DL><DT>  <code>a</code>:<DD> <BR> 
       list the near-ring automorphisms.
</DL><P><P>
<strong>Examples\:</strong> 
<P>
<code>LibraryNearringInfo( "C3", [ 3 ], "lmivsea" )</code> will print all
available information on the third class of near-rings on the 
group
<I>C<sub>3</sub></I>.
<P>
<code>LibraryNearringInfo( "C4", [ 1..12 ] )</code> will provide a minimal output
for all classes of near-rings on <I>C<sub>4</sub></I>.
<P>
<code>LibraryNearringInfo( "S3", [ 5, 18, 21 ], "mi" )</code> will print
the minimal information plus the multiplication tables plus the ideals for
the classes <I>5</I>, <I>18</I>, and <I>21</I> of near-rings on the group <I>S<sub>3</sub></I>.
<P><A NAME="SECT068"><h2>63.68 Nearring records</h2></a>
<P><P>
The record of a nearring has the following components: 
<P>
<DL><DT><code>isDomain</code>, <code>isNearring</code>:<DD> <BR> 
  these two are always <code>true</code> for a near-ring.
</DL><P>
<DL><DT><code>isTransformationNearring</code>:<DD> <BR> 
  this is bound and <code>true</code> only for transformation near-rings (i.e. 
  those near-rings that are generated by group transformations by using
  the constructor function <code>Nearring</code> in the second form).
</DL><P>
<DL><DT><code>generators</code>:<DD> <BR> 
  this is bound only for a transformation near-ring and holds the set of 
  generators of the transformation near-ring.
</DL><P>
<DL><DT><code>group</code>:<DD> <BR> 
  this component holds the additive group of the near-ring as permutation
  group.
</DL><P>
<DL><DT><code>addition</code>, subtraction<code>, multiplication</code>:<DD> <BR> 
  these record fields contain the functions that represent the binary 
  operations that can be performed with the elements of the near-ring on the 
  additive group of the  
  near-ring (addition, subtraction) resp. on the multiplicative
  semigroup of the near-ring (multiplication)
</DL><P>
<pre>  gap> nr := Nearring( Transformation( Group( (1,2) ), [2,1] ) );
  Nearring( Transformation( Group( (1,2) ), [ 2, 1 ] ) ) 
  gap> e := Elements( nr );
  [ Transformation( Group( (1,2) ), [ 1, 1 ] ), 
    Transformation( Group( (1,2) ), [ 1, 2 ] ), 
    Transformation( Group( (1,2) ), [ 2, 1 ] ), 
    Transformation( Group( (1,2) ), [ 2, 2 ] ) ]
  gap> nr. addition( e[2], e[3] );
  Transformation( Group( (1,2) ), [ 2, 2 ] )
  gap> nr.multiplication( e[2], e[4] );
  Transformation( Group( (1,2) ), [ 2, 2 ] )
  gap> nr.multiplication( e[2], e[3] );
  Transformation( Group( (1,2) ), [ 2, 1 ] )
</pre>
<P>
<DL><DT><code>operations</code>:<DD> <BR> 
  this is the operations record of the near-ring.
</DL><P>
<code>size</code>, <code>elements</code>, <code>endomorphisms</code>, 
<DL><DT>      <code>automorphisms</code>:<DD> <BR> 
  these entries become bound if the according functions have been performed
  on the near-ring.
</DL><P><A NAME="SECT069"><h2>63.69 Supportive Functions for Groups</h2></a>
<P><P>
In order to support near-ring calculations, a few functions for groups had to 
be added to the standard <strong>GAP3</strong> group library functions. 
<P><A NAME="SECT070"><h2>63.70 DisplayCayleyTable for groups</h2></a>
<P><P>
<code>DisplayCayleyTable( <var>group</var> )</code>  
<P>
<code>DisplayCayleyTable</code> prints the Cayley table of the group <var>group</var>. This 
function works the same way as for semigroups and near-rings: the 
dispatcher function <code>DisplayCayleyTable</code> calls
<code><var>group</var>.op\-er\-a\-tions.Display\-Ta\-ble</code> which performs the printing.
<P>
<pre>  gap> g := Group( (1,2), (3,4) );       # this is Klein's four group  
  Group( (1,2), (3,4) )
  gap> DisplayCayleyTable( g );
  Let:
  g0 := ()
  g1 := (3,4)
  g2 := (1,2)
  g3 := (1,2)(3,4)

    +  | g0 g1 g2 g3 
   ------------------
    g0 | g0 g1 g2 g3 
    g1 | g1 g0 g3 g2 
    g2 | g2 g3 g0 g1 
    g3 | g3 g2 g1 g0 

</pre>
<P><A NAME="SECT071"><h2>63.71 Endomorphisms for groups</h2></a>
<P><P>
<code>Endomorphisms( <var>group</var> )</code>  
<P>
<code>Endomorphisms</code> computes all the endomorphisms of the group <var>group</var>. 
This function is most essential for computing the near-rings on a group.
The endomorphisms are returned as a list of transformations s.t. 
the identity endomorphism is always the last entry in this list. For each  
transformation in this list the record component 
<code>is\-Group\-En\-do\-mor\-phism</code> is
set to <code>true</code> and if such a transformation is in fact an automorphism 
then in
addition the record component 
<code>is\-Group\-Auto\-mor\-phism</code> is set to <code>true</code>.
<P>
<pre>  gap> g := Group( (1,2,3) );                                         
  Group( (1,2,3) )
  gap> Endomorphisms( g );
  [ Transformation( Group( (1,2,3) ), [ 1, 1, 1 ] ), 
    Transformation( Group( (1,2,3) ), [ 1, 3, 2 ] ), 
    Transformation( Group( (1,2,3) ), [ 1, 2, 3 ] ) ]
</pre>
<P><A NAME="SECT072"><h2>63.72 Automorphisms for groups</h2></a>
<P><P>
<code>Automorphisms( <var>group</var> )</code>  
<P>
<code>Automorphisms</code> computes all the automorphisms of the group <var>group</var>. 
The automorphisms are returned as a list of transformations s.t. 
the identity automorphism is always the last entry in this list. For each  
transformation in this list the record components 
<code>is\-Group\-En\-do\-mor\-phism</code> 
and <code>is\-Group\-Auto\-mor\-phism</code> are both set to <code>true</code>.
<P>
<pre>  gap> d8 := Group( (1,2,3,4), (2,4) ); # dihedral group of order 8
  Group( (1,2,3,4), (2,4) )
  gap> a := Automorphisms( d8 );
  [ Transformation( Group( (1,2,3,4), (2,4) ), [ 1, 2, 8, 7, 5, 6, 4, 3 
       ] ), Transformation( Group( (1,2,3,4), (2,4) ), 
      [ 1, 3, 2, 7, 8, 6, 4, 5 ] ), Transformation( Group( (1,2,3,4), 
      (2,4) ), [ 1, 3, 5, 4, 8, 6, 7, 2 ] ), 
    Transformation( Group( (1,2,3,4), (2,4) ), [ 1, 5, 3, 7, 2, 6, 4, 8 
       ] ), Transformation( Group( (1,2,3,4), (2,4) ), 
      [ 1, 5, 8, 4, 2, 6, 7, 3 ] ), Transformation( Group( (1,2,3,4), 
      (2,4) ), [ 1, 8, 2, 4, 3, 6, 7, 5 ] ), 
    Transformation( Group( (1,2,3,4), (2,4) ), [ 1, 8, 5, 7, 3, 6, 4, 2 
       ] ), Transformation( Group( (1,2,3,4), (2,4) ), 
      [ 1, 2, 3, 4, 5, 6, 7, 8 ] ) ]
</pre>
<P><A NAME="SECT073"><h2>63.73 InnerAutomorphisms</h2></a>
<P><P>
<code>InnerAutomorphisms( <var>group</var> )</code>  
<P>
<code>InnerAutomorphisms</code> computes all the inner automorphisms of the group 
<var>group</var>. 
The inner automorphisms are returned as a list of transformations s.t. 
the identity automorphism is always the last entry in this list. For each  
transformation in this list the record components 
<code>is\-Inner\-Auto\-mor\-phism</code>, 
<code>is\-Group\-En\-do\-mor\-phism</code>, 
and <code>is\-Group\-Auto\-mor\-phism</code> are all set to <code>true</code>.
<P>
<pre>  gap> i := InnerAutomorphisms( d8 );
  [ Transformation( Group( (1,2,3,4), (2,4) ), [ 1, 2, 8, 7, 5, 6, 4, 3 
       ] ), Transformation( Group( (1,2,3,4), (2,4) ), 
      [ 1, 5, 3, 7, 2, 6, 4, 8 ] ), Transformation( Group( (1,2,3,4), 
      (2,4) ), [ 1, 5, 8, 4, 2, 6, 7, 3 ] ), 
    Transformation( Group( (1,2,3,4), (2,4) ), [ 1, 2, 3, 4, 5, 6, 7, 8 
       ] ) ]
</pre>
<P><A NAME="SECT074"><h2>63.74 SmallestGeneratingSystem</h2></a>
<P><P>
<code>SmallestGeneratingSystem( <var>group</var> )</code>  
<P>
<code>SmallestGeneratingSystem</code> computes a smallest generating system of 
the group <var>group</var> i.e. a smallest subset of the elements of the group 
s.t. the group is generated by this subset.
<P>
<strong>Remark\:</strong> there is a <strong>GAP3</strong> standard library function 
<code>Smallest\-Generators</code> for
permutation groups. This function computes a generating set of a given
group such that its elements are smallest possible permutations (w.r.t. 
the <strong>GAP3</strong> internal sorting of permutations).
<P>
<pre>  gap> s5 := SymmetricGroup( 5 );
  Group( (1,5), (2,5), (3,5), (4,5) )
  gap> SmallestGenerators( s5 );
  [ (4,5), (3,4), (2,3), (1,2) ]
  gap> SmallestGeneratingSystem( s5 );
  [ (1,3,5)(2,4), (1,2)(3,4,5) ]
</pre>
<P><A NAME="SECT075"><h2>63.75 IsIsomorphicGroup</h2></a>
<P><P>
<code>IsIsomorphicGroup( <var>g1</var>, <var>g2</var> )</code>  
<P>
<code>IsIsomorphicGroup</code> determines if the groups <var>g1</var> and <var>g2</var> are 
isomorphic and if so, returns a group homomorphism that is an isomorphism
between these two groups and <code>false</code> otherwise.
<P>
<pre>  gap> g1 := Group( (1,2,3) );
  Group( (1,2,3) )
  gap> g2 := Group( (7,8,9) );
  Group( (7,8,9) )
  gap> g1 = g2;
  false
  gap> IsIsomorphicGroup( g1, g2 );
  GroupHomomorphismByImages( Group( (1,2,3) ), Group( (7,8,9) ), 
  [ (1,2,3) ], [ (7,8,9) ] )
</pre>
<P><A NAME="SECT076"><h2>63.76 Predefined groups</h2></a>
<P><P>
The following variables are predefined as according permutation groups
with a default smallest set of generators: 
<code>C2</code>, <code>C3</code>, <code>C4</code>, <code>V4</code>, <code>C5</code>, <code>C6</code>, <code>S3</code>, 
<code>C7</code>, <code>C8</code>, <code>C2xC4</code>, <code>C2xC2xC2</code>, <code>D8</code>, <code>Q8</code>, 
<code>C9</code>, <code>C3xC3</code>, <code>C10</code>, <code>D10</code>, <code>C11</code>, <code>C12</code>, 
<code>C2xC6</code>, <code>D12</code>, <code>A4</code>, <code>T</code>, <code>C13</code>, <code>C14</code>, 
<code>D14</code>, <code>C15</code>. 
<P>
<pre>  gap> S3;
  S3
  gap> Elements( S3 );
  [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
  gap> IsPermGroup( S3 );
  true
  gap> S3.generators;
  [ (1,2), (1,2,3) ]
</pre>
<P><A NAME="SECT077"><h2>63.77 How to find near-rings with certain properties</h2></a>
<P><P>
The near-ring library files can be used to systematically search for 
near-rings with (or without) certain properties.
<P>
For instance, the function <code>LibraryNearring</code> can be integrated
into a loop or occur as a part of the <code>Filtered</code> or the
<code>First</code> function to get all numbers of classes (or just the first class) 
of near-rings on a specified group which have the specified properties.  
<P>
In what follows, we shall give a few examples how this can be
accomplished: 
<P>
To get the number of the first class of near-rings on the
group <I>C<sub>6</sub></I> which have an identity, one could use a command like: 
<P>
<pre>  gap> First( [1..60], i ->                                       
  >           Identity( LibraryNearring( "C6", i ) ) &lt;> [ ] ); 
  28
</pre>
<P>
If we try the same with <I>S<sub>3</sub></I>, we will get an error message, indicating 
that there is no near-ring with identity on <I>S<sub>3</sub></I>: 
<P>
<pre>  gap> First( [1..39], i ->                  
  >           Identity( LibraryNearring( "S3", i ) ) &lt;> [ ] );
  Error, at least one element of &lt;list> must fulfill &lt;func> in
  First( [ 1 .. 39 ], function ( i ) ... end ) called from
  main loop
  brk> 
  gap> 
</pre>
<P>
To get all seven classes of near-rings with identity on the dihedral group
<I>D<sub>8</sub></I> of order <I>8</I>, something like the following will work fine: 
<P>
<pre>  gap> l := Filtered( [1..1447], i ->                            
  >           Identity( LibraryNearring( "D8", i ) ) &lt;> [ ] );
  [ 842, 844, 848, 849, 1094, 1096, 1097 ]
  gap> time;
  122490
</pre>
<P>
Note that a search like this may take a few minutes.
<P>
Here is another example that provides the class numbers of the four 
boolean near-rings on <I>D<sub>8</sub></I>: 
<P>
<pre>  gap> l := Filtered( [1..1447], i ->                            
  >           IsBooleanNearring( LibraryNearring( "D8", i ) ) );       
  [ 1314, 1380, 1446, 1447 ]
</pre>
<P>
The search for class numbers of near-rings can also be accomplished in a 
loop like the following: 
<P>
<pre>  gap> l:=[ ];;
  gap> for i in [1..1447] do
  >      n := LibraryNearring( "D8", i );
  >      if IsDgNearring( n ) and
  >        not IsDistributiveNearring( n ) then
  >          Add( l, i );
  >      fi;
  >    od;
  gap> time;
  261580
  gap> l;
  [ 765, 1094, 1098, 1306 ]
</pre>
<P>
This provides a list of those class numbers of near-rings on <I>D<sub>8</sub></I> which
are distributively generated but not distributive.
<P>
Two or more conditions for library near-rings can also be combined with 
<code>or</code>: 
<P>
<pre>  gap> l := [ ];;           
  gap> for i in [1..1447] do
  >      n := LibraryNearring( "D8", i );
  >      if Size( ZeroSymmetricElements( n ) ) &lt; 8 or
  >         Identity( n ) &lt;> [ ] or
  >         IsIntegralNearring( n ) then
  >           Add( l, i );
  >      fi;
  >    od;
  gap> time;
  124480
  gap> l;
  [ 842, 844, 848, 849, 1094, 1096, 1097, 1314, 1315, 1316, 1317, 1318, 
    1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 
    1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 
    1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 
    1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 
    1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 
    1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 
    1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 
    1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 
    1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 
    1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 
    1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 
    1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447 ]
  gap> Length( l );
  141
</pre>
<P>
This provides a list of all 141 class numbers of near-rings on <I>D<sub>8</sub></I> which
are non-zerosymmetric or have an identity or are integral. 
(cf. <A href="biblio.htm#Pil83"><cite>Pil83</cite></a>, pp. 416ff).
<P>
The following loop does the same for the near-rings on the quaternion group
of order 8, <I>Q<sub>8</sub></I>: 
<P>
<pre>  gap> l := [ ];;
  gap> for i in [1..281] do
  >      n := LibraryNearring( "Q8", i );
  >      if Size( ZeroSymmetricElements( n ) ) &lt; 8 or
  >        Identity( n ) &lt;> [ ] or
  >          IsIntegralNearring( n ) then
  >          Add( l, i );
  >      fi;
  >    od;
  gap> time;
  17740
  gap> l;
  [ 280, 281 ]
</pre>
<P>
Once a list of class numbers has been computed (in this case here: <code>l</code>),
e.g. the function <code>Library\-Near\-ring\-Info</code> can be used to print
some information about these near-rings: 
<P>
<pre>  gap> LibraryNearringInfo( "Q8", l );
  ----------------------------------------------------------------------
  >>> GROUP: Q8
  elements: [ n0, n1, n2, n3, n4, n5, n6, n7 ]
  addition table:

    +  | n0 n1 n2 n3 n4 n5 n6 n7 
   ------------------------------
    n0 | n0 n1 n2 n3 n4 n5 n6 n7 
    n1 | n1 n2 n3 n0 n7 n4 n5 n6 
    n2 | n2 n3 n0 n1 n6 n7 n4 n5 
    n3 | n3 n0 n1 n2 n5 n6 n7 n4 
    n4 | n4 n5 n6 n7 n2 n3 n0 n1 
    n5 | n5 n6 n7 n4 n1 n2 n3 n0 
    n6 | n6 n7 n4 n5 n0 n1 n2 n3 
    n7 | n7 n4 n5 n6 n3 n0 n1 n2 

  group endomorphisms:
  1:   [ n0, n0, n0, n0, n0, n0, n0, n0 ]
  2:   [ n0, n0, n0, n0, n2, n2, n2, n2 ]
  3:   [ n0, n1, n2, n3, n5, n6, n7, n4 ]
  4:   [ n0, n1, n2, n3, n6, n7, n4, n5 ]
  5:   [ n0, n1, n2, n3, n7, n4, n5, n6 ]
  6:   [ n0, n2, n0, n2, n0, n2, n0, n2 ]
  7:   [ n0, n2, n0, n2, n2, n0, n2, n0 ]
  8:   [ n0, n3, n2, n1, n4, n7, n6, n5 ]
  9:   [ n0, n3, n2, n1, n5, n4, n7, n6 ]
  10:  [ n0, n3, n2, n1, n6, n5, n4, n7 ]
  11:  [ n0, n3, n2, n1, n7, n6, n5, n4 ]
  12:  [ n0, n4, n2, n6, n1, n7, n3, n5 ]
  13:  [ n0, n4, n2, n6, n3, n5, n1, n7 ]
  14:  [ n0, n4, n2, n6, n5, n1, n7, n3 ]
  15:  [ n0, n4, n2, n6, n7, n3, n5, n1 ]
  16:  [ n0, n5, n2, n7, n1, n4, n3, n6 ]
  17:  [ n0, n5, n2, n7, n3, n6, n1, n4 ]
  18:  [ n0, n5, n2, n7, n4, n3, n6, n1 ]
  19:  [ n0, n5, n2, n7, n6, n1, n4, n3 ]
  20:  [ n0, n6, n2, n4, n1, n5, n3, n7 ]
  21:  [ n0, n6, n2, n4, n3, n7, n1, n5 ]
  22:  [ n0, n6, n2, n4, n5, n3, n7, n1 ]
  23:  [ n0, n6, n2, n4, n7, n1, n5, n3 ]
  24:  [ n0, n7, n2, n5, n1, n6, n3, n4 ]
  25:  [ n0, n7, n2, n5, n3, n4, n1, n6 ]
  26:  [ n0, n7, n2, n5, n4, n1, n6, n3 ]
  27:  [ n0, n7, n2, n5, n6, n3, n4, n1 ]
  28:  [ n0, n1, n2, n3, n4, n5, n6, n7 ]

  NEARRINGS:
  ----------------------------------------------------------------------
  280)  phi: [ 1, 28, 28, 28, 28, 28, 28, 28 ];  28;  -B----I--P-RW
  ----------------------------------------------------------------------
  281)  phi: [ 28, 28, 28, 28, 28, 28, 28, 28 ];  28;  -B----I--P-RW
  ----------------------------------------------------------------------
</pre>
<P><A NAME="SECT078"><h2>63.78 Defining near-rings with known multiplication table</h2></a>
<P><P>
Suppose that for a given group <I>g</I> the multiplication table of a binary
operation <I>*</I> on the elements of <I>g</I> is known such that <I>*</I> is a
near-ring multiplication on <I>g</I>. Then the constructor function <code>Nearring</code>
can be used to input the near-ring specified by <I>g</I> and <I>*</I>.
<P>
An example shall illustrate a possibility how this could be accomplished: 
Take the group <I>S<sub>3</sub></I>, which in <strong>GAP3</strong> can be defined e.g. by
<P>
<pre>  gap> g := Group( (1,2), (1,2,3) );
  Group( (1,2), (1,2,3) )
</pre>
<P>
This group has the following list of elements: 
<P>
<pre>  gap> Elements( g );
  [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
</pre>
<P>
Let <code>1</code> stand for the first element in this list, <code>2</code> for the second,
and so on up to <code>6</code> which stands for the sixth element in the following
multiplication table: 
<P>
<center>
\catcode`|=12 \begintabular{c<code>cccccc} \catcode`\</code>=13
<I>*</I> & 1 & 2 & 3 & 4 & 5 & 6 <BR> 
\hline 
1 & 1 & 1 & 1 & 1 & 1 & 1 <BR> 
2 & 2 & 2 & 2 & 2 & 2 & 2 <BR> 
3 & 2 & 2 & 6 & 3 & 6 & 3 <BR> 
4 & 1 & 1 & 5 & 4 & 5 & 4 <BR> 
5 & 1 & 1 & 4 & 5 & 4 & 5 <BR> 
6 & 2 & 2 & 3 & 6 & 3 & 6 
\endtabular
</center>
A near-ring on <code>g</code> with this multiplication can be input by first defining  
a multiplication function, say <code>m</code> in the following way: 
<P>
<pre>  gap> m := function( x, y )         
  >   local elms, table;
  >     elms := Elements( g );
  >     table := [ [ 1, 1, 1, 1, 1, 1 ],
  >                [ 2, 2, 2, 2, 2, 2 ],
  >                [ 2, 2, 6, 3, 6, 3 ],
  >                [ 1, 1, 5, 4, 5, 4 ],
  >                [ 1, 1, 4, 5, 4, 5 ],
  >                [ 2, 2, 3, 6, 3, 6 ] ];
  >    
  >     return elms[ table[Position( elms, x )][Position( elms, y )] ];
  >   end;
  function ( x, y ) ... end
</pre>
<P>
Then the near-ring can be constructed by calling <code>Nearring</code> with the
parameters <code>g</code> and <code>m</code>: 
<P>
<pre>  gap> n := Nearring( g, m );
  Nearring( Group( (1,2), (1,2,3) ), function ( x, y )
      local  elms, table;
      elms := Elements( g );
      table := [ [ 1, 1, 1, 1, 1, 1 ], [ 2, 2, 2, 2, 2, 2 ], 
          [ 2, 2, 6, 3, 6, 3 ], [ 1, 1, 5, 4, 5, 4 ], 
          [ 1, 1, 4, 5, 4, 5 ], [ 2, 2, 3, 6, 3, 6 ] ];
      return elms[table[Position( elms, x )][Position( elms, y )]];
  end )
</pre>
<a href ="chap062.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap064.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>