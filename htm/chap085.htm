<html><head><title>GAP3 Manual: 85 Root systems and finite Coxeter groups</title></head>
<body bgcolor="ffffff">
<h1>85 Root systems and finite Coxeter groups</h1>
<P><P><P>
In  this  chapter  we  describe  functions  for dealing with finite Coxeter
groups  as permutation groups of root systems. A suitable reference for the
general theory is, for example, the volume of Bourbaki <A href="biblio.htm#Bou68"><cite>Bou68</cite></a>. Finite
Coxeter  groups coincide  with finite  real reflection  groups. If a finite
Coxeter  group can be defined  over the rational numbers  (it is a rational
reflection group), it is called a <strong>Weyl group</strong>.
<P>
Root   systems  play  an  important  role  in  mathematics;  they  classify
semi-simple  Lie algebras and algebraic  groups. A root system  is a set of
roots  defining reflections (see  the chapter on  finite reflection groups)
generating  the Weyl group. We treat at  the same time other finite Coxeter
groups by using a generalization of root systems to the
non-crystallographic (non-rational) case.
<P>
We  give now the definitions. Let <var>V</var>  be a real vector space, <I>V<sup>&or;</sup></I> its
dual  and let <I>( , )</I> be the natural  pairing between <I>V<sup>&or;</sup></I> and <var>V</var>. A
<strong>root system</strong> in <var>V</var> is a finite set of vectors <var>R</var> (the <strong>roots</strong>), together
with a map <I>r&rarr; r<sup>&or;</sup></I> from <var>R</var> to a subset <I>R<sup>&or;</sup></I> of <I>V<sup>&or;</sup></I> (the
<strong>coroots</strong>) such that:
<P>
For  any  <I>r&isin;  R</I>,  we  have  <I>(r<sup>&or;</sup>,r)=2</I> and the reflection <I>V&rarr; V:
x&rarr; x- (r<sup>&or;</sup>,x) r</I> with root <I>r</I> and coroot <I>r<sup>&or;</sup></I> stabilizes <var>R</var>.
If <var>R</var> does not span <var>V</var> we also have to impose the condition that the dual
reflection   <I>V<sup>&or;</sup>  &rarr;  V<sup>&or;</sup></I>:  <I>y  &rarr;  y  -(y,r)r<sup>&or;</sup></I>
stabilizes  <I>R<sup>&or;</sup></I>. Note  <I>(r<sup>&or;</sup>,r)=2</I> is  equivalent to  the condition
that we have true reflections (of order <I>2</I>).
<P>
We will only  consider <strong>reduced</strong> root systems, i.e., such  that the only
elements of <var>R</var> colinear with a root <I>r</I> are <I>r</I> and <I>-r</I>.
<P>
A  root  system  <var>R</var>  is  called  <strong>crystallographic</strong>  if <I>(r<sup>&or;</sup>,s)</I> is an
integer,  for any <I>s&isin; R,r<sup>&or;</sup>&isin; R<sup>&or;</sup></I>  --- these are the root systems
considered by Bourbaki.
<P>
The dimension of the subspace <I>V<sub>R</sub></I> of <var>V</var> spanned by <var>R</var> will be called
the <strong>semi-simple rank</strong> of <var>R</var>.
<P>
The subgroup <I>W=W(R)</I> of <I></i>GL<i>(V)</I> generated by the
<code>Reflection(<var>r</var>,<I>r<sup>&or;</sup></I>)</code>  is a finite Coxeter group (see chapter <a href="chap083.htm">Coxeter
groups</a>  ---  we  describe  explicitly  below  how  to  obtain  the Coxeter
generators  from the root system). If  the root system is crystallographic,
the  representation <var>V</var> of  <var>W</var> is defined  over the rational numbers, thus
<var>W</var>  is  a  Weyl  group,  in  which  case  all finite-dimensional (complex)
representations  of <var>W</var>  can be  realized over  the rational  numbers. Weyl
groups are characterized amongst finite Coxeter groups by the fact that all
numbers <I>m(i,j)</I> in the Coxeter matrix are in <I>{2,3,4,6}</I>.
<P>
If  we identify <var>V</var> with <I>V<sup>&or;</sup></I> by choosing a <var>W</var>-invariant bilinear form
<I>( ; )</I>,   then  we  have   <I>r<sup>&or;</sup>=2r/(r;r)</I>.  A  root   system  <var>R</var>  is
<strong>irreducible</strong>  if it is not the union  of two orthogonal subsets. If <var>R</var> is
reducible then the corresponding Coxeter group is the direct product of the
Coxeter  groups  associated  with  the  irreducible  components of <var>R</var>. The
irreducible  crystallographic root systems are  classified by the following
list  of <strong>Dynkin diagrams</strong>. We show the  labeling of the nodes given by the
function <code>CartanMat</code> described below.
<P><P>
<pre>         1   2   3           n                1   2   3           n
   A_n   o---o---o-- . . . --o          B_n   o=&lt;=o---o-- . . . --o

       1 o
          \    4             n                1   2   3           n
   D_n   3 o---o---  . . . --o          C_n   o=>=o---o-- . . . --o
          /
       2 o

         1   2             1   2   3   4          1   3   4   5   6
   G_2   0->-0        F_4  o---o=>=o---o     E_6  o---o---o---o---o
           6                                              |
                                                          o 2

         1   3   4   5   6   7            1   3   4   5   6   7   8
   E_7   o---o---o---o---o---o       E_8  o---o---o---o---o---o---o
                 |                                |
                 o 2                              o 2</pre>
<P><P>
These  diagrams  encode  the  presentation  of  the  Coxeter  group  <var>W</var> as
follows: the vertices represent the set <code>S</code> of generating reflections; an
edge  is drawn between <I>s</I> and <I>t</I> if the order <I>m(s,t)</I> of <I>st</I> is greater
than <I>2</I>; the edge is single if <I>m(s,t)=3</I>, double if <I>m(s,t)=4</I>, triple if
<I>m(s,t)=6</I>. The arrows indicate the relative root lengths when <var>W</var> has more
than  one orbit on <var>R</var>,  as explained below; we  get the <strong>Coxeter Diagram</strong>,
which describes the underlying Weyl group, if we ignore the arrows: we see
that the root systems <I>B<sub>n</sub></I> and <I>C<sub>n</sub></I> correspond to the same Coxeter group.
<P>
To complete the classification of finite Coxeter groups, we need to add the
following Coxeter diagrams:
<P>
<pre>             1   2                 1   2   3          1   2   3   4
   I_2(m)    o---o            H_3  o---o---o     H_4  o---o---o---o
               m                     5                  5           </pre>
<P>
where  a single edge has the value <I>m(s,t)</I> written above if <I>m(s,t)&notin;
{2,3,4,6}</I>. These correspond to non-crystallographic groups, excepted for
the special cases <I>I<sub>2</sub>(3)=A<sub>2</sub></I>, <I>I<sub>2</sub>(4)=B<sub>2</sub></I> and <I>I<sub>2</sub>(6)=G<sub>2</sub></I>.
<P>
Let us now describe how the root systems are encoded in these diagrams. Let
<var>R</var>  be a root system in <var>V</var>. Then we can choose a linear form on <var>V</var> which
vanishes  on no element of <var>R</var>. According to  the sign of the value of this
linear  form on a root <I>r &isin; R</I> we call <I>r</I> <strong>positive</strong> or <strong>negative</strong>. Then
there  exists a unique subset of the  set of positive roots, called the set
of <strong>simple roots</strong>, such that any positive root is a linear combination with
non-negative  coefficients of  simple roots.  It can  be shown that any two
sets  of simple roots, corresponding to  different choices of linear forms,
can  be transformed into each  other by a unique  element of <I>W(R)</I>. Hence,
since   the  pairing  between   <I>V</I>  and  <I>V<sup>&or;</sup></I>   is  <I>W</I>-invariant,  if
<I>{r<sub>1</sub>,...,r<sub>n</sub>}</I>  is a set of simple roots and if we define the <strong>Cartan
matrix</strong>  as being the <I>n</I> times <I>n</I> matrix <I>C={r<sub>i</sub><sup>&or;</sup>(r<sub>j</sub>)}<sub>ij</sub></I>, this
matrix  is unique up to simultaneous permutation of rows and columns. It is
this matrix which is encoded in a Dynkin diagram, as follows.
<P>
The  indices for the rows of <I>C</I> label the nodes of the diagram. The edges,
for  <I>i  &ne; j</I>, are given as follows. If <I>C<sub>ij</sub></I> and <I>C<sub>ji</sub></I> are integers
such  that  <I>|C<sub>ij</sub>|   &ge;  |C<sub>ji</sub>|</I>  the  vertices  are  connected by
<I>|C<sub>ij</sub>|</I>  lines, and if <I>|C<sub>ij</sub>|&gt;1</I> then  we put an additional arrow
on  the lines pointing towards the node with label <I>i</I>. In all other cases,
we simply put a single line equipped with the unique integer <I>p<sub>ij</sub>  &ge; 1</I>
such that <I>C<sub>ij</sub>C<sub>ji</sub>=</I>cos<I><sup>2</sup> (&pi;/p<sub>ij</sub>)</I>.
<P>
It  is important  to note  that, conversely,  the whole  root system can be
recovered  from the  simple roots:  the set  <I>S</I> of  reflections in <I>W(R)</I>
corresponding to the simple roots are called <strong>simple</strong> reflections. They are
precisely  the  generators  corresponding  to  the  vertices of the Coxeter
diagram.  Each  root  is  in  the  orbit  of  a simple root, so that <var>R</var> is
obtained  as the orbit of the simple roots under the group generated by the
simple  reflections. The restriction of the  simple reflections to <I>V<sub>R</sub></I> is
determined  by the Cartan matrix, so <var>R</var> is determined by the Cartan matrix
and the set of simple roots.
<P>
The  Cartan  matrix  corresponding  to  one  of  the above irreducible root
systems   (with  the  specified  labeling)   is  returned  by  the  command
<code>CartanMat</code>  which takes as input a  string giving the type (e.g., <code>"A"</code>,
<code>"B"</code>, <I>...</I>, <code>"I"</code>) and a positive integer giving the rank. For type
<I>I<sub>2</sub>(m)</I>,  we  give  as  a  third  argument  the integer <I>m</I>. This function
returns a matrix (that is in <strong>GAP3</strong>, a list of lists) with entries in <I>&#x2124;</I> or
in  a cyclotomic  extension of  the rationals.  Given two  Cartan matrices,
their  matrix direct sum, corresponding to the orthogonal direct sum of the
root systems, ) can be produced by the function <code>DiagonalMat</code>.
<P>
The  function <code>CoxeterGroup</code> takes  as input some  data which determine the
roots and the coroots and produces a <strong>GAP3</strong> permutation group record, where
the  Coxeter group is represented by its faithful permutation action on the
root  system <var>R</var>, with additional  components holding information about <var>R</var>
and  the additional components which makes  it also a Coxeter group record.
If  we label the  positive roots by  <code>[1 .. N]</code>,  and the negative roots by
<code>[N+1  ..  2*N]</code>,  then  each  simple  reflection  is  represented  by the
permutation of <code>[ 1 .. 2*N ]</code> which it induces on the roots.
<P><P>
The function <code>CoxeterGroup</code> has several forms; in one of them, the argument
is the Cartan matrix of the root system This constructs a root system where
the  simple roots  are the  canonical basis  of <var>V</var>,  and the matrix of the
coroots expressed in the dual basis of <I>V<sup>&or;</sup></I> is then equal to the Cartan
matrix.
<P>
If one only wants to work with Cartan matrices with a labeling as specified
by  the  above  list,  the  function  call  can  be  simplified. Instead of
<code>CoxeterGroup( CartanMat("D", 4 ) )</code> the following is also possible.
<P>
<pre>    gap> W := CoxeterGroup( "D", 4 );       # Coxeter group of type <I>D<sub>4</sub></I>
    CoxeterGroup("D",4)
    gap> PrintArray(CartanMat(W));
    [[ 2,  0, -1,  0],
     [ 0,  2, -1,  0],
     [-1, -1,  2, -1],
     [ 0,  0, -1,  2]]</pre>
<P>
Also,  the Coxeter group  record associated to  a direct sum of irreducible
root  systems with the  above standard labeling  can be obtained by listing
the types of the irreducible components:
<P>
<pre>    gap> W := CoxeterGroup( "A", 2, "B", 2 );;
    gap> PrintArray(CartanMat(W));
    [[ 2, -1,  0,  0],
     [-1,  2,  0,  0],
     [ 0,  0,  2, -2],
     [ 0,  0, -1,  2]]</pre>
<P>
The  same record  is constructed  by applying  <code>CoxeterGroup</code> to the matrix
<code>CartanMat("A",2,"B",2)</code>    or    to   <code>DiagonalMat(CartanMat("A",2),
CartanMat("B",2))</code>, or even by calling
<code>CoxeterGroup("A",2)*CoxeterGroup("B",2)</code>
<P>
The  following sections give more details on  how to work with the elements
of  <var>W</var>  and  different  representations  for  them  (permutations, reduced
expressions, matrices).
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap085.htm#SECT001">CartanMat for Dynkin types</a>
<LI> <A HREF="chap085.htm#SECT002">CoxeterGroup</a>
<LI> <A HREF="chap085.htm#SECT003">Operations and functions for finite Coxeter groups</a>
<LI> <A HREF="chap085.htm#SECT004">HighestShortRoot</a>
<LI> <A HREF="chap085.htm#SECT005">BadPrimes</a>
<LI> <A HREF="chap085.htm#SECT006">PermMatY</a>
<LI> <A HREF="chap085.htm#SECT007">Inversions</a>
<LI> <A HREF="chap085.htm#SECT008">ElementWithInversions</a>
<LI> <A HREF="chap085.htm#SECT009">DescribeInvolution</a>
<LI> <A HREF="chap085.htm#SECT010">ParabolicSubgroups</a>
<LI> <A HREF="chap085.htm#SECT011">ExtendedReflectionGroup</a>
</ol>
<A NAME="SECT001"><h2>85.1 CartanMat for Dynkin types</h2></a>
<P><P>
<A name = "I0"></a>

<A name = "I1"></a>

<P>
<code>CartanMat( <var>type</var>, <var>n</var> )</code>
<P>
returns the Cartan matrix of Dynkin type <var>type</var> and rank <var>n</var>. Admissible
types  are  the strings  <code>"A"</code>,  <code>"B"</code>,  <code>"C"</code>, <code>"D"</code>,  <code>"E"</code>,
<code>"F"</code>, <code>"G"</code>, <code>"H"</code>,  <code>"I"</code>, <code>"Bsym"</code>, <code>"Gsym"</code>, <code>"Fsym"</code>,
<code>"Isym"</code>, <code>"B?"</code>, <code>"G?"</code>, <code>"F?"</code>, <code>"I?"</code>.
<P>
<pre>    gap> C := CartanMat( "F", 4 );;
    gap> PrintArray( C );
    [[ 2, -1,  0,  0],
     [-1,  2, -1,  0],
     [ 0, -2,  2, -1],
     [ 0,  0, -1,  2]]</pre>
<P>
For type  <I>I<sub>2</sub>(m)</I>, which is in  fact an infinity of  types depending on
the number <I>m</I>, a third argument is needed specifying the integer <I>m</I> so
the syntax is in fact <code>CartanMat( "I", 2, <var>m</var> )</code>:
<P>
<pre>    gap> CartanMat( "I", 2, 5 );
    [ [ 2, E(5)^2+E(5)^3 ], [ E(5)^2+E(5)^3, 2 ] ]</pre>
<P>
The types like <code>"Bsym"</code> specify (non crystallographic) root systems where
all  roots have the same length,  which is necessary for some automorphisms
to  exist, like  the outer  automorphism of  <I>B<sub>2</sub></I> which  exchanges the two
generating reflections:
<P>
<pre>    gap> CartanMat("Bsym",2);
    [ [ 2, -E(8)+E(8)^3 ], [ -E(8)+E(8)^3, 2 ] ]</pre>
<P>
Finally, for irreducible  root systems which have two  root lengths, the
forms like  <code>"B?"</code> allow to  specify arbitrary  root systems (up  to a
scalar) by  giving explicitly  as a third  argument the  coefficient by
which to  multiply the second conjugacy  class of roots compared  to the
default Cartan matrix for that type.
<P>
<pre>    gap> CartanMat("B?",2,1); # the same as C2
    [ [ 2, -1 ], [ -2, 2 ] ]</pre>
<P><P>
<code>CartanMat( <var>type1</var>, <var>n1</var>, ... , <var>typek</var>, <var>nk</var> )</code>
<P>
returns  the  direct sum  of  <code>CartanMat(  <var>type1</var>, <var>n1</var>  )</code>,  <I>...</I>,
<code>CartanMat( <var>typek</var>, <var>nk</var> )</code>. One can use as argument a computed list of
types by <code>ApplyFunc(  CartanMat, [ <var>type1</var>, <var>n1</var>, ... ,  <var>typek</var>, <var>nk</var> ]
)</code>.
<P><A NAME="SECT002"><h2>85.2 CoxeterGroup</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>CoxeterGroup( <var>C</var> )</code>
<P>
<code>CoxeterGroup( <var>type1</var>, <var>n1</var>, ... , <var>typek</var>, <var>nk</var> )</code>
<P>
<code>CoxeterGroup( <var>rec</var> )</code>
<P>
This  function  returns  a  permutation  group  record containing the basic
information  about the Coxeter group and  the root system determined by its
arguments. In the first form the canonical basis of a real vector space <var>V</var>
of  dimension <code>Length(<var>C</var>)</code> is taken as simple  roots, and the lines of the
matrix  <var>C</var> express the set  of coroots in the  dual basis of <I>V<sup>&or;</sup></I>. The
matrix  <var>C</var> must be a valid Cartan  matrix (see <a href="chap082.htm#SECT003">CartanMat</a>). The length of
<var>C</var>  is called  the <strong>semisimple  rank</strong> of  the Coxeter datum. This function
creates  a <strong>semisimple</strong> root system, where the  length of <var>C</var> is also equal
to the dimension of <var>V</var>, called the <strong>rank</strong>. The function
<a href="chap088.htm#SECT001">ReflectionSubgroup</a>  can create a  Coxeter group record  where the rank is
not equal to the semisimple rank.
<P>
The  second form  is  equivalent to
<P>
<code>CoxeterGroup(CartanMat(<var>type1</var>, <var>n1</var>, ..., <var>typek</var>, <var>nk</var>))</code>.
<P>
The  resulting record, that we will  call a <strong>Coxeter datum</strong>, has additional
entries describing various information on the root system and Coxeter group
that we describe below.
<P>
The last form takes as an argument a record which has a field <code>coxeter</code> and
returns  the value of this field. This  is used to return the Coxeter group
of  objects  derived  from  Coxeter  groups,  such as Coxeter cosets, Hecke
algebras and braid elements.
<P>
We  document  the  following  entries  in  a Coxeter datum record which are
guaranteed  to  remain  present  in  future  versions of the package. Other
undocumented  entries should  not be  relied upon,  they may change without
notice.
<P>
<DL><DT><code>isCoxeterGroup</code>, <code>isDomain</code>, <code>isGroup</code>, <code>isPermGroup</code>, <code>isFinite</code>:<DD><BR> 
        <code>true</code>
</DL><P>
<DL><DT><code>cartan</code>:<DD><BR> the Cartan matrix <var>C</var>
</DL><P>
<DL><DT><code>roots</code>:<DD><BR> the root vectors, given  as linear combinations of simple roots.
       The first <code>N</code> roots are positive, the next <code>N</code> are the corresponding
       negative  roots. Moreover,  the first  <code>SemisimpleRank(W)</code> roots are
       the  simple  roots.  The  positive  roots  are ordered by increasing
       height.
</DL><P>
<DL><DT><code>coroots</code>:<DD><BR>   the same   information    for  the  coroots.    The coroot
       corresponding  to a given  root is in  the same relative position in
       the list of coroots as the root in the list of roots.
</DL><P>
<DL><DT><code>N</code>:<DD><BR> the number of positive roots
</DL><P>
<DL><DT><code>rootLengths</code>:<DD><BR> the vector of length of roots the simple roots.
       The  shortest roots in an irreducible subsystem are given the length
       1. The others then have length 2 (or 3 in type <I>G<sub>2</sub></I>). The matrix of
       the <var>W</var>-invariant bilinear form is given by
       <code>List([1..SemisimpleRank(W)], i->W.rootLengths[i]*W.cartan[i])/2</code>.
</DL><P>
<DL><DT><code>orbitRepresentative</code>:<DD><BR> this is a list of  same length as <code>roots</code>, which
       for  each  root,  gives  the  smallest  index  of a root in the same
       <var>W</var>-orbit.
</DL><P>
<DL><DT><code>orbitRepresentativeElements</code>:<DD><BR> a list of  same length as <code>roots</code>, which
       for  the <I>i</I>-th root, gives an element  <var>w</var> of <var>W</var> of minimal length
       such that <code>i=orbitRepresentative[i]^w</code>.
</DL><P>
<DL><DT><code>matgens</code>:<DD><BR>  the  matrices  (in  row  convention  ---  that is the matrices
       operate  <strong>from the right</strong>) of the  simple reflections of the Coxeter
       group.
</DL><P>
<DL><DT><code>generators</code>:<DD><BR> the generators as permutations of the root vectors.  They
       are given in the same order as the first <code>SemisimpleRank(W)</code> roots.
</DL><P>
<pre>    gap> W := CoxeterGroup( "A", 4 );;
    gap> PrintArray( W.cartan );
    [[ 2, -1,  0,  0],
     [-1,  2, -1,  0],
     [ 0, -1,  2, -1],
     [ 0,  0, -1,  2]]
    gap> W.matgens;
    [ [ [ -1, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ],
      [ [ 1, 1, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 0, 1 ] ],
      [ [ 1, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, -1, 0 ], [ 0, 0, 1, 1 ] ],
      [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 0, 0, -1 ] ]
     ]
    gap> W.roots;
    [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ],
      [ 1, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 1 ], [ 1, 1, 1, 0 ],
      [ 0, 1, 1, 1 ], [ 1, 1, 1, 1 ], [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ],
      [ 0, 0, -1, 0 ], [ 0, 0, 0, -1 ], [ -1, -1, 0, 0 ],
      [ 0, -1, -1, 0 ], [ 0, 0, -1, -1 ], [ -1, -1, -1, 0 ],
      [ 0, -1, -1, -1 ], [ -1, -1, -1, -1 ] ]</pre>
<P><A NAME="SECT003"><h2>85.3 Operations and functions for finite Coxeter groups</h2></a>
<P><P><P>
All  permutation group operations are defined on Coxeter groups, as well as
all  functions defined for finite reflection groups. However, the following
operations  and functions have been specially  written to take advantage of
the particular structure of real reflection groups:
<P>
<DL><DT><code>=</code>:<DD><BR> Two Coxeter data are equal if they are equal as permutation groups
     and   the    fields   <code>simpleRoots</code>  and    <code>simpleCoroots</code>    agree
     (independently of the value of   any other bound fields).
</DL><P>
<DL><DT><code>Print</code>:<DD><BR>  prints a Coxeter group in  a form that  can  be input back in
     <strong>GAP3</strong> as a Coxeter group.
</DL><P>
<DL><DT><code>Size</code>:<DD><BR>  uses  the classification  of  Coxeter   groups to work  faster
     (specifically, uses the function <code>ReflectionDegrees</code>).
</DL><P>
<A name = "I3"></a>

<DL><DT><code>Elements</code>:<DD><BR> returns the  set    of elements. They are    computed using
     <a href="chap083.htm#SECT019">CoxeterElements</a>. (Note that in an  earlier version of the package
     the elements  were sorted  by length.  You can get  such a  list by
     <code>Concatenation( List( [1..W.N], i -> CoxeterElements(W, i)))</code>)
</DL><P>
<A name = "I4"></a>

<DL><DT><code>ConjugacyClasses</code>:<DD><BR>   Uses  classification of  Coxeter  groups  to work
     faster,  and the  resulting  list is  given in  the  same order  as
     the  result  of  <code>ChevieClassInfo</code>  (see  <a href="chap087.htm#SECT001">ChevieClassInfo</a>).  Each
     <code>Representative</code> given by  <strong>CHEVIE</strong> has the property that  it is of
     minimal Coxeter  length in  its conjugacy class  and is  a "good"
     element in the sense of <A href="biblio.htm#GM97"><cite>GM97</cite></a>.
</DL><P>
<A name = "I5"></a>

<DL><DT><code>CharTable</code>:<DD><BR> Uses the classification of  Coxeter groups to work faster,
     and   the result has better  labeling  than the default (see
     <a href="chap087.htm">Classes and representations for reflection groups</a>).
</DL><P>
<A name = "I6"></a>

<A name = "I7"></a>

<A name = "I8"></a>

<DL><DT><code>PositionClass</code>,  <code>ClassInvariants</code>, <code>FusionConjugacyClasses</code>:<DD><BR> Use  the
     classification     of    Coxeter   groups     to    work     faster.
</DL><P>
<A name = "I9"></a>

<DL><DT><code>DecompositionMatrix(W,p)</code>:<DD><BR>  Returns the <I>p</I>-modular decomposition matrix
for Weyl groups which have no component of type <code>D</code>.
</DL><P>
Similarly,  all  functions  for  abstract  Coxeter groups are available for
finite  Coxeter  groups.  However  a  few  of  them are implemented by more
efficient methods. For instance, an efficient way of coding
<code>IsLeftDescending(W,w,s)</code>  is <code>s^w>W.N</code> (for  reflection subgroups this has
to  be changed slightly:  elements are represented  as permutations of the
roots  of  the  parent  group,  so  one  needs to write <code>s^w>W.parentN</code>, or
<code>W.rootRestriction[s^w]>W.N</code>). The functions <code>CoxeterWord</code>,
<code>CoxeterLength</code>, <code>ReducedCoxeterWord</code>, <code>IsLeftDescending</code>,
<code>FirstLeftDescending</code>,  <code>LeftDescentSet</code> and <code>RightDescentSet</code>  also have a
special  implementation.  Finally,  some  functions  for  finite reflection
groups which are implemented by more efficient methods, are
<code>ReflectionType</code>,      <code>ReflectionName</code>,     <code>MatXPerm</code>,     <code>Reflections</code>,
<code>ReflectionDegrees</code>, <code>ReflectionCharValue</code>.
<P>
<A name = "I10"></a>

<DL><DT><code>PrintDiagram</code>:<DD><BR> Prints the Dynkin diagram of the root system (a more
  specific  information  that  the  Coxeter  diagram,  since it includes an
  indication of the relative root lengths).
</DL><P>
<pre>    gap> C := [ [ 2, 0, -1 ], [ 0, 2, 0 ], [ -1, 0, 2 ] ];;
    gap> t := ReflectionType( C );
    [ rec(rank    := 2,
          series  := "A",
          indices := [ 1, 3 ]), rec(rank    := 1,
          series  := "A",
          indices := [ 2 ]) ]
    gap> PrintDiagram( t );
    A2 1 - 3
    A1 2
    gap> PrintDiagram( CoxeterGroup( "C", 3) );
    C3 1 >=> 2 - 3</pre>
<P><A NAME="SECT004"><h2>85.4 HighestShortRoot</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>HighestShortRoot( <var>W</var> )</code>
<P>
Let <var>W</var> be an irreducible Coxeter  group. <code>HighestShortRoot</code> computes the
unique short root of maximal height of <var>W</var>.  Note that  if all roots have
the same length then this is the unique root of maximal height, which can
also be obtained by <code>W.roots[W.N]</code>.  An error message is returned for <var>W</var>
not irreducible.
<P>
<pre>    gap> W := CoxeterGroup( "G", 2 );;  W.roots;
    [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ],
      [ -1, 0 ], [ 0, -1 ], [ -1, -1 ], [ -1, -2 ], [ -1, -3 ],
      [ -2, -3 ] ]
    gap> HighestShortRoot( W );
    4
    gap> W1 := CoxeterGroup( "A", 1, "B", 3 );;
    gap> HighestShortRoot( W1 );
    Error, CoxeterGroup("A",1,"B",3) should be irreducible
     in
    HighestShortRoot( W1 ) called from
    main loop
    brk></pre>
<P><A NAME="SECT005"><h2>85.5 BadPrimes</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>BadPrimes( <var>W</var> )</code>
<P>
<code>BadPrimes( <var>R</var> )</code>
<P>
Let  <var>W</var>  be  a  Weyl  group.  A  prime  is  <strong>bad</strong>  for <var>W</var> if it divides a
coefficient  on the  simple roots  of some  root. The  function <code>BadPrimes</code>
returns the list of prime which are bad for <var>W</var>.
<P>
Alternately  the argument  can be  a set  of integer  vectors and  then the
function returns all prime numbers which divide one of their coefficients.
<P>
<pre>    gap> W:=CoxeterGroup("E",8);
    CoxeterGroup("E",8)
    gap> BadPrimes(W);
    [ 2, 3, 5 ]
    gap> BadPrimes(W.roots{[1..50]});
    [ 2 ]</pre>
<P><A NAME="SECT006"><h2>85.6 PermMatY</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>PermMatY( <var>W</var>, <var>M</var> )</code>
<P>
Let <var>M</var> be a linear transformation of  the vector space <I>V<sup>&or;</sup></I> on which
the Coxeter    datum  <var>W</var> acts  which  preserves    the  set of  coroots.
<code>PermMatY</code>  returns  the  corresponding permutation of    the coroots; it
signals an error if <var>M</var> does not normalize the set of coroots.
<P>
<pre>    gap>  W:=ReflectionSubgroup(CoxeterGroup("E",7),[1..6]);
    ReflectionSubgroup(CoxeterGroup("E",7), [ 1, 2, 3, 4, 5, 6 ])
    gap>  w0:=LongestCoxeterElement(W);;
    gap> my:=MatYPerm(W,w0);;
    gap> PermMatY( W, my ) = w0;
    true</pre>
<P><A NAME="SECT007"><h2>85.7 Inversions</h2></a>
<P><P>
<A name = "I14"></a>

<P>
<code>Inversions( <var>W</var>, <var>w</var> )</code>
Returns  the inversions of the element <var>w</var> of the finite Coxeter group <var>W</var>,
that  is, the list of the indices of roots of the parent of <var>W</var> sent by <var>w</var>
to  negative roots. The element <var>w</var> can  also be given as a word <I>s<sub>1</sub>...
s<sub>n</sub></I>,  in which case  the function returns  inversions in the  order of the
roots  of  the  reflections  <I>s<sub>1</sub>,  s<sub>1</sub>  s<sub>2</sub>  s<sub>1</sub>,...,s<sub>1</sub>  s<sub>2</sub>... s<sub>n</sub>
s<sub>n-1</sub>... s<sub>1</sub></I>.
<P>
<pre>    gap> W:=CoxeterGroup("A",3);
    CoxeterGroup("A",3)
    gap> Inversions(W,W.1^W.2);
    [ 1, 2, 4 ]
    gap> Inversions(W,[1,2,1]);
    [ 1, 4, 2 ]</pre>
<P><A NAME="SECT008"><h2>85.8 ElementWithInversions</h2></a>
<P><P>
<A name = "I15"></a>

<P>
<code>ElementWithInversions( <var>W</var>, <var>N</var> )</code>
<P>
<var>W</var>  should  be  a  finite  Coxeter  group  and <var>N</var> a subset of <code>[1..W.N]</code>.
Returns  the element  <var>w</var> of  <var>W</var> such  that <var>N</var>  is the  list of indices of
positive roots which are sent to negative roots by <var>w</var>. Returns false if no
such element exists.
<P>
<pre>    gap> W:=CoxeterGroup("A",2);
    CoxeterGroup("A",2)
    gap> List(Combinations([1..W.N]),N->ElementWithInversions(W,N));
    [ (), (1,4)(2,3)(5,6), false, (1,5)(2,4)(3,6), (1,6,2)(3,5,4),
      (1,3)(2,5)(4,6), (1,2,6)(3,4,5), false ]</pre>
<P><A NAME="SECT009"><h2>85.9 DescribeInvolution</h2></a>
<P><P>
<A name = "I16"></a>

<P>
<code>DescribeInvolution( <var>W</var>, <var>w</var> )</code>
<P>
Given  an involution <var>w</var> of a Coxeter group <var>W</var>, by a theorem of Richardson
(<A href="biblio.htm#rich82"><cite>rich82</cite></a>)  there is a unique parabolic  subgroup <I>P</I> of <I>W</I> such that
that   <var>w</var>  is  the  longest  element  of  <I>P</I>,  and  is  central  in  <I>P</I>.
<code>DescribeInvolution</code>  returns <I>I</I> such that <code>P=ReflectionSubgroup(W,I)</code>, so
that <code>w=LongestCoxeterElement(ReflectionSubgroup(W,I))</code>.
<P>
<pre>    gap> W:=CoxeterGroup("A",2);
    CoxeterGroup("A",2)
    gap> w:=LongestCoxeterElement(W);
    (1,5)(2,4)(3,6)
    gap> DescribeInvolution(W,w);
    [ 3 ]
    gap> w=LongestCoxeterElement(ReflectionSubgroup(W,[3]));
    true</pre>
<P><A NAME="SECT010"><h2>85.10 ParabolicSubgroups</h2></a>
<P><P>
<A name = "I17"></a>

<P>
<code>ParabolicSubgroups( <var>W</var> )</code>
<P>
returns  the  list  of  all  parabolic  subgroups  of  <var>W</var>.  These  are the
conjugates  of the  groups returned  by <code>ParabolicRepresentatives(W)</code>; they
are  also in bijection with the flats of the hyperplane arrangement defined
by  <var>W</var>.  To  save  memory,  the  list  is  given  as  a list of generating
reflections  for each group. For each element  <code>I</code> of this list, one has to
call <code>ReflectionSubgroup(W,I)</code> to actually get the corresponding group.
<P>
<pre>    gap> ParabolicSubgroups(CoxeterGroup("A",3));
    [ [  ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 1, 2 ], [ 1, 5 ],
      [ 2, 3 ], [ 3, 4 ], [ 1, 3 ], [ 2, 6 ], [ 4, 5 ], [ 1, 2, 3 ] ]</pre>
<P><A NAME="SECT011"><h2>85.11 ExtendedReflectionGroup</h2></a>
<P><P>
<A name = "I18"></a>

<P>
<code>ExtendedReflectionGroup( <var>W</var>, <var>M</var> )</code>
<P>
This function creates an extended reflection group, which is represented as
an  object with two field, one recording a reflection group <var>W</var> on a vector
space  <var>V</var>, and the other  a subgroup <var>M</var> of  the linear group of <var>V</var> which
normalizes  <var>W</var>. Actually <var>M</var> should normalize the  set of roots of <var>W</var>. If
<var>W</var>  is semisimple, that is  <code>Rank(W)=SemisimpleRank(W)</code>, then one can give
<var>M</var>  as a group of  permutations (of the roots  of <var>W</var>), otherwise one must
give <var>M</var> as a matrix group.
<P>
<pre>    gap> W:=CoxeterGroup("F",4);
    CoxeterGroup("F",4)
    gap> D4:=ReflectionSubgroup(W,[1,2,9,16]);
    ReflectionSubgroup(CoxeterGroup("F",4), [ 1, 2, 9, 16 ])
    gap> t:=ReducedRightCosetRepresentatives(W,D4){[3,4]};
    [ ( 2, 9)( 3,27)( 4, 7)( 5,11)(10,13)(12,15)(17,19)(20,22)(26,33)
        (28,31)(29,35)(34,37)(36,39)(41,43)(44,46),
      ( 2, 9,16)( 3, 4,31)( 5,11,18)( 6,13,10)( 7,27,28)( 8,15,12)
        (14,22,20)(17,19,21)(26,33,40)(29,35,42)(30,37,34)(32,39,36)
        (38,46,44)(41,43,45) ]
    gap> ExtendedReflectionGroup(D4,Group(t,()));
    Extended(D4&lt;9,2,1,16>,(2,9),(2,9,16))</pre>
<P><a href ="chap084.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap086.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>