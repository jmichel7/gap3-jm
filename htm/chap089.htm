<html><head><title>GAP3 Manual: 89 Garside and braid monoids and groups</title></head>
<body bgcolor="ffffff">
<h1>89 Garside and braid monoids and groups</h1>
<P><P><P>
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid and dual braid monoids. The <strong>CHEVIE</strong> implementation of these
last  monoids is  in the  framework of  a general implementation of Garside
monoids.
<P>
To   define  them  we  first  need   to  introduce  some  vocabulary  about
divisibility  in monoids. A <strong>left divisor</strong> of  <I>x</I> is a <I>d</I> such that there
exists  <I>y</I> with <I>x=dy</I> (and then we say  that <I>x</I> is a <strong>right multiple</strong> of
<I>d</I>). The divisor <I>d</I> is <strong>proper</strong> if <I>y &ne; 1</I>. We say that <I>x</I> is an <strong>atom</strong>
if  it has no proper left  divisor apart from <I>1</I>. A  <strong>left gcd</strong> of <I>x</I> and
<I>y</I>  is a common left divisor <I>d</I> of <I>x</I> and <I>y</I> such that any other common
left divisor is a right multiple of <I>d</I>. Similarly a <strong>right lcm</strong> of <I>x</I> and
<I>y</I>  is  a  common  multiple  which  is  a left divisor of any other common
multiple.  We say that a monoid <I>M</I> is left (resp. right) cancellable if an
equality <I>dx=dy</I> (resp. <I>xd=yd</I>) implies <I>x=y</I>.
<P>
We  call <strong>Garside</strong> a monoid <I>M</I> which is:

<P>&bull; left and right cancellable.
<P>&bull; generated by its atoms,  which are finite in number.
<P>&bull; such that any element has only finitely many divisors.
<P>&bull; admits left and  right  gcds  and  lcms.
<P>&bull; admits a <strong>Garside element</strong>, which is an element <I>&Delta;</I> whose set of
left and right divisors coincide and generate <I>M</I>.

<P>
Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility); we assume such an element has been chosen. Then the divisors
of  <I>&Delta;</I> are called the <strong>simples</strong> of  <I>M</I>. A Garside monoid embeds into
its group of fractions, which is called a <strong>Garside group</strong> (it may be that a
Garside  group has several  distinct Garside structures,  as we will see is
the case for Braid groups of finite Coxeter groups).
<P>
<strong>CHEVIE</strong> also implements <strong>locally Garside</strong> monoids, which are monoids where
lcms  do not always exist,  but exist when any  common multiple exists; the
set  of simples  is then  not defined  using a  Garside element, but by the
condition  that they contain the atoms and are closed under lcms and taking
divisors  (see <A href="biblio.htm#BDM01"><cite>BDM01</cite></a>); since  it is not  ensured by the existence of
<I>&Delta;</I>,  one has to  add the condition  that any element  is divisible by
finitely many simples (but the number of simples can be infinite). The main
example  is the braid monoid of an  infinite Coxeter group. It is not known
if  these monoids embed in  their group of fractions  (though that has been
proved  for braid  monoids of  Coxeter groups  by Paris <A href="biblio.htm#Paris01"><cite>Paris01</cite></a>) and
thus computing in the monoid does not help for computing in the group (only
the monoid is implemented in <strong>CHEVIE</strong>).
<P>
What  allows computation  inside Garside  and locally  Garside monoids, and
Garside  groups, is the fact that they  admit normal forms --- these normal
forms  where first exhibited for braid monoids by Deligne <A href="biblio.htm#Del72"><cite>Del72</cite></a>, who
extended   previous  work  of  Brieskorn,  Saito  <A href="biblio.htm#BS72"><cite>BS72</cite></a>  and  Garside
<A href="biblio.htm#Gar69"><cite>Gar69</cite></a>:
<P>

<P>&bull;[(i)]
Let  <I>M</I> be  a locally  Garside monoid  and let  <I>b&isin; M</I>.  Then there is a
unique maximal left simple divisor <I>&alpha;(b)</I> of <I>b</I>, called the <strong>head</strong> of
<I>b</I>  --- any other simple  dividing <I>b</I> on the  left divides <I>&alpha;(b)</I> on
the left.
<P>&bull;[(ii)]
Assume  <I>M</I> is a Garside monoid, <I>&Delta;</I> is its Garside element and <I>G</I> is
its  group of fractions.  Then, given any  element <I>x&isin; G</I>,  there is some
power <I>&Delta;<sup>i</sup></I> such that <I>&Delta;<sup>i</sup> x&isin; M</I>.

<P>
A consequence of (i) is that any element has a canonical decomposition as a
product  of  simples,  called  its  left-greedy  normal  form. If we define
<I>&omega;(x)</I>  by  <I>x=&alpha;(x)&omega;(x)</I>,  then  the  normal  form of <I>x</I> is
<I>&alpha;(x)&alpha;(&omega;(x))&alpha;(&omega;<sup>2</sup>(x))...</I>  We  use  the  normal
form  to  represent  elements  of  <I>M</I>,  and  when  <I>M</I>  is Garside (ii) to
represent elements of <I>G</I>: given <I>x&isin; G</I> we compute the smallest power of
<I>&Delta;</I>  such that <I>&Delta;<sup>i</sup> x&isin;  M</I>, and we represent  <I>x</I> by the couple
<I>(i,&Delta;<sup>i</sup>  x)</I>. We  are thus  reduced to  the case  where <I>x&isin;  M</I>, not
divisible  by <I>&Delta;</I>, where  we represent <I>x</I>  by the sequence of simples
which constitutes its normal form.
<P>
We  now describe Artin-Tits braid monoids. Let <I>(W,S)</I> be a Coxeter system,
that is <I>W</I> has presentation
<center><table><tr><td><I>
  &lang; s&isin; S | s<sup>2</sup>=1,
         sts...<sub>m(s,t)</i> factors <i></sub>=
         tst...<sub>m(s,t)</i> factors <i></sub>
    &emsp; </i>for all <I>s,t&isin; S</I><i> &rang;
</I></td></tr></table></center>
for some Coxeter matrix <I>{m<sub>s,t</sub>}<sub>s,t&isin; S</sub></I>. The braid group <I>B</I>
associated to <I>(W,S)</I> is the group defined by the presentation
<center><table><tr><td><I>
   &lang; <strong>s</strong>&isin;<strong>S</strong>|
         <strong>s</strong><strong>t</strong><strong>s</strong>...<sub>m(s,t)</i> factors <i></sub>=
         <strong>t</strong><strong>s</strong><strong>t</strong>...<sub>m(s,t)</i> factors <i></sub>
    &emsp; </i>for all <I><strong>s</strong>,<strong>t</strong>&isin;<strong>S</strong></I><i>&rang;
</I></td></tr></table></center>
<P>
The  <strong>positive</strong> braid monoid <I>B<sup>+</sup></I> associated  to <I>W</I> is the monoid defined
by  the  presentation  above  ---  it  identifies  to  the submonoid of <I>B</I>
generated  by <I><strong>S</strong></I> by the result of Paris mentioned above. This monoid
is  locally Garside, with set of simples  in bijection with elements of <I>W</I>
and  atoms  the  elements  of  <I><strong>S</strong></I>;  we  will  denote by <I><strong>W</strong></I> the set of
simples,  and by <I><strong>w</strong>&rarr; w</I> the  bijection between simples and elements
of  <I>W</I>. The group <I>W</I> has a length defined in terms of reduced expressions
(see  <code>CoxeterLength</code>). Similarly, having only homogeneous relations, <I>B<sup>+</sup></I>
has  a  natural  length  function.  Then  <I><strong>W</strong></I> can be characterized as the
subset of the elements of <I>B<sup>+</sup></I> of the same length as their image in <I>W</I>.
<P>
If <I>W</I> is finite, then <I>B<sup>+</sup></I> is Garside with Garside element the element of
<I><strong>W</strong></I>  whose image is the longest element of <I>W</I>. A finite Coxeter group is
also  a reflection group in  a real vector space,  thus in its complexified
<I>V</I>,  and <I>B</I> has also a topological definition as the fundamental group of
the space <I>V<sup></i>reg<i></sup>/W</I>, where <I>V<sup></i>reg<i></sup></I> is the set of elements
of  <I>V</I> which are fixed by no non-identity element of <I>S</I>; however, we will
not use this here.
<P>
Given a Coxeter group <I>W</I>,
<P>
<pre>    gap> W:=CoxeterGroup("A",4);;M:=BraidMonoid(W);
    BraidMonoid(CoxeterGroup("A",4))</pre>
<P>
constructs  the  associated  braid  monoid,  and  then  the  function <code>M.B</code>
constructs  elements of the braid monoid (or group when <I>W</I> is finite) from
a  list  of  generators.  This  function  is directly available from <I>W</I> as
<code>Braid(W)</code>. Here is an example:
<P>
<pre>    gap> W:=CoxeterGroup("A",4);;B:=Braid(W);;
    gap> w:=B(1,2,3,4);
    1234
    gap> w^3;
    121321432.343
    gap> CoxeterWord(W,GarsideAlpha(w^3));
    [ 1, 2, 1, 3, 2, 1, 4, 3, 2 ]
    gap> w^4;
    w0.232432
    gap> w^-1;
    (1234)^-1</pre>
<P>
As  seen in the  fourth line above,  the function <code>GarsideAlpha(b)</code> returns
the simple <I>&alpha;(b)&isin;<strong>W</strong></I>, which is returned as an element of <I>W</I>.
<P>
How  an element of a  Garside group is printed  is controlled by the record
<code>CHEVIE.PrintGarside</code>.  The  user  can  change  the way elements of Garside
monoids  and groups are printed whenever  she wants during a <strong>GAP3</strong> session
by   changing   this   record.   When   you  load  the  <strong>CHEVIE</strong>  package,
<code>PrintGarside</code>  is  initialized  to  the  empty  record.  Then elements are
printed  as  fractions  <I>a<sup>-1</sup>b</I>  where  <I>a</I>  and  <I>b</I> have no left common
divisor.  Each of <I>a</I> and <I>b</I> is printed using its left-greedy normal form,
that  is a maximal power of the  Garside element followed the rest. One can
print  the entire  element in  the left-greedy  normal from  by setting the
<code>Greedy</code> field in <code>PrintGarside</code>; with the same <I>w</I> as above we have:
<P>
<pre>    gap> CHEVIE.PrintGarside:=rec(Greedy:=true);;
    gap> w^-1;
    w0^-1.232432</pre>
<P>
Finally,  if  the  field  <code>GAP</code>  in  the  <code>PrintGarside</code> record is set, the
element  is printed in a form  which after assigning <code>B:=Braid(W);</code> can be
input back into <strong>GAP3</strong>:
<P>
<pre>    gap> CHEVIE.PrintGarside:=rec(GAP:=true);;
    gap> w;
    B(1,2,3,4)
    gap> w ^ 3;
    B(1,2,1,3,2,1,4,3,2,3,4,3)
    gap> w^-1;
    B(1,2,3,4)^-1
    gap> CHEVIE.PrintGarside:=rec(GAP:=true,Greedy:=true);;
    gap> w^-1;
    B([2,3,2,4,3,2],-1)
    gap> CHEVIE.PrintGarside:=rec();;</pre>
<P>
In  general elements of  a Garside monoid  are displayed thus  as a list of
their constituting atoms.
<P>
We  now describe the dual braid monoid.  For that, we first give a possible
approach  to construct Garside monoids. Given a  group <I>W</I> and a set <I>S</I> of
generators  of <I>W</I> as a monoid, we  define the length <I>l(w)</I> as the minimum
number of elements of <I>S</I> needed to write <I>w</I>. We then define left divisors
of   <I>x</I>  as  the  <I>d</I>   such  that  there  exists   <I>y</I>  with  <I>x=dy</I>  and
<I>l(d)+l(y)=l(x)</I>.  We say that <I>w&isin; W</I> is  balanced if its set of left and
right  divisors coincide,  is a  lattice (where  upper and lower bounds are
lcms and gcds) and generates <I>W</I>. Then we have:
<P>
suppose <I>w</I> is balanced and let <I>[1,w]</I> be its set of divisors (an interval
for  the partial order  defined by divisibility).  Then the monoid <I>M</I> with
generators  <I>[1,w]</I> and relations  <I>xy=z</I> whenever <I>xy=z</I>  holds in <I>W</I> and
<I>l(x)+l(y)=l(z)</I> is Garside, with simples <I>[1,w]</I> and atoms <I>S</I>.
<P>
The  Artin-Tits braid monoid can be obtained  in this fashion by taking for
<I>S</I>  the Coxeter generators, in  which case <I>l</I> is  the Coxeter length, and
taking  for <I>w</I> the longest element of <I>W</I>. The dual monoid, constructed by
Birman,  Ko  and  Lee  for  type  <I>A</I>  and by Bessis for all well-generated
complex  reflection groups,  is obtained  in a  similar way, by taking this
time  for <I>S</I> the  set of all  reflections, and for  <I>w</I> a Coxeter element;
then  <I>l</I> is the  <code>ReflectionLength</code>, see <a href="chap084.htm#SECT013">ReflectionLength</a>;  (this is for
Coxeter  groups; for well-generated complex reflection groups <I>S</I> has to be
restricted  to only those  reflections which divide  <I>w</I> for the reflection
length);  the simples  are in  bijection with  <I>[1,w]</I>, a  subset of <I>W</I> of
cardinality  the generalized Catalan numbers.  Monoids <I>M</I> constructed this
way from an interval in a group, are called <strong>interval monoids</strong>. An interval
monoid has naturally an inverse morphism from <I>M</I> to <I>W</I>, called <code>EltBraid</code>
which  is the quotient map from the interval monoid to <I>W</I> which sends back
simple braids to <I>[1,w]</I>.
<P>
A  last notable notion is <strong>reversible</strong>  monoids. Since in <strong>CHEVIE</strong> we store
only  left normal forms, it is easy to compute left lcms and gcds, but hard
to  compute right ones.  But this becomes  easy to do  if the monoid has an
operation  <code>a->Reverse(a)</code>,  which  has  the  property  that  <code>a</code> is a left
divisor  of  <code>b</code>  if  and  only  if  <code>Reverse(a)</code>  is  a  right  divisor of
<code>Reverse(b)</code>.  This holds for Artin-Tits and dual braid monoids; Artin-Tits
monoids  have  a  reverse  operation  which  consists  of reversing a word,
written  as a list of  atoms. The dual monoid  also has a reverse operation
defined  in the same way, but this operation changes monoid: it goes from
the  dual monoid  for the  Coxeter element  <I>w</I> to  the dual monoid for the
Coxeter element <I>w<sup>-1</sup></I>. The operations <code>RightLcm</code> and <code>RightGcd</code>, as well
quite  a few  algorithms have  faster implementations  if the  monoid has a
reverse operation.
<P>
We  have implemented in  <strong>CHEVIE</strong> functions to  solve the conjugacy problem
and  compute centralizers in Garside groups,  following the work of Franco,
Gebhardt and Gonzalez-Meneses (<A href="biblio.htm#gebgon10"><cite>gebgon10</cite></a> and <A href="biblio.htm#fragon03"><cite>fragon03</cite></a>).
<P>
We  say that <I>w</I> and <I>w'</I>, elements  of a monoid <I>M</I> are conjugate in
<I>M</I> if there exists <I>x&isin; M</I> such that <I>wx=xw'</I>; if <I>M</I> satisfies the
&Ouml;re conditions, it has a group of fractions where this becomes
<I>x<sup>-1</sup>wx=w'</I>,  the  usual  definition  of  conjugacy. A special case
which  is even closer to conjugacy in the group is if there exists <I>y&isin; M</I>
such  that <I>w=xy</I>  and <I>w'=yx</I>.  This relation  is not  transitive in
general,  but we  call <strong>cyclic  conjugacy</strong> the  transitive closure  of this
relation, a restricted form of conjugacy.
<P>
The  next observation is that if <I>w,w'</I> are conjugate in the group of
fractions  of the Garside monoid <I>M</I> then  they are conjugate in <I>M</I>, since
if  <I>wx=xw'</I> then  there is  a power  <I>&Delta;<sup>i</sup></I> which is central and
such  that  <I>x&Delta;<sup>i</sup>&isin;  M</I>.  Then  <I>wx&Delta;<sup>i</sup>=x&Delta;<sup>i</sup>  w'</I> is a
conjugation in <I>M</I>.
<P>
The  crucial observation for solving the  conjugacy problem is to introduce
<I></I>inf<I>(w):=</I>sup<I>{i</i>   such  that  <i>&Delta;<sup>i</sup></i>   divides<i>  w}</I>  and
<I></I>sup<I>(w):=</I>inf<I>{i</i>  such  that  <i>w</i>  divides<i> &Delta;<sup>i</sup>}</I>, and to
notice  that the number of conjugates of <I>w</I> with same <I></I>inf<I></I> and <I></I>sup<I></I> as
<I>w</I>  is finite. Further, a theorem of  Birman shows that the maximum <I></I>inf<I></I>
and minimum <I></I>sup<I></I> in a conjugacy class can be achieved simultaneously; the
elements  achieving this are called the super summit set of <I>w</I>. Thus a way
to  determine if two elements are conjugate  is to find a representative of
both  of them in  their super summit  set, and then  solve conjugacy within
that  set. This can also be used to compute the centralizer of an element:
if  we consider  the super  summit set  as the  objects of a category whose
morphisms are the conjugations by simple elements, the centralizer is given
by the endomorphisms of the given object.
<P>
<DL><DT>We illustrate this on an example:<DD>
</DL><P>
<pre>    gap> w:=B(2,1,4,1,4);
    214.14
    gap> ConjugacySet(w,"SS"); # super summit set
    [ 1214.4, 214.14, 124.24, 1343.1, 14.124, 143.13, 24.214, 134.14,
      13.134, 14.143 ]
    gap> RepresentativeConjugation(w,B(1,4,1,4,3));
    (1)^-1.21321432
    gap> w^B(-1,2,1,3,2,1,4,3,2);
    14.143
    gap> CentralizerGenerators(w);
    [ 4, 321432.213243, 21.1 ]</pre>
<P>
There   is  a   faster  solution   to  the   conjugacy  problem   given  in
<A href="biblio.htm#gebgon10"><cite>gebgon10</cite></a>:  for each <I>b&isin; M</I>, they  define a particular simple left
divisor  of <I>b</I>, its  <strong>preferred prefix</strong> such  that the operation <strong>sliding</strong>
which  cyclically  conjugates  <I>b</I>  by  its preferred prefix, is eventually
periodic,  and the period is  contained in the super  summit set of <I>x</I>. We
say  that <I>x</I> is in its sliding circuit  if some iterated sliding of <I>x</I> is
equal  to <I>x</I>. The  set of sliding  circuits in a  given conjugacy class is
smaller  than  the  super  summit  set,  thus allows to solve the conjugacy
problem faster. Continuing from the above example,
<P>
<pre>    gap> CoxeterWord(W,PreferredPrefix(w));
    [ 2, 1 ]
    gap> w^B(PreferredPrefix(w));
    1214.4
    gap> last^B(PreferredPrefix(last));
    1214.4
    gap> ConjugacySet(w,"SC"); # set of sliding circuits
    [ 1214.4, 1343.1 ]</pre>
<P>
Finally, we have implemented Hao Zheng's algorithm to extract roots
in a Garside monoid:
<P>
<pre>    gap> W:=CoxeterGroup("A",3);; M:=BraidMonoid(W);
    BraidMonoid(CoxeterGroup("A",3))
    gap> pi:=M.B(M.delta)^2;
    w0.w0
    gap> GetRoot(pi,2);
    w0
    gap> GetRoot(pi,3);
    1232
    gap> GetRoot(pi,4);
    132</pre>
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap089.htm#SECT001">Operations for (locally) Garside monoid elements</a>
<LI> <A HREF="chap089.htm#SECT002">Records for( locally) Garside monoids</a>
<LI> <A HREF="chap089.htm#SECT003">GarsideWords</a>
<LI> <A HREF="chap089.htm#SECT004">Presentation</a>
<LI> <A HREF="chap089.htm#SECT005">ShrinkGarsideGeneratingSet</a>
<LI> <A HREF="chap089.htm#SECT006">locally Garside monoid and Garside group elements records</a>
<LI> <A HREF="chap089.htm#SECT007">AsWord</a>
<LI> <A HREF="chap089.htm#SECT008">GarsideAlpha</a>
<LI> <A HREF="chap089.htm#SECT009">LeftGcd</a>
<LI> <A HREF="chap089.htm#SECT010">LeftLcm</a>
<LI> <A HREF="chap089.htm#SECT011">ReversedWord</a>
<LI> <A HREF="chap089.htm#SECT012">RightGcd</a>
<LI> <A HREF="chap089.htm#SECT013">RightLcm</a>
<LI> <A HREF="chap089.htm#SECT014">AsFraction</a>
<LI> <A HREF="chap089.htm#SECT015">LeftDivisorsSimple</a>
<LI> <A HREF="chap089.htm#SECT016">EltBraid</a>
<LI> <A HREF="chap089.htm#SECT017">The Artin-Tits braid monoids and groups</a>
<LI> <A HREF="chap089.htm#SECT018">Construction of braids</a>
<LI> <A HREF="chap089.htm#SECT019">Operations for braids</a>
<LI> <A HREF="chap089.htm#SECT020">GoodCoxeterWord</a>
<LI> <A HREF="chap089.htm#SECT021">BipartiteDecomposition</a>
<LI> <A HREF="chap089.htm#SECT022">DualBraidMonoid</a>
<LI> <A HREF="chap089.htm#SECT023">DualBraid</a>
<LI> <A HREF="chap089.htm#SECT024">Operations for dual braids</a>
<LI> <A HREF="chap089.htm#SECT025">ConjugacySet</a>
<LI> <A HREF="chap089.htm#SECT026">CentralizerGenerators</a>
<LI> <A HREF="chap089.htm#SECT027">RepresentativeConjugation</a>
</ol>
<A NAME="SECT001"><h2>89.1 Operations for (locally) Garside monoid elements</h2></a>
<P><P><P>
We illustrate with braids basic operations on elements of a locally Garside
monoid  or  a  Garside  group.  Thus  we  suppose first we have defined two
elements <code>a</code>, <code>b</code> as
<P>
<pre>    gap> W := CoxeterGroup( "A", 2 );;
    gap> a := Braid( W )( [1] );
    1
    gap> b := Braid( W )( [2] );
    2</pre>
<P>
All examples below are with <code>CHEVIE.PrintOption("Garside","Greedy")</code>.
<P>
<code><var>b1</var> * <var>b2</var></code>
<P>
The multiplication of two elements of the same locally Garside monoid or
Garside group is defined.
<P>
<pre>    gap> a * b;
    12</pre>
<P>
<code><var>b1</var> ^ <var>i</var></code>
<P>
An  element can be raised to an integral, positive power (or negative power
if the monoid is Garside, which is the case here since <I>W</I> is finite). Here
<code>w0</code> is how the fundamental element <I>&Delta;</I> prints in the case of braids.
<P>
<pre>    gap> ( a * b ) ^ 4;
    w0.w0.12
    gap> ( a * b ) ^ -1;
    (12)^-1</pre>
<P>
<code><var>b1</var> ^ <var>b2</var></code>
<P>
This is defined if the monoid is Garside and returns <I>b<sub>1</sub><sup>-1</sup>b<sub>2</sub>b<sub>1</sub></I>.
<P>
<pre>    gap> a ^ b;
    (2)^-1.12</pre>
<P>
<code><var>b1</var> / <var>b2</var></code>
<P>
This is defined if the monoid is Garside and returns <I>b<sub>1</sub>b<sub>2</sub><sup>-1</sup></I>.
<P>
<pre>    gap> a / b;
    (12)^-1.21</pre>
<P>
<code>Format( <var>b</var>, <var>option</var> )</code>
<P>
<code>String( <var>b</var> )</code>
<P>
<code>Print( <var>b</var> )</code>
<P>
<code>String</code>  returns a display form of the element <var>b</var>, and <code>Print</code> prints the
result  of <code>String</code>. The way  elements are printed depends  on the value of
the  record  <code>CHEVIE.PrintGarside</code>.  If  if  it  is  <code>rec(GAP:=true)</code>,  the
elements  are printed  in a  form which  can be  read in back by a function
<code>B()</code>  which accepts a list of atoms (for braids, <code>Braid(W)</code> returns such a
function).  If it  is <code>rec(Greedy:=true)</code>  (resp. <code>rec()</code>)  the left-greedy
(resp.  fraction)  normal  form  (as  explained  in  the  introduction)  is
printed:
<P>
<pre>    gap> CHEVIE.PrintGarside:=rec(GAP:=true);;
    gap> ( a * b ) ^ -1;
    B(1,2)^-1
    gap> CHEVIE.PrintGarside:=rec(Greedy:=true);;
    gap> ( a * b ) ^ -1;
    w0^-1.2
    gap> CHEVIE.PrintGarside:=rec();;
    gap> ( a * b ) ^ -1;
    (12)^-1</pre>
<P>
The  function <code>Format( <var>b</var>,  <var>option</var>)</code> returns the  element formatted in a
string  the same  way it  would be  printed with  <code>PrintGarside</code> set to the
corresponding  option. <code>String</code>  is equivalent  to <code>Format(<var>b</var>)</code>  so always
formats its argument as <code>Print</code> does after <code>CHEVIE.PrintGarside:=rec()</code>.
<P>
<code>GetRoot( <var>b</var>, <var>n</var> )</code>
<P>
Returns the <I>n</I>-th root of <var>b</var>.
<P><A NAME="SECT002"><h2>89.2 Records for( locally) Garside monoids</h2></a>
<P><P><P>
This  section is rather technical  and describes an internal representation
which  is not yet completely fixed and thus might still change. We describe
here  how a Garside or  locally Garside monoid with  finitely many atoms is
specified  in <strong>CHEVIE</strong>, as a particular kind  of record. If someone uses the
information  below to construct  a new kind  of Garside monoid,  it is thus
advisable  to  contact  me  (Jean  Michel)  to discuss possible changes.
<P>
To  construct a locally Garside monoid  one creates a record <code>M</code> containing
the   following  fields  holding  data   and  operations,  and  then  calls
<code>CompleteGarsideRecord(M)</code>.  The  simples  can  be  arbitrary  objects (for
interval  monoids  they  should  be  elements  of  a  group), the following
operations should just be defined on them.
<P>
<DL><DT><code>M.atoms</code>:<DD><BR> the list of simples which are atoms of <var>M</var>.
</DL><P>
<DL><DT><code>M.identity</code>:<DD><BR> the identity element of <var>M</var>, a simple.
</DL><P>
<DL><DT><code>M.IsLeftDescending(s,i)</code>:<DD><BR> tells whether <code>M.atoms[i]</code> divides on the left
the simple <var>s</var>.
</DL><P>
<DL><DT><code>M.IsRightAscending(s,i)</code>:<DD><BR> tells whether the product of the simple <var>s</var> by
<code>M.atoms[i]</code> is still simple.
</DL><P>
<DL><DT><code>M.Product(s,t)</code>:<DD><BR> returns the product of the simples <var>s</var> and <var>t</var>. It does
not  have to be defined  in all cases, but  should at least be defined when
<code>t=M.atom[i]</code> and <code>M.IsRightAscending(s,i)</code>.
</DL><P>
<DL><DT><code>M.LeftQuotient(s,t)</code>:<DD><BR>  returns the  quotient <code>s^-1*t</code>  for simples <var>s</var>
and  <var>t</var>. It does not have to be  defined in all cases, but should at least
be defined when <code>s=M.atom[i]</code> and <code>M.IsLeftDescending(t,i)</code>.
</DL><P>
<DL><DT><code>M.RightQuotient(s,t)</code>:<DD><BR> returns the quotient <code>s/t</code> for simples <var>s</var> and <var>t</var>
</DL><P>
The  source code for <code>BraidMonoid</code>  and <code>DualBraidMonoid</code> provide examples.
The  above functions are sufficient for multiplication, and most operations
on  locally Garside monoids,  like <code>LeftGcd</code>, <code>GarsideAlpha</code>,  etc... to be
defined; however see below for conjugacy.
<P>
In  the case the monoid is an interval monoid, which is specified by giving
a  second argument <code>rec(interval:=true)</code>  to <code>CompleteGarsideMonoid</code>, then
the  functions <code>Product</code>, <code>LeftQuotient</code>, <code>RightQuotient</code> are automatically
defined  (since  in  that  case  simples  are  element of a group, they are
defined by the group operations).
<P>
For  <code>ReversedBraid</code>, <code>RightGcd</code>,  <code>RightLcm</code>, <code>M.RightGcdSimples</code>  to work
(see  below) and the Franco  and Gonz&aacute;lez-Meneses conjugacy and
centralizer algorithms to be defined, one needs in addition either:
<P>
a  function <code>M.ReverseSimple</code>  to be  defined, which  defines the <code>Reverse</code>
operation  (if <code>M</code> is an  interval monoid and <code>M.delta^2=M.identity</code>, this
is just <code>x->x^-1</code> thus is then automatically defined),
<P>
or  the symmetric routines <code>M.IsRightDescending</code>, <code>M.IsLeftAscending</code> to be
defined,  and  one  needs  that  <code>Product(M.atoms[i],s)</code> be defined for <code>s</code>
simple such that <code>M.IsLeftAscending(s,i)</code>, and that
<code>M.RightQuotient(s,M.atoms[i])</code> be defined when <code>M.IsRightDescending(s,i)</code>.
<P>
For  the monoid constructed to be Garside one should in addition define the
following data and operations:
<P>
<DL><DT><code>M.delta</code>:<DD><BR> the fundamental element <I>&Delta;</I>.
</DL><P>
<DL><DT><code>M.DeltaAction(s,i)</code>:<DD><BR>  Let <var>f</var> be the  automorphism induced on simples by
<I>&Delta;</I> (such that <I>&Delta; s=f(s)&Delta;</I>). The function returns <I>f<sup>i</sup>(s)</I>.
</DL><P>
<DL><DT><code>M.stringDelta</code>:<DD><BR> how <I>&Delta;</I> should be printed in normal forms.
</DL><P>
If the monoid is an interval monoid, <code>DeltaAction</code> is automatically defined
as conjugation by <code>M.delta</code> in the group to which simples belong.
<P>
<code>CompleteGarsideRecord</code>  uses  internally  the  test  <code>IsBound(M.delta)</code> to
detect if the monoid is Garside.
<P>
Some  additional fields and methods are added by <code>CompleteGarsideRecord</code> if
not  present; they are only added if not present since often the user could
define more efficient or more appropriate versions for a particular kind of
monoid (this is the case for braid monoids, for instance). These fields and
methods are :
<P>
<DL><DT><code>M.AtomListSimple(s)</code>:<DD><BR>  returns the list of atoms of which the simple <var>s</var>
is the product. This is mostly used for display purposes, so the individual
representation  for atoms may be  any kind of object.  However it is useful
for  the function <code>AsWord</code>  that atoms be  represented by positive integers
(if  <code>M.AtomListSimple</code> is not pre-defined, <code>CompleteGarsideRecord</code> defines
a  default version where  an atom is  represented by its  index in the list
<code>M.atoms</code>).  An existing situation  where the representation  of an atom is
not  by its  index in  the list  of atoms  is for  braid monoids of Coxeter
subgroups  (where the index in the list of generators of the parent is used
--- see <code>.reflectionLabels</code>); also in this case the pre-defined function is
faster than the default one would be.
</DL><P>
<DL><DT><code>M.RightComplementToDelta(s)</code>:<DD><BR>  for Garside  monoids. Given  a simple <var>s</var>
returns  the simple <var>t</var> such that <I>st=&Delta;</I>.  Again one may often be able
to pre-define a faster function than the default one.
</DL><P>
<DL><DT><code>M.LeftComplementToDelta(s)</code>:<DD><BR>  for  Garside  monoids.  Given a simple <var>s</var>
returns  the simple  <var>t</var> such  that <I>ts=&Delta;</I>.  The default version reads
<code>DeltaAction(RightComplementToDelta(s),1)</code>.
</DL><P>
For   interval  monoids,  fast  versions  of  <code>RightComplementToDelta</code>  and
<code>LeftComplementToDelta</code> are automatically defined.
<P>
<DL><DT><code>M.LeftGcdSimples(</code><I>a<sub>1</sub>,...,a<sub>n</sub></I><code>)</code>:<DD><BR>  returns the simple  which is the
left gcd of the simples <I>a<sub>1</sub>,...,a<sub>n</sub></I>.
</DL><P>
<DL><DT><code>M.LeftLcmSimples(</code><I>a<sub>1</sub>,...,a<sub>n</sub></I><code>)</code>:<DD><BR>  for Garside monoids. Returns the
simple which is the left lcm of the simples <I>a<sub>1</sub>,...,a<sub>n</sub></I>.
</DL><P>
In  addition <code>CompleteGarsideRecord</code>  defines <code>M.RightGcdSimples</code>  and (for
Garside  monoids) <code>M.RightLcmSimples</code> if the methods <code>M.IsRightDescending</code>,
<code>M.IsLeftAscending</code>, <code>M.LeftMultiple</code>, <code>M.RightQuotient</code> have been defined.
<P><A NAME="SECT003"><h2>89.3 GarsideWords</h2></a>
<P><P>
<A name = "I0"></a>

<P>
<code>GarsideWords( <var>M</var>, <var>l</var> )</code>
<P>
<var>M</var>  should  be  a  (locally)  Garside  monoid which has an additive length
function  (that is, a product  of <var>l</var> atoms is  not equal to any product of
less than <var>l</var> atoms). <code>GarsideWords(<var>M</var>, <var>l</var>)</code> returns the list of elements
of length <var>l</var> in <var>M</var>.
<P>
<pre>    gap>  M := BraidMonoid(CoxeterGroup( "A", 2 ));;
    gap>  GarsideWords( M, 4 );
    [ 21.1.1, 21.12, w0.2, 2.21.1, 2.2.21, 2.2.2.2, w0.1, 1.1.1.1,
      1.1.12, 1.12.2, 12.21, 12.2.2 ]</pre>
<P><A NAME="SECT004"><h2>89.4 Presentation</h2></a>
<P><P>
<A name = "I1"></a>

<P>
<code>Presentation(<var>M</var>)</code>
<P>
<var>M</var>  should be a  Garside monoid. <code>Presentation</code>  returns a presentation of
the  corresponding Garside group  (the presentation is  as given in theorem
4.1 of <A href="biblio.htm#DePa99"><cite>DePa99</cite></a>).
<P>
<pre>    gap>  M := DualBraidMonoid(CoxeterGroup( "A", 3 ));;
    gap>  p:=Presentation(M);Display(p);
    &lt;&lt; presentation with 6 gens and 15 rels of total length 62 >>
    1: ab=da
    2: ac=ca
    3: ec=cb
    4: bd=da
    5: bd=ab
    6: cd=fc
    7: ae=fa
    8: be=cb
    9: be=ec
    10: de=ed
    11: ef=fa
    12: df=fc
    13: df=cd
    14: ef=ae
    15: def=acb
    gap>  ShrinkPresentation(p);Display(p);
    #I  there are 3 generators and 4 relators of total length 26
    #I  there are 3 generators and 3 relators of total length 16
    1: ab=ba
    2: cbc=bcb
    3: cac=aca</pre>
<P><A NAME="SECT005"><h2>89.5 ShrinkGarsideGeneratingSet</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>ShrinkGarsideGeneratingSet(<var>b</var>)</code>
<P>
The  list <var>b</var>  is a  list of  elements of  the same Garside group <I>G</I>. This
function  tries to find  another set of  generators of the  subgroup of <I>G</I>
generated by the elements of <var>b</var>, of smaller total length (the length being
counted  as returned by the function  <code>AsWord</code>).
<P>
<pre>    gap> B:=Braid(CoxeterGroupSymmetricGroup(3));
    function ( arg ) ... end
    gap> b:=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)];
    [ 1.1.1, 2.2.2, (1.12)^-1.2.2.2.21.12, 1.1.12 ]
    gap>  ShrinkGarsideGeneratingSet(b);
    [ 2, 1 ]</pre>
<P><A NAME="SECT006"><h2>89.6 locally Garside monoid and Garside group elements records</h2></a>
<P><P><P>
Now,  we describe elements of a  (locally) Garside monoid which are records
with 3 fields:
<P>
<DL><DT><code>elm</code>:<DD><BR> the list of simples in the left-greedy normal form.
</DL><P>
<DL><DT><code>operations</code>:<DD><BR> points to GarsideEltOps.
</DL><P>
<DL><DT><code>monoid</code>:<DD><BR>  points to the  record describing the  corresponding Garside or
locally Garside monoid.
</DL><P>
And a fourth field if the monoid is Garside:
<P>
<DL><DT><code>pd</code>:<DD><BR> the power of <I>&Delta;</I> involved in the greedy normal form.
</DL><P>
<code>CompleteGarsideRecord</code>  adds  to  (locally)  Garside  monoid records <code>M</code> a
function <code>M.Elt</code> which can be used to build such elements. The syntax is
<P>
<code>M.Elt(<var>s</var> [,<var>pd</var>])</code>
<P>
which  defines an element with <code>.elm=<var>s</var></code>  and <code>.pd=<var>pd</var></code> (if the monoid is
Garside but <var>pd</var> is not given it is initialized to <code>0</code>). The user must only
give  valid normal forms in <var>s</var>,  otherwise unpredictable errors may occur.
For  example, <I>&Delta;</I> should be entered  as <code>M.Elt([],1)</code> and the identity
as <code>M.Elt([])</code>.
<P><A NAME="SECT007"><h2>89.7 AsWord</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>AsWord( <var>b</var> )</code>
<P>
<var>b</var>  should be a locally Garside  monoid or Garside group element. <code>AsWord</code>
then  returns a description of <var>b</var> as a list  of the atoms of which it is a
product  (as returned by <code>AtomListSimple</code>). If <var>b</var>  is in the group but not
the  monoid, it is represented  in fraction normal form  where as a special
convention  the  inverses  of  the  atoms  are  represented by negating the
corresponding integer.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2, 1, 2, 1, 1)*Braid(W)(2,2)^-1;
    (21)^-1.1.12.21
    gap> AsWord( b );
    [ -1, -2, 1, 1, 2, 2, 1 ]</pre>
<P><A NAME="SECT008"><h2>89.8 GarsideAlpha</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>GarsideAlpha( <var>b</var> )</code>
<P>
<I>b</I> should be  an element of a (locally)  Garside monoid. <code>GarsideAlpha</code>
returns the  simple <I>&alpha;(b)</I> (for  braids this  is an element  of the
corresponding Coxeter group).
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid( W )(2, 1, 2, 1, 1);
    121.1.1
    gap> CoxeterWord(W,GarsideAlpha( b ));
    [ 1, 2, 1 ]</pre>
<P><A NAME="SECT009"><h2>89.9 LeftGcd</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>LeftGcd(</code> <I>a<sub>1</sub>,...,a<sub>n</sub></I> <code>)</code>
<P>
<I>a<sub>1</sub>,...,a<sub>n</sub></I>  should be elements  of the same  (locally) Garside monoid
<I>M</I>.  Let <I>d</I> be the greatest common left divisor of <I>a<sub>1</sub>,...,a<sub>n</sub></I>; then
<code>LeftGcd</code> returns the list <code>[d,d^-1*</code><I>a<sub>1</sub>,...,</I><code>d^-1*</code><I>a<sub>n</sub></I><code>]</code>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2,1,2)^2;
    121.121
    gap> LeftGcd(b,Braid(W)(3,2)^2);
    [ 2, 121.21, 32.2 ]</pre>
<P><A NAME="SECT010"><h2>89.10 LeftLcm</h2></a>
<P><P>
<A name = "I6"></a>

<P>
<code>LeftLcm(</code> <I>a<sub>1</sub>,...,a<sub>n</sub></I> <code>)</code>
<P>
<I>a<sub>1</sub>,...,a<sub>n</sub></I> should be elements of the same Garside monoid <I>M</I>. Let <I>m</I>
be  the  least  common  left  multiple  of <I>a<sub>1</sub>,...,a<sub>n</sub></I>; then <code>LeftGcd</code>
returns the list <code>[m,m*</code><I>a<sub>1</sub><sup>-1</sup>,...,</I><code>m*</code><I>a<sub>n</sub><sup>-1</sup></I><code>]</code>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2,1,2)^2;
    121.121
    gap> LeftLcm(b,Braid(W)(3,2)^2);
    [ w0.121, 123, 23.321 ]</pre>
<P><A NAME="SECT011"><h2>89.11 ReversedWord</h2></a>
<P><P>
<A name = "I7"></a>

<P>
<code>ReversedWord( <var>b</var> )</code>
<P>
<I>b</I>  should be  an element  of a  (locally) Garside  monoid which  has a
<code>reverse</code>  operation (see  the end  of the  introduction). The  function
returns the result of the reverse operation applied to <var>b</var>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2,1);
    21
    gap> ReversedWord(b);
    12</pre>
<P><A NAME="SECT012"><h2>89.12 RightGcd</h2></a>
<P><P>
<A name = "I8"></a>

<P>
<code>RightGcd(</code> <I>a<sub>1</sub>,...,a<sub>n</sub></I> <code>)</code>
<P>
<I>a<sub>1</sub>,...,a<sub>n</sub></I> should be elements  of the same (locally) Garside monoid <I>M</I>
which has a  <code>reverse</code> operation (see the end of  the introduction). Let
<I>d</I> be the greatest common right divisor of <I>a<sub>1</sub>,...,a<sub>n</sub></I>; then <code>RightGcd</code>
returns the list <code>[d,</code><I>a<sub>1</sub></I><code>*d^-1</code><I>,...,a<sub>n</sub></I><code>*d^-1]</code>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2,1,2)^2;
    121.121
    gap> RightGcd(b,Braid(W)(3,2)^2);
    [ 2.2, 12.21, 23 ]</pre>
<P><A NAME="SECT013"><h2>89.13 RightLcm</h2></a>
<P><P>
<A name = "I9"></a>

<P>
<code>RightLcm( <var>a</var>, <var>b</var> )</code>
<P>
<I>a<sub>1</sub>,...,a<sub>n</sub></I>  should be elements  of the same  Garside monoid <I>M</I> which
has a <code>reverse</code> operation (see the end of the introduction). Let <I>m</I> be the
least  common right  multiple of  <I>a<sub>1</sub>,...,a<sub>n</sub></I>; then <code>RightLcm</code> returns
the list <code>[m,</code><I>a<sub>1</sub><sup>-1</sup></I><code>*m</code><I>,...,a<sub>n</sub><sup>-1</sup></I><code>*m]</code>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)(2,1,2)^2;
    121.121
    gap> RightLcm(b,Braid(W)(3,2)^2);
    [ w0.w0, 321.123, 12321.321 ]</pre>
<P><A NAME="SECT014"><h2>89.14 AsFraction</h2></a>
<P><P>
<A name = "I10"></a>

<P>
<code>AsFraction( <var>b</var> )</code>
<P>
Let <I>b</I> be  an element of the Garside group  <I>G</I>. <code>AsFraction</code> returns a
pair <code>[x,y]</code>  of two  elements of  <I>M</I> with  no non-trivial  common left
divisor and such that <code>b=x^-1*y</code>.
<P>
<pre>    gap>  W := CoxeterGroup( "A", 3 );;
    gap>  b := Braid(W)( 2, 1, -3, 1, 1);
    (23)^-1.321.1.1
    gap> AsFraction(b);
    [ 23, 321.1.1 ]</pre>
<P><A NAME="SECT015"><h2>89.15 LeftDivisorsSimple</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>LeftDivisorsSimple( <var>M</var>, <var>s</var> [,<var>i</var>])</code>
<P>
Returns  all the left divisors  of the simple element  <var>s</var> of the (locally)
Garside  monoid <var>M</var>, as a  list of lists, where  the <var>i+1</var>th list holds the
divisors  of length  <var>i</var> in  the atoms.  If a  third argument <var>i</var> is given,
returns only the list of divisors of length <var>i</var>.
<P>
<pre>    gap> W:=CoxeterGroup("A",3);
    CoxeterGroup("A",3)
    gap> M:=BraidMonoid(W);
    BraidMonoid(CoxeterGroup("A",3))
    gap> List(LeftDivisorsSimple(M,EltWord(W,[1,3,2])),x->List(x,M.B));
    [ [ . ], [ 3, 1 ], [ 13 ], [ 132 ] ]
    gap> M:=DualBraidMonoid(W);
    DualBraidMonoid(CoxeterGroup("A",3),[ 1, 3, 2 ])
    gap> List(LeftDivisorsSimple(M,EltWord(W,[1,3,2])),x->List(x,M.B));
    [ [ . ], [ 3, 2, 5, 1, 4, 6 ], [ 45, 25, 13, 34, 12, 15 ], [ c ] ]</pre>
<P>
<code>Concatenation(LeftDivisorsSimple(M,M.delta))</code>  returns all  simples of the
monoid <var>M</var>.
<P><A NAME="SECT016"><h2>89.16 EltBraid</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>EltBraid( <var>b</var> )</code>
<P>
This  function is defined only if <var>b</var>  is an element of an interval monoid,
for instance a braid. It returns the image of <var>b</var> in the group of which the
monoid  is an interval  monoid. For instance  it gives the  projection of a
braid in an Artin monoid back to the Coxeter group.
<P>
<pre>    gap>  W := CoxeterGroupSymmetricGroup( 4 );;
    gap>  b := Braid( W )(2, 1, 2, 1, 1);
    121.1.1
    gap> p := EltBraid( b );
    (1,3)
    gap> CoxeterWord( W, p );
    [ 1, 2, 1 ]</pre>
<P><A NAME="SECT017"><h2>89.17 The Artin-Tits braid monoids and groups</h2></a>
<P><P><P>
<code>BraidMonoid(<var>W</var>)</code>
<A name = "I13"></a>

<P>
Returns (as a  Garside or locally Garside monoid  record) the Artin-Tits
braid monoid of the Coxeter group <var>W</var>. The monoid is Garside if and only
if <var>W</var> is finite; in which case  elements of the resulting monoid can be
used as elements of a group.
<P><A NAME="SECT018"><h2>89.18 Construction of braids</h2></a>
<P><P>
<A name = "I14"></a>

<P>
<code>Braid( <var>W</var> )( <var>s1</var>, .., <var>sn</var> )</code>
<P>
<code>Braid( <var>W</var> )( <var>list</var> [, <var>pd</var> ])</code>
<P>
<code>Braid( <var>W</var> )( <var>w</var> [, <var>pd</var> ])</code>
<P>
Let  <var>W</var> be a Coxeter group and let <var>w</var>  be an element of <var>W</var> or a sequence
<I>s<sub>1</sub>,..,s<sub>n</sub></I>  of integers representing a  (non necessarily reduced) word in
the  generators of  <var>W</var>. The  calls above  return the  element of the braid
monoid  of <var>W</var> defined by <var>w</var>.  In the second form the  <var>list</var> is a list of
<I>s<sub>i</sub></I>  as in the  first form. If  <var>pd</var> (a positive  or negative integer) is
given  (which is allowed only when <var>W</var> is finite), the resulting element is
multiplied  in the braid group by <I><strong>w</strong><sub>0</sub><sup>pd</sup></I>. The result of <code>Braid(W)</code> is
a  braid-making function, which can be  assigned to make conveniently braid
elements  as in the  example below. This  function can also  be obtained as
<code>BraidMonoid(W).B</code>.
<P>
<pre>    gap> W := CoxeterGroup( "A", 3 );;
    gap> B := Braid( W );
    function ( arg ) ... end
    gap> B( W.generators[1] );
    1
    gap> B( 2, 1, 2, 1, 1 );
    121.1.1
    gap> CHEVIE.PrintGarside:=rec(Greedy:=true);;
    gap> B( [ 2, 1, 2, 1, 1 ], -1 );
    w0^-1.121.1.1</pre>
<P>
As  a  special  case  (to  follow  usual conventions for entering braids) a
negative  integer in a given list representing  a word in the generators is
taken as representing the inverse of a generator.
<P>
<pre>    gap> CHEVIE.PrintGarside:=rec();;
    gap> B( -1, -2, -3, 1, 1 );
    (321)^-1.1.1</pre>
<P><A NAME="SECT019"><h2>89.19 Operations for braids</h2></a>
<P><P><P>
<A name = "I15"></a>

<DL><DT><code>Frobenius(  <var>WF</var> )(<var>b</var>)</code>:<DD><BR> If  <code>WF</code> is a  Coxeter coset associated to the
Coxeter  group  <I>W</I>,  the  function  <code>Frobenius(WF)</code> returns the associated
automorphism of the braid monoid of <I>W</I>.
</DL><P>
<pre>    gap> W:=CoxeterGroup("D",4);WF:=CoxeterCoset(W,(1,2,4));
    CoxeterGroup("D",4)
    3D4
    gap> B:=Braid(W);;b:=B(1,3);
    13
    gap> Frobenius(WF)(b);
    43
    gap> Frobenius(WF)(b,-1);
    23</pre>
<P>
<A name = "I16"></a>

<DL><DT><code>BrieskornNormalForm( <var>b</var> )</code>:<DD><BR> If <I>b</I> is an element of the braid monoid of
the  Coxeter group <code>W</code>, this function  returns the Brieskorn normal form of
<I>b</I>, which is defined as the concatenation of the Brieskorn normal form for
the terms of the normal form of <I>b</I> (see <a href="chap083.htm#SECT016">BrieskornNormalForm</a>).
</DL><P><A NAME="SECT020"><h2>89.20 GoodCoxeterWord</h2></a>
<P><P>
<A name = "I17"></a>

<P>
<code>GoodCoxeterWord( <var>W</var>, <var>w</var> )</code>
<P>
Let   <var>W</var>  be  a   Coxeter  group  with   associated  braid  monoid  <I>B<sup>+</sup></I>.
<code>GoodCoxeterWord</code>  checks if the  element <var>w</var> of  <var>W</var> (given as sequence of
generators  of  <var>W</var>)  represents  a  ``good  element''  in  the sense of
Geck-Michel <A href="biblio.htm#GM97"><cite>GM97</cite></a> of the braid monoid, i.e., if <I><strong>w</strong><sup>d</sup></I> (where <I>d</I> is
the order of the element <I>w</I> in <I>W</I>, and <I><strong>w</strong></I> is the element of <I><strong>W</strong></I> with
image  <var>w</var>) is a  product of (the  braid elements corresponding to) longest
elements  in a decreasing chain  of parabolic subgroups of  <I>W</I>. If this is
true,  then a list of couples,  the corresponding subsets of the generators
with  their multiplicities in the chain, is returned. Otherwise, <code>false</code> is
returned.
<P>
Good  elements have  nice properties  with respect  to their eigenvalues in
irreducible  representations of  the Hecke-Iwahori  algebra associated to
<var>W</var>. The representatives in the component <code>classtext</code> of
<code>ChevieClassInfo(<var>W</var>)</code>  are all  good elements  of minimal  length in their
class.
<P>
<pre>    gap> W := CoxeterGroup( "F", 4 );;
    gap> w:=[ 2, 3, 2, 3, 4, 3, 2, 1, 3, 4 ];;
    gap> GoodCoxeterWord( W, w );
    [ [ [ 1, 2, 3, 4 ], 2 ], [ [ 3, 4 ], 4 ] ]
    gap> OrderPerm( EltWord( W, w ) );
    6
    gap> Braid( W )( w ) ^ 6;
    w0.w0.343.343.343.343
    gap>  GoodCoxeterWord( W, [ 3, 2, 3, 4, 3, 2, 1, 3, 4, 2 ] );
    false</pre>
<P><A NAME="SECT021"><h2>89.21 BipartiteDecomposition</h2></a>
<P><P>
<A name = "I18"></a>

<P>
<code>BipartiteDecomposition(<var>W</var>)</code>
<P>
Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators
of  the  reflection  group  <code>W</code>,  such  that  <code>ReflectionSubgroup(W,L)</code> and
<code>ReflectionSubgroup(W,R)</code> are abelian subgroups (and
<code>W=ReflectionSubgroup(W,Concatenation(L,R))</code>).  Gives an  error if  no such
decomposition is possible.
<P>
<pre>    gap> BipartiteDecomposition(CoxeterGroup("E",8));
    [ [ 1, 4, 6, 8 ], [ 3, 2, 5, 7 ] ]</pre>
<P><A NAME="SECT022"><h2>89.22 DualBraidMonoid</h2></a>
<P><P>
<A name = "I19"></a>

<P>
<code>DualBraidMonoid(<var>W</var> [, <var>c</var>])</code>
<P>
Returns  (as a Garside monoid record) the dual braid monoid of the <strong>finite</strong>
and <strong>well-generated</strong> complex reflection group <var>W</var> associated to the Coxeter
element  <var>c</var> of <var>W</var>.  If <var>W</var> is  a Coxeter group,  <var>c</var> can be omitted and a
particular one is then chosen, the element
<code>EltWord(W,Concatenation(BipartiteDecomposition(W)))</code>.
<P>
<pre>    gap> DualBraidMonoid(CoxeterGroup("A",4));
    DualBraidMonoid(CoxeterGroup("A",4),[ 1, 3, 2, 4 ])
    gap> M:=DualBraidMonoid(CoxeterGroup("A",4),[1,2,3,4]);
    DualBraidMonoid(CoxeterGroup("A",4),[ 1, 2, 3, 4 ])</pre>
<P>
For  Coxeter groups,  the dual  monoid contains  an operation <code>.ToOrdinary</code>
which  converts simples to elements of the ordinary braid monoid of <var>W</var>. To
go  on  from  the  above  example,  we  compute the list of ordinary braids
<DL><DT>corresponding to each simple of length 2 of the dual monoid:<DD>
</DL><P>
<pre>    gap> List(LeftDivisorsSimple(M,M.delta,2),M.ToOrdinary);
    [ 34, 24, 23, (34)^-1.2343, (3)^-1.234, (4)^-1.234, 14, 13,
      (4)^-1.134, (2)^-1.124, (23)^-1.1232, (2343)^-1.123243, 12,
      (2)^-1.123, (234)^-1.12324, (3)^-1.123, (23)^-1.1234,
      (234)^-1.12343, (24)^-1.1234, (34)^-1.1234 ]</pre>
<P><A NAME="SECT023"><h2>89.23 DualBraid</h2></a>
<P><P>
<A name = "I20"></a>

<P>
<code>B:=DualBraid( <var>W</var> [, <var>c</var>])</code>
<P>
then
<P>
<code>B( <var>s1</var>, .., <var>sn</var> )</code>
<P>
<code>B( <var>list</var> [, <var>pd</var> ])</code>
<P>
<code>B( <var>w</var> [, <var>pd</var> ])</code>
<P>
Let  <var>W</var> be a ell  generated complex reflection group  and <var>c</var> be a Coxeter
element  of <var>W</var> (if <var>W</var> is a Coxeter group and no <var>c</var> is given a particular
one  is chosen  by making  the product  of elements  in a  partition of the
Coxeter  diagram in two sets where  elements in each commute pairwise). The
result  of <code>DualBraid</code> is a dual  braid-making function for the dual monoid
determined  by <var>W</var> and  <var>c</var>: let <var>w</var>  be an element  of <var>W</var> or a sequence
<I>s<sub>1</sub>,..,s<sub>n</sub></I>  of integers  representing a  list of  reflections of <var>W</var>. The
calls  to <code>B</code>  above return  the element  of the  dual braid  monoid of <var>W</var>
defined  by <var>w</var>. In the second form the <var>list</var> is a list of <I>s<sub>i</sub></I> as in the
first  form.  If  <var>pd</var>  (a  positive  or  negative  integer)  is given, the
resulting element is multiplied in the braid group by <I>c<sup>pd</sup></I>.
<P>
<pre>    gap> W := CoxeterGroup( "A", 3 );;
    gap> B := DualBraid( W );
    function ( arg ) ... end
    gap> B( W.reflections[4] );
    4
    gap> B( 2, 1, 2, 1, 1 );
    12.1.1.1
    gap> B( [ 2, 1, 2, 1, 1 ], -1 );
    (3)^-1.5.5.5</pre>
<P>
As  a  special  case  (to  follow  usual conventions for entering braids) a
negative  integer in a given list representing  a word in the generators is
taken as representing the inverse of a generator.
<P>
<pre>    gap> B( -1, -2, -3, 1, 1 );
    (25.1)^-1.1.1</pre>
<P>
The function <code>B</code> can also be obtained by making the calls
<code>M:=DualBraidMonoid( <var>W</var> [, <var>c</var>])</code> and <code>B:=M.B</code>.
<P><A NAME="SECT024"><h2>89.24 Operations for dual braids</h2></a>
<P><P>
<A name = "I21"></a>

<P>
<code>EltBraid</code>  has the  same  meaning as  for ordinary braids.
<P><A NAME="SECT025"><h2>89.25 ConjugacySet</h2></a>
<P><P>
<A name = "I22"></a>

<P>
<code>ConjugacySet(<var>b</var>[,<var>F</var>][,<var>type</var>])</code>
<P>
<var>b</var>  should be an element of a Garside  group. By default, or if the <var>type</var>
given  is <code>"SC"</code>, computes the set of  sliding circuits of <var>b</var>. If <var>type</var>
is  <code>"SS"</code>, computes the super summit set of <var>b</var>. If <var>type</var> is <code>"Cyc"</code>,
computes  the cyclic conjugacy class of <var>b</var>. Finally, if type is <code>"Pos"</code>,
computes the set of all positive elements conjugate to <var>b</var>.
<P>
If  an argument  <var>F</var> is  given it  should be  the Frobenius of a Reflection
coset  attached to the same group to  which the Garside monoid is attached.
Then the same computations are effected but relative to <var>F</var>-conjugacy.
<P>
<pre>    gap> W:=CoxeterGroup("A",4);;w:=Braid(W)(4,3,3,2,1);
    43.321
    gap> ConjugacySet(w);
    [ 32143, 21324 ]
    gap> ConjugacySet(w,"SC");
    [ 32143, 21324 ]
    gap> ConjugacySet(w,"SS");
    [ 32143, 13243, 21432, 21324 ]
    gap> ConjugacySet(w,"Cyc");
    [ 43.321, 3.3214, 32143, 2143.3, 143.32, 213.34, 13.324, 13243,
      1243.3, 123.34 ]
    gap> ConjugacySet(w,"Pos");
    [ 43.321, 3.3214, 32143, 2143.3, 21432, 143.32, 213.34, 1432.2,
      21324, 13.324, 432.21, 1324.2, 13243, 324.21, 124.23, 1243.3,
      24.213, 12.234, 123.34, 2.2134 ]
    gap> W:=CoxeterGroup("D",4);;
    gap> F:=Frobenius(CoxeterCoset(W,(1,2,4)));
    function ( arg ) ... end
    gap> w:=Braid(W)(4,4,4);
    4.4.4
    gap> ConjugacySet(w);
    [ 4.4.4, 3.3.3, 1.1.1, 2.2.2 ]
    gap> ConjugacySet(w,F);
    [ 124 ]</pre>
<P><A NAME="SECT026"><h2>89.26 CentralizerGenerators</h2></a>
<P><P>
<A name = "I23"></a>

<P>
<code>CentralizerGenerators(<var>b</var>[,<var>F</var>][,<var>type</var>])</code>
<P>
<var>b</var> should be an element of a Garside group. The function returns a list of
generators  of the centralizer of <var>b</var>. The computation is done by computing
the  endomorphisms  of  the  object  <var>b</var>  in  the  category  of its sliding
circuits.  If an argument <var>type</var>  is given, the computation  is done in the
corresponding  category --- see <a href="chap089.htm#SECT025">ConjugacySet</a>. The  main use of this is to
compute  the  centralizer  in  the  category  of cyclic conjugacy by giving
<code>"Cyc"</code> as the type.
<P>
If  an argument  <var>F</var> is  given it  should be  the Frobenius of a Reflection
coset  attached to the same group to  which the Garside monoid is attached.
Then the <var>F</var>-centralizer is computed.
<P>
<pre>    gap> W:=CoxeterGroup("D",4);;
    gap> w:=Braid(W)(4,4,4);
    4.4.4
    gap> CentralizerGenerators(w);
    [ 4, 2, (1)^-1.34.431, 34.43, (32431)^-1.132431, 1, (2)^-1.34.432,
      (31432)^-1.231432 ]
    gap> ShrinkGarsideGeneratingSet(last);
    [ 4, 2, 1, 34.43, (3243)^-1.13243 ]
    gap> CentralizerGenerators(w,"Cyc");
    [ 4 ]
    gap> F:=Frobenius(CoxeterCoset(W,(1,2,4)));
    function ( arg ) ... end
    gap> CentralizerGenerators(w,F);
    [ 312343123, 124 ]</pre>
<P><A NAME="SECT027"><h2>89.27 RepresentativeConjugation</h2></a>
<P><P>
<A name = "I24"></a>

<P>
<code>RepresentativeConjugation(<var>b</var>,<var>b1</var>[,<var>F</var>][,<var>type</var>])</code>
<P>
<var>b</var>  and <var>b1</var> should  be elements of  the same Garside  group. The function
returns  <code>false</code> if they  are not conjugate,  and an element  <var>a</var> such that
<code>b^a=b1</code>  if they are conjugate. The  computation is done by computing the
set  of the sliding circuits of <var>b</var> and check  if it is the same as the set
of  sliding  circuits  of  <var>b1</var>.  If  an  argument  <var>type</var>  is  given,  the
computation  is done in the  corresponding category --- see <a href="chap089.htm#SECT025">ConjugacySet</a>.
The  main use of this is  to compute if <var>b</var> and  <var>b1</var> are related by cyclic
conjugacy by giving <code>"Cyc"</code> as the type.
<P>
If  an argument  <var>F</var> is  given it  should be  the Frobenius of a Reflection
coset  attached to the same group to  which the Garside monoid is attached.
Then <var>F</var>-conjugacy is used for the computations.
<P>
<pre>    gap> W:=CoxeterGroup("D",4);;B:=Braid(W);
    function ( arg ) ... end
    gap> b:=B(2,3,1,2,4,3);b1:=B(1,4,3,2,2,2);
    231243
    1432.2.2
    gap> RepresentativeConjugation(b,b1);
    (134312.23)^-1
    gap> b^last;
    1432.2.2
    gap> RepresentativeConjugation(b,b1,"Cyc");
    232.2
    gap> b^last;
    1432.2.2
    gap> RepresentativeConjugation(b,b1,F);
    false
    gap> c:=B(3,2,2,3,3,4);
    32.23.34
    gap> F:=Frobenius(CoxeterCoset(W,(1,2,4)));
    function ( arg ) ... end
    gap> RepresentativeConjugation(b,c,F);
    (13)^-1.23.31
    gap> a:=RepresentativeConjugation(b,c,F);
    (13)^-1.23.31
    gap> a^-1*b*F(a);
    32.23.34
    gap> a:=RepresentativeConjugation(b,c,F,"Cyc");
    2312431.312343.324.23.31
    gap> a^-1*b*F(a);
    32.23.34</pre>
<P><a href ="chap088.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap090.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>