<html><head><title>GAP3 Manual: 82 Reflections, and reflection groups</title></head>
<body bgcolor="ffffff">
<h1>82 Reflections, and reflection groups</h1>
<P><P><P>
Central  in <strong>CHEVIE</strong>  is the  notion of  <strong>reflection groups</strong>.
<P>
<A name = "I0"></a>

Let  <I>V</I> be a vector  space over a subfield  <I>K</I> of the complex numbers; in
<strong>GAP3</strong>  this  usually  means  the  <code>Rationals</code>,  the  <code>Cyclotomics</code>,  or  a
subfield. A <strong>complex reflection</strong> is an element <I>s&isin; GL(V)</I> of finite order
whose  fixed point set is an hyperplane (we will in the following just call
it  a <strong>reflection</strong> to abbreviate; in some literature the term reflection is
only  employed when the  order is 2  and the more  general case is called a
<strong>pseudo-reflection</strong>).  Thus a reflection has  a unique eigenvalue not equal
to  <I>1</I>. If <I>K</I> is a subfield of the real numbers, we get a real reflection
which  is necessarily of order 2 and the non-trivial eigenvalue is equal to
<I>-1</I>.
<P>
A  reflection group <var>W</var> is a group  generated by a finite number of complex
reflections.
<P>
<A name = "I1"></a>

Since  when <var>W</var> contains  a reflection <I>s</I>  it contains its  powers, <var>W</var> is
always generated by reflections <I>s</I> with eigenvalue <code>E(d)</code> where <I>d</I> is the
order  of <I>s</I>; we may in addition assume that <I>s</I> is not a power of another
reflection  with  eigenvalue  <code>E(d')</code>  with  <code>d'>d</code>. Such a reflection is
called <strong>distinguished</strong>; we take it as the canonical generator of the cyclic
subgroup it generates. The generators of reflection groups in <strong>CHEVIE</strong> are
always   distinguished  reflections.   In  a   real  reflection  group  all
reflections are distinguished.
<P>
Reflection groups in <strong>CHEVIE</strong> are groups <var>W</var> with the following fields (in
the group record) defined
<P>
<DL><DT><code>.nbGeneratingReflections</code>:<DD><BR> the number of reflections which generate
         <var>W</var>
</DL><P>
<DL><DT><code>.reflections</code>:<DD><BR> a list of distinguished reflections, given as elements of
  <var>W</var>, such that a list of reflections which generate <var>W</var> is
  <code>W.reflections{[1..W.nbGeneratingReflections]}</code>.
</DL><P>
<DL><DT><code>.OrdersGeneratingReflections</code>:<DD><BR> a list (of length at least
  <code>W.nbGeneratingReflections</code>)   such  that   its  <I>i</I>-th   element  is
  the   order  of   <code>W.reflections[i]</code>.   By   the  above   conventions
  <code>W.reflections[i]</code> thus  has <code>E(W.OrdersGeneratingReflections[i])</code> as
  its nontrivial eigenvalue.
</DL><P>
Note that <var>W</var> does  <strong>not</strong> need to be a matrix group.  The meaning of the
above  fields  is  just  that  <var>W</var>  has  a  representation  (called  the
<strong>reflection representation</strong>  of <var>W</var>) where the  elements <code>W.reflections</code>
operate  as reflections.  It  is  much more  efficient  to compute  with
permutation  groups which  have such  fields defined,  than with  matrix
groups, when possible. Information  sufficient to determine a particular
reflection representation is stored for such groups (see <code>CartanMat</code>).
<P>
Also  note that, although <code>.reflections</code> is usually just initialized to the
generating reflections, it is usually augmented by adding other reflections
to it as computations require. For instance, when <I>W</I> is finite, the set of
all  reflections  in  <I>W</I>  is  finite  (they  are  just the elements of the
conjugacy  classes of the generating reflections and their powers), and all
the  distinguished  reflections  in  <I>W</I>  are  added to <code>.reflections</code> when
required,  for instance  when calling  <code>Reflections(<var>W</var>)</code> which returns the
list  of all (distinguished) reflections. Note that when <I>W</I> is finite, the
distinguished reflections are in bijection with the reflecting hyperplanes.
<P>
There are  very few functions  in <strong>CHEVIE</strong> which deal  with reflections
groups in full generality. Usually the groups one wants to deal with is
in a more  restricted class (Coxeter groups,  finite reflection groups)
which are described in the following chapters.
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap082.htm#SECT001">Reflection</a>
<LI> <A HREF="chap082.htm#SECT002">AsReflection</a>
<LI> <A HREF="chap082.htm#SECT003">CartanMat</a>
<LI> <A HREF="chap082.htm#SECT004">Rank</a>
<LI> <A HREF="chap082.htm#SECT005">SemisimpleRank</a>
</ol>
<A NAME="SECT001"><h2>82.1 Reflection</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>Reflection( <var>root</var>, <var>coroot</var>)</code>
<P>
A  (complex)  reflection  <var>s</var>  acting  on  the  vector space <var>V</var> (over some
subfield  of the complex  numbers), is a  linear map of  finite order whose
fixed  points are an hyperplane <var>H</var>  (called the <strong>reflecting hyperplane</strong> of
<var>s</var>);  an eigenvector <var>r</var> for the non-trivial eigenvalue <I>&zeta;</I> (a root of
unity)  is called  a <strong>root</strong>  of <var>s</var>.  We may  chose a  linear form <I>r<sup>&or;</sup></I>
(called  a <strong>coroot</strong> of <var>s</var>) defining  <var>H</var> such that <I>r<sup>&or;</sup>(r)=1-&zeta;</I> and
then as a linear map <var>s</var> is given by <I> x&rarr; x-r<sup>&or;</sup>(x)r</I>.
<P>
A  first way of specifying  a reflection is by  giving a root and a coroot,
which are uniquely determined by the reflection up to multiplication of the
root  by a  scalar and  of the  coroot by  the inverse scalar. The function
<code>Reflection</code>  gives  the  matrix  of  the  corresponding  reflection in the
standard  basis of <var>V</var>, where the <var>root</var> and the <var>coroot</var> are vectors given
in  the standard bases of  <var>V</var> and <I>V<sup>&or;</sup></I> (thus  in <strong>GAP3</strong> <I>r<sup>&or;</sup>(r)</I> is
obtained as <code><var>root</var>*<var>coroot</var></code>).
<P>
<pre>    gap> r:=Reflection([1,0,0],[2,-1,0]);
    [ [ -1, 0, 0 ], [ 1, 1, 0 ], [ 0, 0, 1 ] ]
    gap> r=CoxeterGroup("A",3).matgens[1];
    true
    gap> [1,0,0]*r;
    [ -1, 0, 0 ]</pre>
<P>
As we see in the last line, in <strong>GAP3</strong> the matrices operate <strong>from the right</strong>
on the vector space.
<P>
<code>Reflection( <var>root</var> [, <var>eigenvalue</var>] )</code>
<P>
We  may  give   slightly  less  information  if  we   assume  that  the
standard hermitian  scalar product  <I>(x,y)</I> on <I>V</I>  (given in  <strong>GAP3</strong> by
<code>x*ComplexConjugate(y)</code>) is <I>s</I>-invariant.  Then, identifying  <I>V</I> and
<I>V<sup>&or;</sup></I> via this scalar product, <I>s</I> is given by the formula
<P>
<center><table><tr><td><I> x&rarr; x-(1-&zeta;)(x,r)/(r,r)r</I></td></tr></table></center>
<P>
so  <I>s</I> is specified by just  <var>root</var> and <var>eigenvalue</var>. When <var>eigenvalue</var> is
omitted  it is assumed to  be equal to -1.  The function <code>Reflection</code> gives
again the matrix of the reflection.
<P>
<pre>    gap> Reflection([0,0,1],E(3));
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, E(3) ] ]
    gap> last=ComplexReflectionGroup(25).matgens[1];
    true</pre>
<P>
<code>Reflection( <var>W</var>, <var>i</var> )</code>
<P>
This  form returns the  reflection with respect  to the <var>i</var>-th  root in the
finite  reflection group  <var>W</var> (this  works only  for groups  represented as
permutation groups of the roots, see <a href="chap084.htm">Finite Reflection Groups</a>). Note that
one  would not get the same result with <code>W.reflections[i]</code> since this entry
might  not yet be  bound (not yet  have been computed),  and also it is not
guaranteed  apart from the generating roots (and the positive roots of Weyl
groups)  that the <I>i</I>-th  reflection corresponds to  the <I>i</I>-th root, since
two  roots  corresponding  to  the  same  reflection may have been obtained
before all the reflections have been obtained.
<P>
<pre>    gap> Reflection(CoxeterGroup("A",3),6);
    ( 1,11)( 3,10)( 4, 9)( 5, 7)( 6,12)</pre>
<P><A NAME="SECT002"><h2>82.2 AsReflection</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>AsReflection( <var>s</var> [,<var>r</var>])</code>
<P>
Here  <var>s</var> is a square matrix with  entries cyclotomic numbers, and if given
<var>r</var>  is  a  vector  of  the  same  length as <var>s</var> of cyclotomic numbers. The
function  determines if <var>s</var> is the matrix  of a reflection (resp. if <var>r</var> is
given  if it is the matrix of a reflection of root <var>r</var>; the point of giving
<var>r</var>  is to specify exactly the desired root and coroot, which otherwise are
determined  only up to  a scalar and  its inverse). The  returned result is
<code>false</code>  if <var>s</var> is not a reflection (resp. not a reflection with root <var>r</var>),
and otherwise is a record with four fields :
<P>
<DL><DT><code>.root</code>:<DD>   <BR> the root of the reflection <var>s</var> (equal to <var>r</var> if given)
</DL><P>
<DL><DT><code>.coroot</code>:<DD> <BR> the coroot of <var>s</var>
</DL><P>
<DL><DT><code>.eigenvalue</code>:<DD> <BR> the non-trivial eigenvalue of <var>s</var>
</DL><P>
<DL><DT><code>.isOrthogonal</code>:<DD>  <BR> a  boolean  which is  <code>true</code> if  and  only if  <var>s</var> is
  orthogonal  with respect to  the usual scalar  product (then the root and
  eigenvalue are sufficient to determine <var>s</var>)
</DL><P>
<pre>    gap> AsReflection([[-1,0,0],[1,1,0],[0,0,1]]);
    rec(
      root := [ 2, 0, 0 ],
      coroot := [ 1, -1/2, 0 ],
      eigenvalue := -1,
      isOrthogonal := false )
    gap> AsReflection([[-1,0,0],[1,1,0],[0,0,1]],[1,0,0]);
    rec(
      root := [ 1, 0, 0 ],
      coroot := [ 2, -1, 0 ],
      eigenvalue := -1,
      isOrthogonal := false )</pre>
<P><A NAME="SECT003"><h2>82.3 CartanMat</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>CartanMat( <var>W</var> )</code>
<P>
Let  <I>s<sub>1</sub>,...,s<sub>n</sub></I> be a list of reflections with associated root vectors
<I>r<sub>i</sub></I>   and  coroots   <I>r<sub>i</sub><sup>&or;</sup></I>.  Then   the  matrix   <I>C<sub>i,j</sub></I>  of  the
<I>r<sub>i</sub><sup>&or;</sup>(r<sub>j</sub>)</I>  is called the <strong>Cartan matrix</strong>  of the list of reflections.
It  is uniquely determined by the reflections up to conjugating by diagonal
matrices.
<P>
If  <I>s<sub>1</sub>,...,s<sub>n</sub></I>  are  the  generators  of  a reflection group <var>W</var>, the
matrix  <code>C</code> up to conjugation  by diagonal matrices is  an invariant of the
reflection  representation of  <var>W</var>. It  actually completely determines this
representation  if the  <I>r<sub>i</sub></I> are  linearly independent  (which is e.g. the
case  if <code>C</code> is  invertible), since in  the <I>r<sub>i</sub></I> basis  the matrix for the
<I>s<sub>i</sub></I>  differs  from  the  identity  only  on  the  <I>i</I>-th  line, where the
corresponding line of <code>C</code> has been subtracted.
<P>
<pre>    gap> W:=CoxeterGroup("A",3);;
    gap> CartanMat(W);
    [ [ 2, -1, 0 ], [ -1, 2, -1 ], [ 0, -1, 2 ] ]</pre>
<P>
<code>CartanMat( <var>W</var>, <var>l</var> )</code>
<P>
Returns  the Cartan  matrix of  the roots  of <var>W</var>  specified by the list of
integers  <var>l</var>  (for  a  finite  reflection  group represented as a group of
permutation  of root  vectors, these  integers are  indices in  the list of
roots of the parent reflection group).
<P>
<code>CartanMat( <var>type</var> )</code>
<P>
This   form  returns  the   Cartan  matrix  of   some  standard  reflection
representations  for Coxeter groups,  taking a symbolic  description of the
Coxeter group given by the arguments. See <a href="chap085.htm#SECT001">CartanMat for Dynkin types</a>
<P><A NAME="SECT004"><h2>82.4 Rank</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>Rank( <var>W</var> )</code>
<P>
Let  <var>W</var>  be  a  reflection  group  in  the vector space <var>V</var>. This function
returns the dimension of <var>V</var>, if known. If reflections of <var>W</var> are generated
by a root and a coroot, it is the length of the root as a list. If <var>W</var> is a
matrix group it is the dimension of the matrices.
<P>
<pre>    gap> W:=ReflectionSubgroup(CoxeterGroup("A",3),[1,3]);
    ReflectionSubgroup(CoxeterGroup("A",3), [ 1, 3 ])
    gap> Rank(W);
    3</pre>
<P><A NAME="SECT005"><h2>82.5 SemisimpleRank</h2></a>
<P><P>
<A name = "I6"></a>

<P>
<code>SemisimpleRank( <var>W</var> )</code>
<P>
Let  <var>W</var>  be  a  reflection  group  in  the vector space <var>V</var>. This function
returns  the dimension of  the subspace <var>V'</var>  of <var>V</var> where <var>W</var> effectively
acts,  which is the subspace  generated by the roots  of the reflections of
<var>W</var>. The space <var>V'</var> is <var>W</var>-stable and has a <var>W</var>-stable complement on which
<var>W</var>  acts trivially. The <code>SemisimpleRank</code>  is independent of the reflection
representation. <var>W</var> is called <strong>essential</strong> if <var>V'=V</var>.
<P>
<pre>    gap> W:=ReflectionSubgroup(CoxeterGroup("A",3),[1,3]);
    ReflectionSubgroup(CoxeterGroup("A",3), [ 1, 3 ])
    gap> SemisimpleRank(W);
    2</pre>
<P><a href ="chap081.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap083.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>