<html><head><title>GAP3 Manual: 95 Reflection cosets</title></head>
<body bgcolor="ffffff">
<h1>95 Reflection cosets</h1>
<P><P>
Let <I>W&sub;</I>GL<I>(V)</I> be a complex reflection group on the vector space <I>V</I>.
Let  <I>&phi;</I> be an element of <I></I>GL<I>(V)</I>  which normalizes <I>W</I>. Then the coset
<I>W&phi;</I> is called a reflection coset.
<P>
A  reference for these cosets is  <A href="biblio.htm#BMM99"><cite>BMM99</cite></a>; the main motivation is that
in  the case where <I>W</I>  is a rational reflection  group (a Weyl group) such
cosets,  that  we  will  call  <strong>Weyl  cosets</strong>, model rational structures on
finite reductive groups. Finally, when <I>W</I> is a so-called <strong>Spetsial</strong> group,
they  are the basic object for the construction of a <strong>Spetses</strong>, which is an
object  attached to  a complex  reflection group  from which one can derive
combinatorially  some attributes shared with  finite reductive groups, like
unipotent degrees, etc<I>...</I>.
<P>
We  say that  a reflection  coset is  irreducible if  <I>W</I> is irreducible. A
general  coset is a direct  product of <strong>descents of  scalars</strong>, which is the
case  where <I>&phi;</I> is transitive on  the irreducible components of <I>W</I>. The
irreducible   cosets  have   been  classified   in  <A href="biblio.htm#BMM99"><cite>BMM99</cite></a>:  up  to
multiplication  of <I>&phi;</I>  by a  scalar, there  is usually  only one or two
possible cosets for a given irreducible group.
<P>
In  <strong>CHEVIE</strong> we deal  only with <strong>finite  order</strong> cosets, that  is, we assume
there  is a  (minimal) integer  <I>&delta;</I> such  that <I>(W&phi;)<sup>&delta;</sup>=W&phi;</I>.
Then   the  group  generated  by  <I>W</I>   and  <I>&phi;</I>  is  finite,  of  order
<I>&delta;|W|</I>.
<P>
A  subset <I>C</I>  of a  <I>W&phi;</I> is  called a  <strong>conjugacy class</strong>  if one of the
following equivalent conditions is fulfilled:
<P>
<I>&bull;</I>  <I>C</I> is the orbit of an  element in <I>W&phi;</I> under the conjugation
action of <I>W</I>.
<P>
<I>&bull;</I> <I>C</I> is a conjugacy class of <I>&lang; W,&phi; &rang;</I> contained in
<I>W&phi;</I>.
<P>
<I>&bull;</I>  The set <I>{w&isin; W| w&phi;&isin; C}</I> is a <I>&phi;</I>-conjugacy class
of <I>W</I> (two elements <I>v,w&isin; W</I> are called <I>&phi;</I>-conjugate, if and only if
there exists <I>x&isin; W</I> with <I>v = xw&phi;(x<sup>-1</sup>)</I>).
<P>
An  irreducible  character  of  <I>&lang;  W,&phi; &rang;</I> has some non-zero
values  on <I>W&phi;</I> if  and only if  its restriction to  <I>W</I> is irreducible.
Further,  two characters <I>&chi;<sub>1</sub></I> and  <I>&chi;<sub>2</sub></I> which have same irreducible
restriction   to  <I>W</I>   differ  by   a  character   of  the   cyclic  group
<I>&lang;&phi;&rang;</I>  (which  identifies  to  the  quotient <I>&lang; W,&phi;
&rang;/W</I>).  A set containing one extension to <I>&lang; W,&phi; &rang;</I> of
each  <I>&phi;</I>-invariant character  of <I>W</I>  is called  a <strong>set  of irreducible
characters  of <I>W&phi;</I></strong>. Two such characters  are orthogonal for the scalar
product  on the  class functions  on <I>W&phi;</I>  given by  <center><table><tr><td><I>&lang; &chi;,&psi;
&rang; := 1/| W|&sum;<sub>w&isin; W</sub>
&chi;(w&phi;)<span style="text-decoration: overline">&psi;(w&phi;)</span>.</I></td></tr></table></center>  For  rational  groups  (Weyl groups),
Lusztig  has defined a canonical choice  of a set of irreducible characters
for  <I>W&phi;</I>  (called  the  <strong>preferred  extensions</strong>),  but for more general
reflection cosets we have made some rather arbitrary choices, which however
have the property that their values lie in the smallest possible field.
<P>
The  <strong>character  table</strong>  of  <I>W&phi;</I>  is  the  table  of values of a set of
irreducible characters on the conjugacy classes.
<P>
A  <strong>subcoset</strong> <I>Lw&phi;</I> of <I>W&phi;</I> is given  by a reflection subgroup <I>L</I> of
<I>W</I> and an element <I>w</I> of <I>W</I> such that <I>w&phi;</I> normalizes <I>L</I>.
<P>
We  then  have  a  natural  notion  of  <strong>restriction</strong> of class functions on
<I>W&phi;</I>  to class functions  on <I>Lw&phi;</I> as  well as of  <strong>induction</strong> in the
other  direction. These maps are adjoint with respect to the scalar product
defined above (see <A href="biblio.htm#BMM99"><cite>BMM99</cite></a>).
<P>
In  <strong>CHEVIE</strong>  the  most  general  construction  of a reflection coset is by
starting  from  a  reflection  datum,  and  giving  in  addition the matrix
<code>phiMat</code> of the map <I>&phi;:V&rarr; V</I> (see the command
<code>ReflectionCoset</code>).   However,   at   present,   general  cosets  are  only
implemented for groups represented as permutation groups on a set of roots,
and  it is required that the automorphism  given preserves this set up to a
scalar  (it  is  allowed  that  these  scalars  depend  on  the  pair of an
irreducible  component and its image). If it also allowed to specify <I>&phi;</I>
by the permutation it induces on the roots; in this case it is assumed that
<I>&phi;</I>  acts trivially on the orthogonal of  the roots, but the roots could
be  those of a parent group, generating a larger space. Thus in any case we
have  a  permutation  representation  of  <I>&lang;  W,&phi;  &rang;</I> and we
consider the coset to be a set of permutations.
<P>
Reflection cosets are implemented in <strong>CHEVIE</strong> by a record which points to a
reflection  group record and has additional fields holding <code>phiMat</code> and the
corresponding  permutation <code>phi</code>. In the general case, on each component of
<I>W</I> which is a descent of scalars, <code>phiMat</code> will permute the components and
differ  by a scalar on each  component from an automorphism which preserves
the  roots. In this case, we have  a permutation <code>phi</code> and a <code>scalar</code> which
is stored for that component.
<P>
The  most common situation where cosets  with non-trivial <code>phi</code> arise is as
sub-cosets  of reflection groups. Here is  an ``exotic'' example, see the
next chapter for more classical examples involving Coxeter groups.
<P>
<pre>    gap> W:=ComplexReflectionGroup(14);
    ComplexReflectionGroup(14)
    gap> PrintDiagram(W);
    G14 1--8--2(3)
    gap> R:=ReflectionSubgroup(W,[2,4]);
    ReflectionSubgroup(ComplexReflectionGroup(14), [ 2, 4 ])
    gap> PrintDiagram(R);
    G5(ER(6)) 2(3)==4(3)
    gap> Rphi:=ReflectionCoset(R,W.1);
    2G5(ER(6))&lt;2,4>
    gap> PrintDiagram(Rphi);
    phi acts as (2,4) on the component below
    G5(ER(6)) 2(3)==4(3)
    gap> ReflectionDegrees(Rphi);
    [ [ 6, 1 ], [ 12, -1 ] ]</pre>
<P>
The  last line shows for each  reflection degree the corresponding <strong>factor</strong>
of the coset, which is the scalar by which <I>&phi;</I> acts on the corresponding
fundamental reflection invariant. The factors characterize the coset.
<P>
The  variable <code>CHEVIE.PrintSpets</code>  determines if  a coset  is printed in an
abbreviated  form which  describes its  type, as  above (<code>G5</code> twisted by 2,
with  a Cartan matrix  which differs from  the standard one  by a factor of
<I>&radic;  6</I>), or in  a form which  could be input  back in <strong>GAP3</strong>. The above
example  was for the default value <code>CHEVIE.PrintSpets=rec()</code>. With the same
data we have:
<P>
<pre>    gap> CHEVIE.PrintSpets:=rec(GAP:=true);;
    gap> Rphi;
    Spets(ReflectionSubgroup(ComplexReflectionGroup(14), [ 2, 4 ]), (1,3)(\ 
    2,4)(5,9)(6,10)(7,11)(8,12)(13,21)(14,22)(15,23)(16,24)(17,25)(18,26)(\ 
    19,27)(20,28)(29,41)(30,42)(31,43)(32,44)(33,45)(34,46)(35,47)(36,48)(\ 
    37,49)(38,50)(39,51)(40,52)(53,71)(54,72)(55,73)(56,74)(57,75)(58,76)(\ 
    59,77)(60,78)(62,79)(64,80)(65,81)(66,82)(67,69)(68,70)(83,100)(84,101\ 
    )(85,102)(87,103)(89,99)(90,97)(91,98)(92,96)(93,104)(94,95)(105,113)(\ 
    106,114)(109,111)(110,112)(115,118)(116,117)(119,120))
    gap> CHEVIE.PrintSpets:=rec();;</pre>
<P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap095.htm#SECT001">ReflectionCoset</a>
<LI> <A HREF="chap095.htm#SECT002">Spets</a>
<LI> <A HREF="chap095.htm#SECT003">ReflectionSubCoset</a>
<LI> <A HREF="chap095.htm#SECT004">SubSpets</a>
<LI> <A HREF="chap095.htm#SECT005">Functions for Reflection cosets</a>
<LI> <A HREF="chap095.htm#SECT006">ChevieCharInfo for reflection cosets</a>
<LI> <A HREF="chap095.htm#SECT007">ReflectionType for reflection cosets</a>
<LI> <A HREF="chap095.htm#SECT008">ReflectionDegrees for reflection cosets</a>
<LI> <A HREF="chap095.htm#SECT009">Twistings</a>
<LI> <A HREF="chap095.htm#SECT010">ChevieClassInfo for Reflection cosets</a>
<LI> <A HREF="chap095.htm#SECT011">CharTable for Reflection cosets</a>
</ol>
<A NAME="SECT001"><h2>95.1 ReflectionCoset</h2></a>
<P><P>
<A name = "I0"></a>

<P>
<code>ReflectionCoset( <var>W</var>[, <var>phiMat</var> ] )</code>
<P>
<code>ReflectionCoset( <var>W</var>[, <var>phiPerm</var>] )</code>
<P>
This  function returns a  reflection coset as  a <strong>GAP3</strong> object. The argument
<var>W</var>  must  be  a  reflection  group  (created  by <code>ComplexReflectionGroup</code>,
<code>CoxeterGroup</code>, <code>PermRootGroup</code> or <code>ReflectionSubgroup</code>). In the first form
the  argument <var>phiMat</var> must be an  invertible matrix with <code>Rank(<var>W</var>)</code> rows,
which  normalizes the parent of <var>W</var> (if any)  as well as <var>W</var>. In the second
form  <var>phiPerm</var> is  a permutation  which describes  the images of the roots
under  <I>phi</I> (only the  image of the  roots corresponding to the generating
reflections need be given, since they already determine a unique <var>phiMat</var>).
This  second form is only allowed if  the semisimple rank of <var>W</var> equals the
rank  (i.e., the roots are a basis of  <I>V</I>). If there is no second argument
the  default for  <var>phiMat</var> is  the identity  matrix, so  the result  is the
trivial coset equal to <I>W</I> itself.
<P>
<code>ReflectionCoset</code>  returns a  record from  which we  document the following
components:
<P>
<DL><DT><code>isDomain</code>, <code>isFinite</code>:<DD><BR> 
        true
</DL><P>
<DL><DT><code>group</code>:<DD><BR> 
        the group <var>W</var>
</DL><P>
<DL><DT><code>phiMat</code>:<DD><BR> 
        the matrix acting on <I>V</I> which represents <I>&phi;</I>.
</DL><P>
<DL><DT><code>phi</code>:<DD><BR> 
        the permutation on the roots of <var>W</var> induced by <code>phiMat</code>.
</DL><P>
<pre>    gap> W := CoxeterGroup("A",3);;
    gap> Wphi := ReflectionCoset( W, (1,3));
    2A3
    gap> m:=MatXPerm(W,(1,3));
    [ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 0 ] ]
    gap> ReflectionCoset( W,m);
    2A3</pre>
<P><A NAME="SECT002"><h2>95.2 Spets</h2></a>
<P><P>
<A name = "I1"></a>

<P>
<code>Spets</code> is a synonym for <code>ReflectionCoset</code>. See <a href="chap095.htm#SECT001">ReflectionCoset</a>.
<P><A NAME="SECT003"><h2>95.3 ReflectionSubCoset</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>ReflectionSubCoset( <var>WF</var>, <var>r</var>, [<var>w</var>] )</code>
<P>
Returns  the reflection subcoset of the  reflection coset <var>WF</var> generated by
the  reflections specified by  <var>r</var>. <var>r</var> is  a list of  indices specifying a
subset of the roots of <var>W</var> where <var>W</var> is the reflection group <code>Group(<var>WF</var>)</code>.
If  specified,  <var>w</var>  must  be  an  element  of  <I>W</I>  such  that <code>w*WF.phi</code>
normalizes  up to scalars  the subroot system  generated by <var>r</var>. If absent,
the  default value for <var>w</var> is <code>()</code>. If the subroot system is not normalized
then <code>false</code> is returned, with a warning message if <code>InfoChevie=Print</code>.
<P>
<pre>    gap> W:=ComplexReflectionGroup(14);
    ComplexReflectionGroup(14)
    gap> Wphi:=ReflectionCoset(W);
    G14
    gap> ReflectionSubCoset(Wphi,[2,4],W.1);
    2G5(ER(6))&lt;2,4>
    gap> WF:=ReflectionCoset(CoxeterGroup("A",4),(1,4)(2,3));
    2A4
    gap> ReflectionSubCoset(WF,[2,3]);
    2A2&lt;2,3>.(q-1)(q+1)
    gap> ReflectionSubCoset(WF,[1,2]);
    #I permutation for F0 must normalize set of roots.
    false</pre>
<P><A NAME="SECT004"><h2>95.4 SubSpets</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>SubSpets</code> is a synonym for <code>ReflectionSubCoset</code>. See <a href="chap095.htm#SECT003">ReflectionSubCoset</a>.
<P><A NAME="SECT005"><h2>95.5 Functions for Reflection cosets</h2></a>
<P><P><P>
<DL><DT><code>Group( <var>WF</var> )</code>:<DD><BR> 
     returns the reflection group of which <var>WF</var> is a coset.
</DL><P>
Quite a few functions defined for domains, permutation groups or reflection
groups have been implemented to work with reflection Cosets.
<P>
<DL><DT><code>Size</code>, <code>Rank</code>, <code>SemisimpleRank</code>:<DD><BR> these functions use the corresponding
     functions for <code>Group( <var>WF</var> )</code>.
<code>Elements</code>, <code>Random</code>, <code>Representative</code>,  <code>in</code>:<BR>  these functions
     use the corresponding functions for <code>Group( <var>WF</var> )</code> and multiply the
     result by <code>WF.phi</code>.
</DL><P>
<A name = "I4"></a>

<DL><DT><code>ConjugacyClasses(  <var>WF</var>  )</code>:<DD><BR> returns  the   conjugacy classes  of  the
  coset   <var>WF</var>  (see  the  introduction  of   this  Chapter).  Let  <var>W</var>  be
  <code>Group(<var>WF</var>)</code>.  Then the classes  are defined to  be the <I>W</I>-orbits on <I>W
  &phi;</I>,  where  <I>W</I>  acts  by  conjugation  (they  coincide  with  the  <I>W
  &phi;</I>-orbits,  <I>W &phi;</I> acting by the conjugation); by the translation <I>w
  &rarr; w&phi;<sup>-1</sup></I> they are sent to the <I>&phi;</I>-conjugacy classes of <I>W</I>.
</DL><P>
<A name = "I5"></a>

<DL><DT><code>PositionClass( <var>WF</var> , <var>x</var> )</code>:<DD><BR> for any element <var>x</var> in <var>WF</var> this returns
     the  number   <code>i</code>   such      that  <var>x</var>    is  an     element     of
     <code>ConjugacyClasses(<var>WF</var>)[i]</code>  (to  work  fast,  the classification of
     reflection groups is used).
</DL><P>
<A name = "I6"></a>

<DL><DT><code>FusionConjugacyClasses( <var>WF1</var>, <var>WF</var>  )</code>:<DD><BR> works in the  same way as for
     groups. See the section <code>ReflectionSubCoset</code>.
</DL><P>
<DL><DT><code>Print( <var>WF</var> )</code>:<DD><BR> if  <code><var>WF</var>.name</code> is bound  then  this is printed,  else
     this function prints  the coset  in a form  which can  be input back
     into <strong>GAP3</strong>.
</DL><P>
<A name = "I7"></a>

<DL><DT><code>InductionTable( <var>HF</var>, <var>WF</var> )</code>:<DD><BR> 
     works in the same way as for groups. It gives the induction table from
     the  Reflection  subcoset  <var>HF</var>  to  the  Reflection coset <var>WF</var>. If <I>H
     w&phi;</I> is a Reflection subcoset of <I>W &phi;</I>, restriction of characters
     is defined as restriction of functions from <I>W &phi;</I> to <I>H w&phi;</I>, and
     induction  as the adjoint map for  the natural scalar product <I>&lang;
     f,  g&rang; =1/|  W|&sum;<sub>v&isin; W</sub>  f(v &phi;)<span style="text-decoration: overline">g</span>(v
     &phi;)</I>.
</DL><P>
<pre>    gap> W := CoxeterGroup( "A", 4 );;
    gap> Wphi := ReflectionCoset( W, (1,4)(2,3) );
    2A4
    gap> Display(InductionTable(ReflectionSubCoset(Wphi,[2,3 ]),Wphi));
    Induction from 2A2&lt;2,3>.(q-1)(q+1) to 2A4
          |111 21 3
    ________________
    11111 |  1  . .
    2111  |  .  1 .
    221   |  1  . .
    311   |  1  . 1
    32    |  .  . 1
    41    |  .  1 .
    5     |  .  . 1</pre>
<P>
    <code>InductionTable</code> and <code>FusionConjugacyClasses</code> work only between cosets.
    If the parent coset is the trivial coset it should still be given as
    a coset and not as a group:
<P>
<pre>    gap> Wphi:=ReflectionCoset(W);
    A4
    gap> L:=ReflectionSubCoset(Wphi,[2,3],LongestCoxeterElement(W));
    A2&lt;2,3>.(q-1)(q+1)
    gap> InductionTable(L,W);
    Error, A2&lt;2,3>.(q-1)(q+1) is a coset but CoxeterGroup("A",4) is not in
    S.operations.FusionConjugacyClasses( S, R ) called from
    FusionConjugacyClasses( u, g ) called from
    InductionTable( L, W ) called from
    main loop
    brk>
    gap> InductionTable(L,Wphi);
    InductionTable(A2&lt;2,3>.(q-1)(q+1), A4)</pre>
<P>
<A name = "I8"></a>

<DL><DT><code>ReflectionName( <var>WF</var> )</code>:<DD><BR> returns a string which describes the isomorphism
   type  of the  group <I>W&#8906;&lang;  F&rang;</I>, associated  to <var>WF</var>, as
   described   in   the   introduction   of   this  Chapter.  An  orbit  of
   <I>&phi;=</I><var>WF</var>.<code>phi</code>  on the components is put in brackets if of length <I>k</I>
   greater than <I>1</I>, and is preceded by the order of <I>phi<sup>k</sup></I> on it, if this
   is  not <I>1</I>.  For example  <code>"2(A2xA2)"</code> denotes  2 components  of type
   <I>A<sub>2</sub></I>  permuted by <I>&phi;</I>, and such that <I>phi<sup>2</sup></I> induces the non-trivial
   diagram  automorphism on  any of  them, while  <code>3D4</code> denotes an orbit of
   length 1 on which <I>phi</I> is of order 3.
</DL><P>
<pre>    gap> W:=ReflectionCoset(CoxeterGroup("A",2,"G",2,"A",2),(1,5,2,6));
    2(A2xA2)&lt;1,2,5,6>xG2&lt;3,4>
    gap> ReflectionName( W );
    "2(A2xA2)&lt;1,2,5,6>xG2&lt;3,4>"</pre>
<P>
<A name = "I9"></a>

<DL><DT><code>PrintDiagram( <var>WF</var> )</code>:<DD><BR> this is  a purely  descriptive routine  (as was
     already  the case for finite  Reflection groups themselves). It prints
     the  Dynkin  diagram  of  <code>ReflectionGroup(<var>WF</var>)</code>  together  with  the
     information how <code><var>WF</var>.phi</code> acts on it. Going from the above example:
</DL><P>
<pre>    gap> PrintDiagram( W );
    phi permutes the next 2 components
    phi^2 acts as (1,2) on the component below
    A2 1 - 2
    A2 5 - 6
    G2 3 >>> 4</pre>
<P>
<code>ChevieClassInfo(   <var>WF</var>   )</code>,   see   the   explicit   description   in
<a href="chap095.htm#SECT010">ChevieClassInfo for Reflection cosets</a>.
<P>
<A name = "I10"></a>

<DL><DT><code>CharParams(  <var>WF</var> )</code>:<DD><BR> This returns appropriate labels for the characters
of the ReflectionCoset. <code>CharName</code> has also a special version for cosets.
</DL><P>
<A name = "I11"></a>

<DL><DT><code>GenericOrder(  <var>WF</var>, <var>q</var> )</code>:<DD><BR> Returns the generic order of the associated
     algebraic  group (for a Weyl coset)  or Spetses, using the generalized
     reflection  degrees. We  also have  <code>TorusOrder(WF,i,q)</code> which  is the
     same as
     <code>GenericOrder(SubSpets(WF,[],Representative(ConjugacyClasses(WF)[i])))</code>.
</DL><P>
Note  that  some  functions  for   elements  of  a  Reflection  group  work
naturally   for   elements   of  a   Reflection   coset: 
<code>EltWord</code>,    <code>ReflectionLength</code>, <code>ReducedInRightCoset</code>, etc<I>...</I>
<P><A NAME="SECT006"><h2>95.6 ChevieCharInfo for reflection cosets</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>ChevieCharInfo( <var>WF</var> )</code>
<P>
<code>ChevieCharInfo</code> gives for a reflection coset <var>WF</var> a record similar to what
it  gives for the corresponding group  <var>W</var>, excepted that some fields which
do  not  make  sense  are  omitted,  and that two fields record information
allowing to relate characters of the coset to that of the group:
<P>
<DL><DT><code>charRestriction</code>:<DD><BR> records for each character of <var>WF</var> the index of the
   character of <var>W</var> of which it is an extension.
</DL><P>
<DL><DT><code>nrGroupClasses</code>:<DD><BR> records <code>NrConjugacyClasses(Group(WF))</code>.
</DL><P>
<pre>    gap> ChevieCharInfo(RootDatum("3D4"));
    rec(
      extRefl := [ 1, 5, 4, 6, 2 ],
      charparams := [ [ [ [  ], [ 4 ] ] ], [ [ [  ], [ 1, 1, 1, 1 ] ] ],
          [ [ [  ], [ 2, 2 ] ] ], [ [ [ 1, 1 ], [ 2 ] ] ],
          [ [ [ 1 ], [ 3 ] ] ], [ [ [ 1 ], [ 1, 1, 1 ] ] ],
          [ [ [ 1 ], [ 2, 1 ] ] ] ],
      charRestrictions := [ 13, 4, 10, 5, 11, 3, 6 ],
      nrGroupClasses := 13,
      b := [ 0, 12, 4, 4, 1, 7, 3 ],
      B := [ 0, 12, 8, 8, 5, 11, 9 ],
      positionId := 1,
      positionDet := 2,
      a := [ 0, 12, 7, 1, 3, 3 ],
      A := [ 0, 12, 11, 5, 9, 9 ],
      charnames := [ ".4", ".1111", ".22", "11.2", "1.3", "1.111", "1.21"
         ] )</pre>
<P><A NAME="SECT007"><h2>95.7 ReflectionType for reflection cosets</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>ReflectionType( <var>WF</var> )</code>
<P>
returns  the type of the Reflection coset  <var>WF</var>. This consists of a list of
records,  one for each orbit of <code><var>WF</var>.phi</code> on the irreducible components of
the Dynkin diagram of <code>Group(<var>WF</var>)</code>, which have two fields:<BR> 
<P>
<DL><DT><code>orbit</code>:<DD><BR> is a list of types of the irreducible components in the orbit.
   These  types are the  same as returned  by the function <code>ReflectionType</code>
   for  an  irreducible  untwisted  reflection  group.  The  components are
   ordered  according to the  action of <code><var>WF</var>.phi</code>,  so <code><var>WF</var>.phi</code> maps the
   generating permutations with indices in the first type to indices in the
   second type in the same order as stored in the type, etc <I>...</I><BR> 
</DL><P>
<DL><DT><code>phi</code>:<DD><BR> if <I>k</I> is the number  of  irreducible  components  in  the  orbit,
   this  is the permutation which describes the action of <code><var>WF</var>.phi</code><I><sup>k</sup></I> on
   the simple roots of the first irreducible component in the orbit.
</DL><P>
<pre>    gap> W:=ReflectionCoset(CoxeterGroup("A",2,"A",2), (1,3,2,4));
    2(A2xA2)
    gap> ReflectionType( W );
    [ rec(orbit := [ rec(rank    := 2,
          series  := "A",
          indices := [ 1, 2 ]), rec(rank    := 2,
          series  := "A",
          indices := [ 3, 4 ]) ],
          twist := (1,2)) ]</pre>
<P><A NAME="SECT008"><h2>95.8 ReflectionDegrees for reflection cosets</h2></a>
<P><P>
<A name = "I14"></a>

<P>
<code>ReflectionDegrees( <var>WF</var> )</code>
<P>
Let <var>W</var> be the Reflection group corresponding to the Reflection coset <var>WF</var>,
and  let <I>V</I> be the vector space of dimension <code>W.rank</code> on which <var>W</var> acts as
a  reflection group. Let <I>f<sub>1</sub>,...,f<sub>n</sub></I> be the basic invariants of <var>W</var> on
the  symmetric  algebra  <I>SV</I>  of  <I>V</I>;  they  can  be  chosen  so they are
eigenvectors  of the matrix <code>WF.phiMat</code>.  The corresponding eigenvalues are
called  the <strong>factors</strong> of <I>&phi;</I> acting  on <I>V</I>; they characterize the coset
--- they are equal to 1 for the trivial coset. The <strong>generalized degrees</strong> of
<var>WF</var>  are the pairs formed of  the reflection degrees and the corresponding
factor.
<P>
<pre>    gap> W := CoxeterGroup( "E", 6 );; WF := ReflectionCoset( W );
    E6
    gap> phi := EltWord( W,[6,5,4,2,3,1,4,3,5,4,2,6,5,4,3,1]);;
    gap> HF := ReflectionSubCoset( WF, [ 2..5 ], phi );;
    gap> PrintDiagram( HF );
    phi acts as (2,3,5) on the component below
    D4 2
        \ 
         4 - 5
        /
       3
    gap> ReflectionDegrees( HF );
    [ [ 1, E(3) ], [ 1, E(3)^2 ], [ 2, 1 ], [ 4, E(3) ], [ 6, 1 ],
      [ 4, E(3)^2 ] ]</pre>
<P><A NAME="SECT009"><h2>95.9 Twistings</h2></a>
<P><P>
<A name = "I15"></a>

<P>
<code>Twistings( <var>W</var>, <var>L</var> )</code>
<P>
<var>W</var>  should be a Reflection group record  or a Reflection coset record, and
<var>L</var> should be a reflection subgroup of <var>W</var> (or of <code>Group(<var>W</var>)</code> for a coset),
or  a sublist of  the generating reflections  of <var>W</var> (resp. <code>Group(W)</code>), in
which case the call is the same as
<code>Twistings(<var>W</var>,ReflectionSubgroup(<var>W</var>,<var>L</var>))</code> (resp.
<code>Twistings(<var>W</var>,ReflectionSubgroup(Group(<var>W</var>),<var>L</var>))</code>).
<P>
The  function returns  a list  of representatives,  up to <var>W</var>-conjugacy, of
reflection sub-cosets of <var>W</var> whose reflection group is <var>L</var>.
<P>
<pre>    gap> W:=ComplexReflectionGroup(3,3,4);
    ComplexReflectionGroup(3,3,4)
    gap> Twistings(W,[1..3]);
    [ G333.(q-1), 3'G333&lt;1,2,3,76>.(q-E3^2), 3G333&lt;1,2,3,76>.(q-E3) ]</pre>
<P><A NAME="SECT010"><h2>95.10 ChevieClassInfo for Reflection cosets</h2></a>
<P><P>
<A name = "I16"></a>

<P>
<code>ChevieClassInfo( <var>WF</var> )</code>
<P>
returns  information about  the conjugacy  classes of  the Reflection coset
<var>WF</var>.  The result is a record with three components: <code>classtext</code> contains
a list of reduced words for the representatives in
<code>ConjugacyClasses(<var>WF</var>)</code>, <code>classnames</code> contains corresponding names for the
classes, and <code>classparams</code> gives corresponding parameters for the classes.
<P>
<pre>    gap> W:=ReflectionCoset(ComplexReflectionGroup(14));
    G14
    gap> Rphi:=ReflectionSubCoset(W,[2,4],Group(W).1);
    2G5(ER(6))&lt;2,4>
    gap> ChevieClassInfo(Rphi);
    rec(
      classtext :=
       [ [  ], [ 2, 4, 4, 2, 4, 4, 2 ], [ 2, 4, 4, 2, 4, 4, 2, 2 ],
          [ 2 ], [ 2, 2, 4, 2, 2 ], [ 2, 2, 4, 4, 2, 2 ], [ 2, 4 ],
          [ 2, 4, 2 ], [ 4, 2, 4, 2 ] ],
      classes := [ 12, 6, 6, 6, 12, 6, 6, 6, 12 ],
      orders := [ 2, 24, 24, 24, 6, 8, 24, 8, 6 ],
      classnames := [ "", "1221221", "12212211", "1", "11211", "112211",
          "12", "121", "2121" ] )</pre>
<P><A NAME="SECT011"><h2>95.11 CharTable for Reflection cosets</h2></a>
<P><P>
<A name = "I17"></a>

<P>
<code>CharTable(  <var>WF</var> )</code>
<P>
This function returns the character table of the Reflection coset <var>WF</var> (see
also  the introduction  of this  Chapter). We  call ``characters'' of the
Reflection   coset  <I>WF</I>  with  corresponding   Reflection  group  <I>W</I>  the
restriction  to  <I>W  &phi;</I>  of  a  set  containing  one  extension  of each
<I>&phi;</I>-invariant character of <I>W</I> to the semidirect product of <I>W</I> with the
cyclic  group generated  by <I>&phi;</I>.  The choice  of extension is always the
same for a given coset, but rather arbitrary in general; for Weyl cosets it
is the "preferred extension" of Lusztig.
<P>
The returned record contains almost all components present in the character
table of a Reflection group. But if <I>&phi;</I> is not trivial then there are no
components <code>powermap</code> (since powers of elements in the coset need not be in
the  coset)  and  <code>orders</code>  (if  you  really  need  them, use <code>MatXPerm</code> to
determine the order of elements in the coset).
<P>
<pre>    gap> W := ReflectionCoset( CoxeterGroup( "D", 4 ), (1,2,4) );
    3D4
    gap> Display( CharTable( W ) );
    3D4

           2  2   2     2      2  2      3      3
           3  1   1     1      .  .      1      1

             C3 ~A2 C3+A1 ~A2+A1 F4 ~A2+A2 F4(a1)

    .4        1   1     1      1  1      1      1
    .1111    -1   1     1     -1  1      1      1
    .22       .   2     2      . -1     -1     -1
    11.2      .   .     .      . -1      3      3
    1.3       1   1    -1     -1  .     -2      2
    1.111    -1   1    -1      1  .     -2      2
    1.21      .   2    -2      .  .      2     -2
    </pre>
<P><a href ="chap094.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap096.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>