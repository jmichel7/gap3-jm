<html><head><title>GAP3 Manual: 80 XMOD</title></head>
<body bgcolor="ffffff">
<h1>80 XMOD</h1>
<P><P><P>
<H3> Subsections</H3>
<oL>
<LI> <A HREF="chap080.htm#SECT001">About XMOD</a>
<LI> <A HREF="chap080.htm#SECT002">About crossed modules</a>
<LI> <A HREF="chap080.htm#SECT003">The XMod Function</a>
<LI> <A HREF="chap080.htm#SECT004">IsXMod</a>
<LI> <A HREF="chap080.htm#SECT005">XModPrint</a>
<LI> <A HREF="chap080.htm#SECT006">ConjugationXMod</a>
<LI> <A HREF="chap080.htm#SECT007">XModName</a>
<LI> <A HREF="chap080.htm#SECT008">CentralExtensionXMod</a>
<LI> <A HREF="chap080.htm#SECT009">AutomorphismXMod</a>
<LI> <A HREF="chap080.htm#SECT010">InnerAutomorphismXMod</a>
<LI> <A HREF="chap080.htm#SECT011">TrivialActionXMod</a>
<LI> <A HREF="chap080.htm#SECT012">IsRModule for groups</a>
<LI> <A HREF="chap080.htm#SECT013">RModuleXMod</a>
<LI> <A HREF="chap080.htm#SECT014">XModSelect</a>
<LI> <A HREF="chap080.htm#SECT015">Operations for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT016">Print for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT017">Size for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT018">Elements for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT019">IsConjugation for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT020">IsAspherical</a>
<LI> <A HREF="chap080.htm#SECT021">IsSimplyConnected</a>
<LI> <A HREF="chap080.htm#SECT022">IsCentralExtension</a>
<LI> <A HREF="chap080.htm#SECT023">IsAutomorphismXMod</a>
<LI> <A HREF="chap080.htm#SECT024">IsTrivialAction</a>
<LI> <A HREF="chap080.htm#SECT025">IsZeroBoundary</a>
<LI> <A HREF="chap080.htm#SECT026">IsRModule for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT027">WhatTypeXMod</a>
<LI> <A HREF="chap080.htm#SECT028">DirectProduct for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT029">XModMorphism</a>
<LI> <A HREF="chap080.htm#SECT030">IsXModMorphism</a>
<LI> <A HREF="chap080.htm#SECT031">XModMorphismPrint</a>
<LI> <A HREF="chap080.htm#SECT032">XModMorphismName</a>
<LI> <A HREF="chap080.htm#SECT033">Operations for morphisms of crossed modules</a>
<LI> <A HREF="chap080.htm#SECT034">IdentitySubXMod</a>
<LI> <A HREF="chap080.htm#SECT035">SubXMod</a>
<LI> <A HREF="chap080.htm#SECT036">IsSubXMod</a>
<LI> <A HREF="chap080.htm#SECT037">InclusionMorphism for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT038">IsNormalSubXMod</a>
<LI> <A HREF="chap080.htm#SECT039">NormalSubXMods</a>
<LI> <A HREF="chap080.htm#SECT040">Factor crossed module</a>
<LI> <A HREF="chap080.htm#SECT041">Kernel of a crossed module morphism</a>
<LI> <A HREF="chap080.htm#SECT042">Image for a crossed module morphism</a>
<LI> <A HREF="chap080.htm#SECT043">InnerAutomorphism of a crossed module</a>
<LI> <A HREF="chap080.htm#SECT044">Order of a crossed module morphism</a>
<LI> <A HREF="chap080.htm#SECT045">CompositeMorphism for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT046">SourceXModXPModMorphism</a>
<LI> <A HREF="chap080.htm#SECT047">About cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT048">Cat1</a>
<LI> <A HREF="chap080.htm#SECT049">IsCat1</a>
<LI> <A HREF="chap080.htm#SECT050">Cat1Print</a>
<LI> <A HREF="chap080.htm#SECT051">Cat1Name</a>
<LI> <A HREF="chap080.htm#SECT052">ConjugationCat1</a>
<LI> <A HREF="chap080.htm#SECT053">Operations for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT054">Size for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT055">Elements for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT056">XModCat1</a>
<LI> <A HREF="chap080.htm#SECT057">Cat1XMod</a>
<LI> <A HREF="chap080.htm#SECT058">SemidirectCat1XMod</a>
<LI> <A HREF="chap080.htm#SECT059">Cat1List</a>
<LI> <A HREF="chap080.htm#SECT060">Cat1Select</a>
<LI> <A HREF="chap080.htm#SECT061">Cat1Morphism</a>
<LI> <A HREF="chap080.htm#SECT062">IsCat1Morphism</a>
<LI> <A HREF="chap080.htm#SECT063">Cat1MorphismName</a>
<LI> <A HREF="chap080.htm#SECT064">Cat1MorphismPrint</a>
<LI> <A HREF="chap080.htm#SECT065">Operations for morphisms of cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT066">Cat1MorphismSourceHomomorphism</a>
<LI> <A HREF="chap080.htm#SECT067">ReverseCat1</a>
<LI> <A HREF="chap080.htm#SECT068">ReverseIsomorphismCat1</a>
<LI> <A HREF="chap080.htm#SECT069">Cat1MorphismXModMorphism</a>
<LI> <A HREF="chap080.htm#SECT070">XModMorphismCat1Morphism</a>
<LI> <A HREF="chap080.htm#SECT071">CompositeMorphism for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT072">IdentitySubCat1</a>
<LI> <A HREF="chap080.htm#SECT073">SubCat1</a>
<LI> <A HREF="chap080.htm#SECT074">InclusionMorphism for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT075">NormalSubCat1s</a>
<LI> <A HREF="chap080.htm#SECT076">AllCat1s</a>
<LI> <A HREF="chap080.htm#SECT077">About derivations and sections</a>
<LI> <A HREF="chap080.htm#SECT078">XModDerivationByImages</a>
<LI> <A HREF="chap080.htm#SECT079">IsDerivation</a>
<LI> <A HREF="chap080.htm#SECT080">DerivationImage</a>
<LI> <A HREF="chap080.htm#SECT081">DerivationImages</a>
<LI> <A HREF="chap080.htm#SECT082">InnerDerivation</a>
<LI> <A HREF="chap080.htm#SECT083">ListInnerDerivations</a>
<LI> <A HREF="chap080.htm#SECT084">Operations for derivations</a>
<LI> <A HREF="chap080.htm#SECT085">Cat1SectionByImages</a>
<LI> <A HREF="chap080.htm#SECT086">IsSection</a>
<LI> <A HREF="chap080.htm#SECT087">IsRegular for Crossed Modules</a>
<LI> <A HREF="chap080.htm#SECT088">Operations for sections</a>
<LI> <A HREF="chap080.htm#SECT089">RegularDerivations</a>
<LI> <A HREF="chap080.htm#SECT090">AllDerivations</a>
<LI> <A HREF="chap080.htm#SECT091">DerivationsSorted</a>
<LI> <A HREF="chap080.htm#SECT092">DerivationTable</a>
<LI> <A HREF="chap080.htm#SECT093">AreDerivations</a>
<LI> <A HREF="chap080.htm#SECT094">RegularSections</a>
<LI> <A HREF="chap080.htm#SECT095">AllSections</a>
<LI> <A HREF="chap080.htm#SECT096">AreSections</a>
<LI> <A HREF="chap080.htm#SECT097">SectionDerivation</a>
<LI> <A HREF="chap080.htm#SECT098">DerivationSection</a>
<LI> <A HREF="chap080.htm#SECT099">CompositeDerivation</a>
<LI> <A HREF="chap080.htm#SECT100">CompositeSection</a>
<LI> <A HREF="chap080.htm#SECT101">WhiteheadGroupTable</a>
<LI> <A HREF="chap080.htm#SECT102">WhiteheadMonoidTable</a>
<LI> <A HREF="chap080.htm#SECT103">InverseDerivations</a>
<LI> <A HREF="chap080.htm#SECT104">ListInverseDerivations</a>
<LI> <A HREF="chap080.htm#SECT105">SourceEndomorphismDerivation</a>
<LI> <A HREF="chap080.htm#SECT106">TableSourceEndomorphismDerivations</a>
<LI> <A HREF="chap080.htm#SECT107">RangeEndomorphismDerivation</a>
<LI> <A HREF="chap080.htm#SECT108">TableRangeEndomorphismDerivations</a>
<LI> <A HREF="chap080.htm#SECT109">XModEndomorphismDerivation</a>
<LI> <A HREF="chap080.htm#SECT110">SourceEndomorphismSection</a>
<LI> <A HREF="chap080.htm#SECT111">RangeEndomorphismSection</a>
<LI> <A HREF="chap080.htm#SECT112">Cat1EndomorphismSection</a>
<LI> <A HREF="chap080.htm#SECT113">About actors</a>
<LI> <A HREF="chap080.htm#SECT114">ActorSquareRecord</a>
<LI> <A HREF="chap080.htm#SECT115">WhiteheadPermGroup</a>
<LI> <A HREF="chap080.htm#SECT116">Whitehead crossed module</a>
<LI> <A HREF="chap080.htm#SECT117">AutomorphismPermGroup for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT118">XModMorphismAutoPerm</a>
<LI> <A HREF="chap080.htm#SECT119">ImageAutomorphismDerivation</a>
<LI> <A HREF="chap080.htm#SECT120">Norrie crossed module</a>
<LI> <A HREF="chap080.htm#SECT121">Lue crossed module</a>
<LI> <A HREF="chap080.htm#SECT122">Actor crossed module</a>
<LI> <A HREF="chap080.htm#SECT123">InnerMorphism for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT124">Centre for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT125">InnerActor for crossed modules</a>
<LI> <A HREF="chap080.htm#SECT126">Actor for cat1-groups</a>
<LI> <A HREF="chap080.htm#SECT127">About induced constructions</a>
<LI> <A HREF="chap080.htm#SECT128">InducedXMod</a>
<LI> <A HREF="chap080.htm#SECT129">AllInducedXMods</a>
<LI> <A HREF="chap080.htm#SECT130">InducedCat1</a>
<LI> <A HREF="chap080.htm#SECT131">About utilities</a>
<LI> <A HREF="chap080.htm#SECT132">InclusionMorphism</a>
<LI> <A HREF="chap080.htm#SECT133">ZeroMorphism</a>
<LI> <A HREF="chap080.htm#SECT134">EndomorphismClasses</a>
<LI> <A HREF="chap080.htm#SECT135">EndomorphismImages</a>
<LI> <A HREF="chap080.htm#SECT136">IdempotentImages</a>
<LI> <A HREF="chap080.htm#SECT137">InnerAutomorphismGroup</a>
<LI> <A HREF="chap080.htm#SECT138">IsAutomorphismGroup</a>
<LI> <A HREF="chap080.htm#SECT139">AutomorphismPair</a>
<LI> <A HREF="chap080.htm#SECT140">IsAutomorphismPair</a>
<LI> <A HREF="chap080.htm#SECT141">AutomorphismPermGroup</a>
<LI> <A HREF="chap080.htm#SECT142">FpPair</a>
<LI> <A HREF="chap080.htm#SECT143">IsFpPair</a>
<LI> <A HREF="chap080.htm#SECT144">SemidirectPair</a>
<LI> <A HREF="chap080.htm#SECT145">IsSemidirectPair</a>
<LI> <A HREF="chap080.htm#SECT146">PrintList</a>
<LI> <A HREF="chap080.htm#SECT147">DistinctRepresentatives</a>
<LI> <A HREF="chap080.htm#SECT148">CommonRepresentatives</a>
<LI> <A HREF="chap080.htm#SECT149">CommonTransversal</a>
<LI> <A HREF="chap080.htm#SECT150">IsCommonTransversal</a>
</ol>
<A NAME="SECT001"><h2>80.1 About XMOD</h2></a>
<P><P><P>
This document describes a package for the <strong>GAP3</strong> group theory langauge
which  enables computations with    the equivalent notions  of finite,
permutation <em> crossed modules</em> and <em> cat1-groups</em>.
<P>
The package divides into six parts, each of which has its own introduction:

<P>&bull; for constructing crossed modules and their morphisms in section 
      \refAbout crossed modules: About crossed modules;
<P>&bull; for cat1-groups, their morphisms, and for converting between
      crossed modules and cat1-groups, 
      in section \refAbout cat1-groups: About cat1-groups;
<P>&bull; for derivations and sections and the monoids which they form
      under the Whitehead multiplication, in section
      \refAbout derivations and sections: About derivations and sections;
<P>&bull; for actor crossed modules, actor cat1-groups and the actors squares
      which they form,  in section \refAbout actors: About actors;
<P>&bull; for the construction of induced crossed modules
      and induced cat1-groups, in section 
      \refAbout induced constructions: About induced constructions;
<P>&bull; for a collection of utility functions in section 
      \refAbout utilities: About utilities.

<P>

These seven <code>About...</code> sections are collected together in a separate
<strong>LaTeX</strong> file, <code>xmabout.tex</code>, which forms a short introduction to the package.
<P>
The  package may be obtained as  a compressed file by  ftp from one of
the sites with   a <strong>GAP3</strong> archive.  After  decompression, instructions
for installing the package may be found in the <code>README</code> file.
<P>
The following constructions are planned  for the  next version of  the
package.  Firstly,  although  sub-crossed  module functions  have been
included,  the  equivalent set  of  sub-cat1-groups  functions  is not
complete.  Secondly,  functions for  pre-crossed modules,  the Peiffer
subgroup of a pre-crossed module  and the associated crossed  modules,
will  be added.  Group-graphs  provide examples of pre-crossed modules
and their implementation will require interaction with graph-theoretic
functions in <strong>GAP3</strong>.  Crossed squares  and the equivalent  cat2-groups
are   the structures   which  arise as  "three-dimensional  groups".
Examples of  these are implicitly  included already, namely inclusions
of normal  sub-crossed modules, and the inner  morphism from a crossed
module to its actor (section \refInnerMorphism for crossed modules).
<P><A NAME="SECT002"><h2>80.2 About crossed modules</h2></a>
<P><P><P>
The term crossed module was introduced by J. H. C. Whitehead in
<A href="biblio.htm#xmodW2"><cite>xmodW2</cite></a>, <A href="biblio.htm#xmodW1"><cite>xmodW1</cite></a>. In <A href="biblio.htm#xmodL1"><cite>xmodL1</cite></a> Loday reformulated the notion of a 
crossed  module  as a   cat1-group.  Norrie <A href="biblio.htm#xmodN1"><cite>xmodN1</cite></a>,   <A href="biblio.htm#xmodN2"><cite>xmodN2</cite></a> and
Gilbert <A href="biblio.htm#xmodG1"><cite>xmodG1</cite></a> have studied  derivations, automorphisms  of crossed
modules and the actor of  a crossed module,  while Ellis <A href="biblio.htm#xmodE1"><cite>xmodE1</cite></a> has
investigated   higher dimensional analogues.    Properties  of induced
crossed modules have been determined  by Brown, Higgins and Wensley in
<A href="biblio.htm#xmodBH1"><cite>xmodBH1</cite></a>,  <A href="biblio.htm#xmodBW1"><cite>xmodBW1</cite></a>  and <A href="biblio.htm#xmodBW2"><cite>xmodBW2</cite></a>.    For further references see
<A href="biblio.htm#xmodAW1"><cite>xmodAW1</cite></a> where we discuss some of the data structures and algorithms
used in this  package,  and  also   tabulate isomorphism   classes  of
cat1-groups up to size <I>30</I>.
<P>
We first recall the descriptions of three equivalent categories:  
\textbfXMod, the category of crossed modules and their morphisms;  
\textbfCat1, the category of cat1-groups and their morphisms; and  
\textbfGpGpd, the subcategory of group objects in the category
\textbfGpd of groupoids.
We also  include functors between  these categories which  exhibit the
equivalences.  Most papers on crossed modules use left actions, but we
give the alternative right action axioms here, which are more suitable
for use in computational group theory programs.
<P>
A crossed module  <I><span style="font-family: cursive"> X</span> =  (&part; : S  &rarr; R )</I>  consists of a
group homomorphism   <I>&part;  </I>,   called  the  <em>   boundary</em>  of
<I>\mathcalX</I>,   with <em> source</em> <I>S</I>   and <em> range</em> <I>R</I>, together
with an action  <I>&alpha; : R  &rarr; \mathrmAut(S)</I> satisfying, for all
<I>s,s<sub>1</sub>,s<sub>2</sub> &isin; S</I> and <I>r &isin; R</I>,
<center>
\begintabularc r c l 
\textbfXMod 1: &  <I>&part;(s<sup>r</sup>)</I>   &  =  &  <I>r<sup>-1</sup> (&part; s) r</I> <BR> 
\textbfXMod 2: &  <I>s<sub>1</sub><sup>&part; s<sub>2</sub></sup></I>  &  =  &  <I>s<sub>2</sub><sup>-1</sup>s<sub>1</sub> s<sub>2</sub></I>.
\endtabular
</center>
The kernel of  <I>&part;</I>  is abelian.
<P><P>
<DL><DT>The standard constructions for crossed modules are as follows:<DD>
</DL><P>

<P>&bull; A <em> conjugation crossed module</em>
      is an  inclusion of a  normal subgroup  <I>S  \unlhd R</I>, where <I>R</I>
      acts on <I>S</I> by conjugation.
<P>&bull; A <em> central extension crossed module</em> has as boundary a surjection
      <I>&part; : S &rarr; R</I> with central  kernel, where <I>r &isin; R</I> acts
      on <I>S</I> by conjugation with <I>&part;<sup>-1</sup>r</I>.
<P>&bull; An <em> automorphism crossed module</em> has as range a subgroup <I>R</I>
      of the automorphism  group <I></i>Aut<i>(S)</I> of <I>S</I> which contains
      the inner  automorphism group of <I>S</I>.  The  boundary maps <I>s &isin;
      S</I> to the inner automorphism of <I>S</I> by <I>s</I>.
<P>&bull; A <em> trivial action crossed module</em>  <I>&part; : S &rarr; R</I>
      has <I>s<sup>r</sup> =  s</I> for all  <I>s &isin; S,    r &isin;   R</I>, the source  is
      abelian and the image lies in the centre of the range.
<P>&bull; An <em> R-Module crossed module</em> has an <I>R</I>-module as source
      and the zero map as boundary.
<P>&bull; The direct product  <I><span style="font-family: cursive"> X</span><sub>1</sub> &times; <span style="font-family: cursive"> X</span><sub>2</sub></I>
      of two crossed  modules has source <I>S<sub>1</sub>  &times; S<sub>2</sub></I>, range <I>R<sub>1</sub>
      &times; R<sub>2</sub></I> and   boundary <I>&part;<sub>1</sub> &times; &part;<sub>2</sub></I>,  with
      <I>R<sub>1</sub>, R<sub>2</sub></I> acting trivially on <I>S<sub>2</sub>, S<sub>1</sub></I> respectively.

<P>
A morphism between two crossed  modules <I><span style="font-family: cursive"> X</span><sub>1</sub> = (&part;<sub>1</sub> :
S<sub>1</sub> &rarr; R<sub>1</sub>)</I> and  <I><span style="font-family: cursive"> X</span><sub>2</sub> = (&part;<sub>2</sub>  : S<sub>2</sub> &rarr; R<sub>2</sub>)</I> is  a
pair <I>(&sigma;,  &rho;)</I>, where <I>  &sigma; : S<sub>1</sub> &rarr; S<sub>2</sub></I>  and <I> &rho; :
R<sub>1</sub> &rarr; R<sub>2</sub></I> are homomorphisms satisfying 
<center><table><tr><td><I>&part;<sub>2</sub> &sigma; = &rho; &part;<sub>1</sub>,    
&sigma;(s<sup>r</sup>) = (&sigma; s)<sup>&rho; r</sup>.
</I></td></tr></table></center>  
<P>
When <I><span style="font-family: cursive"> X</span><sub>1</sub>    = <span style="font-family: cursive"> X</span><sub>2</sub></I> and   <I>  &sigma;, &rho; </I>  are
automorphisms then <I>(&sigma;,  &rho;)</I>   is an automorphism   of  <I><span style="font-family: cursive">
X</span><sub>1</sub></I>.  The group of  automorphisms is denoted  by <I>\mathrmAut(<span style="font-family: cursive">
X</span><sub>1</sub> ).</I>
<P><P>
<DL><DT>In this implementation a crossed module  <code>X</code>  is a record with fields:<DD>
</DL><P>
beg-tabular<s></s>ll
<code>X.source</code>,     & the source <I>S</I> of <I>&part;</I>,       <BR> 
<code>X.boundary</code>,   & the homomorphsim <I>&part;</I>,        <BR> 
<code>X.range</code>,      & the range <I>R</I> of <I>&part;</I>,        <BR> 
<code>X.aut</code>,        & a group of automorphisms of <I>S</I>,    <BR> 
<code>X.action</code>,     & a homomorphism from <I>R</I> to <code>X.aut</code>, <BR> 
<code>X.isXMod</code>,     & a boolean flag, normally <code>true</code>,    <BR> 
<code>X.isDomain</code>,   & always true,                        <BR> 
<code>X.operations</code>, & special set of operations <code>XModOps</code>
                  (see \refOperations for crossed modules),  <BR> 
<code>X.name</code>,       & a concatenation of the names of the source and range.
end-tabular<s></s>
<P>
Here   is a simple  example of   an automorphism  crossed  module, the
holomorph of the cyclic group of size five.
<P>
<pre>    gap> c5 := CyclicGroup( 5 );;   c5.name := "c5";;
    gap> X1 := AutomorphismXMod( c5 );
    Crossed module [c5->PermAut(c5)]
    gap> XModPrint( X1 );
    Crossed module [c5->PermAut(c5)] :- 
    : Source group c5 has generators:
      [ (1,2,3,4,5) ]
    : Range group = PermAut(c5) has generators:
      [ (1,2,4,3) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,4,3) --> { source gens --> [ (1,3,5,2,4) ] }
      This automorphism generates the group of automorphisms.    </pre>
<P><P>
Implementation of the  standard constructions is described in sections
<code>ConjugationXMod</code>,    <code>CentralExtensionXMod</code>,      <code>AutomorphismXMod</code>,
<code>TrivialActionXMod</code> and  <code>RModuleXMod</code>.  With  these  building blocks,
sub-crossed modules <code>SubXMod</code>, quotients of normal sub-crossed modules
<code>FactorXMod</code>  and  direct  products  <code>XModOps.DirectProduct</code>  may   be
constructed.  An   extra function <code>XModSelect</code>  is used  to call these
constructions using groups of  order up to  <I>47</I> and data from file in
<code>Cat1List</code>.
<P>
A morphism  from  a crossed module <I><span style="font-family: cursive">  X</span><sub>1</sub></I>  to a crossed  module
<I><span style="font-family: cursive">  X</span><sub>2</sub></I> is  a  pair  of homomorphisms  <I>(&sigma;,  &rho;)</I>,  where
<I>&sigma;, &rho;</I> are respectively homomorphisms  between the sources and
ranges of  <I><span style="font-family: cursive"> X</span><sub>1</sub></I> and <I><span style="font-family: cursive"> X</span><sub>2</sub></I>,  which  commute with the two
boundary  maps and which are  morphisms  for the two  actions.  In the
following code we construct a simple automorphism of <code>X1</code>.
<P>
<pre>    gap> sigma1 := GroupHomomorphismByImages( c5, c5, [ (1,2,3,4,5) ],
    >        [ (1,5,4,3,2) ] );;
    gap> rho1 := InclusionMorphism( X1.range, X1.range );;
    gap> mor1 := XModMorphism( X1, X1, [ sigma1, rho1 ] );
    Morphism of crossed modules &lt;[c5->PermAut(c5)] >-> [c5->PermAut(c5)]>
    gap> IsXModMorphism( mor1 );
    true
    gap> XModMorphismPrint( mor1 );
    Morphism of crossed modules :- 
    : Source = Crossed module [c5->PermAut(c5)] with generating sets:
      [ (1,2,3,4,5) ]
      [ (1,2,4,3) ]
    : Range = Source
    : Source Homomorphism maps source generators to:
      [ (1,5,4,3,2) ]
    : Range Homomorphism maps range generators to:
      [ (1,2,4,3) ]
    : isXModMorphism? true
    gap> IsAutomorphism( mor1 );
    true  </pre>
<P>
The functors between  \textbfXMod and \textbfCat1, are implemented
as functions <code>XModCat1</code> and <code>Cat1XMod</code>.
<P>
An integer variable <code>XModPrintLevel</code>   is set initially equal to  <code>1</code>.
If it is increased, additional  information is printed out during  the
execution of many of the functions.
<P><A NAME="SECT003"><h2>80.3 The XMod Function</h2></a>
<P><P><P>
<code>XMod( <var>f, a</var> )</code>
<P>
A   crossed   module is   determined  by    its  boundary and   action
homomorphisms, <I>f</I> and <I>a</I>.  All  the standard constructions described
below call this function after constructing the two homomorphisms.  In
the following example we construct  a central extension crossed module
<I>s3 &times; c4 &rarr; s3</I>  directly by defining the  projection on to  the
first factor to be the boundary map, and constructing the automorphism
group by taking two inner automorphisms as generators.
<P>
<pre>    gap> s3c4 := Group( (1,2),(2,3),(4,5,6,7));;
    gap> s3c4.name := "s3c4";;
    gap> s3 := Subgroup( s3c4, [ (1,2), (2,3) ] );;
    gap> s3.name := "s3";;
    gap> # construct the boundary
    gap> gen := s3c4.generators;;
    gap> imb := [ (1,2), (2,3), () ];;
    gap> bX := GroupHomomorphismByImages( s3c4, s3, gen, imb );;
    gap> # construct the inner automorphisms by (1,2) and (2,3)
    gap> im1 := List( gen, g -> g^(1,2) );;
    gap> a1 := GroupHomomorphismByImages( s3c4, s3c4, gen, im1 );;
    gap> im2 := List( gen, g -> g^(2,3) );;
    gap> a2 := GroupHomomorphismByImages( s3c4, s3c4, gen, im2 );;
    gap> A := Group( a1, a2 );;
    gap> # construct the action map from s3 to A
    gap> aX := GroupHomomorphismByImages( s3, A, [(1,2),(2,3)], [a1,a2] );;
    gap> X := XMod( bX, aX );
    Crossed module [s3c4->s3]  </pre>
<P><A NAME="SECT004"><h2>80.4 IsXMod</h2></a>
<P><P>
<A name = "I0"></a>

<P>
<code>IsXMod( <var>X</var> )</code>
<P>
This Boolean function  checks that the five  main fields of  <I>X</I> exist
and that the crossed module axioms are satisfied.
<P>
<pre>    gap> IsXMod( X );
    true </pre>
<P><A NAME="SECT005"><h2>80.5 XModPrint</h2></a>
<P><P>
<A name = "I1"></a>

<P>
<code>XModPrint( <var>X</var> )</code>
<P>
This function is used to display the main fields of a crossed module.
<P>
<pre>    gap> XModPrint( X );
    Crossed module [s3c4->s3] :- 
    : Source group s3c4 has generators:
      [ (1,2), (2,3), (4,5,6,7) ]
    : Range group has parent ( s3c4 ) and has generators:
      [ (1,2), (2,3) ]
    : Boundary homomorphism maps source generators to:
      [ (1,2), (2,3), () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2) --> { source gens --> [ (1,2), (1,3), (4,5,6,7) ] }
      (2,3) --> { source gens --> [ (1,3), (2,3), (4,5,6,7) ] }
      These 2 automorphisms generate the group of automorphisms.   </pre>
<P><A NAME="SECT006"><h2>80.6 ConjugationXMod</h2></a>
<P><P><P>
<code>ConjugationXMod( <var>R [,S]</var> )</code>
<P>
This construction returns the  crossed module  whose  source <I>S</I> is  a
normal subgroup of  the range <I>R</I>, the  boundary is the inclusion map,
the group of automorphisms is the inner automorphism group of <I>S</I>, and
the action maps an element of <I>r &isin; R</I>  to conjugation of <I>S</I> by <I>r</I>.
The default value for <I>S</I> is <I>R</I>.
<P>
<pre>    gap> s4 := Group( (1,2,3,4), (1,2) );;
    gap> a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );;
    gap> k4 := Subgroup( a4, [ (1,2)(3,4), (1,3)(2,4) ] );;
    gap> s4.name := "s4";;  a4.name := "a4";;  k4.name := "k4";;
    gap> CX := ConjugationXMod( a4, k4 );
    Crossed module [k4->a4] </pre>
<P><A NAME="SECT007"><h2>80.7 XModName</h2></a>
<P><P>
<A name = "I2"></a>

<P>
<code>XModName( <var>X</var> )</code>
<P>
Whenever  the names of the  source or range of  <code>X</code>  are changed, this
function may     be   used  to produce      the  new   standard   form
<code>[X.source.name->X.range.name]</code> for the name of <code>X</code>.  This function is
called automatically by <code>XModPrint</code>.
<P>
<pre>    gap> k4.name := "v4";;
    gap> XModName( CX );
    "[v4->a4]"           </pre>
<P><A NAME="SECT008"><h2>80.8 CentralExtensionXMod</h2></a>
<P><P><P>
<code>CentralExtensionXMod( <var>f</var> )</code>
<P>
This  construction returns the crossed module  whose boundary <I>f</I> is a
surjection from <I>S</I>  to <I>R</I> having as kernel  a subgroup of the centre
of <I>S</I>.  The action maps an element of <I>r &isin; R</I> to conjugation of <I>S</I>
by <I>f<sup>-1</sup>r</I>.
<P>
<pre>    gap> d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );; d8.name := "d8";;
    gap> gend8 := d8.generators;; genk4 := k4.generators;;
    gap> f := GroupHomomorphismByImages( d8, k4, gend8, genk4 );;
    gap> EX := CentralExtensionXMod( f );
    Crossed module [d8->v4] 
    gap> XModPrint( EX );
    Crossed module [d8->v4] :-
    : Source group d8 has parent s4 and generators:
      [ (1,2,3,4), (1,3) ]
    : Range group k4 has parent s4 and generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Boundary homomorphism maps source generators to:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2)(3,4) --> { source gens --> [ (1,2,3,4), (2,4) ] }
      (1,3)(2,4) --> { source gens --> [ (1,4,3,2), (1,3) ] }
    These 2 automorphisms generate the group of automorphisms.   </pre>
<P><A NAME="SECT009"><h2>80.9 AutomorphismXMod</h2></a>
<P><P><P>
<code>AutomorphismXMod( <var>S [, A]</var> )</code>
<P>
This construction  returns the  crossed module  whose  range <I>R</I> is  a
permutation  representation  of a  group   <I>A</I> which  is  a  group  of
automorphisms of  the    source <I>S</I> and    which  contains the   inner
automorphism group  of <I>S</I> as a subgroup.   When <I>A</I> is  not specified
the full automorphism group is  used.   The boundary morphism maps  <I>s
&isin; S</I> to the representation of the  inner automorphism of <I>S</I> by <I>s</I>.
The action is the isomorphism <I>R &rarr; A</I>.
<P>
In  the following example, recall  that the automorphism  group of the
quaternion group is isomorphic to the symmetric  group of degree 4 and
that  the inner automorphism group  is isomorphic  to <code>k4</code>.  The group
<code>A</code> is a subgroup of <code>Aut(q8)</code> isomorphic to <code>d8</code>.
<P>
<pre>    gap> q8 := Group( (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) );;
    gap> q8.name := "q8";; genq8 := q8.generators;;
    gap> iaq8 := InnerAutomorphismGroup( q8 );;
    gap> a := GroupHomomorphismByImages( q8, q8, genq8,
    >             [(1,5,3,7)(2,6,4,8),(1,4,3,2)(5,6,7,8)]);;
    gap> genA := Concatenation( iaq8.generators, [a] );
    [ InnerAutomorphism( q8, (1,2,3,4)(5,8,7,6) ), 
      InnerAutomorphism( q8, (1,5,3,7)(2,6,4,8) ), 
      GroupHomomorphismByImages( q8, q8, [ (1,2,3,4)(5,8,7,6),
       (1,5,3,7)(2,6,4,8) ], [ (1,5,3,7)(2,6,4,8), (1,4,3,2)(5,6,7,8) ] ) ]
    gap> id := IdentityMapping( q8 );;
    gap> A := Group( genA, id );;
    gap> AX := AutomorphismXMod( q8, A );
    Crossed module [q8->PermSubAut(q8)] 
    gap> RecFields( AX );
    [ "isDomain", "isParent", "source", "range", "boundary", "action",
      "aut", "isXMod", "operations", "name", "isAutomorphismXMod" ]       </pre>
<P><A NAME="SECT010"><h2>80.10 InnerAutomorphismXMod</h2></a>
<P><P>
<A name = "I3"></a>

<P>
<code>InnerAutomorphismXMod( <var>S</var> )</code>
<P>
This function  is  equivalent to  <code>AutomorphismXMod(S,A)</code>  in the case
when <code>A</code> is the inner automorphism group of <code>S</code>.
<P>
<pre>    gap> IX := InnerAutomorphismXMod( q8 );
    Crossed module [q8->PermInn(q8)]   </pre>
<P><A NAME="SECT011"><h2>80.11 TrivialActionXMod</h2></a>
<P><P><P>
<code>TrivialActionXMod( <var>f</var> )</code>
<P>
For a crossed  module to have trivial  action, the axioms require  the
source  to be  abelian and  the image of   the boundary to  lie in the
centre of the range.  A  homomorphism <code>f</code> can act  as the boundary map
when these conditions are satisfied.
<P>
<pre>    gap> imf := [ (1,3)(2,4), (1,3)(2,4) ];;
    gap> f := GroupHomomorphismByImages( k4, d8, genk4, imf );;
    gap> TX := TrivialActionXMod( f );
    Crossed module [v4->d8]
    gap> XModPrint( TX );

    Crossed module [v4->d8] :- 
    : Source group has parent ( s4 ) and has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Range group has parent ( s4 ) and has generators:
      [ (1,2,3,4), (1,3) ]
    : Boundary homomorphism maps source generators to:
      [ (1,3)(2,4), (1,3)(2,4) ]
      The automorphism group is trivial   </pre>
<P><A NAME="SECT012"><h2>80.12 IsRModule for groups</h2></a>
<P><P>
<A name = "I4"></a>

<P>
<code>IsRModule( <var>Rmod</var> )</code>
<P>
<code>IsRModuleRecord( <var>Rmod</var> )</code>
<P>
An <I>R</I>-module consists of   a  permutation group  <I>R</I> with  an  action
<I>&alpha; : R  &rarr;  A</I> where <I>A</I>  is  a group  of automorphisms  of  an
abelian    group  <I>M</I>.   When <code>R</code>   is    not specified,  the function
<code>AutomorphismPair</code> is automatically called to construct it.
<P>
<DL><DT>This structure is implemented here as a record <code>Rmod</code> with fields:<DD>
</DL><P>
beg-tabular<s></s>ll
<code>Rmod.module</code>,     & the abelian group <I>M</I>,   <BR> 
<code>Rmod.perm</code>,       & the group <I>R</I>,           <BR> 
<code>Rmod.auto</code>,       & the action group <I>A</I>,    <BR> 
<code>Rmod.isRModule</code>,  & set true.
end-tabular<s></s>
<P>
The <code>IsRModule</code> distributor calls  this function when the parameter is
a record but not a crossed module.
<P>
<pre>    gap> k4gen := k4.generators;;
    gap> k4im := [ (1,3)(2,4), (1,4)(2,3) ];;
    gap> a := GroupHomomorphismByImages( k4, k4, k4gen, k4im );;
    gap> Ak4 := Group( a );;
    gap> R := rec( );;
    gap> R.module := k4;;
    gap> R.auto := Ak4;;
    gap> IsRModule( R );
    true
    gap> RecFields( R );
    [ "module", "auto", "perm", "isRModule" ]
    gap> R.perm;
    PermSubAut(v4)   </pre>
<P><A NAME="SECT013"><h2>80.13 RModuleXMod</h2></a>
<P><P><P>
<code>RModuleXMod( <var>Rmod</var> )</code>
<P>
The crossed module  <code>RX</code> obtained from an  <I>R</I>-module  has the abelian
group <I>M</I> as  source, the zero  map  as boundary, the group  <I>R</I> which
acts on <I>M</I> as  range,   the group  <I>A</I>  of  automorphisms of  <I>M</I>  as
<code>RX.aut</code> and <I>&alpha; : R &rarr; A</I>  as <code>RX.action</code>.  An appropriate name
for <code>RX</code>  is chosen automatically.    Continuing the previous example,
<I>M</I> is <code>k4</code> and <I>R</I> is cyclic of order <I>3</I>.
<P>
<pre>    gap> RX := RModuleXMod( R );
    Crossed module [v4->PermSubAut(v4)]
    gap> XModPrint( RX );

    Crossed module [v4->PermSubAut(v4)]
    : Source group has parent s4 and has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Range group = PermSubAut(v4) has generators:
      [ (1,2,3) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3) --> { source gens --> [ (1,3)(2,4), (1,4)(2,3) ] }
      This automorphism generates the group of automorphisms.    </pre>
<P><A NAME="SECT014"><h2>80.14 XModSelect</h2></a>
<P><P>
<A name = "I5"></a>

<P>
<code>XModSelect( <var>size</var> [, <var>gpnum</var>, <var>type</var>, <var>norm</var>] )</code>
<P>
Here the parameter <var>size</var> may take any value  up to 47, <var>gpnum</var> refers
to the isomorphism class of  groups of order <var>size</var>  as ordered in the
<strong>GAP3</strong> <I> </I>   library.  The <var>norm</var>  parameter  is only  used in the case
<code>"conj"</code> and specifies the position of the source group in the list of
normal subgroups  of the range <I>R</I>.   The  list <code>Cat1List</code>  is used to
store the data for these  groups.  The allowable <var>types</var> are  <code>"conj"</code>
for  normal  inclusions with  conjugation,   <code>"aut"</code>  for automorphism
groups  and <code>"rmod"</code> for <I>R</I>modules.   If <var>type</var>  is not specified the
default  is  <code>"conj"</code>.  If   <var>norm</var>     is not specified,  then    the
<code>AutomorphismXMod</code> of <I>R</I> is returned.
<P>
In the following example the fourteenth class of  groups of size 24 is
a  special linear  group <code>sl(2,3)</code>  and a  double cover  of <code>a4</code>.  The
third normal  subgroup   of <code>sl(2,3)</code> is a    quaternion group, and  a
conjugation crossed module is returned.
<P>
<pre>    gap> SX := XModSelect( 24, 14, "conj", 3 );
    Crossed module [N3->sl(2,3)] 
    gap> XModPrint( SX );

    Crossed module [N3->sl(2,3)] :- 
    : Source group has parent ( sl(2,3) )  and has generators:
      [ (1,2,3,4)(5,8,7,6), ( 1, 5, 3, 7)( 2, 6, 4, 8) ]
    : Range group = sl(2,3)  has generators:
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8), (2,5,6)(4,7,8)(9,10,11) ]
    : Boundary homomorphism maps source generators to:
      [ (1,2,3,4)(5,8,7,6), ( 1, 5, 3, 7)( 2, 6, 4, 8) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3,4)(5,8,7,6) --> { source gens --> 
    [ (1,2,3,4)(5,8,7,6), ( 1, 7, 3, 5)( 2, 8, 4, 6) ] }
      (1,5,3,7)(2,6,4,8) --> { source gens -->  
    [ (1,4,3,2)(5,6,7,8), ( 1, 5, 3, 7)( 2, 6, 4, 8) ] }
      ( 2, 5, 6)( 4, 7, 8)( 9,10,11) --> { source gens --> 
    [ ( 1, 5, 3, 7)( 2, 6, 4, 8), ( 1, 6, 3, 8)( 2, 7, 4, 5) ] }
      These 3 automorphisms generate the group of automorphisms. </pre>
<P><A NAME="SECT015"><h2>80.15 Operations for crossed modules</h2></a>
<P><P><P>
Special  operations  defined for crossed    modules are stored  in the
record   structure    <code>XModOps</code>.  Every    crossed   module  <code>X</code>   has
<code>X.operations := XModOps;</code>.
<P>
<pre>    gap> RecFields( XModOps );
    [ "name", "operations", "Elements", "IsFinite", "Size", "=", "&lt;", 
      "in", "IsSubset", "Intersection", "Union", "IsParent", "Parent", 
      "Difference", "Representative", "Random", "Print", "Kernel", 
      "IsAspherical", "IsSimplyConnected", "IsConjugation", 
      "IsTrivialAction", "IsCentralExtension", "DirectProduct", 
      "IsAutomorphismXMod", "IsZeroBoundary", "IsRModule",
      "InclusionMorphism", "WhiteheadPermGroup", "Whitehead", "Norrie",
      "Lue", "Actor", "InnerMorphism", "Centre", "InnerActor",
       "AutomorphismPermGroup", "IdentityMorphism", "InnerAutomorphism", ] </pre>
<P>
Crossed  modules <code>X,Y</code>  are  considered equal if   they have  the same
source, boundary,  range, and  action.   The remaining  functions  are
discussed below and following section <a href="chap080.htm#SECT113">About actors</a>.
<P><A NAME="SECT016"><h2>80.16 Print for crossed modules</h2></a>
<P><P>
<A name = "I6"></a>

<P>
<code>XModOps.Print( <var>X</var> )</code>
<P>
This  function  is  the  special print  command  for crossed modules,
producing a single line of output,  and is called automatically when a
crossed module is displayed.  For more detail use <code>XModPrint( X )</code>.
<P>
<pre>    gap> CX;
    Crossed module [v4->a4] </pre> 
<P><A NAME="SECT017"><h2>80.17 Size for crossed modules</h2></a>
<P><P>
<A name = "I7"></a>

<P>
<code>XModOps.Size( <var>X</var> )</code>
<P>
This function  returns  a 2-element  list containing  the sizes of the
source and the range of <code>X</code>.
<P>
<pre>    gap> Size( CX );
    [ 4, 12 ] </pre> 
<P><A NAME="SECT018"><h2>80.18 Elements for crossed modules</h2></a>
<P><P>
<A name = "I8"></a>

<P>
<code>XModOps.Elements( <var>X</var> )</code>
<P>
This function returns  a 2-element list of   lists of elements of  the
source and range of <code>X</code>.
<P>
<pre>    gap> Elements( CX );
    [ [ (), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ],
      [ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2),
        (1,3,4), (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ] ]   </pre> 
<P><A NAME="SECT019"><h2>80.19 IsConjugation for crossed modules</h2></a>
<P><P>
<A name = "I9"></a>

<P>
<code>XModOps.IsConjugation( <var>X</var> )</code>
<P>
This  Boolean function checks that the  source is a normal subgroup of
the range and that the boundary is an inclusion.
<P>
<pre>    gap> IsConjugation( CX );
    true </pre>
<P><A NAME="SECT020"><h2>80.20 IsAspherical</h2></a>
<P><P>
<A name = "I10"></a>

<P>
<code>XModOps.IsAspherical( <var>X</var> )</code>
<P>
This Boolean function checks that the boundary map is monomorphic.
<P>
<pre>    gap> IsAspherical( CX );
    true </pre>
<P><A NAME="SECT021"><h2>80.21 IsSimplyConnected</h2></a>
<P><P>
<A name = "I11"></a>

<P>
<code>XModOps.IsSimplyConnected( <var>X</var> )</code>
<P>
This Boolean function checks that the boundary map is surjective.  The
corresponding groupoid then has a single connected component.
<P>
<pre>    gap> IsSimplyConnected( EX );
    true </pre>
<P><A NAME="SECT022"><h2>80.22 IsCentralExtension</h2></a>
<P><P>
<A name = "I12"></a>

<P>
<code>XModOps.IsCentralExtension( <var>X</var> )</code>
<P>
This  Boolean function checks  that the   boundary is surjective  with
kernel central in the source.
<P>
<pre>    gap> IsCentralExtension( EX );
    true </pre>
<P><A NAME="SECT023"><h2>80.23 IsAutomorphismXMod</h2></a>
<P><P>
<A name = "I13"></a>

<P>
<code>XModOps.IsAutomorphismXMod( <var>X</var> )</code>
<P>
This Boolean function checks that the range group is a subgroup of the
automorphism group of  the source group  containing the group of inner
automorphisms,  and that the boundary and  action homomorphisms are of
the correct form.
<P>
<pre>    gap> IsAutomorphismXMod( AX );
    true </pre>
<P><A NAME="SECT024"><h2>80.24 IsTrivialAction</h2></a>
<P><P>
<A name = "I14"></a>

<P>
<code>XModOps.IsTrivialAction( <var>X</var> )</code>
<P>
This Boolean function checks that the action is the zero map.
<P>
<pre>    gap> IsTrivialAction( TX );
    true </pre>
<P><A NAME="SECT025"><h2>80.25 IsZeroBoundary</h2></a>
<P><P>
<A name = "I15"></a>

<P>
<code>XModOps.IsZeroBoundary( <var>X</var> )</code>
<P>
This Boolean function checks that the boundary is the zero map.
<P>
<pre>    gap> IsZeroBoundary( EX );
    false </pre>
<P><A NAME="SECT026"><h2>80.26 IsRModule for crossed modules</h2></a>
<P><P>
<A name = "I16"></a>

<P>
<code>XModOps.IsRModule( <var>X</var> )</code>
<P>
This Boolean  function checks that  the boundary is  the zero  map and
that the source is abelain.
<P>
<pre>    gap> IsRModule( RX );
    true </pre>
<P><A NAME="SECT027"><h2>80.27 WhatTypeXMod</h2></a>
<P><P><P>
<code>WhatTypeXMod( <var>X</var> )</code>
<P>
This function checks whether the crossed module  <code>X</code> is one or more of
the six standard type listed above.
<P>
<pre>    gap> WhatTypeXMod( EX );
    [ " extn, " ]  </pre>
<P><A NAME="SECT028"><h2>80.28 DirectProduct for crossed modules</h2></a>
<P><P>
<A name = "I17"></a>

<P>
<code>XModOps.DirectProduct( <var>X,Y</var> )</code>
<P>
The direct  product of crossed  modules <code>X,Y</code> has  as source and range
the direct products  of the sources  and ranges  of <code>X</code>  and <code>Y</code>.  The
boundary map is the product  of the two  boundaries.  The range of <code>X</code>
acts   trivially on the source  of   <code>Y</code> and  conversely.  Because the
standard <code>DirectProduct</code> function  requires the  two parameters to  be
groups, the <code>XModOps.</code> prefix must be used (at least for <strong>GAP3</strong>3.4.3).
<P>
<pre>    gap> DX := XModOps.DirectProduct( CX, CX );
    Crossed module [v4xv4->a4xa4]
    gap> XModPrint( DX );

    Crossed module [v4xv4->a4xa4] :- 
    : Source group v4xv4 has generators:
      [ (1,2)(3,4), (1,3)(2,4), (5,6)(7,8), (5,7)(6,8) ]
    : Range group = a4xa4 has generators:
      [ (1,2,3), (2,3,4), (5,6,7), (6,7,8) ]
    : Boundary homomorphism maps source generators to:
      [ (1,2)(3,4), (1,3)(2,4), (5,6)(7,8), (5,7)(6,8) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3) --> { source gens -->
          [ (1,4)(2,3), (1,2)(3,4), (5,6)(7,8), (5,7)(6,8) ] }
      (2,3,4) --> { source gens -->
          [ (1,3)(2,4), (1,4)(2,3), (5,6)(7,8), (5,7)(6,8) ] }
      (5,6,7) --> { source gens -->
          [ (1,2)(3,4), (1,3)(2,4), (5,8)(6,7), (5,6)(7,8) ] }
      (6,7,8) --> { source gens -->
          [ (1,2)(3,4), (1,3)(2,4), (5,7)(6,8), (5,8)(6,7) ] }
      These 4 automorphisms generate the group of automorphisms. </pre>
<P><A NAME="SECT029"><h2>80.29 XModMorphism</h2></a>
<P><P>
<A name = "I18"></a>

<P>
<code>XModMorphism( <var>X, Y, homs</var> )</code>
<P>
A morphism of crossed modules is a pair of homomorphisms <code>[ sourceHom,
rangeHom    ]</code>,   where   <code>sourceHom</code>,   <code>rangeHom</code> are   respectively
homomorphisms  between  the sources and ranges  of  <I>X</I> and <I>Y</I>, which
commute with the two boundary maps and which are morphisms for the two
actions.
<P>
In this implementation a morphism of crossed modules <code>mor</code> is a record
<DL><DT>with fields:<DD>
</DL><P>
beg-tabular<s></s>ll
<code>mor.source</code>,         & the source crossed module  <code>X</code>,                <BR> 
<code>mor.range</code>,          & the range crossed module  <code>Y</code>,                 <BR> 
<code>mor.sourceHom</code>,      & a homomorphism from <code>X.source</code> to <code>Y.source</code>,  <BR> 
<code>mor.rangeHom</code>,       & a homomorphism from <code>X.range</code> to <code>Y.range</code>,    <BR> 
<code>mor.isXModMorphism</code>, & a Boolean flag, normally <code>true</code>,               <BR> 
<code>mor.operations</code>,     & a special set of operations <code>XModMorphismOps</code>
              (see \refOperations for morphisms of crossed modules), <BR> 
<code>mor.name</code>,           & a concatenation of the names of <code>X</code> and <code>Y</code>.
end-tabular<s></s>
<P>
The function <code>XModMorphism</code> requires as parameters two crossed modules
and a two-element list containing the  source and range homomorphisms.
It  sets  up the  required  fields for <code>mor</code>,   but does not check the
axioms.  The <code>IsXModMorphism</code> function should be used to perform these
checks.  Note that the <code>XModMorphismPrint</code> function is needed to print
out the morphism in detail.
<P>
<pre>    gap> smor := GroupHomomorphismByImages( q8, k4, genq8, genk4 );
    GroupHomomorphismByImages( q8, v4, 
     [(1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8)], [(1,2)(3,4), (1,3)(2,4)] )
    gap> IsHomomorphism(smor);
    true
    gap> sl23 := SX.range;;
    gap> gensl23 := sl23.generators;
     [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8), (2,5,6)(4,7,8)(9,10,11) ]
    gap> images := [ (1,2)(3,4), (1,3)(2,4), (2,3,4) ];;
    gap> rmor := GroupHomomorphismByImages( sl23, a4, gensl23, images );;
    gap> IsHomomorphism(rmor);
    true
    gap> mor := XModMorphism( SX, CX, [ smor, rmor ] );
    Morphism of crossed modules &lt;[N3->sl(2,3)] >-> [v4->a4]> </pre>
<P><A NAME="SECT030"><h2>80.30 IsXModMorphism</h2></a>
<P><P>
<A name = "I19"></a>

<P>
<code>IsXModMorphism( <var>mor</var> )</code>
<P>
This Boolean function checks that <var>mor</var> includes homomorphisms between
the corresponding   source and range  crossed  modules, and that these
homomorphisms commute  with   the two  actions.    In the example   we
increase the value  of <code>XModPrintLevel</code> to  show the effect of such an
increase in a simple case.
<P>
<pre>    gap> XModPrintLevel := 3;;
    gap> IsXModMorphism( mor );
    Checking that the diagram commutes :- 
             Y.boundary(morsrc(x)) = morrng(X.boundary(x)) 
    Checking:  morsrc(x2^x1) = morsrc(x2)^(morrng(x1))
    true
    gap> XModPrintLevel := 1;;   </pre>
<P><A NAME="SECT031"><h2>80.31 XModMorphismPrint</h2></a>
<P><P>
<A name = "I20"></a>

<P>
<code>XModMorphismPrint( <var>mor</var> )</code>
<P>
This function is used to display the main fields of a crossed module.
<P>
<pre>    gap> XModMorphismPrint( mor );
    Morphism of crossed modules :-
    : Source = Crossed module [N3->sl(2,3)] with generating sets
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8), (2,5,6)(4,7,8)(9,10,11) ]
    :  Range = Crossed module [v4->a4] with generating sets
      [ (1,2)(3,4), (1,3)(2,4) ]]
      [ (1,2,3), (2,3,4) ]
    : Source Homomorphism maps source generators to:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Range Homomorphism maps range generators to:
      [ (1,2)(3,4), (1,3)(2,4), (2,3,4) ]
    : isXModMorphism? true  </pre>
<P><A NAME="SECT032"><h2>80.32 XModMorphismName</h2></a>
<P><P>
<A name = "I21"></a>

<P>
<code>XModMorphismName( <var>mor</var> )</code>
<P>
Whenever the names of the source  or range crossed module are changed,
this    function may  be  used to    produce the    new standard  form
<code>&lt;mor.source.name >-> mor.range.name></code> for the  <var>name</var> of <var>mor</var>.  This
function is automatically called by <code>XModMorphismPrint</code>.
<P>
<pre>    gap> k4.name := "k4";;  XModName( CX );;
    gap> XModMorphismName( mor );
    &lt;[N3->sl(2,3)] >-> [k4->a4]>  </pre>
<P><A NAME="SECT033"><h2>80.33 Operations for morphisms of crossed modules</h2></a>
<P><P>
<A name = "I22"></a>

<A name = "I23"></a>

<A name = "I24"></a>

<A name = "I25"></a>

<A name = "I26"></a>

<P>
Special operations defined for morphisms of crossed modules are stored
in  the    record structure  <code>XModMorphismOps</code>     which is  based  on
<code>MappingOps</code>.   Every  crossed    module  morphism  <code>mor</code>   has  field
<code>mor.operations</code> set equal to <code>XModMorphismOps;</code>.
<P>
<pre>    gap> IsMonomorphism( mor );
    false
    gap> IsEpimorphism( mor );
    true
    gap> IsIsomorphism( mor );
    false
    gap> IsEndomorphism( mor );
    false
    gap> IsAutomorphism( mor );
    false   </pre>
<P><A NAME="SECT034"><h2>80.34 IdentitySubXMod</h2></a>
<P><P><P>
<code>IdentitySubXMod( <var>X</var> )</code>
<P>
Every  crossed  module <code>X</code> has  an  identity sub-crossed  module whose
source and range are the identity subgroups of the source and range.
<P>
<pre>    gap> IdentitySubXMod( CX );
    Crossed module [Id[k4->a4]]  </pre>
<P><A NAME="SECT035"><h2>80.35 SubXMod</h2></a>
<P><P><P>
<code>SubXMod( <var>X, subS, subR</var> )</code>
<P>
A sub-crossed module of a crossed module <code>X</code> has  as source a subgroup
<code>subS</code> of <code>X.source</code> and as range a subgroup <code>subR</code> of <code>X.range</code>.  The
boundary map and the action are  the appropriate restrictions.  In the
following example we construct a sub-crossed module of <code>SX</code> with range
<code>q8</code> and source a cyclic group of order 4.
<P>
<pre>    gap> q8 := SX.source;; genq8 := q8.generators;;
    gap> q8.name := "q8";; XModName( SX );;
    gap> c4 := Subgroup( q8, [ genq8[1] ] );
    Subgroup( sl(2,3), [ (1,2,3,4)(5,8,7,6) ] )
    gap> c4.name := "c4";;
    gap> subSX := SubXMod( SX, c4, q8 );
    Crossed module [c4->q8] 
    gap> XModPrint( subSX );
    Crossed module [c4->q8] :- 
    : Source group has parent ( sl(2,3) ) and has generators:
      [ (1,2,3,4)(5,8,7,6) ]
    : Range group has parent ( sl(2,3) ) and has generators:
      [ (1,2,3,4)(5,8,7,6), ( 1, 5, 3, 7)( 2, 6, 4, 8) ]
    : Boundary homomorphism maps source generators to:
      [ ( 1, 2, 3, 4)( 5, 8, 7, 6) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3,4)(5,8,7,6) --> {source gens --> [ (1,2,3,4)(5,8,7,6) ]}
      (1,5,3,7)(2,6,4,8) --> {source gens --> [ (1,4,3,2)(5,6,7,8) ]}
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT036"><h2>80.36 IsSubXMod</h2></a>
<P><P>
<A name = "I27"></a>

<P>
<code>IsSubXMod( <var>X,S</var> )</code>
<P>
This boolean function checks that <code>S</code> is a sub-crossed module of <code>X</code>.
<P>
<pre>    gap> IsSubXMod( SX, subSX );
    true  </pre>
<P><A NAME="SECT037"><h2>80.37 InclusionMorphism for crossed modules</h2></a>
<P><P>
<A name = "I28"></a>

<P>
<code>InclusionMorphism( <var>S,X</var> )</code>
<P>
This function constructs the inclusion of a  sub-crossed module <code>S</code> of
<code>X</code>.  When <code>S = X</code> the identity morphism is returned.
<P>
<pre>    gap> inc := InclusionMorphism( subSX, SX );
    Morphism of crossed modules &lt;[c4->q8] >-> [q8->sl(2,3)]>
    gap> IsXModMorphism( inc );
    true
    gap> XModMorphismPrint( inc );
    Morphism of crossed modules :- 
    : Source = Crossed module [c4->q8] with generating sets:
      [ (1,2,3,4)(5,8,7,6) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
    :  Range = Crossed module [q8->sl(2,3)] with generating sets:
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8), (2,5,6)(4,7,80(9,10,11) ]
    : Source Homomorphism maps source generators to:
      [ (1,2,3,4)(5,8,7,6) ]
    : Range Homomorphism maps range generators to:
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ] 
    :  isXModMorphism? true                            </pre>
<P><A NAME="SECT038"><h2>80.38 IsNormalSubXMod</h2></a>
<P><P>
<A name = "I29"></a>

<P>
<code>IsNormalSubXMod( <var>X,Y</var> )</code>
<P>
A sub-crossed module <code>Y=(N->M)</code> is normal in <code>X=(S->R)</code> when

<P>&bull; <I>N,M</I> are normal subgroups of <I>S,R</I> respectively,
<P>&bull; <I>n<sup>r</sup> &isin; N</I> for all <I>n &isin; N,   r &isin; R</I>,
<P>&bull; <I>s<sup>-1</sup> s<sup>m</sup> &isin; N</I> for all <I>m &isin; M,   s &isin; S</I>.

<P>
These axioms  are  sufficient to  ensure that <I>M   \semidirect N</I> is a
normal subgroup of  <I>R \semidirect S</I>.   
They also  ensure that the  inclusion morphism of a normal sub-crossed
module forms  a     conjugation  crossed square,  analogous   to   the
construction of a conjugation crossed module.
<P>
<pre>    gap> IsNormalSubXMod( SX, subSX );
    false  </pre>
<P><A NAME="SECT039"><h2>80.39 NormalSubXMods</h2></a>
<P><P><P>
<code>NormalSubXMods( <var>X</var> )</code>
<P>
This  function takes  pairs of normal   subgroups from the source  and
range of <code>X</code>  and constructs a normal  sub-crossed module whenever the
axioms are satisfied.  Appropriate names are chosen where possible.
<P>
<pre>    gap> NSX := NormalSubXMods( SX );
    [ Crossed module [Id[q8->sl(2,3)]], Crossed module [I->?], 
      Crossed module [Sub[q8->sl(2,3)]], Crossed module [?->q8], 
      Crossed module [?->q8], Crossed module [q8->sl(2,3)] ]    </pre>
<P><A NAME="SECT040"><h2>80.40 Factor crossed module</h2></a>
<P><P>
<A name = "I30"></a>

<P>
<code>FactorXMod( <var>X, subX</var> )</code>
<P>
The  quotient   crossed module  of  a   crossed   module  by a  normal
sub-crossed module  has quotient groups as  source and range, with the
obvious action.
<P>
<pre>    gap> Size( NSX[3] );
    [ 2, 2 ]
    gap> FX := FactorXMod( SX, NSX[3] );
    Crossed module [?->?]
    gap> Size( FX );
    [ 4, 12 ]  </pre>
<P><A NAME="SECT041"><h2>80.41 Kernel of a crossed module morphism</h2></a>
<P><P>
<A name = "I31"></a>

<P>
<code>Kernel( <var>mor</var> )</code>
<P>
The kernel of a morphism <code>mor</code> <I>: X &rarr;  Y</I> of crossed modules is the
normal  sub-crossed  module of  <I>X</I>  whose  source  is the   kernel of
<code>mor.sourceHom</code> and whose range  is the kernel  of <code>mor.rangeHom</code>.  An
appropriate  name for the  kernel  is  chosen automatically.  A  field
<code>.kernel</code> is added to <code>mor</code>.
<P>
<pre>    gap> XModMorphismName( mor );;
    gap> KX := Kernel( mor );
    Crossed module Ker&lt;[q8->sl(2,3)] >-> [k4->a4]>
    gap> XModPrint( KX );
    Crossed module Ker&lt;[q8->SL(2,3)] >-> [k4->a4]> :- 
    : Source group has parent ( sl(2,3) )  and has generators:
      [ (1,3)(2,4)(5,7)(6,8) ]
    : Range group has parent ( sl(2,3) )  and has generators:
      [ ( 1, 3)( 2, 4)( 5, 7)( 6, 8) ]
    : Boundary homomorphism maps source generators to:
      [ (1,3)(2,4)(5,7)(6,8) ]
    : The automorphism group is trivial.
    gap> IsNormalSubXMod( SX, KX );
    true   </pre>
<P><A NAME="SECT042"><h2>80.42 Image for a crossed module morphism</h2></a>
<P><P>
<A name = "I32"></a>

<P>
<code>ImageXModMorphism( <var>mor</var>, <var>S</var> )</code>
<P>
The  image of a sub-crossed module  <code>S</code> of <code>X</code>  under a morphism <code>mor</code>
<I>: X &rarr; Y</I> of crossed modules is the sub-crossed module of <I>Y</I> whose
source  is  the image  of  <code>S.source</code> under  <code>mor.sourceHom</code> and whose
range is the image of  <code>S.range</code> under <code>mor.rangeHom</code>.  An appropriate
name for the image is chosen automatically.  A field <code>.image</code> is added
to  <code>mor</code>.    Note      that    thjis function  should      be   named
<code>XModMorphismOps.Image</code>, but the command <code>J := Image(  mor, S );</code> does
not work with version 3 of <strong>GAP3</strong>.
<P>
<pre>    gap> subSX;
    Crossed module [c4->q8]
    gap> JX := ImageXModMorphism( mor, subSX );
    Crossed module [Im([c4->q8]) by &lt;[q8->sl(2,3)] >-> [k4->a4]>]
    gap> RecFields( mor );
    [ "sourceHom", "rangeHom", "source", "range", "name", "isXModMorphism",
       "domain", "kernel", "image", "isMonomorphism", "isEpimorphism",
       "isIsomorphism", "isEndomorphism", "isAutomorphism", "operations" ]
    gap> XModPrint( JX );
    
    Crossed module [Im([c4->q8]) by &lt;[q8->sl(2,3)] >-> [k4->a4]>] :-
    : Source group has parent ( s4 )  and has generators:
      [ (1,2)(3,4) ]
    : Range group has parent ( s4 )  and has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Boundary homomorphism maps source generators to:
      [ (1,2)(3,4) ]
    : The automorphism group is trivial.  </pre>
<P><A NAME="SECT043"><h2>80.43 InnerAutomorphism of a crossed module</h2></a>
<P><P>
<A name = "I33"></a>

<P>
<code>InnerAutomorphism( <var>X, r</var> )</code>
<P>
Each element <code>r</code> of  <code>X.range</code> determines an   automorphism of <code>X</code>  in
which the   automorphism of <code>X.source</code>   is  given  by the  image   of
<code>X.action</code> on <code>r</code> and the  automorphism of <code>X.range</code> is conjugation by
<code>r</code>.  The command  <code>InnerAutomorphism(  X, r );</code>  does not  work  with
version 3 of <strong>GAP3</strong>.
<P>
<pre>    gap> g := Elements( q8 )[8];
    (1,8,3,6)(2,5,4,7)
    gap> psi := XModOps.InnerAutomorphism( subSX, g );
    Morphism of crossed modules &lt;[c4->q8] >-> [c4->q8]>
    gap> XModMorphismPrint( psi );
    Morphism of crossed modules :- 
    : Source = Crossed module [c4->q8] with generating sets:
      [ (1,2,3,4)(5,8,7,6) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
    :  Range = Crossed module [c4->q8] with generating sets:
      [ (1,2,3,4)(5,8,7,6) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ] 
    : Source Homomorphism maps source generators to:
      [ ( 1,4,3,2)(5,6,7,8) ]
    : Range Homomorphism maps range generators to:
      [ ( 1,4,3,2)(5,6,7,8), (1,7,3,5)(2,8,4,6) ]
      isXModMorphism? true   </pre>
<P><A NAME="SECT044"><h2>80.44 Order of a crossed module morphism</h2></a>
<P><P>
<A name = "I34"></a>

<P>
<code>XModMorphismOps.Order( <var>mor</var> )</code>
<P>
This function calculates the order of an automorphism of a crossed module.
<P>
<pre>    gap> XModMorphismOps.Order( psi );
    2   </pre>
<P><A NAME="SECT045"><h2>80.45 CompositeMorphism for crossed modules</h2></a>
<P><P>
<A name = "I35"></a>

<P>
<code>CompositeMorphism( <var>mor1, mor2</var> )</code>
<P>
Morphisms <I>&mu;<sub>1</sub> : X &rarr; Y</I>  and <I>&mu;<sub>2</sub> :  Y &rarr; Z</I> have a composite
<I>&mu;   =  &mu;<sub>2</sub> o  &mu;<sub>1</sub>    : X &rarr;   Z</I> whose   source and range
homomorphisms are the composites of those of <I>&mu;<sub>1</sub></I> and <I>&mu;<sub>2</sub></I>.
<P>
In the following example we compose <code>psi</code> with the <code>inc</code> obtained previously.
<P>
<pre>    gap> xcomp := XModMorphismOps.CompositeMorphism( psi, inc );
    Morphism of crossed modules &lt;[c4->q8] >-> [q8->sl(2,3)]> 
    gap> XModMorphismPrint( xcomp );
    Morphism of crossed modules :- 
    : Source = Crossed module [c4->q8] with generating sets:
      [ (1,2,3,4)(5,8,7,6) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
    : Range = Crossed module [q8->sl(2,3)] with generating sets:
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) ]
      [ (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8), (2,5,6)(4,7,8)(9,10,11) ]
    : Source Homomorphism maps source generators to:
      [ (1,4,3,2)(5,6,7,8) ]
    : Range Homomorphism maps range generators to:
      [ (1,4,3,2)(5,6,7,8), (1,7,3,5)(2,8,4,6) ]
    : isXModMorphism? true    </pre>
<P><A NAME="SECT046"><h2>80.46 SourceXModXPModMorphism</h2></a>
<P><P><P>
<code>SourceXModXPModMorphism( <var>mor</var> )</code>
<P>
When  crossed modules <var>X,Y</var>  have a  common range <var>P</var>  and  <code>mor</code> is a
morphism from  <var>X</var> to <var>Y</var>  whose  range  homomorphism is the  identity
homomorphism,  then  <code>mor.sourceHom  :  X.source ->  Y.source)</code>   is a
crossed module.
<P>
<pre>    gap> c2 := Subgroup( q8, [ genq8[1]^2 ] );
    Subgroup( sl(2,3), [ (1,3)(2,4)(5,7)(6,8) ] )
    gap> c2.name := "c2";;
    gap> sub2 := SubXMod( subSX, c2, q8 );
    Crossed module [c2->q8]
    gap>inc2 := InclusionMorphism( sub2, subSX );
    Morphism of crossed modules &lt;[c2->q8] >-> [c4->q8]>
    gap> PX := SourceXModXPModMorphism( inc2 );
    Crossed module [c2->c4]
    gap> IsConjugation( PX );
    true   </pre>
<P>
\newpage
<P><A NAME="SECT047"><h2>80.47 About cat1-groups</h2></a>
<P><P><P>
In <A href="biblio.htm#xmodL1"><cite>xmodL1</cite></a> Loday  reformulated the notion of  a crossed module as  a
cat1-group, namely a group <I>G</I> with a pair of homomorphisms <I>t,h
: G &rarr; G</I> having a  common image <I>R</I>  and satisfying certain axioms.
We find it convenient to  define a cat1-group  <I><span style="font-family: cursive"> C</span> = (e;t,h : G
&rarr; R  )</I> as  having  source  group <I>G</I>,  range group  <I>R</I>,  and three
homomorphisms:  two surjections <I>t,h : G &rarr; R</I> and an embedding <I>e
: R &rarr; G</I> satisfying:
<center>
\begintabularr l
\textbfCat 1:  &  <I>te = he = \mathrmid<sub>R</sub> </I>, <BR> 
\textbfCat 2:  &  <I>[</I>ker<I> t, </I>ker<I> h] = { 1<sub>G</sub> }</I>.
\endtabular
</center>
It follows that  <I>teh = h,   het = t,   tet = t,   heh = h</I>.
<P>
The maps <I>t,h</I> are often   referred to as  the  <em> source</em> and  <em>
target</em>, but we choose to  call them the <em>  tail</em> and <em> head</em> of
<I><span style="font-family: cursive"> C</span></I>, because <em> source</em> is the <strong>GAP3</strong>  term for the domain of
a function.
<P><P>
A  morphism  <I><span style="font-family: cursive">  C</span><sub>1</sub> &rarr; <span style="font-family: cursive">  C</span><sub>2</sub></I>  of  cat1-groups is  a pair
<I>(&gamma;, &rho;)</I>  where <I>&gamma; : G<sub>1</sub> &rarr;  G<sub>2</sub></I> and  <I>&rho; : R<sub>1</sub> &rarr;
R<sub>2</sub></I> are homomorphisms satisfying  <center><table><tr><td><I> h<sub>2</sub> &gamma;  = &rho; h<sub>1</sub>,    t<sub>2</sub>
&gamma;   =   &rho;   t<sub>1</sub>,     e<sub>2</sub>    &rho;  =   &gamma;  e<sub>1</sub>,  </I></td></tr></table></center>  (see
\refCat1Morphism and subsequent sections).
<P>
In this  implementation a cat1-group <I> <span style="font-family: cursive">  C</span></I> is a record with the
following fields:
<P>
beg-tabular<s></s>ll
<code>C.source</code>,     & the source <code>G</code>,                                      <BR> 
<code>C.range</code>,      & the range <code>R</code>,                                       <BR> 
<code>C.tail</code>,       & the tail homomorphism <code>t</code>,                           <BR> 
<code>C.head</code>,       & the head homomorphism <code>h</code>,                           <BR> 
<code>C.embedRange</code>, & the embedding of <code>R</code> in <code>G</code>,                         <BR> 
<code>C.kernel</code>,     & a permutation group isomorphic to the kernel of <code>t</code>, <BR> 
<code>C.embedKernel</code>,& the inclusion of the kernel in <code>G</code>,                <BR> 
<code>C.boundary</code>,   & the restriction of <code>h</code> to the kernel,                <BR> 
<code>C.isDomain</code>,   & set <code>true</code>,                                          <BR> 
<code>C.operations</code>, & a special set of operations <code>Cat1Ops</code>
                  (see \refOperations for cat1-groups, <BR> 
<code>C.name</code>,       & a concatenation of the names of the source and range.<BR> 
<code>C.isCat1</code> & a boolean flag, normally <code>true</code>.
end-tabular<s></s>
<P>
The following listing shows a simple example:
<P>
<pre>    gap> s3c4gen := s3c4.generators;
    [ (1,2), (2,3), (4,5,6,7) ]
    gap> t1 := GroupHomomorphismByImages( s3c4, s3, s3c4gen,
    >     [ (1,2), (2,3), () ] );;
    gap> C1 := Cat1( s3c4, t1, t1 );
    cat1-group [s3c4 ==> s3] 
    gap> Cat1Print( C1 );
    cat1-group [s3c4 ==> s3] :- 
    : source group has generators:
      [ (1,2), (2,3), (4,5,6,7) ]
    :  range group has generators:
      [ (1,2), (2,3) ]
    : tail homomorphism maps source generators to:
      [ ( 1, 2), ( 2, 3), () ]
    : head homomorphism maps source generators to:
      [ ( 1, 2), ( 2, 3), () ]
    : range embedding maps range generators to:
      [ (1,2), (2,3) ]
    : kernel has generators:
      [ (4,5,6,7) ]
    : boundary homomorphism maps generators of kernel to:
      [ () ]
    : kernel embedding maps generators of kernel to:
      [ (4,5,6,7) ]  </pre>
<P>
The  category of  crossed modules is   equivalent to  the  category of
cat1-groups, and  the  functors between these  two categories   may be
described as follows.
<P>
Starting  with the crossed  module <I><span style="font-family: cursive"> X</span>  = (&part; : S &rarr; R)</I>
the  group   <I> G </I>   is  defined as  the semidirect  product  <I>  G = R
\semidirect  S</I>  using the  action  from  <I><span style="font-family: cursive">  X</span></I>.  The structural
morphisms are given by <center><table><tr><td><I> t(r,s)  = r,   h(r,s) =  r (&part; s),  
er = (r,1).  </I></td></tr></table></center>
<P>
On the other hand, starting with a cat1-group <I> <span style="font-family: cursive"> C</span> = (e;t,h : G
&rarr; R)</I> we define <I> S = </I>ker<I> t</I>, the range <I>R</I> remains unchanged and <I>
&part; = h|<sub>S</sub> </I>.  The action of <I>R</I> on  <I>S</I> is conjugation in <I>S</I>
via the embedding of <I>R</I> in <I>G</I>.
<P>
<pre>    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> CX1 := Cat1XMod(X1);
    cat1-group [Perm(PermAut(c5) |X c5) ==> PermAut(c5)] 
    gap> CX1.source.generators;
    [ (2,3,5,4), (1,2,3,4,5) ]
    gap>
    gap> XC1 := XModCat1( C1 );
    Crossed module [ker([s3c4 ==> s3])->s3]
    gap> WhatTypeXMod( XC1 );
    [ " triv, ", " zero, ", " RMod, " ]  </pre>
<P><A NAME="SECT048"><h2>80.48 Cat1</h2></a>
<P><P><P>
<code>Cat1( <var>G, t, h</var> )</code>
<P>
This function constructs a cat1-group <I><span style="font-family: cursive"> C</span></I>  from a group <I>G</I> and
a pair of endomorphisms, the tail and head of <I><span style="font-family: cursive"> C</span></I>.  The example
uses the holomorph of  <code>c5</code>, a group of  size 20, which was the source
group in <code>XC1</code> in \refAbout cat1-groups.  Note that when <I>t = h</I> the
boundary is the zero map.
<P>
<pre>    gap> h20 := Group( (1,2,3,4,5), (2,3,5,4) );;
    gap> h20.name := "h20";;
    gap> genh20 := h20.generators;;
    gap> imh20 := [ (), (2,3,5,4) ];;
    gap> h := GroupHomomorphismByImages( h20, h20, genh20, imh20 );;
    gap> t := h;;
    gap> C := Cat1( h20, t, h );
    cat1-group [h20 ==> R]    </pre>
<P><A NAME="SECT049"><h2>80.49 IsCat1</h2></a>
<P><P>
<A name = "I36"></a>

<P>
<code>IsCat1( <var>C</var> )</code>
<P>
This function checks that the axioms of a cat1-group are satisfied and
that the main fields of a cat1-group record exist.
<P>
<pre>    gap> IsCat1(C);
    true  </pre>
<P><A NAME="SECT050"><h2>80.50 Cat1Print</h2></a>
<P><P>
<A name = "I37"></a>

<P>
<code>Cat1Print( <var>C</var> ) </code>
<P>
This function is used to display the main fields of a cat1-group.
<P>
<pre>    gap> Cat1Print(C);

    cat1-group [h20 ==> R] :- 
    : source group has generators:
      [ (1,2,3,4,5), (2,3,5,4) ]
    : range group has generators:
      [ ( 2, 3, 5, 4) ]
    : tail homomorphism maps source generators to:
      [ (), ( 2, 3, 5, 4) ]
    : head homomorphism maps source generators to:
      [ (), ( 2, 3, 5, 4) ]
    : range embedding maps range generators to:
      [ ( 2, 3, 5, 4) ]
    : kernel has generators:
      [ (1,2,3,4,5) ]
    : boundary homomorphism maps generators of kernel to:
      [ () ]
    : kernel embedding maps generators of kernel to:
      [ ( 1, 2, 3, 4, 5) ]   </pre>
<P><A NAME="SECT051"><h2>80.51 Cat1Name</h2></a>
<P><P>
<A name = "I38"></a>

<P>
<code>Cat1Name( <var>C</var> )</code>   
<P>
Whenever the names of the source or the range of <code>C</code> are changed, this
function    may    be  used    to  produce    the    new standard form
<code>[&lt;C.source.name>   ==> &lt;C.range.name>]</code> for  the   name of <code>C</code>.  This
function is called automatically by <code>Cat1Print</code>.  Note the use of <code>=</code>,
rather than <code>-</code> in the arrow shaft, to indicate the pair of maps.
<P>
<pre>    gap> C.range.name := "c4";; Cat1Name( C ); 
    "[h20 ==> c4]"  </pre> 
<P>
\newpage
<P><A NAME="SECT052"><h2>80.52 ConjugationCat1</h2></a>
<P><P><P>
<code>ConjugationCat1( <var>R, S</var> )</code>
<P>
When  <I>S</I>  is a normal subgroup  of  a group  <I>R</I> form the semi-direct
product <I>G = R \semidirect S</I> to <I>R</I> and take this as the source, with
<I>R</I> as  the range.   The tail and  head homomorphisms  are  defined by
<I>t(r,s) = r(&part; s),   h(r,s) = r</I>.  In  the example <code>h20</code> is the
range, rather than the source.
<P>
<pre>    gap> c5 := Subgroup( h20, [(1,2,3,4,5)] );;
    gap> c5.name := "c5";;
    gap> CC := ConjugationCat1( h20, c5 );
    cat1-group [Perm(h20 |X c5) ==> h20] 
    gap> Cat1Print( CC );

    cat1-group [Perm(h20 |X c5) ==> h20] :- 
    : source group has generators:
      [ ( 6, 7, 8, 9,10), ( 2, 3, 5, 4)( 7, 8,10, 9), (1,2,3,4,5) ]
    :  range group has generators:
      [ (1,2,3,4,5), (2,3,5,4) ]
    : tail homomorphism maps source generators to:
      [ ( 1, 2, 3, 4, 5), ( 2, 3, 5, 4), () ]
    : head homomorphism maps source generators to:
      [ ( 1, 2, 3, 4, 5), ( 2, 3, 5, 4), ( 1, 2, 3, 4, 5) ]
    : range embedding maps range generators to:
      [ ( 6, 7, 8, 9,10), ( 2, 3, 5, 4)( 7, 8,10, 9) ]
    : kernel has generators:
      [ (1,2,3,4,5) ]
    : boundary homomorphism maps generators of kernel to:
      [ ( 1, 2, 3, 4, 5) ]
    : kernel embedding maps generators of kernel to:
      [ ( 1, 2, 3, 4, 5) ]
    : associated crossed module is Crossed module [c5->h20]

    gap> ct := CC.tail;;
    gap> ch := CC.head;;
    gap> CG := CC.source;;
    gap> genCG := CG.generators;;
    gap> x := genCG[2] * genCG[3];
    ( 1, 2, 4, 3 )( 7, 8,10, 9 )
    gap> tx := Image( ct, x );
    ( 2, 3, 5, 4)
    gap> hx := Image( ch, x );
    ( 1, 2, 4, 3)
    
    gap> RecFields( CC );
    [ "source", "range", "tail", "head", "embedRange", "kernel", 
      "boundary", "embedKernel", "isDomain", "operations", "isCat1",
      "name", "xmod" ]</pre>
<P><A NAME="SECT053"><h2>80.53 Operations for cat1-groups</h2></a>
<P><P><P>
Special   operations defined for   crossed  modules are stored  in the
record structure <code>Cat1Ops</code> based on <code>DomainOps</code>.  Every cat1-group <code>C</code>
has <code>C.operations := Cat1Ops;</code>.
<P>
<pre>    gap> RecFields( Cat1Ops );
    [ "name", "operations", "Elements", "IsFinite", "Size", "=", "&lt;", 
      "in", "IsSubset", "Intersection", "Union", "IsParent", "Parent", 
      "Difference", "Representative", "Random", "Print", "Actor",
      "InnerActor", "InclusionMorphism", "WhiteheadPermGroup" ]  </pre>
<P>
Cat1-groups are considered equal if  they have the same source, range,
tail,   head  and embedding.  The   remaining  functions are described
below.
<P><A NAME="SECT054"><h2>80.54 Size for cat1-groups</h2></a>
<P><P>
<A name = "I39"></a>

<P>
<code>Cat1Ops.Size( <var>C</var> )</code>
<P>
This function returns  a two-element list  containing the sizes of the
source and range of <code>C</code>.
<P>
<pre>    gap> Size( C );
     [ 20, 4 ] </pre> 
<P><A NAME="SECT055"><h2>80.55 Elements for cat1-groups</h2></a>
<P><P>
<A name = "I40"></a>

<P>
<code>Cat1Ops.Elements( <var>C</var> )</code>
<P>
This function returns the two-element list of lists of elements of the
source and range of <I>C</I>.
<P><P>
<pre>    gap> Elements( C );
    [ [ (), (2,3,5,4), (2,4,5,3), (2,5)(3,4), (1,2)(3,5), (1,2,3,4,5),
        (1,2,4,3), (1,2,5,4), (1,3,4,2), (1,3)(4,5), (1,3,5,2,4),
        (1,3,2,5), (1,4,5,2), (1,4,3,5), (1,4)(2,3), (1,4,2,5,3), 
        (1,5,4,3,2), (1,5,3,4), (1,5,2,3), (1,5)(2,4) ],
      [ (), (2,3,5,4), (2,4,5,3), (2,5)(3,4) ] ]  </pre>
<P><A NAME="SECT056"><h2>80.56 XModCat1</h2></a>
<P><P><P>
<code>XModCat1( <var>C</var> )</code>
<P>
This function acts as the functor  from the category of cat1-groups to
the category of crossed modules.
<P>
<pre>    gap> XC := XModCat1( C );
    Crossed module [ker([h20 ==> c4])->c4]
    gap> XModPrint( XC );

    Crossed module [ker([h20 ==> c4])->c4] :- 
    : Source group has parent ( h20 ) and has generators:
      [ (1,2,3,4,5) ]
    : Range group has parent ( h20 ) and has generators:
      [ ( 2, 3, 5, 4) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (2,3,5,4) --> { source gens --> [ (1,3,5,2,4) ] }
      This automorphism generates the group of automorphisms.
    : Associated cat1-group = cat1-group [h20 ==> c4]  </pre>
<P><A NAME="SECT057"><h2>80.57 Cat1XMod</h2></a>
<P><P><P>
<code>Cat1XMod( <var>X</var> )</code>
<P>
This function acts as the functor from the category of crossed modules
to the category of  cat1-groups.  A permutation representation of  the
semidirect product <I>R   \semidirect S</I> is constructed  for  <I>G</I>.   See
section \refSemidirectCat1XMod  for   a  version  where  <I>G</I> is    a
semidirect product group.  The   example uses the crossed module  <code>CX</code>
constructed in section
\refConjugationXMod.
<P>
<pre>    gap> CX;
    Crossed module [k4->a4]
    gap> CCX := Cat1XMod( CX );
    cat1-group [a4.k4 ==> a4] 
    gap> Cat1Print( CCX );

    cat1-group [a4.k4 ==> a4] :- 
    : source group has generators:
      [ (2,4,3)(5,6,7), (2,3,4)(6,7,8), (1,2)(3,4), (1,3)(2,4) ]
    :  range group has generators:
      [ (1,2,3), (2,3,4) ]
    : tail homomorphism maps source generators to:
      [ ( 1, 2, 3), ( 2, 3, 4), (), () ]
    : head homomorphism maps source generators to:
      [ ( 1, 2, 3), ( 2, 3, 4), ( 1, 2)( 3, 4), ( 1, 3)( 2, 4) ]
    : range embedding maps range generators to:
      [ ( 2, 4, 3)( 5, 6, 7), ( 2, 3, 4)( 6, 7, 8) ]
    : kernel has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : boundary homomorphism maps generators of kernel to:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : kernel embedding maps generators of kernel to:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : associated crossed module is Crossed module [k4->a4]    </pre>
<P><A NAME="SECT058"><h2>80.58 SemidirectCat1XMod</h2></a>
<P><P><P>
<code>SemidirectCat1XMod( <var>X</var> )</code>
<P>
This  function is  similar to  the   previous one, but a   permutation
representation for <I>R \semidirect S</I> is not constructed.
<P>
<pre>    gap> Unbind( CX.cat1 );
    gap> SCX := SemidirectCat1XMod( CX );
    cat1-group [a4 |X k4 ==> a4] 
    gap> Cat1Print( SCX );

    cat1-group [a4 |X k4 ==> a4] :- 
    : source group has generators:
      [ SemidirectProductElement( (1,2,3), GroupHomomorphismByImages( k4,
         k4, [(1,3)(2,4), (1,4)(2,3)], [(1,2)(3,4), (1,3)(2,4)] ), () ), 
        SemidirectProductElement( (2,3,4), GroupHomomorphismByImages( k4, 
         k4, [(1,4)(2,3), (1,2)(3,4)], [(1,2)(3,4), (1,3)(2,4)] ), () ), 
        SemidirectProductElement( (), IdentityMapping( k4 ), (1,2)(3,4) ), 
        SemidirectProductElement( (), IdentityMapping( k4 ), (1,3)(2,4) ) ]
    :  range group has generators:
      [ (1,2,3), (2,3,4) ]
    : tail homomorphism maps source generators to:
      [ (1,2,3), (2,3,4), (), () ]
    : head homomorphism maps source generators to:
      [ (1,2,3), (2,3,4), (1,2)(3,4), (1,3)(2,4) ]
    : range embedding maps range generators to:
      [ SemidirectProductElement( (1,2,3), GroupHomomorphismByImages( k4,
         k4, [(1,3)(2,4), (1,4)(2,3)], [(1,2)(3,4), (1,3)(2,4)] ), () ), 
        SemidirectProductElement( (2,3,4), GroupHomomorphismByImages( k4,
         k4, [(1,4)(2,3), (1,2)(3,4)], [(1,2)(3,4), (1,3)(2,4)] ), () ) ]
    : kernel has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : boundary homomorphism maps generators of kernel to:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : kernel embedding maps generators of kernel to:
      [ SemidirectProductElement( (), IdentityMapping( k4 ), (1,2)(3,4) ), 
        SemidirectProductElement( (), IdentityMapping( k4 ), (1,3)(2,4) ) ]
    : associated crossed module is Crossed module [k4->a4]   </pre>
<P><A NAME="SECT059"><h2>80.59 Cat1List</h2></a>
<P><P><P>
<code>Cat1List</code> is a list containing  data on all cat1-structures on groups
of size up to 47.  The list is used by <code>Cat1Select</code> to construct these
small examples of cat1-groups.
<P>
<pre>    gap> Length( Cat1List );
    198
    gap> Cat1List[8];
    [ 6, 2, [ (1,2), (2,3) ], "s3", 
            [ [ [ (2,3), (2,3) ], "c3", "c2", [ (2,3), (2,3) ], 
            [ (2,3), (2,3) ] ] ] ]  </pre>
<P><A NAME="SECT060"><h2>80.60 Cat1Select</h2></a>
<P><P>
<A name = "I41"></a>

<P>
<code>Cat1Select( <var>size, [gpnum, num] </var> )</code>
<P>
All cat-structures  on groups of  order up to 47 are  stored in a list
<code>Cat1List</code> and   may be obtained  from the  list  using this function.
Global        variables    <code>Cat1ListMaxSize      :=    47</code>         and
<code>NumbersOfIsomorphismClasses</code>   are  also    stored.   The     example
illustrated is  the first case  in which <I>t  &ne;  h</I> and the associated
conjugation  crossed module is  given  by the  normal subgroup <code>c3</code> of
<code>s3</code>.
<P>
<pre>    gap> Cat1ListMaxSize;
    47
    gap> NumbersOfIsomorphismClasses[18];
    5
    gap> Cat1Select( 18 );
    Usage:  Cat1Select( size, gpnum, num )
    [ "c6c3", "c18", "d18", "s3c3", "c3^2|Xc2" ]

    gap> Cat1Select( 18, 5 );
    There are 4 cat1-structures for the group c3^2|Xc2.
    [ [range generators], [tail.genimages], [head.genimages] ]  :- 
    [ [ (1,2,3), (4,5,6), (2,3)(5,6) ],  tail = head = identity mapping ]
    [ [ (2,3)(5,6) ], "c3^2", "c2", [ (), (), (2,3)(5,6) ],
        [ (), (), (2,3)(5,6) ] ]
    [ [ (4,5,6), (2,3)(5,6) ], "c3", "s3", [ (), (4,5,6), (2,3)(5,6) ], 
        [ (), (4,5,6), (2,3)(5,6) ] ]
    [ [ (4,5,6), (2,3)(5,6) ], "c3", "s3", [ (4,5,6),(4,5,6),(2,3)(5,6) ],
        [ (), (4,5,6), (2,3)(5,6) ] ]
    Usage:  Cat1Select( size, gpnum, num )
    Group has generators [ (1,2,3), (4,5,6), (2,3)(5,6) ]
 
    gap> SC := Cat1Select( 18, 5, 4 );
    cat1-group [c3^2|Xc2 ==> s3] 
    gap> Cat1Print( SC );

    cat1-group [c3^2|Xc2 ==> s3] :- 
    : source group has generators:
      [ (1,2,3), (4,5,6), (2,3)(5,6) ]
    :  range group has generators:
      [ (4,5,6), (2,3)(5,6) ]
    : tail homomorphism maps source generators to:
      [ ( 4, 5, 6), ( 4, 5, 6), ( 2, 3)( 5, 6) ]
    : head homomorphism maps source generators to:
      [ (), ( 4, 5, 6), ( 2, 3)( 5, 6) ]
    : range embedding maps range generators to:
      [ ( 4, 5, 6), ( 2, 3)( 5, 6) ]
    : kernel has generators:
      [ ( 1, 2, 3)( 4, 6, 5) ]
    : boundary homomorphism maps generators of kernel to:
      [ ( 4, 6, 5) ]
    : kernel embedding maps generators of kernel to:
      [ ( 1, 2, 3)( 4, 6, 5) ]

    gap> XSC := XModCat1( SC );
    Crossed module [c3->s3]   </pre>
<P>
For   each  group <code>G</code>    the first  cat1-structure    is the  identity
cat1-structure  <code>(id;id,id :  G  ->  G)</code> with   trivial   kernel.  The
corresponding crossed module has as  boundary the inclusion map of the
trivial subgroup.
<P>
<pre>    gap> AC := Cat1Select( 12, 5, 1 );
    cat1-group [a4 ==> a4]   </pre>
<P><A NAME="SECT061"><h2>80.61 Cat1Morphism</h2></a>
<P><P>
<A name = "I42"></a>

<P>
<code>Cat1Morphism( <var>C, D, L</var> )</code>
<P>
A  morphism of cat1-groups is   a pair of  homomorphisms <code>[ sourceHom,
rangeHom  ]</code>,   where    <code>sourceHom</code>,  <code>rangeHom</code>  are    respectively
homomorphisms between  the sources and   ranges of <I>C</I> and <I>D</I>,  which
commute   with   the  two  tail homomorphisms     with  the  two  head
homomorphisms and with the two embeddings.
<P>
In this implementation a morphism of cat1-groups <code>mu</code> is a record with
fields:
<P>
beg-tabular<s></s>ll
<code>mu.source</code>,         & the source cat1-group <code>C</code>,              <BR> 
<code>mu.range</code>,          & the range cat1-group  <code>D</code>,               <BR> 
<code>mu.sourceHom</code>,      & a homomorphism from <code>C.source</code> to <code>D.source</code>,<BR> 
<code>mu.rangeHom</code>,       & a homomorphism from <code>C.range</code> to <code>D.range</code>,  <BR> 
<code>mu.isCat1Morphism</code>, & a Boolean flag, normally <code>true</code>,             <BR> 
<code>mu.operations</code>,     & a special set of operations <code>Cat1MorphismOps</code>, <BR> 
<code>mu.name</code>,           & a concatenation of the names of <code>C</code> and <code>D</code>.
end-tabular<s></s>
<P>
The function <code>Cat1Morphism</code> requires as parameters two cat1-groups and
a two-element list containing the source  and range homomorphisms.  It
sets up the required fields for  <code>mu</code>, but does  not check the axioms.
The <code>IsCat1Morphism</code> function should  be used to perform these checks.
Note that the <code>Cat1MorphismPrint</code> function  is needed to print out the
morphism in detail.
<P>
<pre>    gap> GCCX := CCX.source;
    Perm(a4 |X k4)
    gap> GAC := AC.source;
    a4
    gap> genGAC := GAC.generators;
    [ (1,2,3), (2,3,4) ]
    gap> im := Sublist( GCCX.generators, [1..2] );
    [ (2,4,3)(5,6,7), (2,3,4)(6,7,8) ]

    gap> musrc := GroupHomomorphismByImages( GAC, GCCX, genGAC, im );;
    gap> murng := InclusionMorphism( a4, a4 );;
    gap> mu := Cat1Morphism( AC, CCX, [ musrc, murng ] );
    Morphism of cat1-groups &lt;[a4 ==> a4]-->[Perm(a4 |X k4) ==> a4]>   </pre>
<P><A NAME="SECT062"><h2>80.62 IsCat1Morphism</h2></a>
<P><P>
<A name = "I43"></a>

<P>
<code>IsCat1Morphism( <var>mu</var> )</code>
<P>
This Boolean function checks that <I>&mu;</I> includes homomorphisms between
the corresponding   source  and    range   groups, and    that   these
homomorphisms commute with the pairs of tail and head homomorphisms.
<P>
<pre>    gap> IsCat1Morphism( mu );
    true </pre>
<P><A NAME="SECT063"><h2>80.63 Cat1MorphismName</h2></a>
<P><P>
<A name = "I44"></a>

<P>
<code>Cat1MorphismName( <var>mu</var> )</code>
<P>
This function  concatenates the  names of the   source and range  of a
morphism of cat1-groups.
<P>
<pre>    gap> CCX.source.name := "a4.k4";; Cat1Name( CCX );
    "[a4.k4 ==> a4]"
    gap> Cat1MorphismName( mu );
    "&lt;[a4 ==> a4]-->[a4.k4 ==> a4]>"  </pre>
<P><A NAME="SECT064"><h2>80.64 Cat1MorphismPrint</h2></a>
<P><P>
<A name = "I45"></a>

<P>
<code>Cat1MorphismPrint( <var>mu</var> )</code>
<P>
This printing function for cat1-groups is one of the special functions
in <code>Cat1MorphismOps</code>.
<P>
<pre>    gap> Cat1MorphismPrint( mu );
    Morphism of cat1-groups := 
    : Source = cat1-group [a4 ==> a4] 
    :  Range = cat1-group [a4.k4 ==> a4] 
    : Source homomorphism maps source generators to:
      [ (2,4,3)(5,6,7), (2,3,4)(6,7,8) ]
    : Range homomorphism maps range generators to:
      [ (1,2,3), (2,3,4) ]  </pre>
<P><A NAME="SECT065"><h2>80.65 Operations for morphisms of cat1-groups</h2></a>
<P><P><P>
Special operations defined for morphisms of  cat1-groups are stored in
the record structure <code>Cat1MorphismOps</code> which is based on <code>MappingOps</code>.
Every morphism of   cat1-groups <code>mor</code> has  field  <code>mor.operations</code> set
equal to <code>Cat1MorphismOps;</code>.
<P>
<pre>    gap> IsMonomorphism( mu );
    true
    gap> IsEpimorphism( mu );
    false
    gap> IsIsomorphism( mu );
    false
    gap> IsEndomorphism( mu );
    false
    gap> IsAutomorphism( mu );
    false   </pre>
<P><A NAME="SECT066"><h2>80.66 Cat1MorphismSourceHomomorphism</h2></a>
<P><P><P>
<code>Cat1MorphismSourceHomomorphism ( C, D, phi )</code>
<P>
Given a homomorphism from the source of <code>C</code> to the source of <code>D</code>, this
function defines the corresponding cat1-group morphism.
<P>
<pre>    gap> GSC := SC.source;;
    gap> homsrc := GroupHomomorphismByImages( a4, GSC,
    >                [(1,2,3),(2,3,4)],[(4,5,6),(4,6,5)]);;
    gap> musrc := Cat1MorphismSourceHomomorphism( AC, SC, homsrc );
    Morphism of cat1-groups &lt;[a4 ==> a4]-->[c3^2|Xc2 ==> s3]>
    gap> IsCat1Morphism( musrc );
    true
    gap> Cat1MorphismPrint( musrc );
    Morphism of cat1-groups := 
    : Source = cat1-group [a4 ==> a4] 
    :  Range = cat1-group [c3^2|Xc2 ==> s3] 
    : Source homomorphism maps source generators to:
       [ (4,5,6), (4,6,5) ]
    : Range homomorphism maps range generators to:
       [ (4,5,6), (4,6,5) ]  </pre>
<P><A NAME="SECT067"><h2>80.67 ReverseCat1</h2></a>
<P><P><P>
<code>ReverseCat1( <var>C</var> )</code>
<P>
The reverse of a cat1-group is an  isomorphic cat1-group with the same
source,  range and embedding, but with  the tail and head interchanged
(see <A href="biblio.htm#xmodAW1"><cite>xmodAW1</cite></a>, section 2).
<P>
<pre>    gap> revCC := ReverseCat1( CC );
    cat1-group [h20 |X c5 ==> h20]  </pre>
<P><A NAME="SECT068"><h2>80.68 ReverseIsomorphismCat1</h2></a>
<P><P><P>
<code>ReverseIsomorphismCat1( <var>C</var> )</code>
<P>
<pre>    gap> revmu := ReverseIsomorphismCat1( CC );
    Morphism of cat1-groups
       &lt;[Perm(h20 |X c5) ==> h20]-->[h20 |X c5 ==> h20]>
    gap> IsCat1Morphism( revmu );
    true  </pre>
<P><A NAME="SECT069"><h2>80.69 Cat1MorphismXModMorphism</h2></a>
<P><P><P>
<code>Cat1MorphismXModMorphism( <var>mor</var> ) </code>
<P>
If <code>C1, C2</code> are the cat1-groups produced from <code>X1, X2</code> by the function
<code>Cat1XMod</code>, then for any <code>mor : X1 -> X2</code> there is an associated <pre>mu :
C1 -> C2</pre>.  The result is stored as <code>mor.cat1Morphism</code>.
<P>
<pre>    gap> CX.Cat1 := CCX;;
    gap> CSX := Cat1XMod( SX );
    cat1-group [Perm(sl(2,3) |X q8) ==> sl(2,3)]
    gap> mor;
    Morphism of crossed modules &lt;[q8->sl(2,3)] >-> [k4->a4]>
    gap> catmor := Cat1MorphismXModMorphism( mor );
    Morphism of cat1-groups
       &lt;[Perm(sl(2,3) |X q8) ==> sl(2,3)]-->[Perm(a4 |X k4) ==> a4]>
    gap> IsCat1Morphism( catmor );
    true
    gap> Cat1MorphismPrint( catmor );
    Morphism of cat1-groups := 
    : Source = cat1-group [Perm(sl(2,3) |X q8) ==> sl(2,3)] 
    :  Range = cat1-group [Perm(a4 |X k4) ==> a4] 
    : Source homomorphism maps source generators to:
      [ (5,6)(7,8), (5,7)(6,8), (2,3,4)(6,7,8), (1,2)(3,4), (1,3)(2,4) ]
    : Range homomorphism maps range generators to:
      [ (1,2)(3,4), (1,3)(2,4), (2,3,4) ]           </pre>
<P><A NAME="SECT070"><h2>80.70 XModMorphismCat1Morphism</h2></a>
<P><P><P>
<code>XModMorphismCat1Morphism ( <var>mu</var> ) </code>
<P>
If  <code>X1,X2</code> are the two crossed  modules produced from  <code>C1,C2</code> by the
function <code>XModCat1</code>, then  for   any <code> mu  :  C1  -> C2</code> there  is  an
associated morphism of crossed modules  from <code>X1</code> to <code>X2</code>.  The result
is stored as <code>mu.xmodMorphism</code>.
<P>
<pre>    gap> mu;
    Morphism of cat1-groups &lt;[a4 ==> a4]-->[a4.k4 ==> a4]>
    gap> xmu := XModMorphismCat1Morphism( mu );
    Morphism of crossed modules &lt;[a4->a4] >-> [k4->a4]>   </pre>
<P><A NAME="SECT071"><h2>80.71 CompositeMorphism for cat1-groups</h2></a>
<P><P>
<A name = "I46"></a>

<P>
<code>Cat1MorphismOps.CompositeMorphism( <var>mu1,mu2</var> )</code>
<P>
Morphisms <I>&mu;<sub>1</sub> : C &rarr; D</I>  and <I>&mu;<sub>2</sub> :  D &rarr; E</I> have a composite
<I>&mu; =   &mu;<sub>2</sub>  o &mu;<sub>1</sub>   :   C &rarr; E</I>  whose   source  and range
homomorphisms are the composites of those of <I>&mu;<sub>1</sub></I> and <I>&mu;<sub>2</sub></I>.  The
example corresponds to that in
\refCompositeMorphism for crossed modules.
<P>
<pre>    gap> psi;
    Morphism of crossed modules &lt;[c4->q8] >-> [c4->q8]>
    gap> inc;
    Morphism of crossed modules &lt;[c4->q8] >-> [q8->sl(2,3)]>
    gap> mupsi := Cat1MorphismXModMorphism( psi );
    Morphism of cat1-groups
        &lt;[Perm(q8 |X c4) ==> q8]-->[Perm(q8 |X c4) ==> q8]>
    gap> muinc := Cat1MorphismXModMorphism( inc );
    Morphism of cat1-groups
        &lt;[Perm(q8 |X c4) ==> q8]-->[Perm(sl(2,3) |X q8) ==> sl(2,3)]>
    gap> mucomp := Cat1MorphismOps.CompositeMorphism( mupsi, muinc );
    Morphism of cat1-groups
        &lt;[Perm(q8 |X c4) ==> q8]-->[Perm(sl(2,3) |X q8) ==> sl(2,3)]>
    gap> muxcomp := Cat1MorphismXModMorphism( xcomp );;
    gap> mucomp = muxcomp;
    true   </pre>
<P><A NAME="SECT072"><h2>80.72 IdentitySubCat1</h2></a>
<P><P><P>
<code>IdentitySubCat1( <var>C</var> )</code>
<P>
Every  cat1-group  <I><span style="font-family: cursive">  C</span></I> has  an   identity sub-cat1-group whose
source and range are the identity subgroups of the source and range of
<I><span style="font-family: cursive"> C</span></I>.
<P>
<pre>    gap> IdentitySubCat1( SC );
    cat1-group [Id[c3^2|Xc2 ==> s3]]  </pre> 
<P><A NAME="SECT073"><h2>80.73 SubCat1</h2></a>
<P><P><P>
<code>SubCat1( <var>C, H</var> )</code>
<P>
When <code>H</code> is a subgroup of  <code>C.source</code> and the restrictions of <code>C.tail</code>
and <code>C.head</code> to <code>H</code> have a common image, these homomorphisms determine
a sub-cat1-group of <code>C</code>.
<P>
<pre>    gap> d20 := Subgroup( h20, [ (1,2,3,4,5), (2,5)(3,4) ] );;
    gap> subC := SubCat1( C, d20 );
    cat1-group [Sub[h20 ==> c4]] 
    gap> Cat1Print( subC );

    cat1-group [Sub[h20 ==> c4]] :- 
    : source group has generators:
      [ (1,2,3,4,5), (2,5)(3,4) ]
    :  range group has generators:
      [ ( 2, 5)( 3, 4) ]
    : tail homomorphism maps source generators to:
      [ (), ( 2, 5)( 3, 4) ]
    : head homomorphism maps source generators to:
      [ (), ( 2, 5)( 3, 4) ]
    : range embedding maps range generators to:
      [ ( 2, 5)( 3, 4) ]
    : kernel has generators:
      [ (1,2,3,4,5) ]
    : boundary homomorphism maps generators of kernel to:
      [ () ]
    : kernel embedding maps generators of kernel to:
      [ ( 1, 2, 3, 4, 5) ]   </pre>
<P><A NAME="SECT074"><h2>80.74 InclusionMorphism for cat1-groups</h2></a>
<P><P>
<A name = "I47"></a>

<P>
<code>InclusionMorphism( <var>S, C</var> )</code>
<P>
This  function   constructs the inclusion   morphism  <code>S  ->   C</code> of a
sub-cat1-group <code>S</code> of a cat1-group <code>C</code>.
<P>
<pre>    gap> InclusionMorphism( subC, C );
    Morphism of cat1-groups &lt;[Sub[h20 ==> c4]]-->[h20 ==> c4]>  </pre>
<P><A NAME="SECT075"><h2>80.75 NormalSubCat1s</h2></a>
<P><P><P>
<code>NormalSubCat1s( <var>C</var> )</code>
<P>
This  function takes  pairs of  normal  subgroups from  the source and
range of <I><span style="font-family: cursive"> C</span></I>  and  constructs a normal sub-cat1-group  whenever
the axioms are satisfied.
<P>
<pre>    gap> NormalSubCat1s( SC );
    [ cat1-group [Sub[c3^2|Xc2 ==> s3]] ,
      cat1-group [Sub[c3^2|Xc2 ==> s3]] , 
      cat1-group [Sub[c3^2|Xc2 ==> s3]] ,
      cat1-group [Sub[c3^2|Xc2 ==> s3]]  ] </pre>
<P><A NAME="SECT076"><h2>80.76 AllCat1s</h2></a>
<P><P><P>
<code>AllCat1s( <var>G</var> )</code>
<P>
By a <em> cat1-structure</em> on <I>G</I> we mean a cat1-group <I><span style="font-family: cursive"> C</span></I> where
<I>R</I> is a subgroup of  <I>G</I> and <I>e</I> is the   inclusion map.  For such  a
structure to exist, <I>G</I>  must contain a normal  subgroup <I>S</I> with <I>G/S
&cong; R</I>.  Furthermore, since <I>t,h</I> are  respectively the identity and
zero maps  on <I>S</I>, we  require <I>R &cap; S  = { 1<sub>G</sub> }</I>.  This function
uses <code>EndomorphismClasses(  G,  3  )</code>  (see \refEndomorphismClasses,
\refIdempotentImages) to construct  idempotent endomorphisms  of <code>G</code>
as potential tails and heads.  A backtrack procedure then tests to see
which    pairs  of idempotents   give  cat1-groups.   A non-documented
function  <code>AreIsomorphicCat1s</code> is called  in  order that the  function
returns representatives for  isomorphism classes of cat1-structures on
<code>G</code>.  See <A href="biblio.htm#xmodAW1"><cite>xmodAW1</cite></a> for all cat1-structures  on groups of order up to
30.
<P>
<pre>    gap> AllCat1s( a4 );
    There are 1 endomorphism classes.
    Calculating idempotent endomorphisms.
    # idempotents mapping to lattice class representatives:
    [ 1, 0, 1, 0, 1 ]
    Isomorphism class 1
    : kernel of tail = [ "2x2" ]
    :    range group = [ "3" ]
    Isomorphism class 2
    : kernel of tail = [ "1" ]
    :    range group = [ "A4" ]
    [ cat1-group [a4 ==> a4.H3] , cat1-group [a4 ==> a4] ]  </pre>
<P>
The first class has range <code>c3</code> and kernel <code>k4</code>.
The second class contails all cat1-groups 
<I><span style="font-family: cursive"> C</span> = (&alpha;<sup>-1</sup>; &alpha;, &alpha; : G &rarr; G)</I>
where  <I>&alpha;</I>  is an automorphism of <I>G</I>.
<P>
\newpage
<P><A NAME="SECT077"><h2>80.77 About derivations and sections</h2></a>
<P><P><P>
The Whitehead monoid <I>\rmDer(<span style="font-family: cursive"> X</span>)</I> of <I><span style="font-family: cursive"> X</span></I> was defined in
<A href="biblio.htm#xmodW2"><cite>xmodW2</cite></a> to be the monoid of all <I> derivations</I> from <I> R </I> to <I>S</I>,
that is the set of all maps <I>R &rarr; S</I>, with  composition <I> o  </I>,
satisfying
<center>
\begintabularc r c l 
\textbfDer 1:  &  <I>&chi;(qr)</I>              &  = 
           & <I>(&chi; q)<sup>r</sup>   (&chi; r)</I>  <BR> 
\textbfDer 2:  &  <I>(&chi;<sub>1</sub> o &chi;<sub>2</sub>)(r)</I>  &  =
           & <I>(&chi;<sub>1</sub> r)(&chi;<sub>2</sub> r)(&chi;<sub>1</sub> &part; &chi;<sub>2</sub> r)</I>. 
\endtabular
</center>
<P>

The  zero   map  is the identity  for    this composition.  Invertible
elements in the monoid are called  <em> regular</em>.  The Whitehead group
of <I><span style="font-family: cursive">  X</span></I> is the  group of regular derivations in <I>\rmDer(<span style="font-family: cursive">
X</span> )</I>.  In section \refAbout actors the <em> actor</em> of <I><span style="font-family: cursive"> X</span></I> is
defined  as a crossed  module whose  source and  range are permutation
representations of the Whitehead group  and the automorphism group  of
<I><span style="font-family: cursive"> X</span></I>.
<P>
The  construction for  cat1-groups  equivalent to the  derivation of a
crossed module is the <em> section</em>.  The monoid of sections of <I><span style="font-family: cursive">
C</span></I>  is  the  set of   group homomorphisms   <I>&xi; : R   &rarr;  G</I>, with
composition <I> o  </I>, satisfying:
<center>
\begintabularl l
\textbfSect 1:  &  <I>t &xi; = \mathrmid<sub>R</sub></I>,               <BR> 
\textbfSect 2:  &  <I>(&xi;<sub>1</sub> o &xi;<sub>2</sub>)(r) =
                       (&xi;<sub>2</sub>r)(e h &xi;<sub>2</sub>r)<sup>-1</sup>(&xi;<sub>1</sub> h &xi;<sub>2</sub>r)</I>.
\endtabular
</center>
The embedding  <I>e</I> is the identity for  this composition, and <I>h(&xi;<sub>1</sub>
o  &xi;<sub>2</sub>) = (h &xi;<sub>1</sub>)(h &xi;<sub>2</sub>)</I>.   A section is <em> regular</em> when
<I>h   &xi;</I>  is an automorphism and,   of  course, the group  of regular
sections is isomorphic to the Whitehead group.
<P>
Derivations  are  stored  like group homomorphisms  by  specifying the
images of a generating set.  Images of the remaining elements may then
be obtained using  axiom \textbfDer 1.  The function <code>IsDerivation</code>
is automatically called to check that this procedure is well-defined.
<P>
<pre>    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> chi1 := XModDerivationByImages( X1, [ () ] );
    XModDerivationByImages( PermAut(c5), c5, [ (1,2,4,3) ], [ () ] )
    gap> IsDerivation( chi1 );
    true  </pre>
<P>
A derivation is stored as a record <code>chi</code> with fields:
<P>
beg-tabular<s></s>ll
<code>chi.source</code>,      & the range group <I>R</I> of <I><span style="font-family: cursive"> X</span></I>,         <BR> 
<code>chi.range</code>,       & the source group <I>S</I> of <I><span style="font-family: cursive"> X</span></I>,        <BR> 
<code>chi.generators</code>,  & a fixed generating set for <I>R</I>,            <BR> 
<code>chi.genimages</code>,   & the chosen images of the generators,       <BR> 
<code>chi.xmod</code>,        & the crossed module <I><span style="font-family: cursive"> X</span></I>,             <BR> 
<code>chi.operations</code>,  & special set of operations <code>XModDerivationByImagesOps</code>, <BR> 
<code>chi.isDerivation</code>,& a boolean flag, normally <code>true</code>.
end-tabular<s></s>
<P>
Sections \emphare group  homomorphisms, and are  stored as such, but
with  a  modified  set  of  operations <code>Cat1SectionByImagesOps</code>  which
includes  a special <code>.Print</code>  function  to display  the section in the
manner   shown    below.    Functions    <code>SectionDerivation</code>       and
<code>DerivationSection</code>  convert  derivations to sections, and vice-versa,
calling <code>Cat1XMod</code> and <code>XModCat1</code> automatically.
<P>
The equation <I>&xi;  r  = (er)(&chi;  r)</I> determines a  section  <I>&xi;</I> of
<I>\mathcalC</I>,   given   a  derivation <I>&chi;</I>    of <I>\mathcalX</I>, and
conversely.
<P>
<pre>    gap> xi1 := SectionDerivation( chi1 );
    Cat1SectionByImages( PermAut(c5), Perm(PermAut(c5) |X c5),
        [ (1,2,4,3) ], [ (2,3,5,4) ] )
    gap> xi1.cat1;
    cat1-group [Perm(PermAut(c5) |X c5) ==> PermAut(c5)]  </pre>
<P>
There are two functions to determine all the elements of the Whitehead
group   and  the   Whitehead      monoid   of <I><span style="font-family: cursive">   X</span></I>,     namely
<code>RegularDerivations</code>  and <code>AllDerivations</code>.   If the  whole  monoid is
needed at some  stage,  then the  latter function should  be  used.  A
field  <code>D = X.derivations</code>  is created which   stores all the required
information:
<P>
beg-tabular<s></s>ll
<code>D.areDerivations</code>,  & a boolean flag, normally <code>true</code>,                    <BR> 
<code>D.isReg</code>,           & <code>true</code> when only the regular derivations are known, <BR> 
<code>D.isAll</code>,           & <code>true</code> when all the derivations have been found,    <BR> 
<code>D.generators</code>,      & a \emphcopy of <code>R.generators</code>,                    <BR> 
<code>D.genimageList</code>,    & a list of <code>.genimages</code> lists for the derivations,   <BR> 
<code>D.regular</code>,         & the number of regular derivations (if known),       <BR> 
<code>D.xmod</code>,            & the crossed module <I><span style="font-family: cursive"> X</span></I>,                      <BR> 
<code>D.operations</code>,      & a special set of operations <code>XModDerivationsOps</code>.
end-tabular<s></s>
<P>
Using  our  standard example <code>X1</code> we   find that there   are just five
derivations, all of them regular, so the associated group is cyclic of
size 5.
<P>
<pre>    gap> RegularDerivations( X1 );
    RegularDerivations record for crossed module [c5->PermAut(c5)],
    : 5 regular derivations, others not found.
    gap> AllDerivations( X1 );
    AllDerivations record for crossed module [c5->PermAut(c5)],
    : 5 derivations found but unsorted.
    gap> DerivationsSorted( X1 );
    true
    gap> imder1 := X1.derivations.genimageList;
    [ [()], [(1,2,3,4,5)], [(1,3,5,2,4)], [(1,4,2,5,3)], [(1,5,4,3,2)] ] </pre>
<P>
The    functions     <code>RegularSections</code>  and   <code>AllSections</code>    perform
corresponding tasks for  a cat1-group.  Two strategies for calculating
derivations and sections are implemented, see <A href="biblio.htm#xmodAW1"><cite>xmodAW1</cite></a>.  The default
method for <code>AllDerivations</code>   is to search for  all  possible sets  of
images using  a backtracking procedure,  and when all  the derivations
are  found   it  is  not   known  which   are regular.  The   function
<code>DerivationsSorted</code>  sorts  the  <code>.genImageList</code>  field,  placing  the
regular ones at the top  of the list  and adding the <code>.regular</code> field.
The  default method for <code>AllSections( C  )</code> computes all endomorphisms
on the  range  group <code>R</code>  of  <code>C</code> as possibilities  for  the composite
<I>h&xi;</I>.  A  backtrack  method then  finds  possible images  for such a
section.  When  either the set of derivations  or the  set of sections
already exists, the other set is computed using <code>SectionDerivation</code> or
<code>DerivationSection</code>.
<P>
<pre>    gap> CX1 := Cat1XMod( X1 );
    cat1-group [Perm(PermAut(c5) |X c5) ==> PermAut(c5)] 
    gap> CX1.source.name := "Hol(c5)";; Cat1Name( CX1 );
    gap> RegularSections( CX1 );
    RegularSections record for cat1-group [Hol(c5) ==> PermAut(c5)],
    : 5 regular sections, others not found.
    gap> CX1.sections.genimageList;
    [ [(2,3,5,4)], [(1,2,4,3)], [(1,3,2,5)], [(1,4,5,2)], [(1,5,3,4)] ]  </pre>
<P>
The derivation images and the composition table may be listed as follows.
<P>
<pre>    gap> chi2 := XModDerivationByImages( X1, imder1[2] ); 
    XModDerivationByImages( PermAut(c5), c5, [(1,2,4,3)], [(1,2,3,4,5)] )
    gap> DerivationImage( chi2, (1,4)(2,3) );
    ( 1, 4, 2, 5, 3)
    gap> DerivationImages( chi2 );
    [ 1, 2, 3, 4 ]
    gap> PrintList( DerivationTable( X1 ) );
    [ 1, 1, 1, 1 ]
    [ 1, 2, 3, 4 ]
    [ 1, 3, 5, 2 ]
    [ 1, 4, 2, 5 ]
    [ 1, 5, 4, 3 ]
    gap> PrintList( WhiteheadGroupTable( X1 ) );
    [ 1, 2, 3, 4, 5 ]
    [ 2, 3, 4, 5, 1 ]
    [ 3, 4, 5, 1, 2 ]
    [ 4, 5, 1, 2, 3 ]
    [ 5, 1, 2, 3, 4 ]  </pre>
<P><P>
Each <I>&chi;</I> or <I>&xi;</I>  determines endomorphisms of <I>R,  S, G, <span style="font-family: cursive"> X</span></I>
and <I><span style="font-family: cursive"> C</span></I>, namely:
<center>
\begintabularrccl
    <I>&rho;</I>  &  :  &  <I>R &rarr; R,</I> 
                  &  <I>r &rarr; r(&part; &chi; r) = h &xi; r</I>,  <BR> 
  <I>&sigma;</I>  &  :  &  <I>S &rarr; S,</I>
                  &  <I>s &rarr; s(&chi; &part; s)</I>,            <BR> 
  <I>&gamma;</I>  &  :  &  <I>G &rarr; G,</I>
                  &  <I>g &rarr; (eh &xi; tg)(&xi; tg<sup>-1</sup>)g(ehg<sup>-1</sup>)(&xi; hg)</I>,<BR> 
  <I>(&sigma;,&rho;)</I> & :  & <I><span style="font-family: cursive"> X</span> &rarr; <span style="font-family: cursive"> X</span>,</I>              <BR> 
  <I>(&gamma;,&rho;)</I> & :  & <I><span style="font-family: cursive"> C</span> &rarr; <span style="font-family: cursive"> C</span></I>.
\endtabular
</center>
<P>
When these endomorphisms are automorphisms, the derivation is regular.
When the boundary  of <I><span style="font-family: cursive"> X</span></I> is  the  zero map, both  <I>&sigma;</I> and
<I>&rho;</I> are identity  homomorphisms,  and every derivation  is regular,
which is the case in this example.
<P>
<pre>    gap> sigma2 := SourceEndomorphismDerivation( chi2 );
    GroupHomomorphismByImages( c5, c5, [ (1,2,3,4,5) ], [ (1,2,3,4,5) ] )
    gap> rho2 := RangeEndomorphismDerivation( chi2 );
    GroupHomomorphismByImages( PermAut(c5), PermAut(c5), [ (1,2,4,3) ], 
       [ (1,2,4,3) ] )
    gap> xi2 := SectionDerivation( chi2 );;
    gap> gamma2 := SourceEndomorphismSection( xi2 );
    GroupHomomorphismByImages( Hol(c5), Hol(c5), [(2,3,5,4),(1,2,3,4,5)],
       [(2,3,5,4),(1,2,3,4,5)] )
    gap> mor2 := XModMorphism( X1, X1, [sigma2,rho2] );
    Morphism of crossed modules &lt;[c5->PermAut(c5)] >-> [c5->PermAut(c5)]>
    gap> mu2 := Cat1Morphism( CX1, CX1, [gamma2,rho2] );
    Morphism of cat1-groups &lt;[Hol(c5) ==> PermAut(c5)]-->
       [Hol(c5) ==> PermAut(c5)]>  </pre>
<P><A NAME="SECT078"><h2>80.78 XModDerivationByImages</h2></a>
<P><P><P>
<code>XModDerivationByImages( <var>X, im</var> )</code>
<P>
This   function takes a    list of images  in <code>S   = X.source</code> for the
generators of  <code>R = X.range</code>  and constructs a map <I>&chi;  : R  &rarr; S</I>
which is  then tested to see whether   the axioms of  a derivation are
satisfied.
<P>
<pre>    gap> XSC;
    Crossed module [c3->s3]
    gap> imchi := [ (1,2,3)(4,6,5), (1,2,3)(4,6,5) ];;
    gap> chi := XModDerivationByImages( XSC, imchi );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ], 
       [ (1,2,3)(4,6,5), (1,2,3)(4,6,5) ] )  </pre>
<P><A NAME="SECT079"><h2>80.79 IsDerivation</h2></a>
<P><P>
<A name = "I48"></a>

<P>
<code>IsDerivation( <var>X, im</var> )</code>
<P>
<code>IsDerivation( <var>chi</var> )</code>
<P>
This function may be called in two ways, and tests that the derivation
given by the images of its generators is well-defined.
<P>
<pre>    gap> im0 := [ (1,3,2)(4,5,6), () ];;
    gap> IsDerivation( XSC, im0 );
    true  </pre>
<P><A NAME="SECT080"><h2>80.80 DerivationImage</h2></a>
<P><P>
<A name = "I49"></a>

<P>
<code>DerivationImage( <var>chi, r</var> )</code>
<P>
This function returns <I>&chi;(r) &isin; S</I> when <I>&chi;</I> is a derivation.
<P>
<pre>    gap> DerivationImage( chi, (4,6,5) );
    (1,3,2)(4,5,6)  </pre>
<P><A NAME="SECT081"><h2>80.81 DerivationImages</h2></a>
<P><P>
<A name = "I50"></a>

<P>
<code>DerivationImages( <var>chi</var> )</code>
<P>
All   the  images   of  the   elements     of  <I>R</I> are  found    using
<code>DerivationImage</code> and their positions in <code>S.elements</code> is returned as a
list.
<P>
<pre>    gap> XSC.source.elements;
    [ (), ( 1, 2, 3)( 4, 6, 5), ( 1, 3, 2)( 4, 5, 6) ]
    gap> DerivationImages(chi);
    [ 1, 2, 3, 2, 3, 1 ]  </pre>
<P><A NAME="SECT082"><h2>80.82 InnerDerivation</h2></a>
<P><P><P>
<code>InnerDerivation( <var>X, s</var> )</code>
<P>
When <I>S,R</I> are respectively the source  and range of  <code>X</code>, each <I>s &isin;
S</I> defines a derivation <I>&eta;<sub>s</sub>  : R  &rarr; S,  r &rarr; s<sup>r</sup>  s<sup>-1</sup></I>.
These <em> inner   derivations</em>   are  often  called  <em>   principal
derivations</em> in the literature.
<P>
<pre>    gap> InnerDerivation( XSC, (1,2,3)(4,6,5) );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ],
       [ (), (1,2,3)(4,6,5) ] )  </pre>
<P><A NAME="SECT083"><h2>80.83 ListInnerDerivations</h2></a>
<P><P>
<A name = "I51"></a>

<P>
<code>ListInnerDerivations( <var>X</var> )</code>
<P>
This    functions  applies <code>InnerDerivation</code>     to every  element  of
<code>X.source</code> and outputs    a   list of  genimages  for   the  resulting
derivations.   This   list is   stored   as <code>.innerImageList</code>   in the
derivations record.
<P>
<pre>    gap> PrintList( ListInnerDerivations( XSC ) );
    [ (), () ]
    [ (), ( 1, 2, 3)( 4, 6, 5) ]
    [ (), ( 1, 3, 2)( 4, 5, 6) ]  </pre>
<P><A NAME="SECT084"><h2>80.84 Operations for derivations</h2></a>
<P><P><P>
The operations record for derivations is  <code>XModDerivationByImagesOps</code>.
<P>
<pre>    gap> RecFields( chi.operations );
    [ "name", "operations", "IsMapping", "IsInjective", "IsSurjective", 
      "IsBijection", "IsHomomorphism", "IsMonomorphism", "IsEpimorphism", 
      "IsIsomorphism", "IsEndomorphism", "IsAutomorphism", "=", "&lt;", "*",
      "/", "mod", "Comm", "^", "ImageElm", "ImagesElm", "ImagesSet",
      "ImagesSource", "ImagesRepresentative", "PreImageElm",
      "PreImagesSet", "PreImagesRange", "PreImagesRepresentative",
      "PreImagesElm", "CompositionMapping", "PowerMapping",
      "IsGroupHomomorphism", "KernelGroupHomomorphism",
      "IsFieldHomomorphism", "KernelFieldHomomorphism",
      "InverseMapping", "Print", "IsRegular" ]  </pre>
<P><A NAME="SECT085"><h2>80.85 Cat1SectionByImages</h2></a>
<P><P><P>
<code>Cat1SectionByImages( <var>C, im</var> )</code>
<P>
This function  takes  a list  of  images in   <code>G =  C.source</code>  for the
generators of <code>R  = C.range</code> and constructs a  homomorphism  <I>&xi; : R
&rarr; G</I> which is then tested to see whether the axioms of a section are
satisfied.
<P>
<pre>    gap> SC;
    cat1-group [c3^2|Xc2 ==> s3] 
    gap> imxi := [ (1,2,3), (1,2)(4,6) ];;
    gap> xi := Cat1SectionByImages( SC, imxi );
    Cat1SectionByImages( s3, c3^2|Xc2, [ (4,5,6), (2,3)(5,6) ], 
       [ (1,2,3), (1,2)(4,6) ] )  </pre>
<P><A NAME="SECT086"><h2>80.86 IsSection</h2></a>
<P><P>
<A name = "I52"></a>

<P>
<code>IsSection( <var>C, im</var> )</code>
<P>
<code>IsSection( <var>xi</var> )</code>
<P>
This function may be  called in two  ways, and tests that  the section
given by the images of its generators is well-defined.
<P>
<pre>    gap> im0 := [ (1,2,3), (2,3)(4,5) ];;
    gap> IsSection( SC, im0 );
    false   </pre>
<P><A NAME="SECT087"><h2>80.87 IsRegular for Crossed Modules</h2></a>
<P><P>
<A name = "I53"></a>

<A name = "I54"></a>

<P>
<code>IsRegular( <var>chi</var> )</code>
<P>
This function tests a  derivation or a  section  to see whether  it is
invertible in the Whitehead monoid.
<P>
<pre>    gap> IsRegular( chi );
    false
    gap> IsRegular( xi );
    false  </pre>
<P><A NAME="SECT088"><h2>80.88 Operations for sections</h2></a>
<P><P><P>
The operations record for sections is <code>Cat1SectionByImagesOps</code>.
<P>
<pre>    gap> RecFields( xi.operations );
    [ "name", "operations", "IsMapping", "IsInjective", "IsSurjective", 
      "IsBijection", "IsHomomorphism", "IsMonomorphism", "IsEpimorphism", 
      "IsIsomorphism", "IsEndomorphism", "IsAutomorphism", "=", "&lt;", "*",
      "/", "mod", "Comm", "^", "ImageElm", "ImagesElm", "ImagesSet",
      "ImagesSource","ImagesRepresentative", "PreImageElm", "PreImagesElm",
      "PreImagesSet", "PreImagesRange", "PreImagesRepresentative",
      "CompositionMapping", "PowerMapping", "InverseMapping",
      "IsGroupHomomorphism", "CoKernel", "KernelGroupHomomorphism",
      "MakeMapping", "Print", "IsRegular" ]  </pre>
<P><A NAME="SECT089"><h2>80.89 RegularDerivations</h2></a>
<P><P>
<A name = "I55"></a>

<P>
<code>RegularDerivations( <var>X [,"back" \rm or "cat1"]</var> )</code>
<P>
By default,   this function uses  a  backtrack search to  find all the
regular  derivations   of <I><span style="font-family: cursive"> X</span></I>.   The  result   is stored  in  a
derivations record.     The alternative strategy,  for  which "cat1"
option should be specified is to calculate the regular sections of the
associated cat1-group first, and convert these to derivations.
<P>
<pre>    gap> regXSC := RegularDerivations( XSC );
    RegularDerivations record for crossed module [c3->s3],
    : 6 regular derivations, others not found.
    gap> PrintList( regXSC.genimageList );
    [ (), () ]
    [ (), ( 1, 2, 3)( 4, 6, 5) ]
    [ (), ( 1, 3, 2)( 4, 5, 6) ]
    [ ( 1, 3, 2)( 4, 5, 6), () ]
    [ ( 1, 3, 2)( 4, 5, 6), ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 3, 2)( 4, 5, 6), ( 1, 3, 2)( 4, 5, 6) ]
    gap> RecFields( regXSC );
    [ "areDerivations", "isReg", "isAll", "genimageList", "operations",
      "xmod", "generators", "regular" ]  </pre>
<P><A NAME="SECT090"><h2>80.90 AllDerivations</h2></a>
<P><P>
<A name = "I56"></a>

<P>
<code>AllDerivations( <var>X [,"back" \rm or "cat1"]</var> )</code>
<P>
This function  calculates  all  the   derivations  of <I><span style="font-family: cursive">  X</span></I>  and
overwrites any existing subfields of <code>X.derivations</code>.
<P>
<pre>    gap> allXSC := AllDerivations( XSC );
    AllDerivations record for crossed module [c3->s3],
    : 9 derivations found but unsorted.  </pre>
<P><A NAME="SECT091"><h2>80.91 DerivationsSorted</h2></a>
<P><P><P>
<code>DerivationsSorted( <var>D</var> )</code>
<P>
This function tests  the derivations in  the derivation record <code>D</code>  to
see  which are regular; sorts the   list <code>D.genimageList</code>, placing the
regular images first; and stores  the number of regular derivations in
<code>D.regular</code>.  The function returns <code>true</code> on successful completion.
<P>
<pre>    gap> DerivationsSorted( allXSC );
    true
    gap> PrintList( allXSC.genimageList );
    [ (), () ]
    [ (), ( 1, 2, 3)( 4, 6, 5) ]
    [ (), ( 1, 3, 2)( 4, 5, 6) ]
    [ ( 1, 3, 2)( 4, 5, 6), () ]
    [ ( 1, 3, 2)( 4, 5, 6), ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 3, 2)( 4, 5, 6), ( 1, 3, 2)( 4, 5, 6) ]
    [ ( 1, 2, 3)( 4, 6, 5), () ]
    [ ( 1, 2, 3)( 4, 6, 5), ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 2, 3)( 4, 6, 5), ( 1, 3, 2)( 4, 5, 6) ]  </pre>
<P><A NAME="SECT092"><h2>80.92 DerivationTable</h2></a>
<P><P>
<A name = "I57"></a>

<P>
<code>DerivationTable( <var>D</var> )</code>
<P>
The function  <code>DerivationImages</code>  in \refDerivationImages is applied
to  each derivation in  the current derivations  record and  a list of
positions of images in <I>S</I> is returned.
<P>
<pre>    gap> PrintList( DerivationTable( allXSC ) );
    [ 1, 1, 1, 1, 1, 1 ]
    [ 1, 1, 1, 2, 2, 2 ]
    [ 1, 1, 1, 3, 3, 3 ]
    [ 1, 3, 2, 1, 3, 2 ]
    [ 1, 3, 2, 2, 1, 3 ]
    [ 1, 3, 2, 3, 2, 1 ]
    [ 1, 2, 3, 1, 2, 3 ]
    [ 1, 2, 3, 2, 3, 1 ]
    [ 1, 2, 3, 3, 1, 2 ]  </pre>
<P><A NAME="SECT093"><h2>80.93 AreDerivations</h2></a>
<P><P>
<A name = "I58"></a>

<P>
<code>AreDerivations( <var>D</var> )</code>
<P>
This function checks that the record <code>D</code> has  the correct fields for a
derivations record (regular or all).
<P>
<pre>    gap> AreDerivations( regXSC );
    true </pre>
<P><A NAME="SECT094"><h2>80.94 RegularSections</h2></a>
<P><P>
<A name = "I59"></a>

<P>
<code>RegularSections( <var>C [,"endo" \rm or "xmod"]</var> )</code>
<P>
By default, this function computes the set of idempotent automorphisms
from <I>R &rarr;  R</I>  and takes these as  possible  choices for <I>h&xi;</I>.   A
backtrack procedure  then  calculates   possible images for    such  a
section.  The result is stored in  a sections record <code>C.sections</code> with
fields  similar  to those of   a serivations  record.  The alternative
strategy,    for  which "xmod"   option should   be  specified is to
calculate the regular derivations   of the associated  crossed  module
first, and convert the resulting derivations to sections.
<P>
<pre>    gap> Unbind( XSC.derivations );
    gap> regSC := RegularSections( SC );
    RegularSections record for cat1-group [c3^2|Xc2 ==> s3],
    : 6 regular sections, others not found.  </pre>
<P><A NAME="SECT095"><h2>80.95 AllSections</h2></a>
<P><P>
<A name = "I60"></a>

<P>
<code>AllSections( <var>C [,"endo" \rm or "xmod"]</var> )</code>
<P>
By default, this function computes the set of idempotent endomorphisms
from    <I>R    &rarr;   R</I>   (see     sections  \refEndomorphismClasses,
\refIdempotentImages) and takes  these  as possible choices  for the
composite homomorphism <I>h&xi;</I>.   A backtrack procedure then calculates
possible images for such a  section.  This function calculates all the
sections  of  <I><span style="font-family: cursive"> C</span></I>  and  overwrites any   existing subfields  of
<code>C.sections</code>.
<P>
<pre>    gap> allSC := AllSections( SC );
    AllSections record for cat1-group [c3^2|Xc2 ==> s3],
    : 6 regular sections,  3 irregular ones found. 
    gap> RecFields( allSC );
    [ "areSections", "isReg", "isAll", "regular", "genimageList",
      "generators", "cat1", "operations" ]
    gap> PrintList( allSC.genimageList );
    [ ( 4, 5, 6), ( 2, 3)( 5, 6) ]
    [ ( 4, 5, 6), ( 1, 3)( 4, 5) ]
    [ ( 4, 5, 6), ( 1, 2)( 4, 6) ]
    [ ( 1, 3, 2)( 4, 6, 5), ( 2, 3)( 5, 6) ]
    [ ( 1, 3, 2)( 4, 6, 5), ( 1, 3)( 4, 5) ]
    [ ( 1, 3, 2)( 4, 6, 5), ( 1, 2)( 4, 6) ]
    [ ( 1, 2, 3), ( 2, 3)( 5, 6) ]
    [ ( 1, 2, 3), ( 1, 2)( 4, 6) ]
    [ ( 1, 2, 3), ( 1, 3)( 4, 5) ] 
    gap> allXSC := AllDerivations( XSC, "cat1" );
    AllDerivations record for crossed module [c3->s3],
    : 6 regular derivations,  3 irregular ones found.   </pre>
<P><A NAME="SECT096"><h2>80.96 AreSections</h2></a>
<P><P>
<A name = "I61"></a>

<P>
<code>AreSections( <var>S</var> )</code>
<P>
This function checks that the record <code>S</code> has  the correct fields for a
sections record (regular or all).
<P>
<pre>    gap> AreSections( allSC );
    true </pre>
<P><A NAME="SECT097"><h2>80.97 SectionDerivation</h2></a>
<P><P><P>
<code>SectionDerivation( <var>D, i</var> )</code>
<P>
This function   converts  a derivation  of  <code>X</code>  to a  section  of the
associated cat1-group      <code>C</code>.  This    function  is    inverse    to
<code>DerivationSection</code>.  In the following  examples we note that <code>allXSC</code>
has  been  obtained using <code>allSC</code>,   so the  derivations and  sections
correspond in the same order.
<P>
<pre>    gap> chi8 := XModDerivationByImages( XSC, allXSC.genimageList[8] );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ], 
       [ ( 1,2,3)(4,6,5), (1,2,3)(4,6,5) ] )
    gap> xi8 := SectionDerivation( chi8 );
    GroupHomomorphismByImages( s3, c3^2|Xc2,
        [ (4,5,6), (2,3)(5,6) ], [ (1,2,3), (1,2)(4,6) ] )  </pre>
<P><A NAME="SECT098"><h2>80.98 DerivationSection</h2></a>
<P><P><P>
<code>DerivationSection( <var> C, xi </var> )</code>
<P>
This  function  converts a  section   of <code>C</code> to   a derivation  of the
associated   crossed  module    <code>X</code>.  This function    is   inverse to
<code>SectionDerivation</code>.
<P>
<pre>    gap> xi4 := Cat1SectionByImages( SC, allSC.genimageList[4] );
    Cat1SectionByImages( s3, c3^2|Xc2, [ (4,5,6), (2,3)(5,6) ], 
       [ (1,3,2)(4,6,5), (2,3)(5,6) ] )
    gap> chi4 := DerivationSection( xi4 );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ],
       [ (1,3,2)(4,5,6), () ] )  </pre>
<P><A NAME="SECT099"><h2>80.99 CompositeDerivation</h2></a>
<P><P>
<A name = "I62"></a>

<P>
<code>CompositeDerivation( <var>chi, chj</var> )</code>
<P>
This function  applies the  Whitehead product  to  two derivations and
returns the  composite.   In the  example,  derivations <code>chi4</code>, <code>chi8</code>
correspond to sections <code>xi4</code> and <code>xi8</code>.
<P>
<pre>    gap> chi48 := CompositeDerivation( chi4, chi8 );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ], 
       [ (1,2,3)(4,6,5), (1,3,2)(4,5,6) ] )  </pre>
<P><A NAME="SECT100"><h2>80.100 CompositeSection</h2></a>
<P><P>
<A name = "I63"></a>

<P>
<code>CompositeSection( <var>xi, xj</var> )</code>
<P>
This function  applies the Whitehead  composition to  two sections and
returns the composite.
<P>
<pre>    gap> xi48 := CompositeSection( xi4, xi8 );
    Cat1SectionByImages( s3, c3^2|Xc2, [ (4,5,6), (2,3)(5,6) ], 
       [ ( 1,2,3), (1,3)(4,5) ] )
    gap> SectionDerivation( chi48 ) = xi48;
    true  </pre>
<P><A NAME="SECT101"><h2>80.101 WhiteheadGroupTable</h2></a>
<P><P>
<A name = "I64"></a>

<P>
<code>WhiteheadGroupTable( <var>X</var> )</code>
<P>
This  function applies <code>CompositeDerivation</code>   to all pairs of regular
derivations,  producing the Whitehead  group  multiplication table.  A
field <code>.groupTable</code> is added to <code>D</code>.
<P>
<pre>    gap> WGT := WhiteheadGroupTable( XSC );; PrintList( WGT );
    returning existing ALL derivations
    [ 1, 2, 3, 4, 5, 6 ]
    [ 2, 3, 1, 5, 6, 4 ]
    [ 3, 1, 2, 6, 4, 5 ]
    [ 4, 6, 5, 1, 3, 2 ]
    [ 5, 4, 6, 2, 1, 3 ]
    [ 6, 5, 4, 3, 2, 1 ]  </pre>
<P><A NAME="SECT102"><h2>80.102 WhiteheadMonoidTable</h2></a>
<P><P>
<A name = "I65"></a>

<P>
<code>WhiteheadMonoidTable( <var>X</var> )</code>
<P>
The derivations of   <code>X</code> form a monoid  with  the first  derivation as
identity.  This function applies <code>CompositeDerivation</code> to all pairs of
derivations and produces the multiplication  table as a list of lists.
A field  <code>.monoidTable</code> is added  to <code>D</code>.  In  our example there are 9
derivations and the three irregular ones,  numbers 7,8,9, are all left
zeroes.
<P>
<pre>    gap> WMT := WhiteheadMonoidTable( XSC );; PrintList(WMT );
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    [ 2, 3, 1, 5, 6, 4, 9, 7, 8 ]
    [ 3, 1, 2, 6, 4, 5, 8, 9, 7 ]
    [ 4, 6, 5, 1, 3, 2, 7, 9, 8 ]
    [ 5, 4, 6, 2, 1, 3, 9, 8, 7 ]
    [ 6, 5, 4, 3, 2, 1, 8, 7, 9 ]
    [ 7, 7, 7, 7, 7, 7, 7, 7, 7 ]
    [ 8, 8, 8, 8, 8, 8, 8, 8, 8 ]
    [ 9, 9, 9, 9, 9, 9, 9, 9, 9 ]  </pre>
<P><A NAME="SECT103"><h2>80.103 InverseDerivations</h2></a>
<P><P><P>
<code>InverseDerivations( <var>X, i</var> )</code>
<P>
When  <code>T[i]</code> is  a  regular  derivation,   this  function returns  the
position <code>j</code>   such  that <code>T[j]</code>  is the   inverse of <code>T[i]</code>   in  the
Whitehead group.  When <code>T[i]</code> is not regular,  a list of values <code>j</code> is
returned such that the inverse semigroup condition <I>xyx =  x,   yxy =
y</I> is satisfied, where <I>x = T[i], y = T[j]</I>.  Notice that derivation 8
has order 3 and derivation 15 as inverse.
<P>
<pre>    gap> inv4 := InverseDerivations( chi4 );
    [ 4 ]
    gap> inv8 := InverseDerivations( chi8 );
    [ 7, 8, 9 ]   </pre>
<P><A NAME="SECT104"><h2>80.104 ListInverseDerivations</h2></a>
<P><P>
<A name = "I66"></a>

<P>
<code>ListInverseDerivations( <var>X</var> )</code>
<P>
This function applies <code>InverseDerivations</code> to all  the derivations.  A
field <code>.inverses</code> is added to <code>D</code>.
<P>
<pre>    gap> inv := ListInverseDerivations( XSC );
    [ [ 1 ], [ 3 ], [ 2 ], [ 4 ], [ 5 ], [ 6 ],
      [ 7, 8, 9 ], [ 7, 8, 9 ], [ 7, 8, 9 ] ]    </pre>
<P><A NAME="SECT105"><h2>80.105 SourceEndomorphismDerivation</h2></a>
<P><P><P>
<code>SourceEndomorphismDerivation( <var>chi</var> )</code>
<P>
Each derivation <I>&chi;</I> determines an endomorphism <I>&sigma;</I> of <code>S</code> such
that <I>&sigma;  s = s (&chi;  &part; s)</I>.  This construction  defines a
homomorphism   from the Whitehead group   to <I>Aut(S)</I>  which forms the
action  homomorphism of   the Whitehead crossed    module described in
section
\refWhitehead crossed module.
<P>
<pre>    gap> sigma8 := SourceEndomorphismDerivation( chi8 );
    GroupHomomorphismByImages( c3, c3, [ (1,2,3)(4,6,5) ], [ () ] )
    gap> sigma4 := SourceEndomorphismDerivation( chi4 );
    GroupHomomorphismByImages( c3, c3, [ (1,2,3)(4,6,5) ], 
       [ (1,3,2)(4,5,6) ] ) </pre>
<P><A NAME="SECT106"><h2>80.106 TableSourceEndomorphismDerivations</h2></a>
<P><P>
<A name = "I67"></a>

<P>
<code>TableSourceEndomorphismDerivations( <var>X</var> )</code>
<P>
Applying <code>SourceEndomorphismDerivation</code> to every derivation produces a
list of endomorphisms of <code>S = X.source</code>.  This function returns a list
of <code>.genimages</code> for these endomorphisms.  Note  that, in this example,
<code>S = c3</code> and the irregular derivations produce zero maps.
<P>
<pre>    gap> TSE := TableSourceEndomorphismDerivations( XSC );;
    gap> PrintList( TSE );
    [ ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 2, 3)( 4, 6, 5) ]
    [ ( 1, 3, 2)( 4, 5, 6) ]
    [ ( 1, 3, 2)( 4, 5, 6) ]
    [ ( 1, 3, 2)( 4, 5, 6) ]
    [ () ]
    [ () ]
    [ () ]  </pre>
<P><A NAME="SECT107"><h2>80.107 RangeEndomorphismDerivation</h2></a>
<P><P><P>
<code>RangeEndomorphismDerivation( <var>chi</var> )</code>
<P>
Each derivation  <I>&chi;</I> determines an  endomorphism <I>&rho;</I> of <code>R</code> such
that  <I>&rho; r  = r (&part;  &chi;  r)</I>.  This  construction defines a
homomorphism from the Whitehead group to <I>Aut(R)</I>.
<P>
<pre>    gap> rho8 := RangeEndomorphismDerivation( chi8 );
    GroupHomomorphismByImages( s3, s3, [ (4,5,6), (2,3)(5,6) ], 
      [ (), (2,3)(4,6) ] )
    gap> rho4 := RangeEndomorphismDerivation( chi4 );
    GroupHomomorphismByImages( s3, s3, [ (4,5,6), (2,3)(5,6) ], 
      [ (4,6,5), (2,3)(5,6) ] )   </pre>
<P><A NAME="SECT108"><h2>80.108 TableRangeEndomorphismDerivations</h2></a>
<P><P>
<A name = "I68"></a>

<P>
<code>TableRangeEndomorphismDerivations( <var>X</var> )</code>
<P>
Applying <code>RangeEndomorphismDerivation</code>  to every derivation produces a
list of endomorphisms of <code>R =  X.range</code>.  This function returns a list
of <code>.genimages</code> for these endomorphisms.  Note  that, in this example,
the 3  irregular derivations map onto  the 3 cyclic subgroups of order
2.
<P>
<pre>    gap> TRE := TableRangeEndomorphismDerivations( XSC );;
    gap> PrintList( TRE );
    [ (4,5,6), (2,3)(5,6) ]
    [ (4,5,6), (2,3)(4,5) ]
    [ (4,5,6), (2,3)(4 6) ]
    [ (4,6,5), (2,3)(5,6) ]
    [ (4,6,5), (2,3)(4,5) ]
    [ (4,6,5), (2,3)(4,6) ]
    [ (), (2,3)(5,6) ]
    [ (), (2,3)(4,6) ]
    [ (), (2,3)(4,5) ]  </pre>
<P><A NAME="SECT109"><h2>80.109 XModEndomorphismDerivation</h2></a>
<P><P><P>
<code>XModEndomorphismDerivation( <var>chi</var> )</code>
<P>
The endomorphisms <code>sigma4</code>, <code>rho4</code> together determine a pair which may
be used   to construct   an endomorphism  of  <I><span style="font-family: cursive">  X</span></I>.    When the
derivation is regular, the resulting  morphism is an automorphism, and
this construction determines a  homomorphism from the  Whitehead group
to the automorphism group of <code>X</code>.
<P>
<pre>    gap> phi4 := XModEndomorphismDerivation( chi4 );
    Morphism of crossed modules &lt;[c3->s3]->[c3->s3]>  </pre>
<P><A NAME="SECT110"><h2>80.110 SourceEndomorphismSection</h2></a>
<P><P><P>
<code>SourceEndomorphismSection( <var>xi</var> )</code>
<P>
Each section  <I>&xi;</I>  determines an  endomorphism <I>&gamma;</I>  of <code>G</code> such
that <center><table><tr><td><I>&gamma; g =  (e h &xi; t g)(&xi;  t g<sup>-1</sup>) g (e  h g<sup>-1</sup>) (&xi; h
g).</I></td></tr></table></center>
<P>
<pre>    gap> gamma4 := SourceEndomorphismSection( xi4 );
    GroupHomomorphismByImages( c3^2|Xc2, c3^2|Xc2,
      [ (1,2,3), (4,5,6), (2,3)(5,6) ], [ (1,3,2), (4,6,5), (2,3)(5,6) ] )</pre>
<P><A NAME="SECT111"><h2>80.111 RangeEndomorphismSection</h2></a>
<P><P><P>
<code>RangeEndomorphismSection( <var>xi</var> )</code>
<P>
Each derivation <I>&xi;</I> determines  an  endomorphism <I>&rho;</I> of <code>R</code>  such
that <I>&rho; r = h &xi; r</I>.
<P>
<pre>    gap> rho4 := RangeEndomorphismSection( xi4 );
    GroupHomomorphismByImages( s3, s3, [ (4,5,6), (2,3)(5,6) ], 
      [ (4,6,5), (2,3)(5,6) ] )   </pre>
<P><A NAME="SECT112"><h2>80.112 Cat1EndomorphismSection</h2></a>
<P><P><P>
<code>Cat1EndomorphismSection( <var>xi</var> )</code>
<P>
The endomorphisms <code>gamma4</code>, <code>rho4</code> together determine a pair which may
be  used  to  construct an  endomorphism    of <I><span style="font-family: cursive">  C</span></I>.  When  the
derivation is regular, the  resulting morphism is an automorphism, and
this  construction determines a homomorphism  from the Whitehead group
to the automorphism group of <code>C</code>.
<P>
<pre>    gap> psi4 := Cat1EndomorphismSection( xi4 );
    Morphism of cat1-groups &lt;[c3^2|Xc2 ==> s3]-->[c3^2|Xc2 ==> s3]></pre>
<P>
\newpage
<P><A NAME="SECT113"><h2>80.113 About actors</h2></a>
<P><P><P>
The \emphactor  of <I><span style="font-family: cursive"> X</span></I> is a  crossed module <I>(&Delta; : <span style="font-family: cursive">
W</span>(<span style="font-family: cursive">  X</span>) &rarr; <I>   Aut</I>(<span style="font-family: cursive"> X</span>))</I> which  was shown  by Lue and
Norrie, in <A href="biblio.htm#xmodN2"><cite>xmodN2</cite></a> and <A href="biblio.htm#xmodN1"><cite>xmodN1</cite></a>  to give the automorphism object of
a crossed module <I><span style="font-family: cursive"> X</span></I>.  The source of the actor is a permutation
representation  <I>W</I> of the  Whitehead group of regular derivations and
the  range is a   permutation  representation <I>A</I> of the  automorphism
group <I><I> Aut</I>(<span style="font-family: cursive"> X</span>)</I> of <I><span style="font-family: cursive"> X</span></I>.
<P>
An automorphism <I>( &sigma;, &rho; )</I> of <code>X</code> acts on the Whitehead monoid
by  <I>&chi;<sup>(&sigma;,&rho;)</sup> =  &sigma;<sup>-1</sup>  &chi; &rho;</I>,  and this action
determines the action for the actor.
<P>
In fact the  four groups <I>R, S,  W, A</I>, the homomorphisms between them
and the various actions, form five crossed modules:
<P>
beg-tabular<s></s>rcll
   <I><span style="font-family: cursive"> X</span></I> &:& <I>S &rarr; R</I>  &  the initial crossed module,                 <BR> 
<I><span style="font-family: cursive"> W(X)</span></I> &:& <I>S &rarr; W</I>  &  the Whitehead crossed module of <I><span style="font-family: cursive"> X</span></I>, <BR> 
<I><span style="font-family: cursive"> L(X)</span></I> &:& <I>S &rarr; A</I>  &  the Lue crossed module of <I><span style="font-family: cursive"> X</span></I>,       <BR> 
<I><span style="font-family: cursive"> N(X)</span></I> &:& <I>R &rarr; A</I>  &  the Norrie crossed module of <I><span style="font-family: cursive"> X</span></I>, and <BR> 
<I><I> Act</I>(<span style="font-family: cursive"> X</span>)</I> &:& <I>W &rarr; A</I>  &  the actor crossed module of <I><span style="font-family: cursive"> X</span></I>.
end-tabular<s></s>
<P>
These <I>5</I> crossed modules, together with the evaluation  
<I>W &times; R &rarr; S,   (&chi;,r) &rarr; &chi; r</I>, 
form a crossed square:
<P>
<pre>                        S ------ WX ------> W
                        :  \                :
                        :     \             :
                        X        LX        ActX
                        :           \       :
                        :              \    :
                        V                 \ V
                        R ------ NX ------> A  </pre>
<P><P>
in which   pairs   of boundaries  or  identity  mappings   provide six
morphisms of crossed modules.   In particular, the boundaries of  <code>WX</code>
and <code>NX</code>   form the  \emphinner   morphism of  <code>X</code>,   mapping source
elements to   inner    derivations  and  range  elements     to  inner
automorphisms.   The image  of    <code>X</code> under  this  morphism  is    the
\emphinner actor  of <code>X</code>, while  the kernel  is the \emphcentre of
<code>X</code>.
<P>
In the example which follows, using the usual <code>(X1 : c5 -> Aut(c5))</code>,
 <code>Act(X1)</code>  is isomorphic to  <code>X1</code>  and to  <code>LX1</code>  
while the Whitehead and Norrie boundaries are identity homomorphisms.
<P>
<pre>    gap> X1;
    Crossed module [c5->PermAut(c5)]
    gap> WGX1 := WhiteheadPermGroup( X1 );
    WG([c5->PermAut(c5)])
    gap> WGX1.generators;
    [ (1,2,3,4,5) ]
    gap> AX1 := AutomorphismPermGroup( X1 );
    PermAut([c5->PermAut(c5)])
    gap> AX1.generators;
    [ (1,2,4,3) ]
    gap> XModMorphismAutoPerm( X1, AX1.generators[1] );
    Morphism of crossed modules &lt;[c5->PermAut(c5)] >-> [c5->PermAut(c5)]>

    gap> WX1 := Whitehead( X1 );
    Crossed module Whitehead[c5->PermAut(c5)]
    gap> NX1 := Norrie( X1 );
    Crossed module Norrie[c5->PermAut(c5)]
    gap> LX1 := Lue( X1 );
    Crossed module Lue[c5->PermAut(c5)]
    gap> ActX1 := Actor( X1 );;
    gap> XModPrint( ActX1);
    Crossed module Actor[c5->PermAut(c5)] :- 
    : Source group WG([c5->PermAut(c5)]) has generators:
      [ (1,2,3,4,5) ]
    : Range group has parent ( PermAut(c5)xPermAut(PermAut(c5)) )
        and has generators:  [ (1,2,4,3) ]
    : Boundary homomorphism maps source generators to:
      [ () ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,4,3) --> { source gens --> [ (1,3,5,2,4) ] }
      This automorphism generates the group of automorphisms.

    gap> InActX1 := InnerActor( X1 );
    Crossed module Actor[c5->PermAut(c5)]
    gap> InActX1 = ActX1;
    true
    gap> InnerMorphism( X1 );
    Morphism of crossed modules
        &lt;[c5->PermAut(c5)] >-> Actor[c5->PermAut(c5)]>
    gap> Centre( X1 );
    Crossed module Centre[c5->PermAut(c5)]  </pre>
<P>
All of these constructions are stored in a sub-record <code>X1.actorSquare</code>.
<P><A NAME="SECT114"><h2>80.114 ActorSquareRecord</h2></a>
<P><P>
<A name = "I69"></a>

<A name = "I70"></a>

<P>
<code>ActorSquareRecord( <var>X</var> )</code>
<P>
<code>ActorSquareRecord( <var>C</var> )</code>
<P>
This function  creates a   new  field <code>.actorSquare</code> for the   crossed
module or  cat1-group, initially  containing <code>.isActorSquare :=  true</code>
and <code>.xmod</code>  or <code>.cat1</code> as  appropriate.  Components for  the actor of
<code>X</code> or <code>C</code> are stored here when constructed.
<P>
<pre>    gap> ActorSquareRecord( X1 );
    rec(
      isActorSquare := true,
      xmod := Crossed module [c5->PermAut(c5)],
      WhiteheadPermGroup := WG([c5->PermAut(c5)]),
      automorphismPermGroup := PermAut([c5->PermAut(c5)]),
      Whitehead := Crossed module Whitehead[c5->PermAut(c5)],
      Norrie := Crossed module Norrie[c5->PermAut(c5)],
      Lue := Crossed module Lue[c5->PermAut(c5)],
      actor := Crossed module Actor[c5->PermAut(c5)],
      innerMorphism :=  Morphism of crossed modules
          &lt;[c5->PermAut(c5)] >-> Actor[c5->PermAut(c5)]>,
      innerActor := Crossed module Actor[c5->PermAut(c5)] )  </pre>
<P><A NAME="SECT115"><h2>80.115 WhiteheadPermGroup</h2></a>
<P><P><P>
<code>WhiteheadPermGroup( <var>X</var> )</code>
<P>
This  function     first        calls   <code>WhiteheadGroupTable</code>,     see
\refWhiteheadGroupTable.  These  lists   are  then   converted    to
permutations,  producing a  permutation group  which  is effectively a
regular representation of the group.  A field <code>.WhiteheadPermGroup</code> is
added to <code>X.actorSquare</code>  and  a field <code>.genpos</code>   is  added to  <pre>D  =
X.derivations</pre>.  The    latter  is a    list   of  the   positions  in
<code>D.genimageList</code> corresponding to the chosen generating elements.  The
group is given the name <code>WG(&lt;name of X>)</code>.
<P>
For  an example,  we  return to the  crossed  module <code>XSC  = [c3->s3]</code>
obtained  from the cat1-group <code>SC</code>  in  section \refCat1Select which
has Whitehead group and automorphism group isomorphic to <code>s3</code>.
<P>
<pre>    gap> WG := WhiteheadPermGroup( XSC );
    WG([c3->s3])
    gap> XSC.derivations.genpos;
    [ 2, 4 ]
    gap> Elements( WG );
    [ (), (1,2,3)(4,6,5), (1,3,2)(4,5,6), (1,4)(2,5)(3,6),
      (1,5)(2,6)(3,4), (1,6)(2,4)(3,5) ]  </pre>
<P><A NAME="SECT116"><h2>80.116 Whitehead crossed module</h2></a>
<P><P>
<A name = "I71"></a>

<P>
<code>Whitehead( <var>X</var> )</code>
<P>
This crossed module has the source of <code>X</code> as source, and the Whitehead
group  <code>WX</code>  as range.  The  boundary maps  each  element to the inner
derivation      which        it   defines.       The     action   uses
<code>SourceEndomorphismDerivation</code>.
<P>
<pre>    gap> WXSC := Whitehead( XSC );
    Crossed module Whitehead[c3->s3]
    gap> XModPrint( WXSC );
    Crossed module Whitehead[c3->s3] :- 
    : Source group has parent ( c3^2|Xc2 ) and has generators:
      [ (1,2,3)(4,6,5) ]
    : Range group = WG([c3->s3]) has generators:
      [ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
    : Boundary homomorphism maps source generators to:
      [ (1,3,2)(4,5,6) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3)(4,6,5) --> { source gens --> [ (1,2,3)(4,6,5) ] }
      (1,4)(2,5)(3,6) --> { source gens --> [ (1,3,2)(4,5,6) ] }
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT117"><h2>80.117 AutomorphismPermGroup for crossed modules</h2></a>
<P><P>
<A name = "I72"></a>

<P>
<code>XModOps.AutomorphismPermGroup( <var>X</var> )</code>
<P>
This function constructs  a permutation group  <code>PermAut(X)</code> isomorphic
to the  group of automorphisms  of the crossed  module <code>X</code>.  First the
automorphism groups  of the source and  range of  <code>X</code> are obtained and
<code>AutomorphismPair</code>  used to   obtain  permutation  representations  of
these.  The direct product of these permutation groups is constructed,
and the required  automorphism  group is  a  subgroup of   this direct
product.  The result is  stored as <code>X.automorphismPermGroup</code> which has
fields defining the various embeddings and projections.
<P>
<pre>    gap> autXSC := AutomorphismPermGroup( XSC );
    PermAut([c3->s3])
    gap> autXSC.projsrc;
    GroupHomomorphismByImages( PermAut([c3->s3]), PermAut(c3), 
    [ (5,6,7), (1,2)(3,4)(6,7) ], [ (), (1,2) ] )
    gap> autXSC.projrng;
    GroupHomomorphismByImages( PermAut([c3->s3]), PermAut(s3), 
    [ (5,6,7), (1,2)(3,4)(6,7) ], [ (3,4,5), (1,2)(4,5) ] )
    gap> autXSC.embedSourceAuto;
    GroupHomomorphismByImages( PermAut(c3), PermAut(c3)xPermAut(s3),
        [ (1,2) ], [ (1,2) ] )
    gap> autXSC.embedRangeAuto;
    GroupHomomorphismByImages( PermAut(s3), PermAut(c3)xPermAut(s3), 
    [ (3,5,4), (1,2)(4,5) ], [ (5,7,6), (3,4)(6,7) ] )
    gap> autXSC.autogens;
    [ [ GroupHomomorphismByImages( c3, c3, [ (1,2,3)(4,6,5) ],
            [ (1,2,3)(4,6,5) ] ), GroupHomomorphismByImages( s3, s3, 
            [ (4,5,6), (2,3)(5,6) ], [ (4,5,6), (2,3)(4,5) ] ) ], 
      [ GroupHomomorphismByImages( c3, c3, [ (1,2,3)(4,6,5) ], 
            [ (1,3,2)(4,5,6) ] ), GroupHomomorphismByImages( s3, s3, 
            [ (4,5,6), (2,3)(5,6) ], [ (4,6,5), (2,3)(5,6) ] ) ] ]   </pre>
<P><A NAME="SECT118"><h2>80.118 XModMorphismAutoPerm</h2></a>
<P><P><P>
<code>XModMorphismAutoPerm( <var>X, perm</var> )</code>
<P>
Given the  isomorphism between the automorphism group  of <code>X</code>  and its
permutation representation  <code>PermAut(X)</code>, an  element  of  the  latter
determines an automorphism of <code>X</code>.
<P>
<pre>    gap> XModMorphismAutoPerm( XSC, (1,2)(3,4)(6,7) );
    Morphism of crossed modules &lt;[c3->s3] >-> [c3->s3]>  </pre>
<P><A NAME="SECT119"><h2>80.119 ImageAutomorphismDerivation</h2></a>
<P><P><P>
<code>ImageAutomorphismDerivation( <var>mor, chi</var> )</code>
<P>
An automorphism <I>( &sigma;,  &rho; )</I> of  <code>X</code> acts on   the left on  the
Whitehead   monoid  by   <I></i><P><i><sup>(&sigma;,&rho;)</sup>&chi;   =  &sigma; &chi;
&rho;<sup>-1</sup></I>.  This   is   converted  to    a   right action    on   the
<code>WhiteheadPermGroup</code>.  In the  example we see  that <code>phi4</code> maps <code>chi8</code>
to <code>chi9</code>.
<P>
<pre>    gap> chi8im := ImageAutomorphismDerivation( phi4, chi8 );
    XModDerivationByImages( s3, c3, [ (4,5,6), (2,3)(5,6) ], 
       [ (1,2,3)(4,6,5), (1,3,2)(4,5,6) ] )
    gap> Position( allXSC.genimageList, chi8im.genimages );
    9  </pre>
<P><A NAME="SECT120"><h2>80.120 Norrie crossed module</h2></a>
<P><P><P>
<code>Norrie( <var>X</var> )</code>
<P>
This   crossed  module has  the   range  of  <code>X</code>   as  source and  the
automorphism permutation group of <code>X</code> as range.
<P>
<pre>    gap> NXSC := Norrie( XSC );
    Crossed module Norrie[c3->s3]
    gap> XModPrint( NXSC );

    Crossed module Norrie[c3->s3] :- 
    : Source group has parent ( c3^2|Xc2 ) and has generators:
      [ (4,5,6), (2,3)(5,6) ]
    : Range group has parent ( PermAut(c3)xPermAut(s3) ) and has
        generators: [ (5,6,7), (1,2)(3,4)(6,7) ]
    : Boundary homomorphism maps source generators to:
      [ (5,7,6), (1,2)(3,4)(6,7) ]
    : Action homomorphism maps range generators to automorphisms:
      (5,6,7) --> { source gens --> [ (4,5,6), (2,3)(4,5) ] }
      (1,2)(3,4)(6,7) --> { source gens --> [ (4,6,5), (2,3)(5,6) ] }
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT121"><h2>80.121 Lue crossed module</h2></a>
<P><P><P>
<code>Lue( <var>X</var> )</code>
<P>
This  crossed   module has  the  source of   <code>X</code>  as  source, and  the
automorphism permutation group of <code>X</code> as range.
<P>
<pre>    gap> LXSC := Lue( XSC );
    Crossed module Lue[c3->s3]
    gap> XModPrint( LXSC );

    Crossed module Lue[c3->s3] :- 
    : Source group has parent ( c3^2|Xc2 ) and has generators:
      [ (1,2,3)(4,6,5) ]
    : Range group has parent ( PermAut(c3)xPermAut(s3) ) and has
        generators: [ (5,6,7), (1,2)(3,4)(6,7) ]
    : Boundary homomorphism maps source generators to:
      [ (5,6,7) ]
    : Action homomorphism maps range generators to automorphisms:
      (5,6,7) --> { source gens --> [ (1,2,3)(4,6,5) ] }
      (1,2)(3,4)(6,7) --> { source gens --> [ (1,3,2)(4,5,6) ] }
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT122"><h2>80.122 Actor crossed module</h2></a>
<P><P>
<A name = "I73"></a>

<P>
<code>Actor( <var>X</var> )</code>
<P>
The actor  of a crossed module <code>X</code>  is a crossed module <code>Act(X)</code> which
has the  Whitehead group (of regular derivations)  as source group and
the automorphism  group <code>PermAut(X)</code>   of <code>X</code>  as  range  group.   The
boundary of <code>Act(X)</code> maps each derivation to the automorphism provided
by <code>XModEndomorphismDerivation</code>.   The action of  an automorphism on a
derivation is that provided by <code>ImageAutomorphismDerivation</code>.
<P>
<pre>    gap> ActXSC := Actor( XSC );
    Crossed module Actor[c3->s3]
    gap> XModPrint( ActXSC );

    Crossed module Actor[c3->s3] :- 
    : Source group WG([c3->s3]) has generators:
      [ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
    : Range group has parent ( PermAut(c3)xPermAut(s3) ) and has
        generators: [ (5,6,7), (1,2)(3,4)(6,7) ]
    : Boundary homomorphism maps source generators to:
      [ (5,7,6), (1,2)(3,4)(6,7) ]
    : Action homomorphism maps range generators to automorphisms:
      (5,6,7) --> { source gens --> [ (1,2,3)(4,6,5), (1,6)(2,4)(3,5) ] }
      (1,2)(3,4)(6,7) -->
                  { source gens --> [ (1,3,2)(4,5,6), (1,4)(2,5)(3,6) ] }
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT123"><h2>80.123 InnerMorphism for crossed modules</h2></a>
<P><P>
<A name = "I74"></a>

<P>
<code>InnerMorphism( <var>X</var> )</code>
<P>
The boundary maps of <code>WX</code> and <code>NX</code> form a morphism from <code>X</code> to its actor.
<P>
<pre>    gap> innXSC := InnerMorphism( XSC );
    Morphism of crossed modules &lt;[c3->s3] >-> Actor[c3->s3]>
    gap> XModMorphismPrint( innXSC );
    Morphism of crossed modules :- 
    : Source = Crossed module [c3->s3] with generating sets:
      [ (1,2,3)(4,6,5) ]
      [ (4,5,6), (2,3)(5,6) ]
    :  Range = Crossed module Actor[c3->s3]
          with generating sets:
      [ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
      [ (5,6,7), (1,2)(3,4)(6,7) ]
    : Source Homomorphism maps source generators to:
      [ (1,3,2)(4,5,6) ]
    : Range Homomorphism maps range generators to:
      [ (5,7,6), (1,2)(3,4)(6,7) ]
    : isXModMorphism? true  </pre>
<P><A NAME="SECT124"><h2>80.124 Centre for crossed modules</h2></a>
<P><P>
<A name = "I75"></a>

<P>
<code>XModOps.Centre( <var>X</var> )</code>
<P>
The kernel of the inner morphism  <code>X -> ActX</code> is  called the centre of
<code>X</code>, generalising the centre of a group <I>G</I>, which is the kernel of <I>G
&rarr; Aut(G),   g &rarr; (h &rarr; h<sup>g</sup>)</I>.  In this example the centre
is trivial.
<P>
<pre>    gap> ZXSC := Centre( XSC );
    Crossed module Centre[c3->s3]  </pre>
<P><A NAME="SECT125"><h2>80.125 InnerActor for crossed modules</h2></a>
<P><P>
<A name = "I76"></a>

<P>
<code>InnerActor( <var>X</var> )</code>
<P>
The inner actor of <code>X</code> is the image of the inner morphism.
<P>
<pre>    gap> InnActXSC := InnerActor( XSC );
    Crossed module InnerActor[c3->s3] 
    gap> XModPrint( InnActXSC );

    Crossed module InnerActor[c3->s3] :- 
    : Source group has parent ( WG([c3->s3]) ) and has generators:
      [ (1,3,2)(4,5,6) ]
    : Range group has parent ( PermAut(c3)xPermAut(s3) ) and has
        generators: [ (5,7,6), (1,2)(3,4)(6,7) ]
    : Boundary homomorphism maps source generators to:
      [ (5,6,7) ]
    : Action homomorphism maps range generators to automorphisms:
      (5,7,6) --> { source gens --> [ (1,3,2)(4,5,6) ] }
      (1,2)(3,4)(6,7) --> { source gens --> [ (1,2,3)(4,6,5) ] }
      These 2 automorphisms generate the group of automorphisms.  </pre>
<P><A NAME="SECT126"><h2>80.126 Actor for cat1-groups</h2></a>
<P><P>
<A name = "I77"></a>

<P>
<code>Actor( <var>C</var> )</code>
<P>
The actor of  a cat1-group <I><span style="font-family: cursive"> C</span></I> is  the cat1-group associated to
the actor crossed module  of the crossed  module <I><span style="font-family: cursive"> X</span></I> associated
to <I><span style="font-family: cursive"> C</span></I>.  Its range is the automorphism group <I>A</I> and its source
is <I>A \semidirect W</I> where <I>W</I> is the Whitehead group.
<P>
<pre>    gap> ActSC := Actor( SC );;
    gap> Cat1Print( ActSC );
    cat1-group Actor[c3^2|Xc2 ==> s3] :- 
    : source group has generators:
      [ (4,6,5), (2,3)(5,6), (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
    :  range group has generators:
      [ (5,6,7), (1,2)(3,4)(6,7) ]
    : tail homomorphism maps source generators to:
      [ (5,6,7), (1,2)(3,4)(6,7), (), () ]
    : head homomorphism maps source generators to:
      [ (5,6,7), (1,2)(3,4)(6,7), (5,7,6), (1,2)(3,4)(6,7) ]
    : range embedding maps range generators to:
      [ (4,6,5), (2,3)(5,6) ]
    : kernel has generators:
      [ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
    : boundary homomorphism maps generators of kernel to:
      [ (5,7,6), (1,2)(3,4)(6,7) ]
    : kernel embedding maps generators of kernel to:
      [ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ]
    : associated crossed module is Crossed module Actor[c3->s3]  </pre>
<P>
\newpage
<P><A NAME="SECT127"><h2>80.127 About induced constructions</h2></a>
<P><P><P>
A morphism of crossed modules <I>(&sigma;, &rho;) :  <span style="font-family: cursive"> X</span><sub>1</sub> &rarr; <span style="font-family: cursive">
X</span><sub>2</sub></I> factors uniquely through an  induced crossed module <I>&rho;<sub>*</sub>
<span style="font-family: cursive">  X</span><sub>1</sub> =   (&delta; : &rho;<sub>*</sub>  S<sub>1</sub> &rarr;   R<sub>2</sub>)</I>.  Similarly, a
morphism   of  cat1-groups  factors    through an induced  cat1-group.
Calculation of induced crossed modules of  <I><span style="font-family: cursive"> X</span></I> also provides an
algebraic  means  of determining  the   homotopy <I>2</I>-type  of homotopy
pushouts of the classifying space of <I><span style="font-family: cursive">  X</span></I>.  For more background
from   algebraic  topology see  references in  <A href="biblio.htm#xmodBH1"><cite>xmodBH1</cite></a>, <A href="biblio.htm#xmodBW1"><cite>xmodBW1</cite></a>,
<A href="biblio.htm#xmodBW2"><cite>xmodBW2</cite></a>.  Induced crossed   modules  and induced cat1-groups   also
provide the   building    blocks for constructing     pushouts  in the
categories
\textbfXMod and \textbfCat1.
<P>
Data for the cases of algebraic interest  is provided by a conjugation
crossed module <I><span style="font-family: cursive"> X</span> =  (&part; : S &rarr;  R)</I> and a homomorphism
<I>&iota;</I>  from   <I>R</I>  to a  third   group  <I>Q</I>.   The  output  from the
calculation is   a crossed module  <I>&iota;<sub>*</sub><span style="font-family: cursive">  X</span> = (&delta; :
&iota;<sub>*</sub>S  &rarr; Q)</I> together  with   a morphism of crossed  modules
<I><span style="font-family: cursive"> X</span>  &rarr; &iota;<sub>*</sub><span style="font-family: cursive">  X</span></I>.   When <I>&iota;</I> is  a surjection
with kernel <I>K</I> then <I>&iota;<sub>*</sub> S =  [S,K]</I> (see <A href="biblio.htm#xmodBH1"><cite>xmodBH1</cite></a>).  When
<I>&iota;</I> is an  inclusion the induced  crossed module may be calculated
using  a copower construction  <A href="biblio.htm#xmodBW1"><cite>xmodBW1</cite></a> or, in  the case when <I>R</I> is
normal in <I>Q</I>, as a coproduct  of crossed modules (<A href="biblio.htm#xmodBW2"><cite>xmodBW2</cite></a>, not yet
implemented).  When <I>&iota;</I> is  neither a surjection nor an inclusion,
<I>&iota;</I> is written as  the composite of the  surjection onto the image
and the inclusion of the image in  <I>Q</I>, and then the composite induced
crossed module is constructed.
<P>
Other functions  required  by the induced  crossed module construction
include a  function to produce a common  transversal  for the left and
right cosets  of   a   subgroup (see \refIsCommonTransversal     and
\refCommonTransversal).  Also, modifications to  some of  the Tietze
transformation routines in  <code>fptietze.g</code> are required.  These have yet
to be released as part of the <strong>GAP3</strong> library and so are made available
in this package in file <code>felsch.g</code>, but are not documented here.
<P>
As a simple example  we take for <I><span style="font-family: cursive">   X</span></I> the conjugation  crossed
module <I>(&part; : c4 &rarr; d8)</I> and for <I>&iota;</I> the inclusion of <I>d8</I>
in <I>d16</I>.  The induced crossed module has <I>c4 &times; c4</I> as source.
<P>
<pre>    gap> d16 := DihedralGroup( 16 );  d16.name := "d16";;
    Group( (1,2,3,4,5,6,7,8), (2,8)(3,7)(4,6) )
    gap> d8 := Subgroup( d16, [ (1,3,5,7)(2,4,6,8), (1,3)(4,8)(5,7) ] );;
    gap> c4 := Subgroup( d8, [ (1,3,5,7)(2,4,6,8) ] );;
    gap> d8.name :=  "d8";;  c4.name := "c4";;
    gap> DX := ConjugationXMod( d8, c4 );
    Crossed module [c4->d8]
    gap> iota := InclusionMorphism( d8, d16 );;
    gap> IDXincl := InducedXMod( DX, iota );
    Action of RQ on generators of I :- 
      (1,2,3,4,5,6,7,8) : (1,4)(2,3)
      (2,8)(3,7)(4,6) : (1,2)(3,4)
    </pre><code>#</code><pre>I  Protecting the first 1 generators.
    </pre><code>#</code><pre>I  there are 2 generators and 3 relators of total length 12
    partitioning the generators: [ [ 2 ], [ 1 ] ]
    Simplified presentation for I :- 
    </pre><code>#</code><pre>I  generators: [ fI.1, fI.3 ]
    </pre><code>#</code><pre>I  relators:
    </pre><code>#</code><pre>I  1.  4  [ 1, 1, 1, 1 ]
    </pre><code>#</code><pre>I  2.  4  [ 2, 2, 2, 2 ]
    </pre><code>#</code><pre>I  3.  4  [ 2, -1, -2, 1 ]

     I has Size: 16
    **************** 

    Group is abelian 
    factor 1 is abelian with invariants: [ 4 ]
    factor 2 is abelian with invariants: [ 4 ]
    Image of I has index 4 in RQ and is generated by :   
    [ ( 1, 3, 5, 7)( 2, 4, 6, 8), ( 1, 7, 5, 3)( 2, 8, 6, 4) ]

    gap> XModPrint( IDXincl );
    Crossed module [i*(c4)->d16] :- 
    : Source group i*(c4) has generators:
      [ ( 1, 2, 4, 7)( 3, 5, 8,11)( 6, 9,12,14)(10,13,15,16), 
        ( 1, 3, 6,10)( 2, 5, 9,13)( 4, 8,12,15)( 7,11,14,16) ]
    : Range group = d16 has generators:
      [ (1,2,3,4,5,6,7,8), (2,8)(3,7)(4,6) ]
    : Boundary homomorphism maps source generators to:
      [ ( 1, 3, 5, 7)( 2, 4, 6, 8), ( 1, 7, 5, 3)( 2, 8, 6, 4) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2,3,4,5,6,7,8) --> { source gens --> 
    [ ( 1,10, 6, 3)( 2,13, 9, 5)( 4,15,12, 8)( 7,16,14,11), 
      ( 1, 7, 4, 2)( 3,11, 8, 5)( 6,14,12, 9)(10,16,15,13) ] }
      (2,8)(3,7)(4,6) --> { source gens --> 
    [ ( 1, 7, 4, 2)( 3,11, 8, 5)( 6,14,12, 9)(10,16,15,13), 
      ( 1,10, 6, 3)( 2,13, 9, 5)( 4,15,12, 8)( 7,16,14,11) ] }
      These 2 automorphisms generate the group of automorphisms.
    : Kernel of the crossed module has generators:
      [ ( 1, 5,12,16)( 2, 8,14,10)( 3, 9,15, 7)( 4,11, 6,13) ]
    : Induced XMod from Crossed module [c4->d8]  with source morphism:
      [ (1,3,5,7)(2,4,6,8) ]
       --> [ ( 1, 2, 4, 7)( 3, 5, 8,11)( 6, 9,12,14)(10,13,15,16) ]  </pre>
<P>
In some of the sections which follow the output is very lengthy and so
has been pruned.
<P><A NAME="SECT128"><h2>80.128 InducedXMod</h2></a>
<P><P><P>
<code>InducedXMod( <var>X, iota</var> )</code>
<P>
<code>InducedXMod( <var>Q, P, M</var> )</code>
<P>
This function requires as data a  conjugation crossed module <I><span style="font-family: cursive"> X</span>
= (&part; : M &rarr; P)</I> and a homomorphism <I>&iota;  : P &rarr; Q</I>.  This
data may  be specified using either of  the two forms shown, where the
latter form required <I>Q  &ge; P  &ge; M</I>.
<P>
In the first example, <I>&iota;</I> is a surjection from <code>d8</code> to <code>k4</code>.
<P>
<pre>    gap> d8gen := d8.generators;
    [ (1,3,5,7)(2,4,6,8), (1,3)(4,8)(5,7) ]
    gap> k4gen := k4.generators;
    [ (1,2)(3,4), (1,3)(2,4) ]
    gap> DX;
    Crossed module [c4->d8]
    gap> iota := GroupHomomorphismByImages( d8, k4, d8gen, k4gen );;
    gap> IDXsurj := InducedXMod( DX, iota );
    Crossed module [c4/ker->k4]
    gap> XModPrint( IDXsurj );
    Crossed module [c4/ker->k4] :- 
    : Source group c4/ker has generators:
      [ (1,2,3,4) ]
    : Range group has parent ( s4 ) and has generators:
      [ (1,2)(3,4), (1,3)(2,4) ]
    : Boundary homomorphism maps source generators to:
      [ ( 1, 2)( 3, 4) ]
    : Action homomorphism maps range generators to automorphisms:
      (1,2)(3,4) --> { source gens --> [ (1,2,3,4) ] }
      (1,3)(2,4) --> { source gens --> [ (1,4,3,2) ] }
      These 2 automorphisms generate the group of automorphisms.
    : Induced XMod from Crossed module [c4->d8]  with source morphism:
      [ (1,3,5,7)(2,4,6,8) ]
       --> [ (1,2,3,4) ]    </pre>
<P>
In a second example we take <code>(c3 -> s3)</code> as the initial crossed module
and <code>s3 -> s4</code>  as the inclusion.  The  induced group turns out  to be
the special linear group <code>sl(2,3)</code>.
<P>
<pre>    gap> s3 := Subgroup( s4, [ (2,3), (1,2,3) ] );;
    gap> c3 := Subgroup( s3, [ (1,2,3) ] );
    gap> s3.name := "s3";;  c3.name := "c3";;
    gap> InducedXMod( s4, s3, c3 );

    Action of RQ on generators of I :- 
      (1,2,3,4) : (1,7,6,3)(2,8,5,4)
      (1,2) : (1,2)(3,4)(5,8)(6,7)
    </pre><code>#</code><pre>I  Protecting the first 1 generators.
    </pre><code>#</code><pre>I  there are 2 generators and 3 relators of total length 12
    Simplified presentation for I :- 
    </pre><code>#</code><pre>I  generators: [ fI.1, fI.5 ]
    </pre><code>#</code><pre>I  relators:
    </pre><code>#</code><pre>I  1.  3  [ 2, 2, 2 ]
    </pre><code>#</code><pre>I  2.  3  [ 1, 1, 1 ]
    </pre><code>#</code><pre>I  3.  6  [ 2, -1, -2, 1, -2, -1 ]

     I has Size: 24
    **************** 
     Searching Solvable Groups Library:
     GroupId = 
    rec(
      catalogue := [ 24, 14 ],
      names := [ "SL(2,3)" ],
      size := 24 )
    Image of I has index 2 in RQ and is generated by : 
    [ (1,2,3), (1,2,4), (1,4,3), (2,3,4) ]

    Crossed module [i*(c3)->s4]            </pre>
<P><A NAME="SECT129"><h2>80.129 AllInducedXMods</h2></a>
<P><P><P>
<code>AllInducedXMods( <var>Q</var> )</code>
<P>
This function calculates <code>InducedXMod( Q, P, M )</code>  where <code>P</code> runs over
all conjugacy classes of subgroups of <code>Q</code> and <code>M</code> runs over all normal
subgroups of <code>P</code>.
<P>
<pre>    gap> AllInducedXMods( d8 );
           </pre> <I>&sdot;</I> <pre>
    Number of induced crossed modules calculated = 11  </pre>
<P><A NAME="SECT130"><h2>80.130 InducedCat1</h2></a>
<P><P><P>
<code>InducedCat1( <var>C, iota</var> )</code>
<P>
When <I><span style="font-family: cursive"> C</span></I> is the induced cat1-group associated to <I><span style="font-family: cursive"> X</span></I> the
induced cat1-group may be obtained by construction the induced crossed
module   and then using  the  <code>Cat1XMod</code>  function.   An experimental,
alternative  procedure   is  to  calculate    the induced   cat1-group
<I>&iota;<sub>*</sub> G = G  *<sub>R</sub> Q</I> directly.  This  has been implemented for
the case when <I><span style="font-family: cursive"> C</span> = ( e;t,h : G &rarr; R)</I> and <I>&iota;  : R &rarr; Q</I>
is an inclusion.
<P>
The output  from the  calculation is a   cat1-group  <I><span style="font-family: cursive"> C</span><sub>*</sub>  =
(e<sub>*</sub>;t<sub>*</sub>,   h<sub>*</sub> : &iota;<sub>*</sub>G    &rarr; Q)</I>  together  with a
morphism of crossed modules <I><span style="font-family: cursive"> C</span> &rarr; <span style="font-family: cursive"> C</span><sub>*</sub></I>.
<P>
In  the example an induced  cat1-group is constructed whose associated
crossed module has  source  <I>c4 &times;  c4</I>  and range <I>d16</I>,  so  the
source of the cat1-group is <I>d16 \semidirect (c4 &times; c4)</I>.
<P>
<pre>    gap> CDX := Cat1XMod( DX );
    cat1-group [Perm(d8 |X c4) ==> d8] 
    gap> inc := InclusionMorphism( d8, d16 );;
    gap> ICDX := InducedCat1( CDX, inc );
          </pre> <I>&sdot;</I> <pre>
    new perm group size 256
    cat1-group &lt;ICG([Perm(d8 |X c4) ==> d8])> 
    gap> XICDX := XModCat1( ICDX );
    Crossed module [ker(&lt;ICG([Perm(d8 |X c4) ==> d8])>)->d16]
    gap> AbelianInvariants( XICDX.source );
    [ 4, 4 ]  </pre>
<P>
\newpage
<P><A NAME="SECT131"><h2>80.131 About utilities</h2></a>
<P><P><P>
By a utility function we mean a <strong>GAP3</strong> function which is:

<P>&bull; needed by other functions in this package,
<P>&bull; not (as far as we know) provided by the standard <strong>GAP3</strong> library,
<P>&bull; more suitable for inclusion in the main library than in this package.

<P>
The  first   two   utilities   give  particular  group  homomorphisms,
<code>InclusionMorphism(H,G)</code> and <code>ZeroMorphism(G,H)</code>.  We often prefer
<P>
<pre>    gap> incs3 := InclusionMorphism( s3, s3 );
    IdentityMapping( s3 )
    gap> incs3.genimages;
    [ (1,2), (2,3) ]  </pre>
<P>
to <code>IdentityMapping(s3)</code> because   the  latter does   not  provide the
fields <code>.generators</code> and the <code>.genimages</code> which  many of the functions
in this package expect homomorphisms to possess.
<P>
The second set of utilities involve endomorphisms and automorphisms of
groups.  For example:
<P>
<pre>    gap> end8 := EndomorphismClasses( d8 );;
    gap> RecFields( end8 );
    [ "isDomain", "isEndomorphismClasses", "areNonTrivial", "classes",
      "intersectionFree", "group", "latticeLength", "latticeReps" ]
    gap> Length( end8.classes );
    11
    gap> end8.classes[3];
    rec(
      quotient := d8.Q3,
      projection := OperationHomomorphism( d8, d8.Q3 ),
      autoGroup := Group( IdentityMapping( d8.Q3 ) ),
      rangeNumber := 2,
      isomorphism := GroupHomomorphismByImages( d8.Q3, d8.H2, [ (1,2) ], 
        [ (1,5)(2,6)(3,7)(4,8) ] ),
      conj := [ () ] )
    gap> innd8 := InnerAutomorphismGroup( d8 );
    Inn(d8)
    gap> innd8.generators;
    [ InnerAutomorphism( d8, (1,3,5,7)(2,4,6,8) ), 
      InnerAutomorphism( d8, (1,3)(4,8)(5,7) ) ]
    gap> IsAutomorphismGroup( innd8 );
    true   </pre>
<P>
The third set of functions construct isomorphic pairs of groups, where
a  faithful permutation  representation of a  given  type of group  is
constructed.  Types covered include  finitely presented groups, groups
of automorphisms   and  semidirect products.   A  typical pair  record
includes the following fields:
<P>
beg-tabular<s></s>ll
.type         &  the given group <I>G</I>,                <BR> 
.perm         &  the permutation representation <I>P</I>, <BR> 
.t2p          &  the isomorphism  <I>G &rarr; P</I>,         <BR> 
.p2t          &  the inverse isomorphism  <I>P &rarr; G</I>, <BR> 
.isTypePair   &  a boolean flag, normally <code>true</code>.
end-tabular<s></s>
<P>
The inner automorphism group of the dihedral  group <code>d8</code> is isomorphic
to <code>k4</code>:
<P>
<pre>    gap> Apair := AutomorphismPair( innd8 );
    rec(
      auto := Inn(d8),
      perm := PermInn(d8),
      a2p := OperationHomomorphism( Inn(d8), PermInn(d8) ),
      p2a := GroupHomomorphismByImages( PermInn(d8), Inn(d8),
        [ (1,3), (2,4) ], 
        [ InnerAutomorphism( d8, (1,3,5,7)(2,4,6,8) ), 
          InnerAutomorphism( d8, (1,3)(4,8)(5,7) ) ] ),
      isAutomorphismPair := true )
    gap> IsAutomorphismPair( Apair );
    true  </pre>
<P>
The final set of functions deal with lists of  subsets of <code>[1..n]</code> and
construct systems of distinct and common representatives using simple,
non-recursive, combinatorial algorithms.   The latter function returns
two lists:  the  set of representatives,   and a permutation of  the
subsets of the second list.   It may also be used  to provide a common
transversal for sets of left and right  cosets of a  subgroup <I>H</I> of a
group <I>G</I>, although a greedy algorithm is usually quicker.
<P>
<pre>    gap> L := [ [1,4], [1,2], [2,3], [1,3], [5] ];;
    gap> DistinctRepresentatives( L );
    [ 4, 2, 3, 1, 5 ]
    gap> M := [ [2,5], [3,5], [4,5], [1,2,3], [1,2,3] ];;
    gap> CommonRepresentatives( L, M );
    [ [ 4, 1, 3, 1, 5 ], [ 3, 5, 2, 4, 1 ] ]
    gap> CommonTransversal( s4, c3 );
    [ (), (3,4), (2,3), (1,3)(2,4), (1,2)(3,4), (2,4), (1,4), (1,4)(2,3) ] </pre>
<P><A NAME="SECT132"><h2>80.132 InclusionMorphism</h2></a>
<P><P>
<A name = "I78"></a>

<P>
<code>InclusionMorphism( <var>H, G</var> )</code>
<P>
This gives the inclusion map of a subgroup <I>H</I> of a group <I>G</I>.  In the
case  that <I>H=G</I> the   <code>IdentityMapping(G)</code>  is returned, with  fields
<code>.generators</code> and <code>.genimages</code> added.
<P>
<pre>    gap> s4 := Group( (1,2,3,4), (1,2) );; s4.name:="s4";;
    gap> a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; a4.name:="a4";;
    gap> InclusionMorphism( a4, s4 );
    GroupHomomorphismByImages( a4, s4, [ (1,2,3), (2,3,4) ],
      [ (1,2,3), (2,3,4) ] ) </pre>
<P><A NAME="SECT133"><h2>80.133 ZeroMorphism</h2></a>
<P><P>
<A name = "I79"></a>

<P>
<code>ZeroMorphism( <var>G, H</var> )</code>
<P>
This gives the zero map from  <I>G</I>  to the identity subgroup of  <I>H</I>.
<P>
<pre>    gap> ZeroMorphism( s4, a4 );
    GroupHomomorphismByImages( s4, a4, [ (1,2,3,4), (1,2) ], [ (), () ] ) </pre>
<P><A NAME="SECT134"><h2>80.134 EndomorphismClasses</h2></a>
<P><P><P>
<code>EndomorphismClasses( <var>G, case</var> )</code>
<P>
The monoid of endomorphisms is required when calculating the monoid of
derivations of    a   crossed module and  when    determining  all the
cat1-structures on a group <I>G</I>  (see sections \refAllDerivations and
\refAllSections).
<P>
An endomorphism <I>&epsilon;</I> of  <I>R</I>  with image <I>H<sup>&prime;</sup></I> is determined by

<P>&bull;  a normal subgroup <I>N</I> of <I>R</I> and a permutation representation 
       <I>&theta; : R/N &rarr; Q</I>  of the quotient,
       giving a projection  <I>&theta; o &nu; : R &rarr; Q </I>,
       where  <I>&nu; : R &rarr; R/N</I>  is the natural homomorphism;
<P>&bull;  an automorphism  <I>&alpha;</I>  of  <I>Q</I>;
<P>&bull;  a subgroup  <I>H<sup>&prime;</sup></I>  in a conjugacy class  <I>[H]</I>
       of subgroups of  <I>R</I>
       isomorphic to  <I>Q</I>  having representative  <I>H</I>,
       an isomorphism  <I>&phi; : Q &cong; H</I>,
       and a conjugating element  <I>c &isin; R</I>
       such that  <I>H<sup>c</sup> = H<sup>&prime;</sup></I>,

and takes values
<center><table><tr><td><I>&epsilon; r   =   (&phi; &alpha; &theta; &nu; r)<sup>c</sup>.</I></td></tr></table></center>
<P>
Endomorphisms are placed  in  the same  class  if they  have the  same
choice of <I>N</I> and <I>[H]</I>, so the number of endomorphisms is
<center>
<code>\|</code><I>\mathrmEnd(R)</I><code>\|</code><I> =   &sum;<sub>classes</sub></I>
<code>\|</code><I>\mathrmAut(Q)</I><code>\|</code> <code>\|</code><I>[H]</I><code>\|</code>.
</center>
The function returns records <code>E  = R.endomorphismClasses</code> and subfield
<code>.classes</code> as  shown below.  Three  cases are catered for as indicated
in the example.
<P>
<pre>    gap> Ea4 := EndomorphismClasses( a4 , 7);
    Usage:  EndomorphismClasses( G [, case] );
     choose  case = 1  to include automorphisms and zero,
    default  case = 2  to exclude automorphisms and zero,
             case = 3  when  N meet H  is trivial,
    false
    gap> Ea4 := EndomorphismClasses( a4 );
    rec(
      isDomain := true,
      isEndomorphismClasses := true,
      areNonTrivial := true,
      intersectionFree := false,
      classes := [ rec(
              quotient := a4.Q2,
              projection := OperationHomomorphism( a4, a4.Q2 ),
              autoGroup := Group( GroupHomomorphismByImages( a4.Q2, a4.Q2, 
                [ (1,3,2) ], [ (1,2,3) ] ) ),
              rangeNumber := 3,
              isomorphism := GroupHomomorphismByImages( a4.Q2, a4.H3, 
                [ (1,3,2) ], [ (2,3,4) ] ),
              conj := [ (), (1,3,2), (1,2)(3,4), (1,4,2) ] ) ],
      group := a4,
      latticeLength := 5,
      latticeReps := [ a4.id, a4.H2, a4.H3, a4.H4, a4 ] ) </pre>
<P><A NAME="SECT135"><h2>80.135 EndomorphismImages</h2></a>
<P><P><P>
<code>EndomorphismImages( <var>G</var> )</code>
<P>
This returns   the   lists of  images   of the  generators  under  the
endomorphisms, using the  data  in <code>G.endomorphismClasses</code>.    In this
example two trivial   normal   subgroups  have been   excluded.    The
remaining normal subgroup of <code>a4</code> is <code>k4</code>, with quotient <code>c3</code> and <code>a4</code>
has 8 elements of  order 3 with which to  generate a <code>c3</code>, and hence 8
endomorphisms in this class.
<P>
<pre>    gap> EndomorphismImages( a4 );
    [ [ (2,3,4), (2,4,3) ], [ (2,4,3), (2,3,4) ], [ (1,2,4), (1,4,2) ], 
      [ (1,4,2), (1,2,4) ], [ (1,4,3), (1,3,4) ], [ (1,3,4), (1,4,3) ], 
      [ (1,3,2), (1,2,3) ], [ (1,2,3), (1,3,2) ] ]  </pre>
<P><A NAME="SECT136"><h2>80.136 IdempotentImages</h2></a>
<P><P><P>
<code>IdempotentImages( <var>G</var> )</code>
<P>
This return the  images of idempotent endomorphisms.   Various options
are allowed.
<P>
<pre>    gap> IdempotentImages( a4, 7 );
    Usage: IdempotentImages( G [, case] );
    where  case = 1  for ALL idempotent images,
           case = 2  for all non-trivial images,
           case = 3  for case 2 and one group per conj class,
           case = 4  for case 3 and sorted into images.
    false
    gap> IdempotentImages( a4, 2 );
    [ [ (2,4,3), (2,3,4) ], [ (1,4,2), (1,2,4) ], [ (1,3,4), (1,4,3) ], 
      [ (1,2,3), (1,3,2) ] ]
    gap> IdempotentImages( a4, 3 );
    [ [ (2,4,3), (2,3,4) ] ]           </pre>
<P><A NAME="SECT137"><h2>80.137 InnerAutomorphismGroup</h2></a>
<P><P>
<A name = "I80"></a>

<P>
<code>InnerAutomorphismGroup( <var> G </var> )</code>
<P>
This creates  the inner automorphism    group of  <code>G</code>  as the    group
generated by the inner automorphisms by generators of <code>G</code>.  If a field
<code>G.automorphismGroup</code>  exists, it  is   specified  as the  parent   of
<code>Inn(G)</code>.
<P>
<pre>    gap> inna4 := InnerAutomorphismGroup( a4 );
    Inn(a4)
    gap> inna4.generators;
    [ InnerAutomorphism( a4, (1,2,3) ), InnerAutomorphism( a4, (2,3,4) ) ]</pre>
<P><A NAME="SECT138"><h2>80.138 IsAutomorphismGroup</h2></a>
<P><P>
<A name = "I81"></a>

<P>
<code>IsAutomorphismGroup( <var>A</var> )</code>
<P>
This tests to see whether <code>A</code> is a group of automorphisms.
<P>
<pre>    gap> IsAutomorphismGroup( inna4 );
    true </pre>
<P><A NAME="SECT139"><h2>80.139 AutomorphismPair</h2></a>
<P><P>
<A name = "I82"></a>

<P>
<code>AutomorphismPair( <var>A</var> )</code>
<P>
This   returns  a   record <code>pairA</code>  containing    a  permutation group
isomorphic to the group <I>A</I> obtained using the <code>OperationHomomorphism</code>
function.       The record contains   <I>A</I>    and  <code>pairA.auto</code>, <I>P</I> as
<code>pairA.perm</code>.  Isomorphisms in each direction are saved as <code>pairA.p2a</code>
and <code>pairA.a2p</code>.
<P>
<pre>    gap> ac3 := AutomorphismGroup( c3 );
    Group( GroupHomomorphismByImages( c3, c3, [(1,2,3)], [(1,3,2)] ) )
    gap> pairc3 := AutomorphismPair( ac3 );
    rec(
      auto := Aut(c3),
      perm := PermAut(c3),
      a2p := OperationHomomorphism( Aut(c3), PermAut(c3) ),
      p2a := GroupHomomorphismByImages( PermAut(c3), Aut(c3), [(1,2)], 
        [ GroupHomomorphismByImages( c3, c3, [(1,2,3)], [(1,3,2)] ) ] ),
      isAutomorphismPair := true )
    gap> pc3 := pairc3.perm;
    PermAut(c3)  </pre>
<P><A NAME="SECT140"><h2>80.140 IsAutomorphismPair</h2></a>
<P><P>
<A name = "I83"></a>

<P>
<code>IsAutomorphismPair( <var>pair</var> )</code>
<P>
This tests to see whether <code>pair</code> is an (automorphism group, perm group) pair.
<P>
<pre>    gap> IsAutomorphismPair( pairc3 );
    true </pre>
<P><A NAME="SECT141"><h2>80.141 AutomorphismPermGroup</h2></a>
<P><P>
<A name = "I84"></a>

<P>
<code>AutomorphismPermGroup( <var> G </var> )</code>
<P>
This    combines  <code>AutomorphismGroup(G)</code>     with  the        function
<code>AutomorphismPair</code>                       and                   returns
<code>G.automorphismGroup.automorphismPair.perm</code>.            The       name
<code>PermAut(&lt;G.name>)</code> is given automatically.
<P>
<pre>    gap> P := AutomorphismPermGroup( a4 );
    PermAut(a4)
    gap> P.generators;
    [ (1,8,4)(2,6,7), (3,6,7)(4,5,8), (1,2)(3,8)(4,7)(5,6) ]  </pre>
<P><A NAME="SECT142"><h2>80.142 FpPair</h2></a>
<P><P>
<A name = "I85"></a>

<P>
<code>FpPair( <var>G</var> )</code>
<P>
When <I>G</I> is a finitely presented group, this function finds a faithful
permutation     representation  <I>P</I>,   which    may    be  the regular
representation, and sets up a pairing between <I>G</I> and <I>P</I>.
<P>
<pre>    gap> f := FreeGroup( 2 );;
    gap> rels := [ f.1^3, f.2^3, (f.1*f.2)^2 ];;
    gap> g := f/rels;;
    gap> pairg := FpPair( g );
    rec(
      perm := Group( (2,4,3), (1,3,2) ),
      fp := Group( f.1, f.2 ),
      f2p := GroupHomomorphismByImages( Group( f.1, f.2 ), 
        Group( (2,4,3), (1,3,2) ), [ f.1, f.2 ], [ (2,4,3), (1,3,2) ] ),
      p2f := GroupHomomorphismByImages( Group( (2,4,3), (1,3,2) ),
        Group( f.1, f.2 ), [ (2,4,3), (1,3,2) ], [ f.1, f.2 ] ),
      isFpPair := true,
      isMinTransitivePair := true,
      generators := [ (2,4,3), (1,3,2) ],
      degree := 4,
      position := 3 )  </pre>
<P>
When     <I>G</I>   is      a    permutation     group,     the    function
<code>PresentationViaCosetTable</code> is called  to find a presentation  for <I>G</I>
and hence a finitely presented group <I>F</I>  isomorphic to <I>G</I>.  When <I>G</I>
has a name, the name <code>&lt;name of G>Fp</code> is given automatically to <I>F</I> and
<code>&lt;name of G>Pair</code> to the pair.
<P>
<pre>    gap> h20.generators;
    [ (1,2,3,4,5), (2,3,5,4) ]
    gap> pairh := FpPair( h20 );
    rec(
      perm := h20,
      fp := h20Fp,
      f2p := GroupHomomorphismByImages( h20Fp, h20, [ f.1, f.2 ], 
        [ (1,2,3,4,5), (2,3,5,4) ] ),
      p2f := GroupHomomorphismByImages( h20, h20Fp,
        [ (1,2,3,4,5), (2,3,5,4) ], [ f.1, f.2 ] ),
      isFpPair := true,
      degree := 5,
      presentation := &lt;&lt; presentation with 2 gens and 3 rels
        of total length 14 >>,
      name := [ 'h', '2', '0', 'P', 'a', 'i', 'r' ] )
    gap> pairh.fp.relators;
    [ f.2^4, f.1^5, f.1*f.2*f.1*f.2^-1*f.1 ]   </pre>
<P><A NAME="SECT143"><h2>80.143 IsFpPair</h2></a>
<P><P>
<A name = "I86"></a>

<P>
<code>IsFpPair( <var>pair</var> )</code>
<P>
This tests to see whether <code>pair</code> is an (Fp-group, perm group) pair.
<P>
<pre>    gap> IsFpPair( pairh );
    true </pre>
<P><A NAME="SECT144"><h2>80.144 SemidirectPair</h2></a>
<P><P>
<A name = "I87"></a>

<P>
<code>SemidirectPair( <var>S</var> )</code>
<P>
When  <code>S</code>  is a semidirect  product,   this function finds  a faithful
permutation  representation <I>P</I> and sets  up a pairing between <I>S</I> and
<I>P</I>.  The example illustrates <code>c2|Xc3</code><I>&cong;</I><code>s3</code>.
<P>
<pre>    gap> agen := ac3.generators;; pgen := pc3.generators;;
    gap> a := GroupHomomorphismByImages( pc3, ac3, pgen, agen );
    GroupHomomorphismByImages( PermAut(c3), Aut(c3), [ (1,2) ], 
    [ GroupHomomorphismByImages( c3, c3, [ (1,2,3) ], [ (1,3,2) ] ) ] )
    gap> G := SemidirectProduct( pc3, a, c3 );;
    gap> G.name := "G";;  PG := SemidirectPair( G );
    rec(
      perm := Perm(G),
      sdp := G,
      s2p := OperationHomomorphism( G, Perm(G) ),
      p2s := GroupHomomorphismByImages( Perm(G), G, [(1,2)(4,5), (3,5,4)],
        [ SemidirectProductElement( (1,2), GroupHomomorphismByImages
              ( c3, c3, [ (1,3,2) ], [ (1,2,3) ] ), () ), 
        SemidirectProductElement( (), IdentityMapping(c3), (1,2,3) ) ] ))</pre>
<P><A NAME="SECT145"><h2>80.145 IsSemidirectPair</h2></a>
<P><P>
<A name = "I88"></a>

<P>
<code>IsSemidirectPair( <var>pair</var> )</code>
<P>
This tests to see whether <code>pair</code> is a (semidirect product, perm group) pair.
<P>
<pre>    gap> IsSemidirectPair( PG );
    true </pre>
<P><A NAME="SECT146"><h2>80.146 PrintList</h2></a>
<P><P>
<A name = "I89"></a>

<P>
<code>PrintList( <var>L</var> )</code>
<P>
This functions prints each of the elements of a list <code>L</code> on a separate
line.
<P>
<pre>    gap> J := [ [1,2,3], [3,4], [3,4], [1,2,4] ];; PrintList( J );
    [ 1, 2, 3 ]
    [ 3, 4 ]
    [ 3, 4 ]
    [ 1, 2, 4 ]  </pre>
<P><A NAME="SECT147"><h2>80.147 DistinctRepresentatives</h2></a>
<P><P><P>
<code>DistinctRepresentatives( <var>L</var> )</code>
<P>
When <I>L</I> is a set of <I>n</I> subsets of <I>[1..n]</I> and the Hall condition is
satisfied (the union of any <I>k</I> subsets  has at least <I>k</I> elements), a
standard algorithm for systems of distinct representatives is applied.
(A backtrack algorithm would  be more efficient.)   If the elements of
<I>L</I> are lists, they are converted to sets.
<P>
<pre>    gap> DistinctRepresentatives( J );
    [ 1, 3, 4, 2 ]  </pre>
<P><A NAME="SECT148"><h2>80.148 CommonRepresentatives</h2></a>
<P><P><P>
<code>CommonRepresentatives( <var>J, K</var> )</code>
<P>
When <code>J</code> and <code>K</code> are  both lists of  <code>n</code> sets, the  list <code>L</code> is formed
where   <I>L[i] := { j    :  J[i] &cap; K[j]   &ne;  &empty; }</I>.  A
system  of    distinct represetatives  <code>reps</code>  for  <code>L</code>    provides  a
permutation of the elements  of <code>K</code> such  that <code>J[i]</code> and  <code>K[i]</code> have
non-empty intersection.   Taking the  first element  in each of  these
intersections determines   a system of common   representatives <code>com</code>.
The function returns the pair <code>[ com, reps ]</code>.   Note that there is no
requirement for the representatives to be distinct.  See also the next
section.
<P>
<pre>   gap> K := [ [3,4], [1,2], [2,3], [2,3,4] ];;
    gap> CommonRepresentatives( J, K );
    [ [ 3, 3, 3, 1 ], [ 1, 3, 4, 2 ] ]  </pre>
<P>
This has produced
<I>3 &isin; J[1] &cap; K[1]</I>, <I>3 &isin; J[2] &cap; K[3]</I>,
<I>3 &isin; J[3] &cap; K[4]</I>  and  <I>1 &isin; J[4] &cap; K[2]</I>.
<P><A NAME="SECT149"><h2>80.149 CommonTransversal</h2></a>
<P><P><P>
<code>CommonTransversal( <var>G, H</var> )</code>
<P>
The existence of a common transversal for the left and right cosets of
a  subgroup <I>H</I> of  <I>G</I>   is a   special  case of  systems of   common
representatives.
<P>
<pre>    gap> T := CommonTransversal( a4, c3 );
    [ (), (1,3)(2,4), (1,2)(3,4), (1,4)(2,3) ]   </pre>
<P><A NAME="SECT150"><h2>80.150 IsCommonTransversal</h2></a>
<P><P>
<A name = "I90"></a>

<P>
<code>IsCommonTransversal( <var>G, H, T</var> )</code>
<P>
<pre>    gap> IsCommonTransversal( a4, c3, T );
    true  </pre>
<P><a href ="chap079.htm">Previous</a> <a href = "index.htm">Up</a> <a href ="chap081.htm">Next</a><BR><a href = "theindex.htm">Index</a>
<P>
<address>gap3-jm<br>11 Mar 2019</address></body></html>