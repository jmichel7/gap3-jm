This file contains the mails sent to the GAP forum in April-June 1996.

Name                Email address                           Mails   Lines
Martin Schoenert    Martin.Schoenert@Math.RWTH-Aachen.DE        7    1320
Thomas Breuer       Thomas.Breuer@Math.RWTH-Aachen.DE           6     455
Alexander Hulpke    Alexander.Hulpke@Math.RWTH-Aachen.DE        5    1009
Heiko Theissen      Heiko.Theissen@Math.RWTH-Aachen.DE          4     909
Volkmar Felsch      Volkmar.Felsch@Math.RWTH-Aachen.DE          4     236
W. David Joyner     wdj@sma.usna.navy.mil                       3      75
Sebastian Egner     egner@ira.uka.de                            3      72
Leonard Soicher     leonard@qmw.ac.uk                           3      62
Frank Celler        Frank.Celler@Math.RWTH-Aachen.DE            2      55
Werner Nickel       werner@dcs.st-and.ac.uk                     2      55
Joachim Neubueser   Joachim.Neubueser@Math.RWTH-Aachen.DE       2      52
Franz Gaehler       gaehler@orphee.polytechnique.fr             1      64
Burkhard Hoefling   hoefling@mat.mathematik.uni-mainz.de        1      43
Derek Holt          dfh@maths.warwick.ac.uk                     1      31
Akihiro Munemasa    g78378a@kyu-cc.cc.kyushu-u.ac.jp            1      27
Bill Bogley         bogley@math.orst.edu                        1      24
David Wood          davidw@cs.monash.edu.au                     1      22
Vitaliy I. Mysovskikh vimys@pdmi.ras.ru                         1      20
Dima Pasechnik      pasec@can.nl                                1      16
Andrew Mathas       a.mathas@ic.ac.uk                           1      15
Darren Long         long@math.ucsb.edu                          1       6
TOTAL                                                          51    4568

This  file is in Berkeley mail drop format, which means you can read this
file with 'mail -f <name-of-the-file>'  or 'mailx -f <name-of-the-file>'.
It is also possible however to read this file with any text editor.



From martin.schoenert@math.rwth-aachen.de Wed Apr  3 09:37:00 1996
Date:           Wed, 03 Apr 96 09:37:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        Re: Shorter Words With AbStab

Istvan T. Hernadvolgyi wrote in his e-mail message of 1996/03/24

    Recently I was playing around with the ordering of the points in the
    stabilizer. I "invented" a heuristic that seems to dramatically improve
    the word-length for the Rubik's Cube.

    ...

    The problem I am having is, that I cannot explain myself why it works so
    well. I include here the few functions that make up the heuristic, and
    how to use it. Anyone interested, please feel free to use it. I would
    truely appreciate any comments and maybe even an explanation. (I am not a
    mathematician, just a "poor" undergrad in Computer Science).

I think I have an idea why your heuristic works.

I think 'SortByGeneratorsOnOrbits' pushes fixpoints of the first
generators to the end of the list.  When you then reverse the list,
you move those fixpoints to the front.

The effect is that each step in the stabilizer chain calculation selects
a basepoint which is likely a fixpoint for the first generator(s).
This has the effect of pushing those generators into the stabilizer.

This is good because it means that we have short (as words in the
original generators) generators for the stabilizers.  And the shorter
the generators, the shorter the words 'FactorPermGroupElement' returns.

This may also explain why you see less of an effect for randomly
generated groups.  Elements of those groups will probably have only very
few fixpoints.  So the chance of selecting a basepoint such that more
than one short generator is pushed into the stabilizer is very small.

I leave it to you to devise ways to test this hypothesis.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,   +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, 52056 Aachen, Germany



From a.mathas@ic.ac.uk Tue Apr  2 16:21:28 1996
Date:           Tue, 02 Apr 96 16:21:28 +0100
From:           "Andrew Mathas" <a.mathas@ic.ac.uk>
Subject:        specht 2.1

Dear Ms and Mr Gap,
     I have just put an updated version of my package for calculating
decomposition numbers of Hecke algebras  on samson.math.rwth-aachen.de;
you will find it in /pub/incoming/specht-2.1.tar.gz. The most current
version will always exist at
  http://www.ma.ic.ac.uk/~apmath/abstracts/specht.html.
     The only changes are a few minor bugs fixes and a rewrite of one
function which previously did not work, together with some changes to the
manual to make it compatible with GAP's online help, and some new functions
for looking at the e-good partition lattice.

Regards,
     Andrew Mathas
     a.mathas@ic.ac.uk



From dfh@maths.warwick.ac.uk Thu Apr  4 15:13:29 1996
Date:           Thu, 04 Apr 96 15:13:29 +0100
From:           "Derek Holt" <dfh@maths.warwick.ac.uk>
Subject:        kbmag package

Dear GAP Forum,

The "kbmag" package is now available as a GAP share library by ftp from

ftp://ftp.math.rwth-aachen.de/pub/incoming/kbmag.zoo

(or as kbmag.tar.gz). Instructions for installing it as a share library
are contained in the README file. (It can also be used as a standalone.)

It is a package written in standard C with an interface to GAP provided.
It should work with any C compiler, but has only been tested on UNIX
machines.

It offers two related facilities that can be applied to a finitely presented
group  G. The first is a Knuth-Bendix completion program, which aims to
construct a finite complete (confluent) rewriting system for the group.
A variety of word-orderings are available, including shortlex, weighted lex,
recursive path, and wreath product orderings.

The second attempts to compute an automatic structure for G relative to a
shortlex ordering. Of course, these will only be successful for a few
particular types of groups  G  (including all finite groups).

If either of these procedures is successful on  G, then the word problem is
solvable efficiently, and words in the group generators can be reduced to
a unique normal form for the group element that they define. The set of
words in normal form can also be enumerated (up to a specified length) or
counted.

Derek Holt.



From martin.schoenert@math.rwth-aachen.de Wed Apr 10 21:18:00 1996
Date:           Wed, 10 Apr 96 21:18:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 05 (serious problem in 'Intersection' for AgGroups)

    This mail contains a bugfix for a serious problem in GAP 3.4.3.
    You should apply this bugfix soon if you are computing with AgGroups.
    The problem is in 'Intersection' for AgGroups, and may cause it
    to fail with a cryptic error message.


HOW TO APPLY

    The problem is a serious problem, because it may cause a computation to
    fail.  Thus the bugfix has medium priority, and we recommend that you
    apply it soon if you are computing with AgGroups.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix05.dif', and issue the command:

        patch -p0 < bugfix05.dif

    This workaround changes only the library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'Intersection' may fail for subgroups of AgGroups and signal

        Error, sorry, the elements of <arg> lie in no common ring domain in
        Domain( [ obj ] ) called from
        Base( V ) called from
        U.operations.AffineOperation( U, V, phi, tau ) called from
        AffineOperation( A, base, phi, tau ) called from
        GlasbyStabilizer( G, A, B, N, R ) called from
        ...


CORRECT BEHAVIOUR

gap> F := FreeGroup( 7 );;
gap> G := AgGroupFpGroup( F / [
>        F.1^3, F.2^3, F.3^2/F.5, F.4^2/F.5, F.5^2, F.6^7, F.7^7,
>        Comm(F.3,F.1)/(F.3*F.4*F.5), Comm(F.4,F.1)/(F.3),
>        Comm(F.6,F.1)/(F.6^3),       Comm(F.7,F.1)/F.7,
>        Comm(F.3,F.2)/(F.4*F.5),     Comm(F.4,F.2)/(F.3*F.4),
>        Comm(F.6,F.2)/(F.6^3),       Comm(F.4,F.3)/(F.5),
>        Comm(F.6,F.3)/(F.6^3*F.7^4), Comm(F.7,F.3)/(F.6*F.7^2),
>        Comm(F.6,F.4)/(F.6^3*F.7^2), Comm(F.7,F.4)/(F.6^2*F.7^2),
>        Comm(F.6,F.5)/F.6^5,         Comm(F.7,F.5)/F.7^5 ] );;
gap> U := Subgroup( G, [ G.1^2*G.2*G.3*G.5*G.6^4*G.7^4,
>                        G.1^2*G.2^2*G.6*G.7^6 ] );;
gap> V := Subgroup( G, [ G.1*G.2^2*G.4*G.5*G.6^5*G.7^5,
>                        G.1^2*G.2^2*G.3*G.6^5*G.7^6 ] );;
gap> Intersection( U, V );
Subgroup( Group( f.1, f.2, f.3, f.4, f.5, f.6, f.7 ),
[ f.2*f.3*f.4*f.5*f.6^5*f.7^6 ] )


COMMENT

    'AffineOperation' did not accept a list of base vectors,
    as called indirectly from 'AgGroupOps.Intersection'
    via 'GlasbyIntersection' and 'GlasbyStabilizer'.


PATCH

Prereq: 3.30.1.2
--- lib/agsubgrp.g      1995/12/05 15:10:40
+++ lib/agsubgrp.g      1996/02/08 12:07:06
@@ -2,7 +2,7 @@
 ##
 #A  agsubgrp.g                  GAP library                      Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -11,6 +11,10 @@
 ##  aggroups and all functions for orbit-stabilizer calculation.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.30.1.3  1996/02/08  12:07:06  sam
+#H  fixed change in 'AffineOperation' (somehow this was lost here,
+#H  and since it was not lost in 'aginters.g' this caused errors)
+#H
 #H  Revision 3.30.1.2  1995/12/05  15:10:40  mschoene
 #H  replaced 'Filtered( <list>, IsBound )' by 'Compacted( <list> )'
 #H
@@ -1388,10 +1392,10 @@

 #############################################################################
 ##
-#F  AffineOperationp( <G>, <V>, <phi>, <tau> )  . . . . . . . . . . affine op
+#F  AffineOperation( <G>, <vectors>, <phi>, <tau> ) . . . . . . . . affine op
 ##
-AgGroupOps.AffineOperation := function( U, V, phi, tau )
-    local   i,  v,  m,  l,  one,  zero,  mats,  M,  B;
+AgGroupOps.AffineOperation := function( U, vectors, phi, tau )
+    local   i,  v,  m,  l,  one,  zero,  mats,  M;

     # Catch trivial cases.
     U := Igs( U );
@@ -1399,15 +1403,20 @@
         return rec( images := [] );
     fi;

-    B := Base( V );
-    if B = []  then
-        mats := List( U, x -> [ [ V.field.one ] ]);
+    if IsRec( vectors ) then
+#T The manual allows this.
+#T Of course it should be changed, the basis not the space should be
+#T the argument ...
+      vectors:= Base( vectors );
+    fi;
+    one := tau( U[ 1 ] )[ 1 ] ^ 0;
+    if Length( vectors ) = 0 then
+        mats := List( U, x -> [ [ one ] ]);
     else
-       one  := tau( U[ 1 ] )[ 1 ] ^ 0;
        zero := 0 * one;

        # First the linear operation.
-       mats := List( U, x -> List( B, y -> phi( y, x ) ) );
+       mats := List( U, x -> List( vectors, y -> phi( y, x ) ) );
        for m  in mats  do
             for l  in m  do
                Add( l, zero );
END OF  bugfix05.dif ________________________________________________________



From martin.schoenert@math.rwth-aachen.de Wed Apr 10 21:19:00 1996
Date:           Wed, 10 Apr 96 21:19:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 06 (serious problem in 'StandardAssociate' for polynomials)

    This mail contains a bugfix for a serious problem in GAP 3.4.3.
    You should apply this bugfix soon if you are computing with polynomials.
    The problem is in 'StandardAssociate' for polynomials, and causes it to
    fail for the 0 polynomial.


HOW TO APPLY

    The problem is a serious problem, because it may cause a computation to
    fail.  Thus the bugfix has medium priority, and we recommend that you
    apply it soon if you are computing with polynomials.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix06.dif', and issue the command:

        patch -p0 < bugfix06.dif

    This workaround changes only the library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'StandardAssociate' fails for the 0 polynomial and signals

        Error, List Element: <position> must be a positive integer at
        return f * f.coefficients[Length( f.coefficients )] ^ (-1 * 1) ... in
        R.operations.StandardAssociate( R, r ) called from
        StandardAssociate( 0 * x ) called from
        main loop


CORRECT BEHAVIOUR

gap> x := X(Rationals);;
gap> StandardAssociate( 0 * x );
0*X(Rationals)^0


COMMENT

    Harald Boegeholz mailed a bugfix for this problem in 1994/04/17.
    That means it was available *before* GAP 3.4.0 was released,
    and still it did not make it into GAP 3.4.3.


PATCH

Prereq: 3.9
--- lib/polyfld.g       1994/06/10 02:44:03
+++ lib/polyfld.g       1996/04/03 13:24:53
@@ -2,13 +2,16 @@
 ##
 #A  polyfld.g                   GAP library                      Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains functions for polynomials over fields.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.9.1.1  1996/01/08  15:20:53  ahulpke
+#H  fixed 'StandardAssociate' for 0
+#H
 #H  Revision 3.9  1994/06/10  02:44:03  sam
 #H  fixed 'EuclideanQuotient'
 #H
@@ -58,6 +61,9 @@
 #F  FieldPolynomialRingOps.StandardAssociate( <R>, <f> )  . . . .  normed pol
 ##
 FieldPolynomialRingOps.StandardAssociate := function( R, f )
+    if Length(f.coefficients)=0 then
+      return Zero(R);
+    fi;
     return f * f.coefficients[ Length( f.coefficients ) ]^-1;
 end;

END OF  bugfix06.dif ________________________________________________________



From martin.schoenert@math.rwth-aachen.de Wed Apr 10 21:20:00 1996
Date:           Wed, 10 Apr 96 21:20:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 07 (DANGEROUS problem in 'CharTable( "ONM5" )')

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible*.
    The problem is that 'CharTable( "ONM5" )' does not return the table
    of the 5th maximal of the O'Nan group, but the table of the 13th
    maximal of the Suzuki group (both have structure (3^2:4xA6).2).


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation
    to produce incorrect results without a warning.  Thus the bugfix has
    high priority, and we recommend that you apply it as soon as possible.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix07.dif', and issue the command:

        patch -p0 < bugfix07.dif

    This workaround changes only the character table library.  Thus you need
    not recompile the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'CharTable( "ONM5" )' does not return the table of the fifth maximal of
    the O'Nan group, but the table of the 13th maximal of the Suzuki group
    (both have structure (3^2:4xA6).2).


CORRECT BEHAVIOUR

gap> C := CharTable( "ONM5" );;
gap> Set( List( C.irreducibles, chi -> chi[1] ) );
[ 1, 2, 8, 9, 10, 16, 18, 20, 40, 64, 72, 80 ]


COMMENT

    Note that 'CharTable( "(3^2:4xA6).2" )' returns the table of the
    13th maximal of the Suzuki group.


PATCH

Prereq: 3.47.1.2
--- tbl/ctlist.tbl      1995/01/16 09:10:09
+++ tbl/ctlist.tbl      1996/03/21 14:09:36
@@ -2,11 +2,14 @@
 ##
 #A  ctlist.tbl                  GAP table library               Thomas Breuer
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.47.1.3  1996/03/21  14:09:12  sam
+#H  fixed name conflict ONM5 <-> (3^2:4xA6).2
+#H
 #H  Revision 3.47.1.2  1995/01/16  09:10:09  sam
 #H  added names W(E6), W(E8); added info for 2xS6(2) = W(E7)
 #H
@@ -784,7 +787,7 @@
 ["3^(2+4):2A5.D8",["LyM7"]],
 ["2^5.psl(5,2)",["ThM2"],["thm2"]],
 ["2^1+8.a9",["ThM3"],["thm3"]],
-["(3^2:4xA6).2",["ONM5"]],
+["ONM5"],
 ["3^(1+4):4A5",["HNM14","HNN3B"]],
 ["3^5:2S6",["ThM8","ThN3C"]],
 ["5^(1+4):2^(1+4).5.4",["HNM6","HNN5B"],["group4","hamax2"]],
Prereq: 3.30
--- tbl/ctomaxi2.tbl    1994/05/27 15:17:28
+++ tbl/ctomaxi2.tbl    1996/03/21 14:11:27
@@ -2,7 +2,7 @@
 ##
 #A  ctomaxi2.tbl                GAP table library
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -11,6 +11,9 @@
 ##  groups HS, McL, He, Ru, Suz, ON, HN, Ly, Th.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.30.1.1  1996/03/21  14:10:57  sam
+#H  fixed name  conflict ONM5 <-> (3^2:4xA6).2
+#H
 #H  Revision 3.30  1994/05/27  15:17:28  sam
 #H  fixed 'identifier' component in three tables
 #H
@@ -2784,7 +2787,7 @@
 automorphisms:=[(13,14)(15,16),(17,18),(11,12),( 7, 8)(13,15)(14,16)],
 libinfo:=rec(othernames:=["ONM9"]));

-LIBTABLE.ctomaxi2.("(3^2:4xA6).2"):=rec(
+LIBTABLE.ctomaxi2.("ONM5"):=rec(
 text:=ConcatenationString(
 "origin: constructed as subdirect product of 3^2:Q8 and M10,\n",
 "5th maximal subgroup of sporadic simple Onan group ON,\n",
@@ -2831,7 +2834,7 @@
 0,0],[40,-5,0,0,8,4,-8,0,-1,4,-5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],
 automorphisms:=[(26,27)(29,30),(23,24),(20,21)(23,24)(26,27)(29,30),(13,14)
 (23,24),(10,11),(25,28)(26,29)(27,30)],
-libinfo:=rec(othernames:=["ONM5"]));
+libinfo:=rec(othernames:=[]));

 LIBTABLE.ctomaxi2.("3^(1+4):4A5"):=rec(
 text:=ConcatenationString(
Prereq: 3.17
--- tbl/ctospora.tbl    1993/09/20 10:48:04
+++ tbl/ctospora.tbl    1996/03/21 14:10:18
@@ -2,7 +2,7 @@
 ##
 #A  ctospora.tbl                GAP table library
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -10,6 +10,9 @@
 ##  groups $HS$, $McL$, $He$, $Ru$, $Suz$, $ON$, $Ly$ and $Th$ of the ATLAS.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.17.1.1  1996/03/21  14:09:55  sam
+#H  fixed 'maxes' component of 'ON' for 'ONM5'
+#H
 #H  Revision 3.17  1993/09/20  10:48:04  sam
 #H  adjusted some table names
 #H
@@ -2220,7 +2223,7 @@
 projections:=[rec(name:="3.ON",
 map:=[1,4,7,8,11,14,17,18,21,24,27,30,33,36,37,40,41,42,45,48,51,54,57,60,63,
 66,69,72,75,78])],
-maxes:=["L3(7).2","L3(7).2","J1","4_2.L3(4).2_1","(3^2:4xA6).2",
+maxes:=["L3(7).2","L3(7).2","J1","4_2.L3(4).2_1","ONM5",
 "3^4:2^(1+4)D10","L2(31)","L2(31)","4^3.L3(2)","M11","M11","A7","A7"],
 powermap:=[,[1,1,3,2,2,6,3,8,9,5,5,6,13,7,8,17,16,10,10,11,11,23,24,22,12,12,
 15,15,29,30],[1,2,1,4,5,6,2,8,9,10,11,12,13,4,15,6,6,19,18,21,20,23,24,22,25,
END OF  bugfix07.dif ________________________________________________________



From long@math.ucsb.edu Fri Apr 12 18:09:15 1996
Date:           Fri, 12 Apr 96 18:09:15 -0700
From:           "Darren Long" <long@math.ucsb.edu>
Subject:        Bugs?

Have there been any reports of bugs in the function

AbelianInvariantsNormalClosureFpGroup( , ) ?

Darren Long



From volkmar.felsch@math.rwth-aachen.de Thu Apr 18 14:16:28 1996
Date:           Thu, 18 Apr 96 14:16:28 +0200
From:           "Volkmar Felsch" <Volkmar.Felsch@Math.RWTH-Aachen.DE>
Subject:        Computing a presentation for a group

Announcement
------------

I would like to announce that a new GAP function,

   PresentationViaCosetTable,

is available which computes a presentation for a given concrete
(e. g. permutation or matrix) group. The method being used is
John Cannon's relations finding algorithm which has been described in

   John J. Cannon: Construction of defining relators for finte groups.
   Discrete Math. 5 (1973), 105-129, and in

   Joachim Neubueser: An elementary introduction to coset table methods
   in computational group theory. Groups-St. Andrews 1981, edited by
   C. M. Campbell and E. F. Robertson, pp. 1-45. London Math. Soc.
   Lecture Note Series no. 71, Cambridge Univ. Press, Cambridge, 1982.

The function is available by anonymous ftp to 'ftp.math.rwth-aachen.de'.
There are two files, a file '/pub/incoming/pres.doc' which contains just
a copy of this announcement, and a file '/pub/incoming/pres.g' which
contains the function.


Description
-----------

The function can be called using either of the two forms

    PresentationViaCosetTable( G );
or
    PresentationViaCosetTable( G, F, words );

In its first form, if only the group G has been specified, it applies
Cannon's single stage algorithm which, by plain element multiplication,
computes a coset table of G with respect to its trivial subgroup and
then uses coset enumeration methods to find a defining set of relators
for G. The resulting presentation is returned as a presentation record.

Example:

   gap> Read( "pres.g" );
   gap> G := GeneralLinearGroup( 2, 7 );
   GL(2,7)
   gap> G.generators;
   [ [ [ Z(7), 0*Z(7) ], [ 0*Z(7), Z(7)^0 ] ],
     [ [ Z(7)^3, Z(7)^0 ], [ Z(7)^3, 0*Z(7) ] ] ]
   gap> Size( G );
   2016
   gap> P := PresentationViaCosetTable( G );
   << presentation with 2 gens and 5 rels of total length 46 >>
   gap> TzPrintRelators( P );
   #I  1. f.2^3
   #I  2. f.1^6
   #I  3. f.1*f.2*f.1*f.2*f.1*f.2*f.1*f.2*f.1*f.2*f.1*f.2
   #I  4. f.1*f.2*f.1^-1*f.2*f.1*f.2^-1*f.1^-1*f.2*f.1*f.2*f.1^-1*f.2^-1
   #I  5. f.1^2*f.2*f.1*f.2*f.1*f.2^-1*f.1^-1*f.2^-1*f.1^3*f.2^-1

The second form allows to call Cannon's two stage algorithm which
first applies the single stage algorithm to an appropriate subgroup
H of G and then uses the resulting relators of H and a coset table
of G with respect to H to find relators of G. In this case the second
argument, F, is assumed to be a free group with the same number of
generators as G, and words is expected to be a list of words in the
generators of F which, when being evaluated in the corresponding
generators of G, provide subgroup generators for H.

Example:

   gap> M12 := MathieuGroup( 12 );;
   gap> M12.generators;
   [ ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11), ( 3, 7,11, 8)( 4,10, 5, 6),
     ( 1,12)( 2,11)( 3, 6)( 4, 8)( 5, 9)( 7,10) ]
   gap> F := FreeGroup( "a", "b", "c" );
   Group( a, b, c )
   gap> words := [ F.1, F.2 ];
   [ a, b ]
   gap> P := PresentationViaCosetTable( M12, F, words );
   << presentation with 3 gens and 10 rels of total length 97 >>
   gap> G := FpGroupPresentation( P );
   Group( a, b, c )
   gap> G.relators;
   [ c^2, b^4, a*c*a*c*a*c, a*b^-2*a*b^-2*a*b^-2, a^11,
     a^2*b*a^-2*b^-2*a*b^-1*a^2*b^-1,
     a*b*a^-1*b*a^-1*b^-1*a*b*a^-1*b*a^-1*b^-1,
     a^2*b*a^2*b^-2*a^-1*b*a^-1*b^-1*a^-1*b^-1,
     a^2*b^-1*a^-1*b^-1*a*c*b*c*a*b*a*b, a^3*b*a^2*b*a^-2*c*a*b*a^-1*c*a
    ]

Before it is returned, the resulting presentation is being simplified
by appropriate calls of the function 'SimplifyPresentation', but without
allowing it to eliminate any generators. This restriction guarantees
that we get a bijection between the list of generators of G and the list
of generators in the presentation. Hence, if the generators of G are
redundant and if you don't care for the bijection, it may be convenient
to apply the function 'SimplifyPresentation' again.

Example:

   gap> H := Group(
   >  [ (2,5,3), (2,7,5), (1,8,4), (1,8,6), (4,8,6), (3,5,7) ], () );;
   gap> P := PresentationViaCosetTable( H );
   << presentation with 6 gens and 12 rels of total length 42 >>
   gap> SimplifyPresentation( P );
   #I  there are 4 generators and 10 relators of total length 36

------------

I hope the function is of some use to someone,   Volkmar Felsch

volkmar.felsch@math.rwth-aachen.de



From leonard@qmw.ac.uk Thu Apr 18 15:03:24 1996
Date:           Thu, 18 Apr 96 15:03:24 BST
From:           "Leonard Soicher" <leonard@qmw.ac.uk>
Subject:        Re: Computing a presentation for a group

Dear Gap-forum,

In his announcement, Volkmar Felsch writes:

>
>Before it is returned, the resulting presentation is being simplified
>by appropriate calls of the function 'SimplifyPresentation', but without
>allowing it to eliminate any generators.

How do you do this?  That is exactly what I need.

Also, the manual says that it may be useful to apply SimplifyPresentation
more than once.  What is a good rule of thumb for the number of times to
apply SimplifyPresentation to a presentation?  Does this rule change if
no generator is being eliminated at any stage?

Thanks for your help.

Leonard Soicher.



From volkmar.felsch@math.rwth-aachen.de Fri Apr 19 14:24:22 1996
Date:           Fri, 19 Apr 96 14:24:22 +0200
From:           "Volkmar Felsch" <Volkmar.Felsch@Math.RWTH-Aachen.DE>
Subject:        Re: Bugs?

Darren Long writes

>  Have there been any reports of bugs in the function
>  AbelianInvariantsNormalClosureFpGroup( , ) ?

At the moment, we do not know of any bugs in that function.

Volkmar Felsch, Aachen   (volkmar.felsch@math.rwth-aachen.de)



From volkmar.felsch@math.rwth-aachen.de Mon Apr 22 11:04:25 1996
Date:           Mon, 22 Apr 96 11:04:25 +0200
From:           "Volkmar Felsch" <Volkmar.Felsch@Math.RWTH-Aachen.DE>
Subject:        Re: Computing a presentation for a group

In his reply to our announcement of the new function
'PresentationViaCosetTable' which is available in a file 'pres.g'
via ftp from our 'incoming' directory, Leonard Soicher writes

>  >Before it is returned, the resulting presentation is being simplified
>  >by appropriate calls of the function 'SimplifyPresentation', but without
>  >allowing it to eliminate any generators.
>
>  How do you do this?  That is exactly what I need.

As described in the manual section 'Tietze Transformations', each
presentation record, 'P' say, carries with it certain parameters,
the so-called 'Tietze options'. One of these is the parameter
'P.generatorsLimit' which by default is initialized to be zero.
Its purpose is to prevent the Tietze transformations functions
from eliminating too many generators.

More precisely: The functions 'SimplifyPresentation', 'TzGo', and
'TzGoGo' are not allowed to eliminate a generator if the resulting
number of generators would be smaller than this bound.

Hence, if you want to apply the function 'SimplifyPresentation'
without generator eliminations, it suffices to set the parameter
'P.generatorsLimit' to a value which is greater than or equal to the
current number of generators before calling the function. (This is
exactly what is done in the function 'PresentationViaCosetTable'.
You will find the corresponding code at the end of file 'pres.g'.)

Remark:

Unfortunately, there is an inconsequence in the current design
of the function 'PresentationFpGroup'. It calls some Tietze
transformations only after initializing the parameter
'P.generatorsLimit' by the default value zero. Hence it sometimes
eliminates some redundant generators. We intend to change this
behaviour in the next release of GAP.

However, the function 'PresentationViaCosetTable' needs already
now such a modified version because it has to guarantee a bijection
between the generators of the given group and those of the resulting
presentation. This is the reason why there is a modified copy of the
function 'PresentationFpGroup' in the file 'pres.g'. (It has been
renamed to 'PresentationFpGroup0' only in order to prevent it from
being overwritten if the library file 'fptietze.g' is read in again
during a GAP session.)

In the file 'pres.g' announced on April 18th, this modified version
was an ad hoc modification which just fulfilled these requirements.
Then, under the aspects of Leonards Soicher's request, I have replaced
it a day later, on April 19th, by another version which is more likely
to become the final one. Hence, if you are interested in this modification
and if you fetched the file 'pres.g' already before that replacement,
you should get a new copy before looking a it. (The performance of the
function 'PresentationViaCosetTable' is not affected by this change.)


>  Also, the manual says that it may be useful to apply SimplifyPresentation
>  more than once.  What is a good rule of thumb for the number of times to
>  apply SimplifyPresentation to a presentation?  Does this rule change if
>  no generator is being eliminated at any stage?

This is hard to be answered in general because the behaviour may be
very different for different presentations. A vague step in this
direction is the command 'TzGoGo' which applies the function
'SimplifyPresentation' again and again until there were five successive
calls which did not provide any improvement. In certain applications
this is quite convenient, in others it is nasty. I wonder whether
one should allow the user to specify the number of repetitions without
improvement by an additional, optional argument such that the value
five would just be the default value of that parameter.


Volkmar Felsch, Aachen      (volkmar.felsch@math.rwth-aachen.de)



From g78378a@kyu-cc.cc.kyushu-u.ac.jp Wed Apr 24 16:43:05 1996
Date:           Wed, 24 Apr 96 16:43:05 JST
From:           "Akihiro Munemasa" <g78378a@kyu-cc.cc.kyushu-u.ac.jp>
Subject:        using packages in Macintosh

Dear Forum
I have been using the port of GAP to Macintosh by Burkhard Hoefling,
and I realized that the command "RequirePackage" does not work. For
example,

gap> RequirePackage("weyl");
Error, share library "weyl" is not installed in
LoadPackage( name ) called from
RequirePackage( "weyl" ) called from
main loop
brk>

A simple fix is to add the following line to the file "gap.rc":

LIBNAME := "lib/";

Alternatively, one can add the following line to the file "gap.options":

-l lib/

(Thanks to Burkhard for pointing this out.) Of course, this assumes
that your lib folder and pkg folder are in the same folder containing
GAP application.

Akihiro Munemasa
munemasa@math.kyushu-u.ac.jp



From gaehler@orphee.polytechnique.fr Fri Apr 26 15:37:15 1996
Date:           Fri, 26 Apr 96 15:37:15 +0200
From:           "Franz Gaehler" <gaehler@orphee.polytechnique.fr>
Subject:        FpGroup for permutation groups

Dear GAP-forum,

I suspect that there is a bug in routine FpGroup when applied to
a permutation group. In the manual FpGroup is mentioned only for
AgGroups, but since it occurs also in the operations record of
a permutation group I thought it would be safe to use it that case,
too. The problem arises with

p := Group( (2,7)(3,6)(4,5), (1,8)(3,5)(4,6), (1,8)(3,5,6,4) );

A correct set of relators for the three generators of this group is

r:= [ [ 1, 1 ], [ 2, 2 ], [ 2, 3, 2, 3 ], [ 1, 2, 1, 2 ], [ 1, 3, 1, -3 ],
  [ 3, 3, 3, 3 ] ];

A first indication of the problem is that FpGroup(p) typically returns
a group on which Size fails (more than 64000 cosets, but Size(p)=16!).

I became aware of this problem when debugging routines which compute
space groups from a given point group g. I first compute a set of
inequivalent group extensions of g by Z^n, and then identify those
which are equivalent as space groups. In 4D the results do not yet
always agree with what is in the GAP group library. Particularly
wierd is the behaviour for the transpose of MatGroupZClass(4,13,7,2),
from which I have constructed above permutation group. On different
invocations I randomly get either 32 or 64 inequivalent group
extensions. Correct seems to be 64. For the computation I need a
set of relators for the point group, which I determine with FpGroup
and PresentationFpGroup. These relators are the only thing that
varies. I am quite confident that my group extensions code works
correctly, but, of course, one can never be completely sure. If
you really trust FpGroup, I would be happy to send you my code,
but the forum is probably not the right place for that.

Following are a few samples of relator sets I obtained with
FpGroup and PresentationFpGroup from p. Relator sets from the
first list are lacking at least one commutator relator, and
yield 32 inequivalent group extensions. Relator sets in the
second list are lacking a relator [3,3,3,3]. These yield 64
inequivalent group extensions.

[ # 32 inequivalent group extensions
  [ [ 1, 1 ], [ 2, 2 ], [ 2, 1, 2, 1 ], [ 3, 2, 3, 2 ], [ 3, 3, 3, 3 ] ],
  [ [ 1, 1 ], [ 2, 2 ], [ 2, 3, 2, 3 ], [ 2, 1, 2, 1 ] ]
]

[ # 64 inequivalent group extensions
  [ [ 1, 1 ], [ 2, 2 ], [ 1, 3, 1, -3 ], [ 2, 1, 2, 1 ], [ 3, 2, 3, 2 ] ],
  [ [ 1, 1 ], [ 2, 2 ], [ 2, -3, 2, -3 ], [ 2, 1, 2, 1 ],
    [ 3, 1, 3, 3, 1, 3 ] ],
  [ [ 1, 1 ], [ 2, 2 ], [ 2, 1, 2, 1 ], [ 3, 2, 3, 2 ],
    [ 2, 3, 1, 2, 3, 1 ] ],
  [ [ 1, 1 ], [ 2, 2 ], [ 2, 1, 2, 1 ], [ 3, 2, 3, 2 ],
    [ 3, 3, 1, 3, 1, 3 ] ]
]

I am running GAP 3.4 at patch level 3, and I think I have applied all
bugfixes, in particular bugfix04. Perhaps I should try the newly
announced PresentationViaCosetTable!

With kind regards,

Franz Gaehler



From joachim.neubueser@math.rwth-aachen.de Fri Apr 26 16:42:40 1996
Date:           Fri, 26 Apr 96 16:42:40 +0200
From:           "Joachim Neubueser" <Joachim.Neubueser@Math.RWTH-Aachen.DE>
Subject:        Re: FpGroup for permutation groups

Dear GAP-forum,

Franz Gaehler writes:
=20
> I suspect that there is a bug in routine FpGroup when applied to=20
> a permutation group. In the manual FpGroup is mentioned only for
> AgGroups, but since it occurs also in the operations record of
> a permutation group I thought it would be safe to use it that case,=20
> too. =20

No, it isn't, and  that is why  such a function for permutation groups
is not in  the manual. The record  component you mention is there  for
other reasons.

> I am running GAP 3.4 at patch level 3, and I think I have applied all
> bugfixes, in particular bugfix04. Perhaps I should try the newly=20
> announced PresentationViaCosetTable!

Indeed   you should, although  the   function is new,    we hope it is
correct, at least it produces a correct answer in your example.

In a later version  we hope to have an  FpGroup function that embraces
more kinds of groups.

Kind regards   Joachim Neubueser and Volkmar Felsch



From hoefling@mat.mathematik.uni-mainz.de Thu May  2 15:05:26 1996
Date:           Thu, 02 May 96 15:05:26 +0100
From:           "Burkhard Hoefling" <hoefling@mat.mathematik.uni-mainz.de>
Subject:        Power Macintosh version of GAP available

Dear GAP Forum members,

finally, there it is: a native Power Macintosh version of GAP. It is
about 8-10 times faster than the 68K version in emulation mode (we
got 58.000 GAPstones versus 6600 GAPstones on a PPC 6100/60), so
Power Macintosh users should upgrade in any case.

The GAP application and a version of unzoo are contained in the
self-extracting Stuffit Lite archive

           bin3r4p2-mac-pt1.02-ppc.sea.bin

in the incoming directory of ftp.rwth-aachen.de. This archive is in
MacBinary II format (i.e. it must be downloaded in *binary* mode). If
you download this file directly to a Macintosh, you should obtain an
application directly. Otherwise, you must use a utility such as
Stuffit Lite or Stuffit Expander to decode MacBinary II.

The Mac-specific source files, which work both for the Symantec C
compiler and the CodeWarrior PPC compiler, are available as

           src3r4p2-mac-pt1.02.sea.bin

at the same location as the application. Note that there has not been
a change in the GAP application in the update 3r4p2 -> 3r4p3 so that
GAP 3.4.2 is still up to date.

There is one minor difference between the native Power Mac version of
GAP 3.4.2 and the 68K Mac version: the default library path has been
changed from ':lib:' (Macintosh style path name) to 'lib/' (Unix
style path name), as has recently been suggested in the GAP forum.

Special thanks to Dirk Mattig (IWR Heidelberg, Germany), for letting
me use his Power Macintosh and CodeWarrior 7 C compiler, and for his
patience and excellent hospitality.

Please send remarks and bug reports specific to the Macintosh port
directly to Burkhard Hoefling <hoefling@mat.mathematik.uni-mainz.de>.

Have fun!

Burkhard.



From martin.schoenert@math.rwth-aachen.de Fri May 10 16:42:00 1996
Date:           Fri, 10 May 96 16:42:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 08 (Performance problem in 'DiagonalizeMatrix')

    This file contains a bugfix for a performance problem in GAP 3.4.3.
    You should apply this bugfix if you are computing with integer matrices.
    The problem is that the function 'DiagonalizeMatrix', which is used by
    'ElementaryDivisorsMat' and by all the function 'AbelianInvariants...',
    is not careful enough to keep the entries small.


HOW TO APPLY

    The problem is a performance problem, because it may cause a computation
    to take much longer that it should.  Thus the bugfix has low priority.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this file 'bugfix08.dif', and issue the command:

        patch -p0 < bugfix08.dif

    This workaround changes only the library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'DiagonalizeMatrix', which is used by 'ElementaryDivisorsMat' and by all
    the functions 'AbelianInvariants...', is not careful enough to keep the
    entries small.  Thus the size of intermediate entries may grow
    exponentially.


CORRECT BEHAVIOUR

gap> M := [
> [ 63851, -4582,-14295, 36409, 31705,-15403,-15221,-26632,
>   -1419,-35034,-33355, 14971,-27398,   -64, 66589 ],
> [ 12285,-51674, -3928, 21474,-57991, 45051, 14076,-74043,
>   56389, 38873,-61766,-32221, 50255,  4823,-28850 ],
> [    64,-48464,-29455,-13125,-44592,-10902,-10389,-13507,
>   19844, 33041, 36473, 42632,-52949,  7623,-42507 ],
> [ -4823, 42496,-15407,-45251,-52043, 10367, 83895,-28792,
>  -20969, 48444, 16651,-27093,-22652,-25856, -3285 ],
> [ -7623,-46432, -8892, -3614,  5233,-25527,  5832, -9893,
>  -21233,  3393,-20748,  1381, 25463,-24033, 21948 ],
> [ 25856,-12008, 14231,-16133,-25740, 14048,-15403,-12659,
>  -30926, 14295,-19395, 22910, -9225,  2553,-51311 ],
> [ 24033,-32034,  8751,-55273, 41195,  6515, 45051, 45380,
>  -29069,  3928, 20419, 21667,  1108,-30892, 14177 ],
> [ -2553, 19910, 37078,-39838,-16195, 23123,-10902, 27179,
>   22077, 29455,-18686,  5617,-48979, -4509, 30080 ],
> [ 30892, 40630,-10449, 31051, 15972, -5480, 10367, 14329,
>  -27746, 15407,-24381,-54678,-18553,  5699, 21319 ],
> [  4509, -1972,-15141, -1309, -5331, 28327,-25527, 28488,
>   12373,  8892,-35329, -4543,-25774,-14010,-32265 ],
> [ -5699, -4262,-11678,  1252,  6003,-47527, 14048, 13077,
>    3295,-14231, 25352,-18861, 16635, -6913,  1566 ],
> [ 14010,  3112,-39643,  -655,-17194, -4692,  6515, 29143,
>   -5442, -8751, 12701,  2368,   183, 14267, 12667 ],
> [  6913, -7678,-41587, 23471,-23397,  3463, 23123,-10394,
>   27929,-37078,  8165,-20649,  2236, 20832,-16395 ],
> [-14267, 13974, 16148, 32402,-20719,-27965, -5480, -3259,
>  -10137, 10449,-14922, 33553, 13955,-31317,  1456 ],
> [-20832, -5168,  1131,-27917, -3088, -1944, 28327, 17523,
>   10660, 15141,  2639,  9860, -4969,  4095,-11097 ] ];;
gap> InfoMatrix1 := Print;;  InfoMatrix2 := Print;;  InfoMatrix3 := Print;;
gap> Collected( ElementaryDivisorsMat( M ) );
[ [ 1, 1 ], [ 78901, 1 ], [ 157802, 13 ] ]
gap> # this should not produce intermediate entries with more than 10 digits
gap> # the old code produced intermediate entries with more than 100 digits


COMMENT

    This patch consists of a new implementation of 'DiagonalizeMatrix'.
    It tries to keep the entries small through careful selection of pivots.
    The selected pivot is the entry for which the product of row and column
    norm is minimal (this need not be the entry with minimal absolute value).
    It is based upon ideas by George Havas and code by Bohdan Majewski.


PATCH

Prereq: 3.33.1.1
--- lib/matrix.g        Mon May  6 14:10:17 1996
+++ lib/matrix.g        Mon May  6 14:38:57 1996
@@ -2,13 +2,16 @@
 ##
 #A  matrix.g                    GAP library                  Martin Schoenert
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains  those  functions  that  mainly  deal  with  matrices.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.33.1.2  1996/05/06  12:20:27  mschoene
+#H  changed 'DiagonalizeMat' to use norms to select the pivot
+#H
 #H  Revision 3.33.1.1  1994/08/24  15:22:00  sam
 #H  improved 'TransposedMat'
 #H
@@ -126,6 +129,7 @@
 ##
 if not IsBound(InfoMatrix1)  then InfoMatrix1 := Ignore;  fi;
 if not IsBound(InfoMatrix2)  then InfoMatrix2 := Ignore;  fi;
+if not IsBound(InfoMatrix3)  then InfoMatrix3 := Ignore;  fi;


 #############################################################################
@@ -1351,149 +1355,363 @@
     fi;
     end;

+
 #############################################################################
 ##
-#F  DiagonalizeMat( <mat> ) . . . . . . . . . . diagonalize an integer matrix
+#F  BestQuoInt(<n>,<m>)
 ##
-DiagonalizeMat := function ( mat )
-    local   i,          # current position
-            k, l,       # row and column loop variables
-            r, c,       # row and column index of minimal element
-            e, f,       # entries of the matrix
-            g,          # (extended) gcd of <e> and <f>
-            v, w,       # rows of the matrix or row and column norms
-            m,          # maximal entry, only for information
-            isClearCol; #
+##  'BestQuoInt' returns the best quotient <q> of the integers  <n> and  <m>.
+##  This is the quotient such that '<n>-<q>\*<m>' has minimal absolute value.
+##  If there are two quotients whose remainders have the same absolute value,
+##  then the quotient with the smaller absolute value is choosen.
+##
+BestQuoInt := function ( n, m )
+    if   0 <= m  and 0 <= n  then
+        return QuoInt( n + QuoInt( m - 1, 2 ), m );
+    elif 0 <= m  then
+        return QuoInt( n - QuoInt( m - 1, 2 ), m );
+    elif 0 <= n  then
+        return QuoInt( n - QuoInt( m + 1, 2 ), m );
+    else
+        return QuoInt( n + QuoInt( m + 1, 2 ), m );
+    fi;
+end;

-    InfoMatrix1("#I  DiagonalizeMat called\n");

-    if mat <> [] then
+#############################################################################
+##
+#F  DiagonalizeIntMatNormDriven(<mat>)  . . . . diagonalize an integer matrix
+##
+##  'DiagonalizeIntMatNormDriven'  diagonalizes  the  integer  matrix  <mat>.
+##
+##  It tries to keep the entries small  through careful  selection of pivots.
+##
+##  First it selects a nonzero entry for which the  product of row and column
+##  norm is minimal (this need not be the entry with minimal absolute value).
+##  Then it brings this pivot to the upper left corner and makes it positive.
+##
+##  Next it subtracts multiples of the first row from the other rows, so that
+##  the new entries in the first column have absolute value at most  pivot/2.
+##  Likewise it subtracts multiples of the 1st column from the other columns.
+##
+##  If afterwards not  all new entries in the  first column and row are zero,
+##  then it selects a  new pivot from those  entries (again driven by product
+##  of norms) and reduces the first column and row again.
+##
+##  If finally all offdiagonal entries in the first column  and row are zero,
+##  then it  starts all over again with the submatrix  '<mat>{[2..]}{[2..]}'.
+##
+##  It is  based  upon  ideas by  George Havas  and code by  Bohdan Majewski.
+##  G. Havas and B. Majewski, Integer Matrix Diagonalization, JSC, to appear
+##
+DiagonalizeIntMatNormDriven := function ( mat )
+    local   nrrows,     # number of rows    (length of <mat>)
+            nrcols,     # number of columns (length of <mat>[1])
+            rownorms,   # norms of rows
+            colnorms,   # norms of columns
+            d,          # diagonal position
+            pivk, pivl, # position of a pivot
+            norm,       # product of row and column norms of the pivot
+            clear,      # are the row and column cleared
+            row,        # one row
+            col,        # one column
+            ent,        # one entry of matrix
+            quo,        # quotient
+            h,          # gap width in shell sort
+            k, l,       # loop variables
+            max, omax;  # maximal entry and overall maximal entry

-       InfoMatrix2("#I    divisors: \c");
-       m := 0;
-
-       # loop over all rows respectively columns of the matrix
-       for i  in [1..Minimum( Length(mat), Length(mat[1]) )]  do
-
-           # compute the row and column norms
-           v := 0 * [1..Length(mat)];
-           w := 0 * [1..Length(mat[1])];
-           for k  in [i..Length(mat)]  do
-               for l  in [i..Length(mat[1])]  do
-                   e := mat[k][l];
-                   if   0 < e  then
-                       v[k] := v[k] + e;
-                       w[l] := w[l] + e;
-                   else
-                       v[k] := v[k] - e;
-                       w[l] := w[l] - e;
-                   fi;
-               od;
-           od;
-
-           # find the element with the smallest absolute value in the matrix
-           f := 0;
-           for k  in [i..Length(mat)]  do
-               for l  in [i..Length(mat[1])]  do
-                   e := mat[k][l];
-                   if   0 < e and (f=0 or  e<f or  e=f and v[k]*w[l]<g) then
-                       f :=  e;  r := k;  c := l;  g := v[k]*w[l];
-                   elif e < 0 and (f=0 or -e<f or -e=f and v[k]*w[l]<g) then
-                       f := -e;  r := k;  c := l;  g := v[k]*w[l];
-                   fi;
-                   if   0 < e and m <  e  then
-                       m :=  e;
-                   elif e < 0 and m < -e  then
-                       m := -e;
-                   fi;
-               od;
-           od;
-
-           # if there is no nonzero entry we are done
-           if f = 0  then
-               InfoMatrix2("\n");
-               InfoMatrix1("#I  DiagonalizeMat returns\n");
-               return;
-           fi;
-
-           # move the minimal element to position 'mat[i][i]' make it positive
-           if i <> r  then
-               v := mat[i];  mat[i] := mat[r];  mat[r] := v;
-           fi;
-           if i <> c  then
-               for k  in [i..Length(mat)]  do
-                   e := mat[k][i];  mat[k][i] := mat[k][c];  mat[k][c] := e;
-               od;
-           fi;
-           if mat[i][i] < 0  then
-               mat[i] := - mat[i];
-           fi;
-
-           # now clear the column i and the row i
-           isClearCol := false;
-           while not isClearCol  do
-
-               # clear the column i using unimodular row operations such that
-               # mat[i][i] becomes gcd(mat[i][i],mat[r][i]) and mat[r][i] = 0
-               k := i + 1;
-               while k <= Length(mat)  do
-                   e := mat[i][i];  f := mat[k][i];
-                   if f mod e = 0  then
-                       mat[k] := mat[k] - f/e * mat[i];
-                   elif f <> 0  then
-                       g := Gcdex( e, f );
-                       v := mat[i];  w := mat[k];
-                       mat[i] := g.coeff1 * v + g.coeff2 * w;
-                       mat[k] := g.coeff3 * v + g.coeff4 * w;
-                   fi;
-                   k := k + 1;
-               od;
-
-               isClearCol := true;
-
-               # clear the row i using unimodular column operations such that
-               # mat[i][i] becomes gcd(mat[i][i],mat[i][c]) and mat[i][c] = 0
-               # after such an operation we may have to clear column i  again
-               l := i + 1;
-               while l <= Length(mat[1])  and isClearCol  do
-                   e := mat[i][i];  f := mat[i][l];
-                   if f mod e = 0  then
-                       mat[i][l] := 0;
-                   elif f <> 0  then
-                       g := Gcdex( e, f );
-                       for k  in [i..Length(mat)]  do
-                           v := mat[k][i];  w := mat[k][l];
-                           mat[k][i] := g.coeff1 * v + g.coeff2 * w;
-                           mat[k][l] := g.coeff3 * v + g.coeff4 * w;
-                       od;
-                       isClearCol := false;
-                   fi;
-                   l := l + 1;
-               od;
-
-           od;
-
-           InfoMatrix2(mat[i][i]," \c");
-       od;
-
-       InfoMatrix2("\n");
-       InfoMatrix2("#I  maximal entry ",m,"\n");
+    # give some information
+    InfoMatrix1("#I  DiagonalizeMat called\n");
+    InfoMatrix2("#I    divisors: \c");
+    omax := 0;
+
+    # get the number of rows and columns
+    nrrows := Length( mat );
+    if nrrows <> 0  then
+        nrcols := Length( mat[1] );
+    else
+        nrcols := 0;
     fi;
+    rownorms := [];
+    colnorms := [];
+
+    # loop over the diagonal positions
+    d := 1;
+    while d <= nrrows and d <= nrcols  do
+        InfoMatrix3("\n#I      d=",d," \c");
+
+        # find the maximal entry
+        if InfoMatrix3 <> Ignore  then
+            max := 0;
+            for k  in [ d .. nrrows ]  do
+                for l  in [ d .. nrcols ]  do
+                    ent := mat[k][l];
+                    if   0 < ent and max <  ent  then
+                        max :=  ent;
+                    elif ent < 0 and max < -ent  then
+                        max := -ent;
+                    fi;
+                od;
+            od;
+            InfoMatrix3("max=",max," \c");
+            if omax < max  then omax := max;  fi;
+        fi;
+
+        # compute the Euclidean norms of the rows and columns
+        for k  in [ d .. nrrows ]  do
+            row := mat[k];
+            rownorms[k] := row * row;
+        od;
+        for l  in [ d .. nrcols ]  do
+            col := mat{[d..nrrows]}[l];
+            colnorms[l] := col * col;
+        od;
+        InfoMatrix3("n\c");
+
+        # push rows containing only zeroes down and forget about them
+        for k  in [ nrrows, nrrows-1 .. d ]  do
+            if k < nrrows and rownorms[k] = 0  then
+                row         := mat[k];
+                mat[k]      := mat[nrrows];
+                mat[nrrows] := row;
+                norm             := rownorms[k];
+                rownorms[k]      := rownorms[nrrows];
+                rownorms[nrrows] := norm;
+            fi;
+            if rownorms[nrrows] = 0  then
+                nrrows := nrrows - 1;
+            fi;
+        od;
+
+        # quit if there are no more nonzero entries
+        if nrrows < d  then
+            #N  1996/04/30 mschoene should 'break'
+            InfoMatrix3("\n#I      overall maximal entry ",omax);
+            InfoMatrix1("\n#I  DiagonalizeMat returns\n");
+            return;
+        fi;

-    InfoMatrix1("#I  DiagonalizeMat returns\n");
+        # push columns containing only zeroes right and forget about them
+        for l  in [ nrcols, nrcols-1 .. d ]  do
+            if l < nrcols and colnorms[l] = 0  then
+                col                      := mat{[d..nrrows]}[l];
+                mat{[d..nrrows]}[l]      := mat{[d..nrrows]}[nrcols];
+                mat{[d..nrrows]}[nrcols] := col;
+                norm             := colnorms[l];
+                colnorms[l]      := colnorms[nrcols];
+                colnorms[nrcols] := norm;
+            fi;
+            if colnorms[nrcols] = 0  then
+                nrcols := nrcols - 1;
+            fi;
+        od;
+
+        # sort the rows with respect to their norms
+        h := 1;  while 9 * h + 4 < nrrows-(d-1)  do h := 3 * h + 1;  od;
+        while 0 < h  do
+            for l  in [ h+1 .. nrrows-(d-1) ]  do
+                norm := rownorms[l+(d-1)];
+                row := mat[l+(d-1)];
+                k := l;
+                while h+1 <= k  and norm < rownorms[k-h+(d-1)]  do
+                    rownorms[k+(d-1)] := rownorms[k-h+(d-1)];
+                    mat[k+(d-1)] := mat[k-h+(d-1)];
+                    k := k - h;
+                od;
+                rownorms[k+(d-1)] := norm;
+                mat[k+(d-1)] := row;
+            od;
+            h := QuoInt( h, 3 );
+        od;
+
+        # choose a pivot in the '<mat>{[<d>..]}{[<d>..]}' submatrix
+        # the pivot must be the topmost nonzero entry in its column,
+        # now that the rows are sorted with respect to their norm
+        pivk := 0;  pivl := 0;
+        norm := Maximum(rownorms) * Maximum(colnorms) + 1;
+        for l  in [ d .. nrcols ]  do
+            k := d;
+            while mat[k][l] = 0  do
+                k := k + 1;
+            od;
+            if rownorms[k] * colnorms[l] < norm  then
+                pivk := k;  pivl := l;
+                norm := rownorms[k] * colnorms[l];
+            fi;
+        od;
+        InfoMatrix3("p\c");
+
+        # move the pivot to the diagonal and make it positive
+        if d <> pivk  then
+            row       := mat[d];
+            mat[d]    := mat[pivk];
+            mat[pivk] := row;
+        fi;
+        if d <> pivl  then
+            col                    := mat{[d..nrrows]}[d];
+            mat{[d..nrrows]}[d]    := mat{[d..nrrows]}[pivl];
+            mat{[d..nrrows]}[pivl] := col;
+        fi;
+        if mat[d][d] < 0  then
+            mat[d] := - mat[d];
+        fi;
+
+        # now perform row operations so that the entries in the
+        # <d>-th column have absolute value at most pivot/2
+        clear := true;
+        row := mat[d];
+        for k  in [ d+1 .. nrrows ]  do
+            quo := BestQuoInt( mat[k][d], mat[d][d] );
+            if quo = 1  then
+                mat[k] := mat[k] - row;
+            elif quo = -1  then
+                mat[k] := mat[k] + row;
+            elif quo <> 0  then
+                mat[k] := mat[k] - quo * row;
+            fi;
+            clear := clear and mat[k][d] = 0;
+        od;
+        InfoMatrix3("c\c");
+
+        # now perform column operations so that the entries in
+        # the <d>-th row have absolute value at most pivot/2
+        col := mat{[d..nrrows]}[d];
+        for l  in [ d+1 .. nrcols ]  do
+            quo := BestQuoInt( mat[d][l], mat[d][d] );
+            if quo = 1  then
+                mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] - col;
+            elif quo = -1  then
+                mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] + col;
+            elif quo <> 0  then
+                mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] - quo * col;
+            fi;
+            clear := clear and mat[d][l] = 0;
+        od;
+        InfoMatrix3("r \c");
+
+        # repeat until the <d>-th row and column are totally cleared
+        while not clear  do
+
+            # compute the Euclidean norms of the rows and columns
+            # that have a nonzero entry in the <d>-th column resp. row
+            for k  in [ d .. nrrows ]  do
+                if mat[k][d] <> 0  then
+                    row := mat[k];
+                    rownorms[k] := row * row;
+                fi;
+            od;
+            for l  in [ d .. nrcols ]  do
+                if mat[d][l] <> 0  then
+                    col := mat{[d..nrrows]}[l];
+                    colnorms[l] := col * col;
+                fi;
+            od;
+            InfoMatrix3("n\c");
+
+            # choose a pivot in the <d>-th row or <d>-th column
+            pivk := 0;  pivl := 0;
+            norm := Maximum(rownorms) * Maximum(colnorms) + 1;
+            for l  in [ d+1 .. nrcols ]  do
+                if 0 <> mat[d][l] and rownorms[d] * colnorms[l] < norm  then
+                    pivk := d;  pivl := l;
+                    norm := rownorms[d] * colnorms[l];
+                fi;
+            od;
+            for k  in [ d+1 .. nrrows ]  do
+                if 0 <> mat[k][d] and rownorms[k] * colnorms[d] < norm  then
+                    pivk := k;  pivl := d;
+                    norm := rownorms[k] * colnorms[d];
+                fi;
+            od;
+            InfoMatrix3("p\c");
+
+            # move the pivot to the diagonal and make it positive
+            if d <> pivk  then
+                row       := mat[d];
+                mat[d]    := mat[pivk];
+                mat[pivk] := row;
+            fi;
+            if d <> pivl  then
+                col                    := mat{[d..nrrows]}[d];
+                mat{[d..nrrows]}[d]    := mat{[d..nrrows]}[pivl];
+                mat{[d..nrrows]}[pivl] := col;
+            fi;
+            if mat[d][d] < 0  then
+                mat[d] := - mat[d];
+            fi;
+
+            # now perform row operations so that the entries in the
+            # <d>-th column have absolute value at most pivot/2
+            clear := true;
+            row := mat[d];
+            for k  in [ d+1 .. nrrows ]  do
+                quo := BestQuoInt( mat[k][d], mat[d][d] );
+                if quo = 1  then
+                    mat[k] := mat[k] - row;
+                elif quo = -1  then
+                    mat[k] := mat[k] + row;
+                elif quo <> 0  then
+                    mat[k] := mat[k] - quo * row;
+                fi;
+                clear := clear and mat[k][d] = 0;
+            od;
+            InfoMatrix3("c\c");
+
+            # now perform column operations so that the entries in
+            # the <d>-th row have absolute value at most pivot/2
+            col := mat{[d..nrrows]}[d];
+            for l  in [ d+1.. nrcols ]  do
+                quo := BestQuoInt( mat[d][l], mat[d][d] );
+                if quo = 1  then
+                    mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] - col;
+                elif quo = -1  then
+                    mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] + col;
+                elif quo <> 0  then
+                    mat{[d..nrrows]}[l] := mat{[d..nrrows]}[l] - quo * col;
+                fi;
+                clear := clear and mat[d][l] = 0;
+            od;
+            InfoMatrix3("r \c");
+
+        od;
+
+        # print the diagonal entry (for information only)
+        InfoMatrix3("div=");
+        InfoMatrix2(mat[d][d]," \c");
+
+        # go on to the next diagonal position
+        d := d + 1;
+
+    od;
+
+    # close with some more information
+    InfoMatrix3("\n#I      overall maximal entry ",omax);
+    InfoMatrix1("\n#I  DiagonalizeMat returns\n");
 end;

+DiagonalizeIntMat := DiagonalizeIntMatNormDriven;
+
+
+#############################################################################
+##
+#F  DiagonalizeMat(<mat>) . . . . . . . . . . . . . . .  diagonalize a matrix
+##
+#N  1996/05/06 mschoene should be extended for other rings
+##
+DiagonalizeMat := DiagonalizeIntMat;
+

 #############################################################################
 ##
-#F  ElementaryDivisorsMat( <mat> )   elementary divisors of an integer matrix
+#F  ElementaryDivisorsMat(<mat>)  . . . . . . elementary divisors of a matrix
 ##
 ##  'ElementaryDivisors' returns a list of the elementary divisors, i.e., the
 ##  unique <d> with '<d>[<i>]' divides '<d>[<i>+1]' and <mat>  is  equivalent
 ##  to a diagonal matrix with the elements '<d>[<i>]' on the diagonal.
 ##
 ElementaryDivisorsMat := function ( mat )
-    local  divs, gcd, m, n, i, k;
+    local  divs, gcd, zero, m, n, i, k;

     # make a copy to avoid changing the original argument
     mat := Copy( mat );
@@ -1507,16 +1725,22 @@
     for i  in [1..Minimum(m,n)]  do
         divs[i] := mat[i][i];
     od;
+    if divs <> []  then zero := divs[1] - divs[1];  fi;

     # transform the divisors so that every divisor divides the next
     for i  in [1..Length(divs)-1]  do
         for k  in [i+1..Length(divs)]  do
-            if divs[i] <> 0  and divs[k] mod divs[i] <> 0  then
-                gcd     := GcdInt( divs[i], divs[k] );
+            if divs[i] = zero and divs[k] <> zero  then
+                divs[i] := divs[k];
+                divs[k] := zero;
+            elif divs[i] <> zero
+              and EuclideanRemainder( divs[k], divs[i] ) <> zero  then
+                gcd     := Gcd( divs[i], divs[k] );
                 divs[k] := divs[k] / gcd * divs[i];
                 divs[i] := gcd;
             fi;
         od;
+        divs[i] := StandardAssociate( divs[i] );
     od;

     return divs;
END OF  bugfix08.dif ________________________________________________________



From egner@ira.uka.de Tue May 14 14:35:20 1996
Date:           Tue, 14 May 96 14:35:20 +0200
From:           "Sebastian Egner" <egner@ira.uka.de>
Subject:        Conjugated permutation groups

Dear GAP-forum,

I am looking for the fastest method to decide if two
permutation groups are conjugated in a sufficiently
large symmetric group and if so to find a conjugating
permutation. Does someone know a method which does
not rely on character theory or brute force?
  In other words: Given permutation groups G, H, solve
the problem

  S := SymmetricGroup(
         Maximum( PermGroupOps.LargestMovedPoint(G),
                  PermGroupOps.LargestMovedPoint(H) )
       );
  x := RepresentativeOperation(
         S,
         AsSubgroup(S, G),
         AsSubgroup(S, H)
       );

(without computing the orbit of G, of course).

  Sebastian Egner.



From alexander.hulpke@math.rwth-aachen.de Wed May 15 11:48:16 1996
Date:           Wed, 15 May 96 11:48:16 +0200
From:           "Alexander Hulpke" <Alexander.Hulpke@Math.RWTH-Aachen.DE>
Subject:        Re: Conjugated permutation groups

Dear GAP-forum,

Sebastian Egner asked:

> I am looking for the fastest method to decide if two
> permutation groups are conjugated in a sufficiently
> large symmetric group and if so to find a conjugating
> permutation.
>   In other words: Given permutation groups G, H, solve
> the problem

>   S := SymmetricGroup(
>          Maximum( PermGroupOps.LargestMovedPoint(G),
>                   PermGroupOps.LargestMovedPoint(H) ));
>   x := RepresentativeOperation(S,AsSubgroup(S, G),AsSubgroup(S, H));

This is -- of course -- the standard GAP semantics for solving this problem.
In the best of all possible worlds there would be a specific, fast, algorithm
to solve this problem. So far, a backtrack search for a conjugating element
is run. this search does not run over all elements of G, but the search
space might be still unfeasibly large.

> Does someone know a method which does
> not rely on character theory or brute force?

I'm a bit puzzled that you rule out character theory. Anyhow, I don't think,
it could give you more than weak necessary conditions.

Seriously, I doubt that there is a general solution, which works without
having to do any backtrack at all. In a general setup, the only possible
answer is: The method you suggested is the fastest possible.
There are, however lots of tricks one can play to reduce the amount of
work needed for the backtracks. To see what can be done, it would be
helpful to know a bit more about the groups you want to check for conjugacy:

- What degree ?
- What sizes are the groups ?
- Are they transitive ?
- Do they have common structure (for example all are abelian)?
- How many conjugacy tests do you have to do ?

Best,

    Alexander Hulpke



From martin.schoenert@math.rwth-aachen.de Wed May 15 12:00:00 1996
Date:           Wed, 15 May 96 12:00:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 09 (DANGEROUS problem in 'SylowSystem' for ag groups)

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible*. Note that
    bugfix02 already provided a partial workaround for this problem.
    The problem is that 'SylowSystem' for ag groups may return a system
    of Sylow subgroups which do not commute.  This affects 'Complement'
    and 'Complementclasses' for ag groups, which use 'SylowSystem'.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation to
    produce incorrect results without a warning.  Thus the bugfix has high
    priority, and we recommend that you apply it as soon as possible.

    Note that bugfix02 already provided a partial workaround for this
    problem.  You have to apply 'bugfix02.dif' before using this patch.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix09.dif', and issue the command:

        patch -p0 < bugfix09.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This bugfix changes only the library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


CORRECT BEHAVIOUR

gap> F9 := FreeGroup( 9 );;
gap> f1:=F9.1;; f2:=F9.2;; f3:=F9.3;;
gap> f4:=F9.4;; f5:=F9.5;; f6:=F9.6;;
gap> f7:=F9.7;; f8:=F9.8;; f9:=F9.9;;
gap> G := AgGroupFpGroup( F9 / [
> f1^3/(f2*f3^4*f5), f2^2/f5, f3^7, f4^2, f5^2, f6^2, f7^2, f8^2, f9^2,
> Comm(f2,f1)/(f3^5*f4*f5*f6*f7*f8), Comm(f3,f1)/(f3^4*f9),
> Comm(f4,f1)/f6, Comm(f5,f1)/(f5*f6*f7), Comm(f6,f1)/(f6*f8),
> Comm(f7,f1)/(f6*f7), Comm(f8,f1)/(f8*f9), Comm(f9,f1)/(f5*f6*f8),
> Comm(f3,f2)/(f3^5*f5*f6*f7*f9), Comm(f4,f2)/(f4*f5*f7),
> Comm(f6,f2)/f5, Comm(f7,f2)/(f4*f5*f7), Comm(f8,f2)/f9,
> Comm(f4,f3)/(f4*f5), Comm(f5,f3)/f7, Comm(f6,f3)/(f5*f8*f9),
> Comm(f7,f3)/(f5*f6*f7*f8), Comm(f8,f3)/f9, Comm(f9,f3)/(f4*f6*f9) ] );;
gap> SylowComplements( G );;
gap> s := SylowSystem( G ).sylowSubgroups;;
gap> Set(List(CartesianProduct(Elements(s[2]),Elements(s[3])),Product))
>  = Set(List(CartesianProduct(Elements(s[3]),Elements(s[2])),Product));
true


COMMENT

    'SylowSystem' may return a system of Sylow subgroups that do not commute.
    'SylowComplements' may return an incorrect system of Sylow complements.
    This also affects 'Complement' and 'Complementclasses' for ag groups,
    which use 'SylowSystem' (even though we cannot find an example where
    'Complement' or 'Complementclasses' return an incorrect result).

    The problem is that 'SylowSystem' and 'SylowComplements' assumed they can
    use 'NormalIntersection(<U>,<V>)' respectively 'SumAgGroup(<U>,<V>)',
    since <U> and <V> commute.  But those functions require the stronger
    condition that <V> must normalize <U>.


PATCH

Prereq: 3.20.1.1
--- lib/aghall.g        1995/05/04 11:16:44
+++ lib/aghall.g        1996/05/13 12:47:42
@@ -2,13 +2,16 @@
 ##
 #A  aghall.g                    GAP library                      Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This files contains functions computing hall subgroups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.20.1.2  1996/05/13  09:23:21  fceller
+#H  fixed 'SylowComplements' and 'SylowSystem'
+#H
 #H  Revision 3.20.1.1  1995/05/04  11:16:44  fceller
 #H  fixed 'CoprimeComplementGS'
 #H
@@ -538,16 +541,16 @@
         com := sys.sylowComplements;
         L := [ U ];
         for i  in [ 2 .. Length( sys.primes ) ]  do
-            L[ i ] := NormalIntersection( L[ i - 1 ], com[ i - 1 ] );
+            L[ i ] := Intersection( L[ i - 1 ], com[ i - 1 ] );
         od;
         R := [];
         R[ Length( sys.primes ) ] := U;
         for i  in Reversed( [ 1 .. Length( sys.primes ) - 1 ] )  do
-            R[ i ] := NormalIntersection( R[ i + 1 ], com[ i + 1 ] );
+            R[ i ] := Intersection( R[ i + 1 ], com[ i + 1 ] );
         od;
         sys.sylowSubgroups := [];
         for i  in [ 1 .. Length( sys.primes ) ]  do
-            sys.sylowSubgroups[i] := NormalIntersection( L[i], R[i] );
+            sys.sylowSubgroups[i] := Intersection( L[i], R[i] );
         od;

     fi;
@@ -564,15 +567,14 @@
 AgGroupOps.SylowComplements := function( U )
     local   i, primes, p, com, syl, sys, K, L;

-    # Catch trivial case.
-    if U.generators = []  then
+    # catch the trivial case
+    if 0 = Length(U.generators)  then
         return rec( primes := [],
                     sylowSubgroups := [],
                     sylowComplements := [] );
     fi;

-    # If  you  already  know a complement system return it. If we know just a
-    # sylow system, return the products.
+    # if we know a system use it
     if IsBound( U.syslowSystem )  then
         if IsBound( U.syslowSystem.sylowComplements )  then
             return U.syslowSystem;
@@ -582,18 +584,18 @@
             primes := U.sylowSystem.primes;
             K := [];
             L := [];
-            K[ 1 ] := AgSubgroup( U, [], true );
-            for i  in [ 2 .. Length( primes ) ]  do
-                K[ i ] := SumAgGroup( K[ i - 1 ], syl[ i - 1 ] );
+            K[1] := AgSubgroup( U, [], true );
+            for i  in [ 2 .. Length(primes) ]  do
+                K[i] := Closure( K[i-1], syl[i-1] );
             od;
-            L[ Length( primes ) ] := AgSubgroup( U, [], true );
-            for i  in Reversed( [ 1 .. Length( primes ) - 1 ] )  do
-                L[ i ] := SumAgGroup( L[ i + 1 ], syl[ i + 1 ] );
+            L[Length(primes)] := AgSubgroup( U, [], true );
+            for i  in Reversed( [ 1 .. Length(primes)-1 ] )  do
+                L[ i ] := Closure( L[i+1], syl[i+1] );
             od;
-            for i  in [ 1 .. Length( primes ) ]  do
-                com[i] := SumAgGroup( K[ i ], L[ i ] );
+            for i  in [ 1 .. Length(primes) ]  do
+                com[i] := Closure( K[i], L[i] );
             od;
-            U.sylowSystem.sylowComplements:=com;
+            U.sylowSystem.sylowComplements := com;
             return U.sylowSystem;
         fi;
     fi;

Prereq: 3.11.1.2
--- lib/agcomple.g      1996/02/22 10:59:28
+++ lib/agcomple.g      1996/05/13 09:25:04
@@ -2,13 +2,16 @@
 ##
 #A  agcomple.g                  GAP library                      Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains all polymorph functions for groups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.11.1.3  1996/05/13  09:24:39  fceller
+#H  undid temporary fix 3.11.1.2, fixed coprime complement case
+#H
 #H  Revision 3.11.1.2  1996/02/22  10:59:28  ahulpke
 #H  disabled erraneous coprime case (only temporary fix)
 #H
@@ -651,7 +654,7 @@
         if IsBound( cor.relators )  then
             ocr.relators := cor.relators;
         fi;
-        ocr.complement := CoprimeComplement( K, M );
+        OneCocyclesOC( ocr, true );
         OneCoboundariesOC( ocr );
        if     IsBound( cor.normalComplements )
           and cor.normalComplements
@@ -904,18 +907,13 @@
        cor := rec();

     # otherwise we compute a hall system for <G>/<N>
-    elif false  then
-        InfoAgCo2( "#I  Complements: computing p prime sets\n" );
+    else
+       InfoAgCo2( "#I  Complements: computing p prime sets\n" );
         a   := NaturalHomomorphism( G, G / N );
         cor := PPrimeSetsOC( Image( a ) );
-        cor.generators := List( cor.generators, x ->
-                                PreImagesRepresentative( a, x ) );
-        cor.useCentralSK := true;
-
-    # use standard algorithm until CoprimeComplement is fixed
-    else
-        cor := rec();
-        cor.useCentralSK := true;
+        cor.generators := List( cor.generators, x ->
+                               PreImagesRepresentative( a, x ) );
+       cor.useCentralSK := true;
     fi;

     # we want our nice elementary abelian series

END OF  bugfix09.dif ________________________________________________________



From vimys@pdmi.ras.ru Fri May 17 13:32:59 1996
Date:           Fri, 17 May 96 13:32:59 +0400
From:           "Vitaliy I. Mysovskikh" <vimys@pdmi.ras.ru>
Subject:        Lattices of intermediate subgroups

Dear members of GAP Forum,

In connection with my research of lattices of intermediate subroups
I plan to extend GAP by the functions IsPronormal, IsAbnormal etc.
Recall that the subgroup H is said to be pronormal in G iff for any
$x \in G$ the subgroups H and $H^x$ are conjugate already in their join
$\langle H, H^x \rangle $. The case of non-normal subgroup H distinct
from p-subgroup is of prime importance.

Has anybody fulfilled a similar computation? Or maybe somebody else have
such an intention? I would be very grateful for any information related
to this topic.

As for myself, I intend to start from the permutation groups. So it is
interesting to know, in particular, the most efficient way to obtain a
right transversal set for the normalizer of a given permutation group H.

Best wishes,                       Vitaliy Mysovskikh
                                   St. Petersburg



From pasec@can.nl Mon May 20 17:35:46 1996
Date:           Mon, 20 May 96 17:35:46 +0200
From:           "Dima Pasechnik" <pasec@can.nl>
Subject:        manual in html

Dear Forum,
Is it possible to download from somewhere the complete
GAP manual in HTML format?
Thanks in advance,
Dima
Dmitrii V. Pasechnik
RIACA
Department of Mathematics and Informatics
Eindhoven University of Technology
PO Box 513
5600 MB Eindhoven
The Netherlands
email: pasec@can.nl
       dima@win.tue.nl
www:   http://www.can.nl/~pasec



From alexander.hulpke@math.rwth-aachen.de Tue May 21 17:06:13 1996
Date:           Tue, 21 May 96 17:06:13 +0200
From:           "Alexander Hulpke" <Alexander.Hulpke@Math.RWTH-Aachen.DE>
Subject:        Identification functions

Group Identification functions in GAP
=====================================

In discussions with other mathematicians I recently found out that a couple
of very helpful GAP functions do not seem to be well known, probably because
they are hidden in the manual. To change this I decided to use the forum
to give a short explanation of them.
In this mail I want to describe some identification functions for groups.
These functions compare given groups with those in one of GAPs group
libraries and identify the type up to isomorphism. This is done by
searching for properties that identify the groups uniquely rather
than searching explicitely for isomorphisms. Accordingly, the functions
are relatively fast. They don't give Isomorphisms, however. I will give
relatively short descriptions, the manual gives more information.

The first of the functions to be mentioned is 'GroupId'. It will recognize
the abstract isomorphism type of a given group. The function returns a
record with several components (depending on the group), see the manual for
further explanation. Sometimes components give the
name or other identifications. If the size of the group is at most 100, the
component 'catalogue' (of the form [size,nr]) gives the isomorphic group in
the catalogue of solvable groups of small order: SolvableGroup(size,nr). (The
only exception is A5, which is group 60/13; but obviously nonsolvable.)
If the group is a 2-group or a 3-group, the component 'pGroupId' gives the
number in Eamonn O'Brien's catalogue of 2- and 3-groups. To use this
feature also for p-groups of size>100, the ANU PQ share package must be loaded.
To get an actual isomorphism, you would need to call
'IsomorphismGroups(group1,group2)'.
The corresponding manual section is 'GroupId'.

As an example, we show that the central product of Q8 with Q8 is isomorphic
to the central product of D8 with D8:

gap> f:=FreeGroup(4);
Group( f.1, f.2, f.3, f.4 )

#D8 central product D8
gap> g:=f/[f.1^4,f.2^2,f.1^f.2*f.1,f.3^4,f.4^2,f.3^f.4*f.3,f.1^2/f.3^2,
> Comm(f.1,f.3),Comm(f.1,f.4),Comm(f.2,f.3),Comm(f.2,f.4)];
Group( f.1, f.2, f.3, f.4 )
gap> Size(g);
32

# GroupId does not work for finitely presented groups, as it compares elements.
# So we make a permutaton group.
gap> p:=OperationCosetsFpGroup(g,TrivialSubgroup(g));;
gap> GroupId(p);
rec(
  catalogue := [ 32, 42 ],
  names := [ "D8YD8" ],
  size := 32,
  pGroupId := 49 )

#Q8 central product Q8
gap> h:=f/[f.1^4,f.2^4,(f.1/f.2)^2/f.1^2,f.1^2/f.2^2,
> f.3^4,f.4^4,(f.3/f.4)^2/f.3^2,f.3^2/f.4^2,f.1^2/f.3^2,
> Comm(f.1,f.3),Comm(f.1,f.4),Comm(f.2,f.3),Comm(f.2,f.4)];
Group( f.1, f.2, f.3, f.4 )
gap> Size(h);
32
gap> q:=OperationCosetsFpGroup(h,TrivialSubgroup(h));;
gap> GroupId(q);
rec(
  catalogue := [ 32, 42 ],
  names := [ "D8YD8" ],
  size := 32,
  pGroupId := 49 )

(Finding the isomorphism using 'IsomorphismGroups' would be quite difficult
in this case, as both groups have a Frattini factor group 2^4).


The other function is 'TransitiveIdentification'. It identifies
transitive permutation groups up to conjugacy in the symmetric group and
returns the number in the catalogue of transitive groups of the same degree
(provided the degree is at most 15). Calling the corresponding group (with
'TransitiveGroup(deg,nr)') provides you with a name.
To get the conjugating permutation, one would have to embed both groups in
the symmetric group and to use 'RepresentativeOperation(Sn,group1,group2)'.
The respective manual section is 'The transitive groups library'.

As an example, we determine the conjugacy classes of maximal transitive
subgroups of S3\wr S4:

gap> g:=TransitiveGroup(12,280);
[S(3)^4]A(4) = S(3) wr A(4)
gap> a:=AgGroup(g);;
gap> s:=SpecialAgGroup(a);
Group( g7, g1, g2, g3, g5, g6, g4, g8, g9, g10, g11 )
gap> m:=ConjugacyClassesMaximalSubgroups(s);;
gap> m:=List(m,Representative);;
gap> m:=List(m,i->Image(a.bijection,Image(s.bijection,i)));;
gap> m:=Filtered(m,i->IsTransitive(i,[1..12]));
[Subgroup([S(3)^4]A(4)=S(3)wrA(4),[(1,2,3)(5,6,7)(9,10,11),
(1,2)(3,4)(5,6)(7,8)(9,10)(11,12),(1,4)(2,3)(5,8)(6,7)(9,12)(10,11),
(1,5)(2,6)(3,7)(4,8),(2,6)(3,7),(3,7)(4,8),(1,5,9),(2,6,10),(3,7,11),
(4,8,12)]),
Subgroup([S(3)^4]A(4)=S(3)wrA(4),[(1,2)(3,4)(5,6)(7,8)(9,10)(11,12),
(1,4)(2,3)(5,8)(6,7)(9,12)(10,11),(1,5)(2,6)(3,7)(4,8),(2,6)(3,7),(3,7)(4,8),
(3,7),(1,5,9),(2,6,10),(3,7,11),(4,8,12)])]
gap> List(m,TransitiveIdentification);
[ 271, 261 ]
gap> List(last,i->TransitiveGroup(12,i));
[ [3^4:2^3]A(4), [S(3)^4]E(4) = S(3) wr E(4) ]

I hope these descriptions are helpful,

Alexander Hulpke



From frank.celler@math.rwth-aachen.de Fri May 24 15:01:00 1996
Date:           Fri, 24 May 96 15:01:00 +0100 (MET)
From:           "Frank Celler" <Frank.Celler@Math.RWTH-Aachen.DE>
Subject:        Re: HTML

Dear GAP Forum,

Dima Pasechnik asked:

    Is it possible to download from somewhere the complete
    GAP manual in HTML format?

the answers is yes, but:

(1) our ftp server contains a tar archive of the manual in HTML format
    in "ftp://ftp.math.rwth-aachen.de/pub/incoming/GAP-Manual-html.tgz".
    However, this is the documentation for GAP 3.4 patchlevel 1. It was not
    updated because the program to convert the LaTeX documention into HTML was
    lost in a disk crash.  At present we cannot say if and when such a
    conversion program will be rewritten.

(2) Steve Fisk has written a program
    ("ftp://ftp.math.rwth-aachen.de/pub/incoming/fisk.zoo") to convert the
    LaTeX documention into emacs info format.  Some time ago Steve Linton has
    successfully used 'texi2html' to convert the emacs info format into HTML.

By the way a new version (that hasn't been released yet) of XGAP will also
contain a DVI viewer for X-Windows, which will support hyperlinks, so that
you can use "?<something>" in a GAP session to get the corresponding help
page from the manual in a DVI viewer.  But this will only work under
X-Windows and requires a graphic terminal.

For more information about the various formats like HTML, emacs info see
for instance:

    http://www.math.rwth-aachen.de/
        LDFM/GAP/Forum/Martin_Schoenert__Re__Re__On-line_manual.html

best wishes
  Frank



From egner@ira.uka.de Fri May 24 18:04:42 1996
Date:           Fri, 24 May 96 18:04:42 +0200
From:           "Sebastian Egner" <egner@ira.uka.de>
Subject:        Little bug in PrimitiveGroup()

Dear GAP-forum,

there is a little bug in the function PrimitiveGroup():
It does not manage to create the 9-th group of degree 50
(the very last one of the table). The bug is in the file
$GAP_DIR/grp/primitiv.grp in function PrimitiveGroup() at

    # check the number
    if Length(PGTable) < deg  then
        Error("<deg> is too large");
    fi;
    if not IsBound( PGTable[h+nr] ) # <-- h+nr is unbound
        or PGTable[h+nr-1][1] <> deg  then
        Error("<nr> is too large");
    fi;

We hope to receive a little patch some time... ;-)
  Sebastian Egner, Markus P"uschel.



From egner@ira.uka.de Sat May 25 16:14:53 1996
Date:           Sat, 25 May 96 16:14:53 +0200
From:           "Sebastian Egner" <egner@ira.uka.de>
Subject:        A wrong bit in the Primitive Groups Library

Dear GAP-forum,

there is a little mistake in the Primitive Groups Library of
GAP v3.4.3: The "isOdd"-Flag of the groups of size 25401600
on 49 points is wrong. PG(393) is in fact odd and PG(394) is
in fact even. Here is a diff-File which I have shot in order
do say precisely what I have fixed (the two wrong bits and
PrimitiveGroup refusing to create PG(406)):

1044,1045c1044,1045
< [49,  25401600,  1, 00100,     ,     ,             , 339,340,326,341],
< [49,  25401600,  1, 00000,     ,     ,             , 339,340,342],
---
> [49,  25401600,  1, 00000,     ,     ,             , 339,340,326,341],
> [49,  25401600,  1, 00100,     ,     ,             , 339,340,342],
1099,1101d1098
<     if deg > PGTable[Length(PGTable)][1]  then
<         Error("<deg> is too large");
<     fi;
1113c1110,1113
<     if not IsBound( PGTable[h+nr-1] )
---
>     if Length(PGTable) < deg  then
>         Error("<deg> is too large");
>     fi;
>     if not IsBound( PGTable[h+nr] )

Sebastian Egner.



From wdj@sma.usna.navy.mil Tue May 28 14:52:49 1996
Date:           Tue, 28 May 96 14:52:49 -0400
From:           "W. David Joyner" <wdj@sma.usna.navy.mil>
Subject:        aut gps of free gps

Dear Forum members:
 Let F be the free group of rank 4 freely generated
by a1,a2,a3,a4. Let w=a1^2*a2^2*a3^2*a4^2.
Proposition 5.7 (due to McCool) of Lyndon and Schupp
asserts that there is an effective procedure for finding
a finite presentation for the stabilizer in Aut(F)
of the cyclic word (w), where (w) is the set of cyclically
reduced conjugates of w. In this particular case, can
anyone tell me what the finite presentation for the
stabilizer is? Or, maybe could you tell me if some software
(for example, GAP) can be used to compute it?
                               Tony Gaglione.



From davidw@cs.monash.edu.au Wed May 29 15:44:01 1996
Date:           Wed, 29 May 96 15:44:01 +1000
From:           "David Wood" <davidw@cs.monash.edu.au>
Subject:        Minor Bug

I found the following strange bug in GAP ...

gap> i := 268435455;
268435455
gap> A := [1..i];
[ 1 .. 268435455 ]
gap> i := i+1;
268435456
gap> IsInt(i);
true
gap> A := [1..i];
Error, Range: <high> must be an integer
gap>



David Wood
http://www.cs.monash.edu.au/~davidw
Tutor - Howitt Hall (+61 3) 9905 6385 (A/H)
PhD Student - Department of Computer Science (+61 3) 9905 5777
Monash University, Clayton, Victoria 3168, Australia



From alexander.hulpke@math.rwth-aachen.de Wed May 29 17:40:33 1996
Date:           Wed, 29 May 96 17:40:33 +0200
From:           "Alexander Hulpke" <Alexander.Hulpke@Math.RWTH-Aachen.DE>
Subject:        Re: 2 bugs in primitive groups

Dear GAP-forum,

Sebastian Egner noted two bugs in the primitive groups library and also gave
fixes. They are indeed errors and I'd like to thank him for reporting and
especially for fixing them. Unfortunately the 'diff'-File he appended was
run from new to old, so you should replace the lines starting with '>' by
the lines starting with '<'. I will send (in a separate mail) a formal
patch to the forum that contains these two fixes. It also adds (taking the
opportunity of changing the primitive groups library) better names for
these groups, devised by Francis Buekenhout and Dimitri Leemans.

Thanks again for pointing out the errors,

         Alexander Hulpke



From alexander.hulpke@math.rwth-aachen.de Wed May 29 17:44:05 1996
Date:           Wed, 29 May 96 17:44:05 +0200
From:           "Alexander Hulpke" <Alexander.Hulpke@Math.RWTH-Aachen.DE>
Subject:        Patch #10

Dear GAP-Forum:

    This mail contains a bugfix for two serious problems in GAP 3.4.3.
    You should apply this bugfix soon if you are using the primitive groups
    library.  One problem is that the library stored the wrong parity for two
    groups.  The other problem is the disability to create the last group.
    Additionally, this bugfix adds new names for the groups.


HOW TO APPLY

    The problem is a serious problem, because it may cause a computation to
    fail.  Thus the bugfix has medium priority, and we recommend that you
    apply it soon if you are using the primitive groups library.

    Go to the GAP directory (the directory with the 'grp/' subdirectory),
    name this file 'bugfix10.dif', and issue the command:

        patch -p0 < bugfix10.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This fix changes only the groups library.  Thus you need not recompile
    the GAP kernel.


VERSION

    3.4.3.0


DESCRIPTION

    'PrimitiveGroup(49,36)' and 'PrimitiveGroup(49,37)' are stored with
    incorrect parity (i.e., with incorrect '<group>.isOdd' value).
    'PrimitiveGroup(50,9)' signals 'Error, <nr> is too large' instead
    of creating the group 'S(50)'.


CORRECT BEHAVIOUR

    gap> g := PrimitiveGroup(49,36);;
    gap> g.isOdd; SignPermGroup(g);
    true
    -1
    gap> g := PrimitiveGroup(49,37);;
    gap> g.isOdd; SignPermGroup(g);
    false
    1
    gap> g := PrimitiveGroup(50,9);
    S(50)


COMMENT

    The problems were found and reported in the GAP forum by Sebastian Egner.
    He also provided a 'diff' file (which unfortunately was reversed).


PATCH

Prereq: 3.1
--- grp/primitiv.grp    Thu Dec 21 15:25:52 1995
+++ grp/primitiv.grp    Wed May 29 17:19:52 1996
@@ -1,15 +1,24 @@
 #############################################################################
 ##
 #A  primitiv.grp                GAP group library                Charles Sims
+#A                                                       & Francis Buekenhout
+#A                                                          & Dimitri Leemans
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1967-1992,  Charles Sims,  Rutgers University,  New Jersey, USA
 ##
 ##  This file contains the functions  of  the  primitive  group  library  and
-##  the primitiv groups of degree up to 50.
+##  the primitiv groups of degree up to 50 with the names given  to  them  by
+##  Buekenhout and Leemans.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.1.1.2  1996/05/29  15:12:43  mschoene
+#H  fixed an error message (problem also found be Sebastian Egner)
+#H
+#H  Revision 3.1.1.1  1996/05/28  09:20:39  ahulpke
+#H  fixed PrimitiveGroup(50,9), isOdd in 49/36,37 and added new names
+#H
 #H  Revision 3.1  1992/01/07  15:58:56  martin
 #H  initial revision under RCS
 #H
@@ -643,6 +652,7 @@
 ##  <stabilizer>:       if the stabilizer of the last point is primitive this
 ##                      is its identity,
 ##  <name>:             if known, a descriptive name for <G>,
+##                         PYL=P\Gamma L, PZL= P\Sigma L
 ##  <generators>:       a list of indices into the table 'PGGens'.
 ##
 FAC := Factorial;  EABL := 0000;
@@ -654,19 +664,19 @@
 [ 3,         6,  3, 10110, 0301, 0201,       "S(3)", 2,1],
 [ 4,        12,  2, 11010, EABL, 0301,       "A(4)", 3,2],
 [ 4,        24,  4, 10100, EABL, 0302,       "S(4)", 4,1],
-[ 5,         5,  1, 00001, 0501,     ,             , 5],
-[ 5,        10,  1, 00010, 0501,     ,             , 5,6],
-[ 5,        20,  2, 10110, 0501,     ,             , 5,7],
+[ 5,         5,  1, 00001, 0501,     ,          "5", 5],
+[ 5,        10,  1, 00010, 0501,     ,        "5:2", 5,6],
+[ 5,        20,  2, 10110, 0501,     ,        "5:4", 5,7],
 [ 5,        60,  3, 11001, 0504, 0401,       "A(5)", 8,2],
 [ 5,       120,  5, 10100, 0504, 0402,       "S(5)", 5,1],
 [ 6,        60,  2, 01001, 0601, 0502,   "PSL(2,5)", 5,6,9],
 [ 6,       120,  3, 10100, 0601, 0503,   "PGL(2,5)", 5,7,9],
 [ 6,       360,  4, 11001, 0603, 0504,       "A(6)", 10,2],
 [ 6,       720,  6, 10100, 0603, 0505,       "S(6)", 11,1],
-[ 7,         7,  1, 00001, 0701,     ,             , 12],
-[ 7,        14,  1, 00110, 0701,     ,             , 12,13],
-[ 7,        21,  1, 00010, 0701,     ,             , 12,14],
-[ 7,        42,  2, 10110, 0701,     ,             , 12,15],
+[ 7,         7,  1, 00001, 0701,     ,          "7", 12],
+[ 7,        14,  1, 00110, 0701,     ,        "7:2", 12,13],
+[ 7,        21,  1, 00010, 0701,     ,        "7:3", 12,14],
+[ 7,        42,  2, 10110, 0701,     ,   "AGL(1,7)", 12,15],
 [ 7,       168,  2, 00001, 0705,     ,   "PSL(3,2)", 12,16],
 [ 7,      2520,  5, 11001, 0706, 0603,       "A(7)", 17,2],
 [ 7,      5040,  7, 10100, 0706, 0604,       "S(7)", 12,1],
@@ -677,15 +687,15 @@
 [ 8,      1344,  3, 00000, EABL, 0705,   "ASL(3,2)", 12,16,18],
 [ 8,     20160,  6, 11001, 0806, 0706,       "A(8)", 20,2],
 [ 8,     40320,  8, 10100, 0806, 0707,       "S(8)", 21,1],
-[ 9,        36,  1, 00010, EABL,     ,             , 22,23],
-[ 9,        72,  1, 00100, EABL,     ,             , 22,23,24],
+[ 9,        36,  1, 00010, EABL,     ,      "3^2:4", 22,23],
+[ 9,        72,  1, 00100, EABL,     ,    "3^2:D_8", 22,23,24],
 [ 9,        72,  2, 10110, EABL,     ,   "AGL(1,9)", 22,25],
-[ 9,        72,  2, 10010, EABL,     ,  "<AYL(1,9)", 22,23,26],
+[ 9,        72,  2, 10010, EABL,     ,        "M_9", 22,23,26],
 [ 9,       144,  2, 00100, EABL,     ,   "AYL(1,9)", 22,25,24],
-[ 9,       216,  2, 00000, EABL,     ,    "Huppert", 22,23,27],
-[ 9,       432,  2, 00100, EABL,     ,    "Huppert", 22,25,27],
+[ 9,       216,  2, 00000, EABL,     ,"3^2:(2`A_4)", 22,23,27],
+[ 9,       432,  2, 00100, EABL,     ,   "AGL(2,3)", 22,25,27],
 [ 9,       504,  3, 11001, 0908, 0801,   "PSL(2,8)", 12,18,28],
-[ 9,      1512,  3, 01000, 0908, 0802,   "PZL(2,8)", 12,18,28,14],
+[ 9,      1512,  3, 01000, 0908, 0802,   "PYL(2,8)", 12,18,28,14],
 [ 9,  FAC(9)/2,  7, 11001, 0910, 0806,       "A(9)", 29,2],
 [ 9,    FAC(9),  9, 10100, 0910, 0807,       "S(9)", 30,1],
 [10,        60,  1, 00001, 1001,     ,       "A(5)", 31,32],
@@ -693,13 +703,13 @@
 [10,       360,  2, 01001, 1003, 0901,   "PSL(2,9)", 22,23,34],
 [10,       720,  2, 01100, 1003, 0902,       "S(6)", 22,23,24,34],
 [10,       720,  3, 10100, 1003, 0903,   "PGL(2,9)", 22,25,34],
-[10,       720,  3, 10000, 1003, 0904,  "<PYL(2,9)", 22,23,26,34],
+[10,       720,  3, 10000, 1003, 0904,       "M_10", 22,23,26,34],
 [10,      1440,  3, 00100, 1003, 0905,   "PYL(2,9)", 22,25,24,34],
 [10, FAC(10)/2,  8, 11001, 1008, 0910,      "A(10)", 35,2],
 [10,   FAC(10), 10, 00100, 1008, 0911,      "S(10)", 36,1],
-[11,        11,  1, 00001, 1101,     ,             , 37],
-[11,        22,  1, 00110, 1101,     ,             , 37,38],
-[11,        55,  1, 00010, 1101,     ,             , 37,39],
+[11,        11,  1, 00001, 1101,     ,         "11", 37],
+[11,        22,  1, 00110, 1101,     ,       "11:2", 37,38],
+[11,        55,  1, 00010, 1101,     ,       "11:5", 37,39],
 [11,       110,  2, 10110, 1101,     ,  "AGL(1,11)", 37,40],
 [11,       660,  2, 01001, 1105, 1001,  "PSL(2,11)", 31,32,41],
 [11,      7920,  4, 10001, 1106, 1006,      "M(11)", 22,23,26,34,42],
@@ -711,11 +721,11 @@
 [12,     95040,  5, 10001, 1204, 1106,      "M(12)", 22,23,26,34,42,46],
 [12, FAC(12)/2, 10, 01001, 1205, 1107,      "A(12)", 47,2],
 [12,   FAC(12), 12, 00100, 1205, 1108,      "S(12)", 48,1],
-[13,        13,  1, 00001, 1301,     ,             , 49],
-[13,        26,  1, 00010, 1301,     ,             , 49,50],
-[13,        39,  1, 00010, 1301,     ,             , 49,51],
-[13,        52,  1, 00110, 1301,     ,             , 49,52],
-[13,        78,  1, 00010, 1301,     ,             , 49,53],
+[13,        13,  1, 00001, 1301,     ,         "13", 49],
+[13,        26,  1, 00010, 1301,     ,       "13:2", 49,50],
+[13,        39,  1, 00010, 1301,     ,       "13:3", 49,51],
+[13,        52,  1, 00110, 1301,     ,       "13:4", 49,52],
+[13,        78,  1, 00010, 1301,     ,       "13:6", 49,53],
 [13,       156,  2, 10110, 1301,     ,  "AGL(1,13)", 49,54],
 [13,      5616,  2, 00001, 1307,     ,   "PSL(3,3)", 49,55],
 [13, FAC(13)/2, 11, 01001, 1308, 1205,      "A(13)", 56,2],
@@ -730,20 +740,20 @@
 [15,     20160,  2, 00001, 1504,     ,   "PSL(4,2)", 63,64],
 [15, FAC(15)/2, 13, 01001, 1505, 1403,      "A(15)", 65,2],
 [15,   FAC(15), 15, 00100, 1505, 1404,      "S(15)", 66,1],
-[16,        80,  1, 00010, EABL,     ,             , 60,67],
-[16,       160,  1, 00000, EABL,     ,             , 60,67,68],
+[16,        80,  1, 00010, EABL,     ,      "2^4:5", 60,67],
+[16,       160,  1, 00000, EABL,     ,   "2^4:D_10", 60,67,68],
 [16,       240,  2, 10010, EABL,     ,  "AGL(1,16)", 69,67],
-[16,       288,  1, 00000, EABL,     ,             , 61,67,70,71],
-[16,       320,  1, 00000, EABL,     ,             , 60,67,72],
-[16,       480,  2, 00000, EABL,     , "<AYL(1,16)", 69,67,68],
-[16,       576,  1, 00000, EABL,     ,             , 61,67,70,73],
-[16,       576,  1, 00000, EABL,     ,             , 61,67,70,71,74],
-[16,       960,  1, 00000, EABL,     ,             , 60,67,75],
+[16,       288,  1, 00000, EABL,     ,"(A_4xA_4):2", 61,67,70,71],
+[16,       320,  1, 00000, EABL,     ,  "(2^4:5).4", 60,67,72],
+[16,       480,  2, 00000, EABL,     ,"AGL(1,16):2", 69,67,68],
+[16,       576,  1, 00000, EABL,     ,  "2^4.3^2:4", 61,67,70,73],
+[16,       576,  1, 00000, EABL,     ,"2^4.S_3xS_3", 61,67,70,71,74],
+[16,       960,  1, 00000, EABL,     ,    "2^4:A_5", 60,67,75],
 [16,       960,  2, 00000, EABL,     ,  "AYL(1,16)", 69,67,72],
 [16,       960,  2, 00000, EABL,     ,   "ASL(2,4)", 60,67,70],
-[16,      1152,  1, 00000, EABL,     ,             , 61,67,70,71,76],
-[16,      1920,  1, 00000, EABL,     ,             , 60,67,77],
-[16,      1920,  2, 00000, EABL,     ,   "AZL(2,4)", 60,67,78],
+[16,      1152,  1, 00000, EABL,     ,"(S_4xS_4):2", 61,67,70,71,76],
+[16,      1920,  1, 00000, EABL,     ,    "2^4:S_5", 60,67,77],
+[16,      1920,  2, 00000, EABL,     , "ASL(2,4):2", 60,67,78],
 [16,      2880,  2, 00000, EABL,     ,   "AGL(2,4)", 69,67,70],
 [16,      5760,  2, 00000, EABL,     ,   "AYL(2,4)", 69,67,78],
 [16,      5760,  2, 01000, EABL, 1501,   "2^4.A(6)", 60,61,67],
@@ -752,13 +762,13 @@
 [16,    322560,  3, 00000, EABL, 1504, "2^4.L(4,2)", 63,64,67],
 [16, FAC(16)/2, 14, 01001, 1621, 1505,      "A(16)", 79,2],
 [16,   FAC(16), 16, 00100, 1621, 1506,      "S(16)", 80,1],
-[17,        17,  1, 00001, 1701,     ,             , 81],
-[17,        34,  1, 00010, 1701,     ,             , 81,82],
-[17,        68,  1, 00010, 1701,     ,             , 81,83],
-[17,       136,  1, 00010, 1701,     ,             , 81,84],
+[17,        17,  1, 00001, 1701,     ,         "17", 81],
+[17,        34,  1, 00010, 1701,     ,       "17:2", 81,82],
+[17,        68,  1, 00010, 1701,     ,       "17:4", 81,83],
+[17,       136,  1, 00010, 1701,     ,       "17:8", 81,84],
 [17,       272,  2, 10110, 1701,     ,  "AGL(1,17)", 81,85],
 [17,      4080,  3, 10001, 1706, 1603,  "PSL(2,16)", 69,67,86],
-[17,      8160,  3, 00000, 1706, 1606, "<PZL(2,16)", 69,67,68,86],
+[17,      8160,  3, 00000, 1706, 1606,"PSL(2,16):2", 69,67,68,86],
 [17,     16320,  3, 00000, 1706, 1610,  "PYL(2,16)", 69,67,72,86],
 [17, FAC(17)/2, 15, 01001, 1709, 1621,      "A(17)", 87,2],
 [17,   FAC(17), 17, 00100, 1709, 1622,      "S(17)", 81,1],
@@ -766,11 +776,11 @@
 [18,      4896,  3, 10100, 1801, 1705,  "PGL(2,17)", 81,85,88],
 [18, FAC(18)/2, 16, 01001, 1803, 1709,      "A(18)", 89,2],
 [18,   FAC(18), 18, 00100, 1803, 1710,      "S(18)", 90,1],
-[19,        19,  1, 00001, 1901,     ,             , 91],
-[19,        38,  1, 00110, 1901,     ,             , 91,92],
-[19,        57,  1, 00010, 1901,     ,             , 91,93],
-[19,       114,  1, 00110, 1901,     ,             , 91,94],
-[19,       171,  1, 00010, 1901,     ,             , 91,95],
+[19,        19,  1, 00001, 1901,     ,         "19", 91],
+[19,        38,  1, 00110, 1901,     ,       "19:2", 91,92],
+[19,        57,  1, 00010, 1901,     ,       "19:3", 91,93],
+[19,       114,  1, 00110, 1901,     ,       "19:6", 91,94],
+[19,       171,  1, 00010, 1901,     ,       "19:9", 91,95],
 [19,       342,  2, 10110, 1901,     ,  "AGL(1,19)", 91,96],
 [19, FAC(19)/2, 17, 01001, 1907, 1803,      "A(19)", 97,2],
 [19,   FAC(19), 19, 00100, 1907, 1804,      "S(19)", 91,1],
@@ -788,12 +798,12 @@
 [21, FAC(21)/2, 19, 11001, 2108, 2003,      "A(21)", 109,2],
 [21,   FAC(21), 21, 10100, 2108, 2004,      "S(21)", 110,1],
 [22,    443520,  3, 00001, 2201, 2104,      "M(22)", 101,106,111],
-[22,    887040,  3, 00100, 2201, 2105,             , 101,106,107,111],
+[22,    887040,  3, 00100, 2201, 2105,    "M(22):2", 101,106,107,111],
 [22, FAC(22)/2, 20, 11001, 2203, 2108,      "A(22)", 112,2],
 [22,   FAC(22), 22, 10100, 2203, 2109,      "S(22)", 113,1],
-[23,        23,  1, 00001, 2301,     ,             , 114],
-[23,        46,  1, 00110, 2301,     ,             , 114,115],
-[23,       253,  1, 00010, 2301,     ,             , 114,116],
+[23,        23,  1, 00001, 2301,     ,         "23", 114],
+[23,        46,  1, 00110, 2301,     ,       "23:2", 114,115],
+[23,       253,  1, 00010, 2301,     ,      "23:11", 114,116],
 [23,       506,  2, 10110, 2301,     ,  "AGL(1,23)", 114,117],
 [23,  10200960,  4, 00001, 2305, 2201,      "M(23)", 101,106,111,118],
 [23, FAC(23)/2, 21, 11001, 2306, 2203,      "A(23)", 119,2],
@@ -803,75 +813,75 @@
 [24, 244823040,  5, 00001, 2403, 2305,      "M(24)", 101,106,111,118,121],
 [24, FAC(24)/2, 22, 11001, 2404, 2306,      "A(24)", 122,2],
 [24,   FAC(24), 24, 10100, 2404, 2307,      "S(24)", 123,1],
-[25,        75,  1, 00010, EABL,     ,             , 124,125],
-[25,       150,  1, 00010, EABL,     ,             , 124,125,126],
-[25,       150,  1, 00000, EABL,     ,             , 124,125,127],
-[25,       200,  1, 00000, EABL,     ,             , 124,128,129],
-[25,       200,  1, 00110, EABL,     ,             , 124,130],
-[25,       200,  1, 00010, EABL,     ,             , 124,131,129],
-[25,       300,  1, 00010, EABL,     ,             , 124,125,132],
-[25,       300,  1, 00010, EABL,     ,             , 124,125,129],
-[25,       300,  1, 00000, EABL,     ,             , 124,125,126,127],
-[25,       400,  1, 00100, EABL,     ,             , 124,130,127],
-[25,       400,  1, 00000, EABL,     ,             , 124,132,128,127],
-[25,       600,  1, 00000, EABL,     ,             , 124,125,132,127],
-[25,       600,  2, 10010, EABL,     ,  "AGL(1,25)", 124,125,133],
-[25,       600,  2, 10110, EABL,     , "<AYL(1,25)", 124,125,130],
-[25,       600,  2, 10110, EABL,     ,    "Huppert", 124,125,134],
-[25,       800,  1, 00100, EABL,     ,             , 124,130,135],
-[25,      1200,  2, 00000, EABL,     ,  "AYL(1,25)", 124,125,133,136],
-[25,      1200,  2, 00100, EABL,     ,    "Huppert", 124,125,130,127],
-[25,      2400,  2, 00100, EABL,     ,    "Huppert", 124,125,133,137],
+[25,        75,  1, 00010, EABL,     ,      "5^2:3", 124,125],
+[25,       150,  1, 00010, EABL,     ,      "5^2:6", 124,125,126],
+[25,       150,  1, 00000, EABL,     ,    "5^2:S_3", 124,125,127],
+[25,       200,  1, 00000, EABL,     ,    "5^2:D_8", 124,128,129],
+[25,       200,  1, 00110, EABL,     ,      "5^2:8", 124,130],
+[25,       200,  1, 00010, EABL,     ,    "5^2:Q_8", 124,131,129],
+[25,       300,  1, 00010, EABL,     ,     "5^2:12", 124,125,132],
+[25,       300,  1, 00010, EABL,     ,"5^2:Q_12 ??", 124,125,129],
+[25,       300,  1, 00000, EABL,     ,   "5^2:D_12", 124,125,126,127],
+[25,       400,  1, 00100, EABL,     ,    "5^2:8:2", 124,130,127],
+[25,       400,  1, 00000, EABL,     ,  "5^2:D_8:2", 124,132,128,127],
+[25,       600,  1, 00000, EABL,     ,  "5^2:4xD_6", 124,125,132,127],
+[25,       600,  2, 10010, EABL,     ,"5^2:(Q_8:3)", 124,125,133],
+[25,       600,  2, 10110, EABL,     ,  "AGL(1,25)", 124,125,130],
+[25,       600,  2, 10110, EABL,     ,    "5^2:3:8", 124,125,134],
+[25,       800,  1, 00100, EABL,     ,"5^2:O_2+(5)", 124,130,135],
+[25,      1200,  2, 00000, EABL,     ,"5^2:((Q_8:3)`2)", 124,125,133,136],
+[25,      1200,  2, 00100, EABL,     ,   "AYL(2,5)", 124,125,130,127],
+[25,      2400,  2, 00100, EABL,     ,"5^2:((Q_8:3)`4)", 124,125,133,137],
 [25,      3000,  2, 00000, EABL,     ,   "ASL(2,5)", 124,125,138],
-[25,      6000,  2, 00000, EABL,     ,  "<AGL(2,5)", 124,125,127,138],
-[25,      7200,  1, 00000,     ,     ,             , 127,139,140],
+[25,      6000,  2, 00000, EABL,     , "ASL(2,5):2", 124,125,127,138],
+[25,      7200,  1, 00000,     ,     ,"(A_5xA_5):2", 127,139,140],
 [25,     12000,  2, 00100, EABL,     ,   "AGL(2,5)", 124,125,135,138],
-[25,     14400,  1, 00000,     ,     ,             , 127,139,140,141],
-[25,     14400,  1, 00100,     ,     ,             , 139,140,142],
-[25,     28800,  1, 00100,     ,     ,             , 127,139,140,142],
+[25,     14400,  1, 00000,     ,     ,"(A_5xA_5):2^2", 127,139,140,141],
+[25,     14400,  1, 00100,     ,     ,"(A_5xA_5):4", 139,140,142],
+[25,     28800,  1, 00100,     ,     ,"(S_5xS_5):2", 127,139,140,142],
 [25, FAC(25)/2, 23, 11001, 2527, 2404,      "A(25)", 143,2],
 [25,   FAC(25), 25, 10100, 2527, 2405,      "S(25)", 144,1],
 [26,      7800,  2, 01001, 2601, 2507,  "PSL(2,25)", 124,125,132,145],
 [26,     15600,  2, 01000, 2601, 2512,  "PZL(2,25)", 124,125,132,127,145],
 [26,     15600,  3, 10100, 2601, 2514,  "PGL(2,25)", 124,125,130,145],
-[26,     15600,  3, 10100, 2601, 2515, "<PYL(2,25)", 124,125,134,145],
+[26,     15600,  3, 10100, 2601, 2515,"PSL(2,25).2", 124,125,134,145],
 [26,     31200,  3, 00100, 2601, 2518,  "PYL(2,25)", 124,125,130,127,145],
 [26, FAC(26)/2, 24, 11001, 2606, 2527,      "A(26)", 146,2],
 [26,   FAC(26), 26, 10100, 2606, 2528,      "S(26)", 147,1],
-[27,       324,  1, 00000, EABL,     ,             , 148,149,150],
-[27,       351,  1, 00010, EABL,     ,             , 148,151],
-[27,       648,  1, 00000, EABL,     ,             , 148,149,150,152],
-[27,       648,  1, 00100, EABL,     ,             , 148,149,153],
-[27,       648,  1, 00100, EABL,     ,             , 148,149,150,154],
+[27,       324,  1, 00000, EABL,     ,    "3^3.A_4", 148,149,150],
+[27,       351,  1, 00010, EABL,     ,     "3^3:13", 148,151],
+[27,       648,  1, 00000, EABL,     , "3^3(A_4x2)", 148,149,150,152],
+[27,       648,  1, 00100, EABL,     ,    "3^3.S_4", 148,149,153],
+[27,       648,  1, 00100, EABL,     ,  "3^3.2.A_4", 148,149,150,154],
 [27,       702,  2, 10110, EABL,     ,  "AGL(1,27)", 148,151,155],
-[27,      1053,  1, 00000, EABL,     ,             , 148,151,156],
-[27,      1296,  1, 00100, EABL,     ,             , 148,149,153,154],
+[27,      1053,  1, 00000, EABL,     ,   "3^3.13.3", 148,151,156],
+[27,      1296,  1, 00100, EABL,     , "3^3(S_4x2)", 148,149,153,154],
 [27,      2106,  2, 00100, EABL,     ,  "AYL(1,27)", 148,151,157],
 [27,     25920,  1, 00001, 2710,     ,   "PSp(4,3)", 158,159],
-[27,     51840,  1, 00000, 2710,     ,             , 158,159,160],
+[27,     51840,  1, 00000, 2710,     , "PSp(4,3):2", 158,159,160],
 [27,    151632,  2, 00000, EABL,     ,   "ASL(3,3)", 148,149,151],
-[27,    303264,  2, 00100, EABL,     ,   "AZL(3,3)", 148,153,151],
+[27,    303264,  2, 00100, EABL,     ,   "AGL(3,3)", 148,153,151],
 [27, FAC(27)/2, 25, 11001, 2714, 2606,      "A(27)", 161,2],
 [27,   FAC(27), 27, 10100, 2714, 2607,      "S(27)", 162,1],
 [28,       336,  1, 00000,     ,     ,   "PGL(2,7)", 163,164,165],
 [28,       504,  1, 00001, 2802,     ,   "PSL(2,8)", 166,167],
-[28,      1512,  2, 00000, 2802,     ,   "PZL(2,8)", 166,167,168],
+[28,      1512,  2, 00000, 2802,     ,   "PYL(2,8)", 166,167,168],
 [28,      6048,  2, 00001, 2804,     , "PSU(3,3^2)", 169,170],
 [28,      9828,  2, 01001, 2805, 2702,  "PSL(2,27)", 148,151,171],
-[28,     12096,  2, 00000, 2804,     , "PZU(3,3^2)", 169,170,172],
+[28,     12096,  2, 00000, 2804,     , "PYU(3,3^2)", 169,170,172],
 [28,     19656,  3, 10100, 2805, 2706,  "PGL(2,27)", 148,151,155,171],
 [28,     20160,  1, 00001, 2808,     ,       "A(8)", 163,173],
-[28,     29484,  2, 01000, 2805, 2707,  "PZL(2,27)", 148,151,156,171],
+[28,     29484,  2, 01000, 2805, 2707,"PSL(2,27):3", 148,151,156,171],
 [28,     40320,  1, 00000, 2808,     ,       "S(8)", 163,174],
 [28,     58968,  3, 00100, 2805, 2709,  "PYL(2,27)", 148,151,157,171],
 [28,   1451520,  2, 01001, 2812, 2711,   "PSp(6,2)", 158,159,160,175],
 [28, FAC(28)/2, 26, 11001, 2813, 2714,      "A(28)", 176,2],
 [28,   FAC(28), 28, 10100, 2813, 2715,      "S(28)", 177,1],
-[29,        29,  1, 00001, 2901,     ,             , 178],
-[29,        58,  1, 00010, 2901,     ,             , 178,179],
-[29,       116,  1, 00110, 2901,     ,             , 178,180],
-[29,       203,  1, 00010, 2901,     ,             , 178,181],
-[29,       406,  1, 00010, 2901,     ,             , 178,182],
+[29,        29,  1, 00001, 2901,     ,         "29", 178],
+[29,        58,  1, 00010, 2901,     ,       "29:2", 178,179],
+[29,       116,  1, 00110, 2901,     ,       "29:4", 178,180],
+[29,       203,  1, 00010, 2901,     ,       "29:7", 178,181],
+[29,       406,  1, 00010, 2901,     ,      "29:14", 178,182],
 [29,       812,  2, 10110, 2901,     ,  "AGL(1,29)", 178,183],
 [29, FAC(29)/2, 27, 11001, 2907, 2813,      "A(29)", 184,2],
 [29,   FAC(29), 29, 10100, 2907, 2814,      "S(29)", 178,1],
@@ -879,14 +889,14 @@
 [30,     24360,  3, 10100, 3001, 2906,  "PGL(2,29)", 178,183,185],
 [30, FAC(30)/2, 28, 11001, 3003, 2907,      "A(30)", 186,2],
 [30,   FAC(30), 30, 10100, 3003, 2908,      "S(30)", 187,1],
-[31,        31,  1, 00001, 3101,     ,             , 188],
-[31,        62,  1, 00110, 3101,     ,             , 188,189],
-[31,        93,  1, 00010, 3101,     ,             , 188,190],
-[31,       155,  1, 00010, 3101,     ,             , 188,191],
-[31,       186,  1, 00110, 3101,     ,             , 188,192],
-[31,       310,  1, 00110, 3101,     ,             , 188,193],
-[31,       465,  1, 00010, 3101,     ,             , 188,194],
-[31,       930,  2, 10110, 3101,     ,             , 188,195],
+[31,        31,  1, 00001, 3101,     ,         "31", 188],
+[31,        62,  1, 00110, 3101,     ,       "31:2", 188,189],
+[31,        93,  1, 00010, 3101,     ,       "31:3", 188,190],
+[31,       155,  1, 00010, 3101,     ,       "31:5", 188,191],
+[31,       186,  1, 00110, 3101,     ,       "31:6", 188,192],
+[31,       310,  1, 00110, 3101,     ,      "31:10", 188,193],
+[31,       465,  1, 00010, 3101,     ,      "31:15", 188,194],
+[31,       930,  2, 10110, 3101,     ,  "AGL(1,31)", 188,195],
 [31,    372000,  2, 00001, 3109,     ,   "PSL(3,5)", 188,190,196],
 [31,   9999360,  2, 00001, 3110,     ,   "PSL(5,2)", 188,191,197],
 [31, FAC(31)/2, 29, 11001, 3111, 3003,      "A(31)", 198,2],
@@ -899,7 +909,7 @@
 [32, FAC(32)/2, 30, 11001, 3206, 3111,      "A(32)", 201,2],
 [32,   FAC(32), 32, 10100, 3206, 3112,      "S(32)", 202,1],
 [33,     32736,  3, 11001, 3301, 3201,  "PSL(2,32)", 188,199,203],
-[33,    163680,  3, 01000, 3301, 3202,  "PZL(2,32)", 188,191,199,203],
+[33,    163680,  3, 01000, 3301, 3202,  "PYL(2,32)", 188,191,199,203],
 [33, FAC(33)/2, 31, 11001, 3303, 3206,      "A(33)", 204,2],
 [33,   FAC(33), 33, 10100, 3303, 3207,      "S(33)", 205,1],
 [34, FAC(34)/2, 32, 11001, 3401, 3303,      "A(34)", 206,2],
@@ -911,36 +921,36 @@
 [35, FAC(35)/2, 33, 11001, 3505, 3401,      "A(35)", 213,2],
 [35,   FAC(35), 35, 10100, 3505, 3402,      "S(35)", 214,1],
 [36,       504,  1, 00001, 3601,     ,   "PSL(2,8)", 215,216,217],
-[36,       720,  1, 00100,     ,     ,             , 218,219,220],
-[36,       720,  1, 00100,     ,     ,             , 218,221,222,220],
-[36,      1440,  1, 00100,     ,     ,             , 218,219,223,220],
-[36,      1512,  1, 00000, 3601,     ,             , 215,216,217,224],
+[36,       720,  1, 00100,     ,     ,   "PGL(2,9)", 218,219,220],
+[36,       720,  1, 00100,     ,     ,       "M_10", 218,221,222,220],
+[36,      1440,  1, 00100,     ,     ,   "PYL(2,9)", 218,219,223,220],
+[36,      1512,  1, 00000, 3601,     ,   "PYL(2,8)", 215,216,217,224],
 [36,      6048,  1, 00001, 3606,     , "PSU(3,3^2)", 225,226,227,228],
-[36,      7200,  1, 00100,     ,     ,             , 229,230,231],
-[36,     12096,  1, 00000, 3606,     ,             , 225,226,227,232,228],
-[36,     14400,  1, 00100,     ,     ,             , 229,230,233],
-[36,     14400,  1, 00100,     ,     ,             , 229,230,231,234],
+[36,      7200,  1, 00100,     ,     ,"(A_5xA_5):2", 229,230,231],
+[36,     12096,  1, 00000, 3606,     , "PYU(3,3^2)", 225,226,227,232,228],
+[36,     14400,  1, 00100,     ,     ,"((A_5xA_5):2)2", 229,230,233],
+[36,     14400,  1, 00100,     ,     ,"(A_5xA_5).4", 229,230,231,234],
 [36,     25920,  1, 00001, 3611,     ,   "PSp(4,3)", 235,236],
-[36,     28800,  1, 00100,     ,     ,             , 229,230,231,233],
-[36,     51840,  1, 00000, 3611,     ,             , 235,236,237],
+[36,     28800,  1, 00100,     ,     ,"(S_5xS_5):2", 229,230,231,233],
+[36,     51840,  1, 00000, 3611,     , "PSp(4,3):2", 235,236,237],
 [36,    181440,  1, 00001, 3614,     ,       "A(9)", 238,239],
-[36,    259200,  1, 00100,     ,     ,             , 240,241,242],
+[36,    259200,  1, 00100,     ,     ,"(A_6xA_6):2", 240,241,242],
 [36,    362880,  1, 00100, 3614,     ,       "S(9)", 238,243],
-[36,    518400,  1, 00100,     ,     ,             , 240,241,244],
-[36,    518400,  1, 00100,     ,     ,             , 240,241,242,245],
-[36,   1036800,  1, 00100,     ,     ,             , 240,241,242,244],
+[36,    518400,  1, 00100,     ,     ,"(A_6xA_6):4", 240,241,244],
+[36,    518400,  1, 00100,     ,     ,"(A_6xA_6):2^2", 240,241,242,245],
+[36,   1036800,  1, 00100,     ,     ,"(S_6xS_6):2", 240,241,242,244],
 [36,   1451520,  2, 01001, 3620, 3504,   "PSp(6,2)", 208,212,246],
 [36, FAC(36)/2, 34, 11001, 3621, 3505,      "A(36)", 247,2],
 [36,   FAC(36), 36, 10100, 3621, 3506,      "S(36)", 248,1],
-[37,        37,  1, 00001, 3701,     ,             , 249],
-[37,        74,  1, 00010, 3701,     ,             , 249,250],
-[37,       111,  1, 00010, 3701,     ,             , 249,251],
-[37,       148,  1, 00110, 3701,     ,             , 249,252],
-[37,       222,  1, 00010, 3701,     ,             , 249,253],
-[37,       333,  1, 00010, 3701,     ,             , 249,254],
-[37,       444,  1, 00110, 3701,     ,             , 249,255],
-[37,       666,  1, 00010, 3701,     ,             , 249,256],
-[37,      1332,  2, 10110, 3701,     ,             , 249,257],
+[37,        37,  1, 00001, 3701,     ,         "37", 249],
+[37,        74,  1, 00010, 3701,     ,       "37:2", 249,250],
+[37,       111,  1, 00010, 3701,     ,       "37:3", 249,251],
+[37,       148,  1, 00110, 3701,     ,       "37:4", 249,252],
+[37,       222,  1, 00010, 3701,     ,       "37:6", 249,253],
+[37,       333,  1, 00010, 3701,     ,       "37:9", 249,254],
+[37,       444,  1, 00110, 3701,     ,      "37:12", 249,255],
+[37,       666,  1, 00010, 3701,     ,      "37:18", 249,256],
+[37,      1332,  2, 10110, 3701,     ,  "AGL(1,37)", 249,257],
 [37, FAC(37)/2, 35, 11001, 3710, 3621,      "A(37)", 258,2],
 [37,   FAC(37), 37, 10100, 3710, 3622,      "S(37)", 249,1],
 [38,     25308,  2, 01001, 3801, 3708,  "PSL(2,37)", 249,256,259],
@@ -951,108 +961,108 @@
 [39,   FAC(39), 39, 10100, 3901, 3804,      "S(39)", 263,1],
 [40,     25920,  1, 00001, 4001,     ,   "PSp(4,3)", 264,265],
 [40,     25920,  1, 00001, 4002,     ,   "PSp(4,3)", 266,267],
-[40,     51840,  1, 00000, 4001,     ,             , 264,265,268],
-[40,     51840,  1, 00100, 4002,     ,             , 266,267,269],
+[40,     51840,  1, 00000, 4001,     , "PSp(4,3):2", 264,265,268],
+[40,     51840,  1, 00100, 4002,     , "PSp(4,3):2", 266,267,269],
 [40,   6065280,  2, 00001, 4005,     ,   "PSL(4,3)", 270,271],
 [40,  12130560,  2, 00100, 4005,     ,   "PGL(4,3)", 270,271,272],
 [40, FAC(40)/2, 38, 11001, 4007, 3901,      "A(40)", 273,2],
 [40,   FAC(40), 40, 10100, 4007, 3902,      "S(40)", 274,1],
-[41,        41,  1, 00001, 4101,     ,             , 275],
-[41,        82,  1, 00010, 4101,     ,             , 275,276],
-[41,       164,  1, 00010, 4101,     ,             , 275,277],
-[41,       205,  1, 00010, 4101,     ,             , 275,278],
-[41,       328,  1, 00110, 4101,     ,             , 275,279],
-[41,       410,  1, 00010, 4101,     ,             , 275,280],
-[41,       820,  1, 00010, 4101,     ,             , 275,281],
-[41,      1640,  2, 10110, 4101,     ,  "AYL(1,41)", 275,282],
+[41,        41,  1, 00001, 4101,     ,         "41", 275],
+[41,        82,  1, 00010, 4101,     ,       "41:2", 275,276],
+[41,       164,  1, 00010, 4101,     ,       "41:4", 275,277],
+[41,       205,  1, 00010, 4101,     ,       "41:5", 275,278],
+[41,       328,  1, 00110, 4101,     ,       "41:8", 275,279],
+[41,       410,  1, 00010, 4101,     ,      "41:10", 275,280],
+[41,       820,  1, 00010, 4101,     ,      "41:20", 275,281],
+[41,      1640,  2, 10110, 4101,     ,  "AGL(1,41)", 275,282],
 [41, FAC(41)/2, 39, 11001, 4109, 4007,      "A(41)", 283,2],
 [41,   FAC(41), 41, 10100, 4109, 4008,      "S(41)", 275,1],
 [42,     34440,  2, 01001, 4201, 4107,  "PSL(2,41)", 275,281,284],
 [42,     68880,  3, 10100, 4201, 4108,  "PGL(2,41)", 275,282,284],
 [42, FAC(42)/2, 40, 11001, 4203, 4109,      "A(42)", 285,2],
 [42,   FAC(42), 42, 10100, 4203, 4110,      "S(42)", 286,1],
-[43,        43,  1, 00001, 4301,     ,             , 287],
-[43,        86,  1, 00110, 4301,     ,             , 287,288],
-[43,       129,  1, 00010, 4301,     ,             , 287,289],
-[43,       258,  1, 00110, 4301,     ,             , 287,290],
-[43,       301,  1, 00010, 4301,     ,             , 287,291],
-[43,       602,  1, 00110, 4301,     ,             , 287,292],
-[43,       903,  1, 00010, 4301,     ,             , 287,293],
-[43,      1806,  2, 10110, 4301,     ,  "AYL(1,43)", 287,294],
+[43,        43,  1, 00001, 4301,     ,         "43", 287],
+[43,        86,  1, 00110, 4301,     ,       "43:2", 287,288],
+[43,       129,  1, 00010, 4301,     ,       "43:3", 287,289],
+[43,       258,  1, 00110, 4301,     ,       "43:6", 287,290],
+[43,       301,  1, 00010, 4301,     ,       "43:7", 287,291],
+[43,       602,  1, 00110, 4301,     ,      "43:14", 287,292],
+[43,       903,  1, 00010, 4301,     ,      "43:21", 287,293],
+[43,      1806,  2, 10110, 4301,     ,  "AGL(1,43)", 287,294],
 [43, FAC(43)/2, 41, 11001, 4309, 4203,      "A(43)", 295,2],
 [43,   FAC(43), 43, 10100, 4309, 4204,      "S(43)", 287,1],
 [44,     39732,  2, 01001, 4401, 4307,  "PSL(2,43)", 287,293,296],
 [44,     79464,  3, 10100, 4401, 4308,  "PGL(2,43)", 287,294,296],
 [44, FAC(44)/2, 42, 11001, 4403, 4309,      "A(44)", 297,2],
 [44,   FAC(44), 44, 10100, 4403, 4310,      "S(44)", 298,1],
-[45,       720,  1, 00000,     ,     ,             , 299,300,301],
-[45,       720,  1, 00000,     ,     ,             , 299,302,303,301],
-[45,      1440,  1, 00000,     ,     ,             , 299,300,304,301],
+[45,       720,  1, 00000,     ,     ,   "PGL(2,9)", 299,300,301],
+[45,       720,  1, 00000,     ,     ,       "M_10", 299,302,303,301],
+[45,      1440,  1, 00000,     ,     ,   "PYL(2,9)", 299,300,304,301],
 [45,     25920,  1, 00001, 4504,     ,   "PSp(4,3)", 305,306],
-[45,     51840,  1, 00100, 4504,     ,             , 305,306,307],
+[45,     51840,  1, 00100, 4504,     , "PSp(4,3):2", 305,306,307],
 [45,   1814400,  1, 00001, 4506,     ,      "A(10)", 308,309],
 [45,   3628800,  1, 00000, 4506,     ,      "S(10)", 308,309,310],
 [45, FAC(45)/2, 43, 11001, 4508, 4403,      "A(45)", 311,2],
 [45,   FAC(45), 45, 10100, 4508, 4404,      "S(45)", 312,1],
 [46, FAC(46)/2, 44, 11001, 4601, 4508,      "A(46)", 313,2],
 [46,   FAC(46), 46, 10100, 4601, 4509,      "S(46)", 314,1],
-[47,        47,  1, 00001, 4701,     ,             , 315],
-[47,        94,  1, 00110, 4701,     ,             , 315,316],
-[47,      1081,  1, 00010, 4701,     ,             , 315,317],
-[47,      2162,  2, 10110, 4701,     ,             , 315,318],
+[47,        47,  1, 00001, 4701,     ,         "47", 315],
+[47,        94,  1, 00110, 4701,     ,       "47:2", 315,316],
+[47,      1081,  1, 00010, 4701,     ,      "47:23", 315,317],
+[47,      2162,  2, 10110, 4701,     ,  "AGL(1,47)", 315,318],
 [47, FAC(47)/2, 45, 11001, 4705, 4601,      "A(47)", 319,2],
 [47,   FAC(47), 47, 10100, 4705, 4602,      "S(47)", 315,1],
 [48,     51888,  2, 01001, 4801, 4703,  "PSL(2,47)", 315,317,320],
 [48,    103776,  3, 10100, 4801, 4704,  "PGL(2,47)", 315,318,320],
 [48, FAC(48)/2, 46, 11001, 4803, 4705,      "A(48)", 321,2],
 [48,   FAC(48), 48, 10100, 4803, 4706,      "S(48)", 322,1],
-[49,       196,  1, 00010, EABL,     ,             , 323,324],
-[49,       294,  1, 00100, EABL,     ,             , 323,325,326],
-[49,       392,  1, 00010, EABL,     ,             , 323,327],
-[49,       392,  1, 00010, EABL,     ,             , 323,324,328],
-[49,       392,  1, 00100, EABL,     ,             , 323,324,329],
-[49,       588,  1, 00010, EABL,     ,             , 323,325,324],
-[49,       588,  1, 00010, EABL,     ,             , 323,330,324],
-[49,       588,  1, 00100, EABL,     ,             , 323,325,331,326],
-[49,       784,  1, 00010, EABL,     ,             , 323,327,328],
-[49,       784,  1, 00110, EABL,     ,             , 323,332],
-[49,       784,  1, 00100, EABL,     ,             , 323,327,329],
-[49,       882,  1, 00100, EABL,     ,             , 323,333,326],
-[49,      1176,  1, 00010, EABL,     ,             , 323,330,327],
-[49,      1176,  1, 00010, EABL,     ,             , 323,330,324,328],
-[49,      1176,  1, 00010, EABL,     ,             , 323,324,328,334],
-[49,      1176,  1, 00000, EABL,     ,             , 323,324,328,335],
-[49,      1176,  1, 00100, EABL,     ,             , 323,325,329,326],
-[49,      1176,  1, 00100, EABL,     ,             , 323,330,324,329],
-[49,      1568,  1, 00100, EABL,     ,             , 323,332,329],
-[49,      1764,  1, 00000, EABL,     ,             , 323,333,324],
-[49,      1764,  1, 00100, EABL,     ,             , 323,333,331,326],
-[49,      2352,  2, 10010, EABL,     ,  "AGL(1,49)", 323,327,328,334],
-[49,      2352,  2, 10010, EABL,     , "<AYL(1,49)", 323,330,327,328],
-[49,      2352,  2, 10110, EABL,     ,    "Huppert", 323,330,332],
-[49,      2352,  1, 00100, EABL,     ,             , 323,330,327,329],
-[49,      3528,  1, 00000, EABL,     ,             , 323,330,328,324,334],
-[49,      3528,  1, 00100, EABL,     ,             , 323,333,329,326],
+[49,       196,  1, 00010, EABL,     ,      "7^2:4", 323,324],
+[49,       294,  1, 00100, EABL,     ,    "7^2:S_3", 323,325,326],
+[49,       392,  1, 00010, EABL,     ,      "7^2:8", 323,327],
+[49,       392,  1, 00010, EABL,     ,    "7^2:Q_8", 323,324,328],
+[49,       392,  1, 00100, EABL,     ,    "7^2:D_8", 323,324,329],
+[49,       588,  1, 00010, EABL,     ,   "7^2:Q_12", 323,325,324],
+[49,       588,  1, 00010, EABL,     ,     "7^2:12", 323,330,324],
+[49,       588,  1, 00100, EABL,     ,   "7^2:D_12", 323,325,331,326],
+[49,       784,  1, 00010, EABL,     ,   "7^2:Q_16", 323,327,328],
+[49,       784,  1, 00110, EABL,     ,     "7^2:16", 323,332],
+[49,       784,  1, 00100, EABL,     ,   "7^2:D_16", 323,327,329],
+[49,       882,  1, 00100, EABL,     ,  "7^2:3xD_6", 323,333,326],
+[49,      1176,  1, 00010, EABL,     ,     "7^2:24", 323,330,327],
+[49,      1176,  1, 00010, EABL,     ,  "7^2:3xQ_8", 323,330,324,328],
+[49,      1176,  1, 00010, EABL,     ,  "7^2:Q_8:3", 323,324,328,334],
+[49,      1176,  1, 00000, EABL,     ,  "7^2:Q_8:3", 323,324,328,335],
+[49,      1176,  1, 00100, EABL,     ,  "7^2:3:D_8", 323,325,329,326],
+[49,      1176,  1, 00100, EABL,     ,  "7^2:3xD_8", 323,330,324,329],
+[49,      1568,  1, 00100, EABL,     , "7^2:Q_16:2", 323,332,329],
+[49,      1764,  1, 00000, EABL,     , "7^2:3xQ_12", 323,333,324],
+[49,      1764,  1, 00100, EABL,     , "7^2:3xD_12", 323,333,331,326],
+[49,      2352,  2, 10010, EABL,     ,"7^2:(Q_8`D_6)", 323,327,328,334],
+[49,      2352,  2, 10010, EABL,     ,"7^2:(3xQ_16)", 323,330,327,328],
+[49,      2352,  2, 10110, EABL,     ,  "AGL(1,49)", 323,330,332],
+[49,      2352,  1, 00100, EABL,     , "7^2:3xD_16", 323,330,327,329],
+[49,      3528,  1, 00000, EABL,     ,"7^2:3x(Q_8:3)", 323,330,328,324,334],
+[49,      3528,  1, 00100, EABL,     ,"(AGL(1,7)^2):2", 323,333,329,326],
 [49,      4704,  2, 00100, EABL,     ,  "AYL(1,49)", 323,330,332,329],
-[49,      7056,  2, 00000, EABL,     ,    "Huppert", 323,330,328,327,334],
+[49,      7056,  2, 00000, EABL,     ,"7^2:((Q_8`D_6)x3)", 323,330,328,327,334],
 [49,     16464,  2, 00000, EABL,     ,   "ASL(2,7)", 323,336,324],
-[49,     32928,  2, 00100, EABL,     ,  ">ASL(2,7)", 323,336,324,326],
-[49,     49392,  2, 00000, EABL,     ,  ">ASL(2,7)", 323,336,324,330],
-[49,     56448,  1, 00100,     ,     ,             , 337,338,326],
+[49,     32928,  2, 00100, EABL,     , "ASL(2,7):2", 323,336,324,326],
+[49,     49392,  2, 00000, EABL,     , "ASL(2,7):3", 323,336,324,330],
+[49,     56448,  1, 00100,     ,     ,"(PSL(3,2)^2):2", 337,338,326],
 [49,     98784,  2, 00100, EABL,     ,   "AGL(2,7)", 323,336,324,326,330],
-[49,  12700800,  1, 00100,     ,     ,             , 339,340,326],
-[49,  25401600,  1, 00000,     ,     ,             , 339,340,326,341],
-[49,  25401600,  1, 00100,     ,     ,             , 339,340,342],
-[49,  50803200,  1, 00100,     ,     ,             , 339,340,326,343],
+[49,  12700800,  1, 00100,     ,     ,"(A_7xA_7):2", 339,340,326],
+[49,  25401600,  1, 00100,     ,     ,"(A_7xA_7):2^2", 339,340,326,341],
+[49,  25401600,  1, 00000,     ,     ,"(A_7xA_7):4", 339,340,342],
+[49,  50803200,  1, 00100,     ,     ,"(S_7xS_7):2", 339,340,326,343],
 [49, FAC(49)/2, 47, 11001, 4939, 4803,      "A(49)", 344,2],
 [49,   FAC(49), 49, 10100, 4939, 4804,      "S(49)", 345,1],
 [50,     58800,  2, 01001, 5001, 4913,  "PSL(2,49)", 323,330,327,346],
 [50,    117600,  3, 10000, 5001, 4922,  "PGL(2,49)", 323,330,327,328,346],
-[50,    117600,  3, 10100, 5001, 4924,             , 323,330,332,346],
-[50,    117600,  2, 01100, 5001, 4925,             , 323,330,327,329,346],
+[50,    117600,  3, 10100, 5001, 4924,"PSL(2,49):2", 323,330,332,346],
+[50,    117600,  2, 01100, 5001, 4925,"PSL(2,49):2", 323,330,327,329,346],
 [50,    126000,  1, 00001, 5005,     , "PSU(3,5^2)", 347,348,349,350],
-[50,    235200,  3, 00100, 5001, 4928,             , 323,330,332,329,346],
-[50,    252000,  1, 00000, 5005,     ,             , 351,348,349,350],
+[50,    235200,  3, 00100, 5001, 4928,  "PYL(2,49)", 323,330,332,329,346],
+[50,    252000,  1, 00000, 5005,     ,"PSU(3,5^2):2", 351,348,349,350],
 [50, FAC(50)/2, 48, 11001, 5008, 4939,      "A(50)", 352,2],
 [50,   FAC(50), 50, 10100, 5008, 4940,      "S(50)", 353,1]

@@ -1107,11 +1117,10 @@
     od;

     # check the number
-    if Length(PGTable) < deg  then
+    if PGTable[ Length(PGTable) ][1] < deg  then
         Error("<deg> is too large");
     fi;
-    if not IsBound( PGTable[h+nr] )
-        or PGTable[h+nr-1][1] <> deg  then
+    if not IsBound( PGTable[h+nr-1] ) or PGTable[h+nr-1][1] <> deg  then
         Error("<nr> is too large");
     fi;

@@ -1155,7 +1164,7 @@
                 fi;
             od;
             inds := inds2;  grps := grps2;
-
+
         # special case for Size
         elif arg[2*i-1] = Size  then

@@ -1292,7 +1301,7 @@
                 fi;

                 res := arg[2*i-1](grp);
-                hasProps := hasProps
+                hasProps := hasProps
                     and (res = arg[2*i]
                         or (IsList(arg[2*i])
                             and res in arg[2*i]));
@@ -1302,7 +1311,7 @@
             i := i + 1;

         od; # run over the properties
-
+
         # if the group has all properties, return it
         if hasProps  then
             if IsInt(grp)  then
END OF  bugfix10.dif ________________________________________________________



From martin.schoenert@math.rwth-aachen.de Thu May 30 22:48:00 1996
Date:           Thu, 30 May 96 22:48:00 +0100 (MET)
From:           "Martin Schoenert" <Martin.Schoenert@Math.RWTH-Aachen.DE>
Subject:        Re: Minor Bug

David Wood and Sebastian Egner have reported errors that occur when one
tries to construct ranges with entries larger than 2^28-1 or smaller than
-2^28.

GAP represents integers between -2^28 and 2^28-1 (including) as
*immediate integers*, i.e., they are stored directly, whereas larger
integers are represented by a pointer to a memory location where the
large integer is stored.  Thus immediate integers must fit into 4
bytes.  Since we need 2 bits to be able to distinguish, one bit for the
sign, and one guard bit (to detect overflow), immediate integers are
restricted to the range -2^28 .. 2^28-1.

The first restriction is that ranges must contain only small integers.
When you try to construct a range containing large integers, you get a
misleading error message.  This is the problem reported by David Wood.

The next restriction is that the position in '<list>[<position>]' must be
a small (and of course positive) integer.  If it isn't, you also get a
misleading error message

    gap> list := [];;
    gap> list[ 2^28 ];
    Error, List Element: <position> must be a positive integer

The final restriction is that *all* lists must have a length < 2^28.
This is of course not a important, given the previous restriction.

While it is possible to contruct some longer ranges, funny things happen
when you do

    gap> list := [-10..2^28-1];
    [ -10 .. 268435455 ]
    gap> Length( list );
    268435466
    gap> 2^28+10;
    268435466
    gap> last = last2;
    false

This is because the length is represented as immediate integer, even
though it is strictly too large for it. But because of the guard bit,
it still *seems* to work.

It gets worse when one constructs the longest possible range.

    gap> list := [-2^28..2^28-1];;
    gap> Length( list );
    -536870912

When GAP tries to print this list (of negative length) it dies (this
is the problem reported by Sebastian Egner).

    gap> [-2^28..2^28-1];
    Segmentation fault

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,   +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, 52056 Aachen, Germany



From heiko.theissen@math.rwth-aachen.de Fri May 31 08:12:00 1996
Date:           Fri, 31 May 96 08:12:00 +0100 (MET)
From:           "Heiko Theissen" <Heiko.Theissen@Math.RWTH-Aachen.DE>
Subject:        Re: Lattices of intermediate subgroups

Dear Gap forum,

Vitaliy   Mysovskikh  has asked  about   a  way   to compute  a  right
transversal for  the normaliser   of  a given permutation  group.  The
general way to produce a right transversal in GAP is to say

gap> RightTransversal( supergroup, subgroup );

which   will  return  the  right transversal   as  a  list. This works
reasonably for permutation groups of small degree. For example, if you
want to loop over all conjugates of $H$ in $G$, it should be faster to
loop over `RightTransversal(  G, Normalizer( G, H   ) )' and form  the
conjugate $H^x$  for each transversal element  $x$ than  to perform an
orbit algorithm  with `Orbit( G,  H  )'. The latter  makes  $G$ act on
$\{H^x | x\in G\}$ by conjugation  and has to check repeatedly whether
a conjugate of $H$  is new in  the orbit, thereby  comparing it to all
the groups in the orbit.

You cannot,  however, let a group  operate on such a right transversal
list via `OnRight', because the product of a right transversal element
with  an arbitrary group  element need not  belong  to the transversal
again. This problem can be overcome by replacing the right transversal
by a ``canonical right transversal'' and the operation `OnRight' by an
operation `opr' which is defined by the two properties

  opr( c, g ) is in the same right coset as c*g and
  opr( c, g ) is in the canonical right transversal again.

An example:

gap> s := SymmetricGroup( 4 );; u := SylowSubgroup( s, 2 );;
gap> c := CanonicalRightTransversal( s, u );
[ (), (2,3), (2,4,3) ]
gap> opr := OnCanonicalCosetElements( s, u );
function ( a, b ) ... end
gap> Operation( s, c, opr );
Group( (1,2), (1,3), (2,3) );

This method of operating on right cosets is faster than the method

gap> Operation( s, RightCosets( s, u ), OnRight );

I hope this helps,

Heiko Thei{\ss}en



From thomas.breuer@math.rwth-aachen.de Wed Jun  5 14:46:00 1996
Date:           Wed, 05 Jun 96 14:46:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        BUGFIX #11 (DANGEROUS problem in VE package)

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible if you are
    computing with the VE share package*.
    The problem is in 'PrintVEInput', and may cause wrong results for
    presentations in characteristic zero that involve proper fractions.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation
    to produce incorrect results without a warning.  Thus the bugfix has
    high priority, and we recommend that you apply it as soon as possible
    if you are using the VE share package.

    Go to the GAP directory (the directory with the 'pkg/' subdirectory),
    name this mail 'bugfix11.dif', and issue the command:

        patch -p0 < bugfix11.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This patch changes only a file with GAP code.
    Thus you need not recompile the VE standalones.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'PrintVEInput' may produce a wrong input file for the VE program
    in characteristic zero if the presentation contains non-integral
    rationals.
    This may cause the standalone to crash, or may yield an incorrect
    result.


CORRECT BEHAVIOUR

gap> RequirePackage( "ve" );
gap> a:= FreeAlgebra( Rationals, 1 );;
gap> a:= a / [ a.1 - One( a ), 1/2 * a.1 - 1/2 * One( a ) ];;
gap> a.operations.MatAlgebraA( a );
UnitalAlgebra( Rationals, [ [ [ 1 ] ] ] )


COMMENT

    'Int' is called for the coefficients of the words in the presentation,
    which is necessary for nonzero characteristics, but obviously should
    not be done in characteristic zero.


PATCH

Prereq: 3.0
--- pkg/ve/gap/ve.g     1994/05/10 19:14:38
+++ pkg/ve/gap/ve.g     1996/06/05 10:48:53
@@ -112,7 +112,11 @@
     fi;

     for j in [ 1 .. Length( elm.words ) ] do
-      coeff:= Int( elm.coeff[j] );
+      if char = 0 then
+        coeff:= elm.coeff[j];
+      else
+        coeff:= Int( elm.coeff[j] );
+      fi;
       if j > 1 and coeff > 0 then
         Pr( "+" );
       fi;
END OF  bugfix11.dif ________________________________________________________



From wdj@sma.usna.navy.mil Wed Jun  5 14:56:33 1996
Date:           Wed, 05 Jun 96 14:56:33 -0400
From:           "W. David Joyner" <wdj@sma.usna.navy.mil>
Subject:        collection process for free groups

Dear Forum:
 Does there exist GAP code to implement the collection process
for free groups?         - Tony Gaglione, David Joyner



From heiko.theissen@math.rwth-aachen.de Wed Jun 12 08:20:00 1996
Date:           Wed, 12 Jun 96 08:20:00 +0100 (MET)
From:           "Heiko Theissen" <Heiko.Theissen@Math.RWTH-Aachen.DE>
Subject:        Centraliser of element outside group

Dear Gap forum,

Frank   L"ubeck  has sent   various comments  and  suggestions  to our
internal mailing list ``gap-trouble''. In this  mail I want to provide
an   answer to his  item (10),   which  is concerned  with centraliser
computations.

GAP is sometimes able to compute the centraliser in  a group $G$ of an
element $g$ even  if $g$ does  not belong to  the parent group of $G$,
but if $G$ and $g$ are both contained  in some overgroup (which is not
present  as a GAP group).  For example, if  $G$ is a permutation group
and $g$ is any permutation, then both are  contained in some symmetric
group, so that it makes sense to define the centraliser

    C_G(g) = { h\in G | g^h = g },

and this subgroup of $G$ could be computed by  the same algorithm that
works if $g$ is an element of  $G$. Unfortunately, the GAP dispatching
mechanism detects that $g$ is not an element  of $G$ and delegates the
calculation to the default function

    Stabilizer( G, g );

which calculates the  orbit (i.e., the conjugacy  class)  of $g$ under
$G$ and uses Schreier's subgroup theorem to construct a generating set
for  the  stabiliser (i.e., the  centraliser).  This takes much longer
than the special function  for permutation groups  would take, and may
render the whole computation infeasible.

You can avoid this dispatching mechanism if you call

    PermGroupOps.Centralizer( G, Group( g ) );

instead of

    Centralizer( G, g );

then the permutation group function will  perform the same computation
much faster. Of course  this only works if $G$  is a permutation group
and $g$ a permutation.

I hope this helps,

Heiko Thei{\ss}en



From heiko.theissen@math.rwth-aachen.de Wed Jun 12 18:11:00 1996
Date:           Wed, 12 Jun 96 18:11:00 +0100 (MET)
From:           "Heiko Theissen" <Heiko.Theissen@Math.RWTH-Aachen.DE>
Subject:        BUGFIX #12 (DANGEROUS problem in 'GroupHomomorphismByImages')

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible.*
    The problem happens for multi-valued 'GroupHomomorphismByImages'
    from a permutation group to a non-permutation group.  It may cause
    'Images' to return sets of images that are too small or too large.
    It may also cause 'IsMapping' and 'IsHomomorphism' to return 'true'.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation
    to produce incorrect results without a warning.  Thus the bugfix has
    high priority, and we recommend that you apply it as soon as possible.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix12.dif', and issue the command:

        patch -p0 < bugfix12.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This bugfix changes only the library.
    Thus you need not recompile the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    If one creates a mapping with 'GroupHomomorphismByImages', that maps
    from a permutation group to a non-permutation group, and that is a
    multi-valued mapping (i.e., where each image has more than one image),
    then GAP may compute an incorrect cokernel (which is the set of images of
    the identity), namely one which is too small.  This causes 'Images' to
    return incorrect sets of images for each element (such a set is a coset
    of the cokernel), which are also too small.  If GAP incorrectly computes
    a trivial cokernel, then 'IsMapping' and 'IsHomomorphism' will
    incorrectly return 'true'.

    If one creates a mapping with 'GroupHomomorphismByImages', that maps from
    a permutation group to a non-permutation group, that is a multi-valued
    mapping, and that is not surjective, then GAP may compute an incorrect
    cokernel, namely one which is too large.  This causes 'Images' to return
    incorrect sets of images for each element, which are also too large.


COMMENT

    There are actually two problems.  One causes the computation to return a
    cokernel that may be too small, and the other causes the computation to
    return a cokernel that may be too large (unfortunately the two bugs do
    not cancel each other ;-).

    `PermGroupHomomorphismByImagesOps.MakeMapping' constructs a stabiliser
    chain for the source group (for which the size is known) by the following
    method:

    1. The top level of the chain is constructed, the levels below remain
    empty.

    2. A random element is built from the generators and is sifted down the
    chain.

    3. If it does not sift through, the remainder is used to extend the level
    where it ``fell out''.

    4. Steps 2 and 3 are repeated until the product of the basic orbit
    lengths equals the size of the source group.

    The problem is that elements which are added further down the chain must
    also be added to the levels above.  They do not move the base point, but
    they must be added to the `generators' lists and may extend the basic
    orbits.  These elements are not added in the incorrect version.

    The cokernel of a 'GroupHomomorphismByImages' from a permutation group to
    a non-permutation group is calculated as the normal closure of images of
    relators in the *range* of the map.  It should be the normal closure in
    the *image* of the map.


CORRECT BEHAVIOUR

gap> G  := Group( (2,7)(3,6)(4,5), (1,8)(3,5)(4,6), (1,8)(3,5,6,4) );;
gap> H1 := Group( (1,2), (4,10)(5,9)(6,8), (3,4,5,6,7,8,9,10) );;
gap> H2 := AgGroup( H1 );;
gap> H3 := Subgroup( H2, List( H1.generators,
>                          h -> PreImagesRepresentative(H2.bijection,h) ) );;
gap> h := GroupHomomorphismByImages( G, H3, G.generators, H3.generators );;
gap> IsHomomorphism( h );
false

gap> G := Group( () );;
gap> H := Group( [[1,1],[0,1]]*Z(2), [[0,1],[1,0]]*Z(2) );;
gap> h := GroupHomomorphismByImages( G, H, [G.identity], [H.1] );;
gap> Size( Images( h, G.identity ) );
2


PATCH

Prereq: 3.22.1.6
--- lib/permhomo.g      1995/12/19 09:27:13
+++ lib/permhomo.g      1996/06/10 13:06:45
@@ -3,13 +3,19 @@
 #A  permhomo.g                  GAP library                  Martin Schoenert
 #A                                                                & Udo Polis
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains functions that implement homomorphisms for permgroups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.22.1.8  1996/06/10  13:06:45  mschoene
+#H  fixed 'PGHBIO.CoKernel', it is a normal subgroup of the image
+#H
+#H  Revision 3.22.1.7  1996/06/10  12:39:16  mschoene
+#H  fixed 'MakeMapping' to add Schreier generators on all levels
+#H
 #H  Revision 3.22.1.6  1995/12/19  09:27:13  mschoene
 #H  fixed 'GHBI' to avoid identities in stabilizer chains
 #H
@@ -163,7 +169,7 @@
             orb,        # orbit
             len,        # length of the orbit before extension
             bpt,        # base point
-            i,  j;      # loop variables
+            i,  j,  S;  # loop variables

     # handle trivial case
     if hom.generators = []  then
@@ -261,39 +267,42 @@
             fi;

             # divide the size of stabilizer chain by the old orbit length
-            size := size / Length( stb.orbit );
-
-            # add the element to the generators
-            Add( stb.generators, elm );
-            Add( stb.genimages,  img );
-
-            # extend orbit and transversal
-            orb := stb.orbit;
-            len := Length(orb);
-            i := 1;
-            while i <= len  do
-                if not IsBound(stb.transversal[orb[i]/elm])  then
-                    stb.transversal[orb[i]/elm] := elm;
-                    stb.transimages[orb[i]/elm] := img;
-                    Add( orb, orb[i]/elm );
-                fi;
-                i := i + 1;
-            od;
-            while i <= Length(orb)  do
-                for j  in [1..Length(stb.generators)]  do
-                    elm := stb.generators[j];
-                    img := stb.genimages[j];
-                    if not IsBound(stb.transversal[orb[i]/elm])  then
-                        stb.transversal[orb[i]/elm] := elm;
-                        stb.transimages[orb[i]/elm] := img;
+            S := hom;
+            repeat
+                S := S.stabilizer;
+
+                # add the element to the generators
+                Add( S.generators, elm );
+                Add( S.genimages,  img );
+
+                # extend orbit and transversal
+                orb := S.orbit;
+                len := Length(orb);
+                size := size / len;
+                i := 1;
+                while i <= len  do
+                    if not IsBound(S.transversal[orb[i]/elm])  then
+                        S.transversal[orb[i]/elm] := elm;
+                        S.transimages[orb[i]/elm] := img;
                         Add( orb, orb[i]/elm );
                     fi;
+                    i := i + 1;
                 od;
-                i := i + 1;
-            od;
-
-            # multiply the size of stabilizer chain by the new orbit length
-            size := size * Length( stb.orbit );
+                while i <= Length(orb)  do
+                    for j  in [1..Length(S.generators)]  do
+                        elm := S.generators[j];
+                        img := S.genimages[j];
+                        if not IsBound(S.transversal[orb[i]/elm])  then
+                            S.transversal[orb[i]/elm] := elm;
+                            S.transimages[orb[i]/elm] := img;
+                            Add( orb, orb[i]/elm );
+                        fi;
+                    od;
+                    i := i + 1;
+                od;
+                size := size * Length( orb );
+
+            until S.orbit[ 1 ] = stb.orbit[ 1 ];

         fi;

@@ -319,8 +328,12 @@
     fi;

     # make sure we have a stabilizer chain for <hom>
+    # (for perm->perm homs. this automatically computes the coKernel)
     if not IsBound( hom.stabilizer )  then
         hom.operations.MakeMapping( hom );
+        if IsBound( hom.coKernel )  then
+           return hom.coKernel;
+        fi;
     fi;

     # loop over the stabilizer chain
@@ -375,7 +388,7 @@
     od;

     # return the cokernel
-    return AsSubgroup( Parent( C ), NormalClosure( hom.range, C ) );
+    return AsSubgroup( Parent( C ), NormalClosure( hom.image, C ) );
 end;

 CoKernelGensPermHom := function ( hom )
END OF  bugfix12.dif ________________________________________________________



From heiko.theissen@math.rwth-aachen.de Wed Jun 12 18:12:00 1996
Date:           Wed, 12 Jun 96 18:12:00 +0100 (MET)
From:           "Heiko Theissen" <Heiko.Theissen@Math.RWTH-Aachen.DE>
Subject:        BUGFIX #13 (serious problem in 'PreImage')

    This mail contains a bugfix for a serious problem in GAP 3.4.3.12.
    You should apply this bugfix soon if you are using homomorphisms.
    The problem is in 'PreImage' and causes it to fail for non surjective
    group homomorphisms.


HOW TO APPLY

    The problem is a serious problem, because if may cause a computation to
    fail.  Thus the bugfix has medium priority, and we recommend that you
    apply it soon if you are using homomorphisms.

    Before applying this bugfix you *must* already have applied bugfix12.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix13.dif', and issue the command:

        patch -p0 < bugfix13.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This bugfix changes only the library.
    Thus you need not recompile the GAP kernel.


VERSION

    GAP 3.4.3.12


DESCRIPTION

    If one creates a non surjective group homomorphisms, then 'PreImage'
    may fail and signal

        Error, <elm> must lie in the preimage of <hom> in
        map.operations.ImagesRepresentative( map, elm ) called from
        ...


COMMENT

    This bugfix actually fixes two problems.

    In the case where this problem first occured, the preimage of the map in
    question was already known from the beginning.  However it was stored in
    the homomorphism record as '<hom>.preimage', whereas 'PreImage' looks for
    the component '<hom>.preImage'.  This bugfix changes all references to
    '<hom>.preimage' to references to '<hom>.preImage' (and there are lots).

    'PreImage' then calls 'PreImages' to compute the set of preimages of the
    range.  This fails because 'PreImages' tries to compute a preimage for
    the generators of the range that are not in the image.  This bugfix fixes
    'PreImages' to intersect the images set with 'Image(<hom>)'.


CORRECT BEHAVIOUR

gap> G := Group( (1,2), (3,4) );;
gap> H := Group( (1,2), (5,6) );
gap> h := GroupHomomorphismByImages( G, H, [G.1], [H.1] );;
gap> PreImage( h );
Subgroup( Group( (1,2), (3,4) ), [ (1,2) ] )


PATCH
Prereq: 3.31.1.4
--- lib/aghomomo.g      1995/12/21 15:29:50
+++ lib/aghomomo.g      1996/06/11 16:47:50
@@ -2,13 +2,16 @@
 ##
 #A  aghomomo.g                  GAP library                      Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains functions for homomorphisms of aggroups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.31.1.5  1996/06/11  14:47:26  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.31.1.4  1995/12/05  15:01:25  mschoene
 #H  replaced 'Filtered( <list>, IsBound )' by 'Compacted( <list> )'
 #H
@@ -664,7 +667,7 @@
        prd  := GroupHomomorphismByImages( b.source, a.range, gens, imgs );
        prd.isMapping      := true;
        prd.isHomomorphism := true;
-        prd.preimage       := b.source;
+        prd.preImage       := b.source;
     else
        prd := MappingOps.CompositionMapping( a, b );
     fi;
@@ -828,7 +831,7 @@
              domain           := Mappings,
               generators       := gens,
               genimages        := imgs,
-             preimage         := D,
+             preImage         := D,
              image            := R.operations.Subgroup( Parent(R), imgs ),
               isGeneralMapping := true,
               operations       := AgGroupHomomorphismByImagesOps );
Prereq: 3.0
--- lib/alghomom.g      1995/12/21 15:29:56
+++ lib/alghomom.g      1996/06/11 16:48:26
@@ -2,7 +2,7 @@
 ##
 #A  alghomom.g                  GAP library                   Thomas Breuer ?
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1993,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -12,6 +12,9 @@
 ##  'grphomom.g'. (Avoid this!)
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.0.1.1  1996/06/11  14:48:18  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.0  1994/05/19  13:20:43  sam
 #H  Initial Revision under RCS
 #H
@@ -570,9 +573,9 @@

     # enter useful information (precious little)
     if IsEqualSet( gens, G.generators )  then
-        hom.preimage    := G;
+        hom.preImage    := G;
     else
-        hom.preimage    := Parent(G).operations.Subalgebra( Parent(G), gens );
+        hom.preImage    := Parent(G).operations.Subalgebra( Parent(G), gens );
     fi;
     if IsEqualSet( imgs, H.generators )  then
         hom.image       := H;
@@ -658,7 +661,7 @@
     if not IsBound( hom.coKernel )  then
         hom.coKernel := hom.operations.CoKernel( hom );
     fi;
-    return hom.source = hom.preimage
+    return hom.source = hom.preImage
        and IsTrivial( hom.coKernel );
 end;

@@ -694,8 +697,8 @@

 AlgebraHomomorphismByImagesOps.ImagesSet := function( hom, elms )
     if IsAlgebra( elms )  and IsSubset( hom.source, elms )  then
-        if hom.preimage <> hom.source  then
-            elms := Intersection( hom.preimage, elms );
+        if hom.preImage <> hom.source  then
+            elms := Intersection( hom.preImage, elms );
         fi;
         if not IsBound( hom.coKernel )  then
             hom.coKernel := hom.operations.CoKernel( hom );
@@ -778,7 +781,7 @@
             # enter useful information
             prd.isMapping       := true;
             prd.isHomomorphism  := true;
-            prd.preimage        := hom2.source;
+            prd.preImage        := hom2.source;
             prd.elements := ShallowCopy( hom2.elements );
             prd.images := List( [ 1 .. Length( prd.elements ) ],
                                 i -> hom1.images[
Prereq: 3.23.1.10
--- lib/fpgrp.g 1995/12/21 15:30:12
+++ lib/fpgrp.g 1996/06/11 16:48:47
@@ -2,13 +2,16 @@
 ##
 #A  fpgrp.g                     GAP library                  Martin Schoenert
 ##
-#H  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#H  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains the  functions dealing with finitely presented groups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.23.1.11  1996/06/11  14:48:40  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.23.1.10  1995/11/25  22:42:44  mschoene
 #H  allowed list of names as only argument of 'FreeGroup' (3.28 -> 3.29)
 #H
@@ -1852,9 +1855,9 @@

     # enter usefull information (precious little)
     if IsEqualSet( gens, G.generators )  then
-        hom.preimage    := G;
+        hom.preImage    := G;
     else
-        hom.preimage    := Parent(G).operations.Subgroup( Parent(G), gens );
+        hom.preImage    := Parent(G).operations.Subgroup( Parent(G), gens );
     fi;
     if IsSubsetSet( imgs, H.generators )  then
         hom.image       := H;
@@ -1883,7 +1886,7 @@
 end;

 FpGroupHomomorphismByImagesOps.IsMapping := function ( hom )
-    return hom.source = hom.preimage
+    return hom.source = hom.preImage
        and ForAll( hom.source.relators,
                    rel -> MappedWord( rel, hom.generators, hom.genimages )
                           = hom.range.identity );
Prereq: 3.85.1.5
--- lib/group.g 1995/12/21 15:30:14
+++ lib/group.g 1996/06/11 16:51:33
@@ -2,7 +2,7 @@
 ##
 #A  group.g                     GAP library                      Frank Celler
 ##
-#H  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#H  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -21,6 +21,9 @@
 ##  'grphomom.g', 'grpprods.g' and 'operatio.g'.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.85.1.6  1996/06/11  14:51:24  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.85.1.5  1995/03/02  14:31:48  vfelsch
 #H  bug fixed in 'IsomorphismTypeFiniteSimpleGroup'
 #H
@@ -3911,7 +3914,7 @@
     P.bijection.isEpimorphism   := true;
     P.bijection.isIsomorphism   := true;
     P.bijection.image           := G;
-    P.bijection.preimage        := P;
+    P.bijection.preImage        := P;
     P.bijection.kernel          := TrivialSubgroup( P );

     # return the permutation group
Prereq: 3.33.1.4
--- lib/grphomom.g      1995/12/21 15:30:18
+++ lib/grphomom.g      1996/06/11 16:50:55
@@ -3,13 +3,22 @@
 #A  grphomom.g                  GAP library                      Frank Celler
 #A                                                         & Martin Schoenert
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains dispatcher and default functions for grp homomorphism.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.33.1.7  1996/06/11  14:50:50  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
+#H  Revision 3.33.1.6  1996/06/11  08:48:43  htheisse
+#H  'GHO.ImagesSet' now looks at 'isMapping' before calling 'CoKernel'
+#H
+#H  Revision 3.33.1.5  1996/06/10  13:33:40  mschoene
+#H  fixed 'GHO.ImagesSet' and 'GHO.PreImagesSet' to intersect
+#H
 #H  Revision 3.33.1.4  1995/12/11  11:03:19  mschoene
 #H  changed 'CompositionGH' and 'IdentityGH' to inherit from 'GHOps'
 #H
@@ -425,8 +434,21 @@
 ##
 GroupHomomorphismOps.ImagesSet := function ( hom, elms )
     if IsGroup( elms )  and IsSubset( hom.source, elms )  then
-        return Parent( hom.range ).operations.Subgroup( Parent( hom.range ),
-                        List( elms.generators, gen -> Image( hom, gen ) ) );
+       if PreImage(hom) <> hom.source  then
+            elms := Intersection( PreImage(hom), elms );
+        fi;
+        if not IsBound( hom.coKernel )  then
+            if IsBound( hom.isMapping ) and hom.isMapping  then
+                hom.coKernel := TrivialSubgroup( hom.range );
+            else
+                hom.coKernel := hom.operations.CoKernel( hom );
+            fi;
+        fi;
+        return Closure( hom.coKernel,
+                    Parent( hom.range ).operations.Subgroup(
+                        Parent( hom.range ),
+                        List( elms.generators,
+                            gen -> ImagesRepresentative( hom, gen ) ) ) );
     else
         return MappingOps.ImagesSet( hom, elms );
     fi;
@@ -449,6 +471,9 @@
 ##
 GroupHomomorphismOps.PreImagesSet := function ( hom, elms )
     if IsGroup( elms )  and IsSubset( hom.range, elms )  then
+        if Image(hom) <> hom.range  then
+            elms := Intersection( Image(hom), elms );
+        fi;
         return Closure( KernelGroupHomomorphism( hom ),
                     Parent( hom.source ).operations.Subgroup(
                         Parent( hom.source ),
@@ -938,9 +963,9 @@

     # enter usefull information (precious little)
     if IsEqualSet( Difference( gens, [ G.identity ] ), G.generators )  then
-        hom.preimage    := G;
+        hom.preImage    := G;
     else
-        hom.preimage    := Parent(G).operations.Subgroup( Parent(G), gens );
+        hom.preImage    := Parent(G).operations.Subgroup( Parent(G), gens );
     fi;
     if IsEqualSet( Difference( imgs, [ H.identity ] ), H.generators )  then
         hom.image       := H;
@@ -1030,7 +1055,7 @@
     if not IsBound( hom.coKernel )  then
         hom.coKernel := hom.operations.CoKernel( hom );
     fi;
-    return hom.source = hom.preimage
+    return hom.source = hom.preImage
        and IsTrivial( hom.coKernel );
 end;

@@ -1080,8 +1105,8 @@

 GroupHomomorphismByImagesOps.ImagesSet := function ( hom, elms )
     if IsGroup( elms )  and IsSubset( hom.source, elms )  then
-        if hom.preimage <> hom.source  then
-            elms := Intersection( hom.preimage, elms );
+        if hom.preImage <> hom.source  then
+            elms := Intersection( hom.preImage, elms );
         fi;
         if not IsBound( hom.coKernel )  then
             hom.coKernel := hom.operations.CoKernel( hom );
@@ -1160,7 +1185,7 @@
             # enter useful information
             prd.isMapping       := true;
             prd.isHomomorphism  := true;
-            prd.preimage        := hom2.source;
+            prd.preImage        := hom2.source;


            # note the images only, if they were already neccessary for hom1
Prereq: 3.16.1.2
--- lib/mapping.g       1995/12/21 15:30:22
+++ lib/mapping.g       1996/06/11 16:50:28
@@ -3,13 +3,16 @@
 #A  mapping.g                   GAP library                  Martin Schoenert
 #A                                                             & Frank Celler
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This  file  contains  the  functions  that  mainly  deal  with  mappings.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.16.1.3  1996/06/11  14:50:23  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.16.1.2  1995/12/11  12:03:58  mschoene
 #H  allowed 'MappingByFunction' with inverse function
 #H
@@ -937,10 +940,10 @@
     inv.source          := map.range;
     inv.range           := map.source;
     if IsBound( map.image )  then
-        inv.preimge     := map.image;
+        inv.preImage    := map.image;
     fi;
-    if IsBound( map.preimage )  then
-        inv.image       := map.preimage;
+    if IsBound( map.preImage )  then
+        inv.image       := map.preImage;
     fi;

     # maybe we know that this mapping is single valued
Prereq: 3.22.1.8
--- lib/permhomo.g      1996/06/11 16:23:33
+++ lib/permhomo.g      1996/06/11 16:49:41
@@ -3,13 +3,16 @@
 #A  permhomo.g                  GAP library                  Martin Schoenert
 #A                                                                & Udo Polis
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains functions that implement homomorphisms for permgroups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.22.1.9  1996/06/11  14:49:34  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.22.1.8  1996/06/10  13:06:45  mschoene
 #H  fixed 'PGHBIO.CoKernel', it is a normal subgroup of the image
 #H
@@ -133,9 +136,9 @@

     # enter useful information (precious little)
     if IsEqualSet( Difference(gens,[G.identity]), G.generators )  then
-        hom.preimage    := G;
+        hom.preImage    := G;
     else
-        hom.preimage    := Parent(G).operations.Subgroup( Parent(G), gens );
+        hom.preImage    := Parent(G).operations.Subgroup( Parent(G), gens );
     fi;
     if IsEqualSet( Difference(imgs,[H.identity]), H.generators )  then
         hom.image       := H;
@@ -227,7 +230,7 @@
     size := Length( hom.orbit );

     # create new elements until we have reached the size
-    while size <> Size( hom.preimage )  do
+    while size <> Size( hom.preImage )  do

         # make a new element from the generators
         elm := rnd[rni];
@@ -512,8 +515,8 @@

 PermGroupHomomorphismByImagesOps.ImagesSet := function ( hom, elms )
     if IsGroup( elms )  and IsSubset( hom.source, elms )  then
-        if hom.preimage <> hom.source  then
-            elms := Intersection( hom.preimage, elms );
+        if hom.preImage <> hom.source  then
+            elms := Intersection( hom.preImage, elms );
         fi;
         if not IsBound( hom.coKernel )  then
             hom.coKernel := hom.operations.CoKernel( hom );
@@ -599,7 +602,7 @@
             # enter useful information
             prd.isMapping       := true;
             prd.isHomomorphism  := true;
-            prd.preimage        := hom2.source;
+            prd.preImage        := hom2.source;

             # copy the stabilizer chain and update the images of the sgs
             gens := [ prd.source.identity ];
@@ -698,10 +701,10 @@
     fi;

     # get the degree of the preimage and image
-    if   hom.preimage.generators = []  then
+    if   hom.preImage.generators = []  then
         sourcedeg := 0;
     else
-        sourcedeg := PermGroupOps.LargestMovedPoint( hom.preimage );
+        sourcedeg := PermGroupOps.LargestMovedPoint( hom.preImage );
     fi;
     if   hom.image.generators = []  then
         rangedeg := 0;
@@ -734,10 +737,10 @@
       and IsBound( hom.source.stabChainOptions.random )
     then
         options.randomsource := hom.source.stabChainOptions.random;
-    elif  IsBound( hom.preimage.stabChainOptions )
-      and IsBound( hom.preimage.stabChainOptions.random )
+    elif  IsBound( hom.preImage.stabChainOptions )
+      and IsBound( hom.preImage.stabChainOptions.random )
     then
-        options.randomsource := hom.preimage.stabChainOptions.random;
+        options.randomsource := hom.preImage.stabChainOptions.random;
     elif IsBound( StabChainOptions.random ) then
         options.randomsource := StabChainOptions.random;
     else
@@ -779,12 +782,12 @@

         if IsBound( hom.source.size ) then
             options.size := hom.source.size;
-        elif IsBound( hom.preimage.size ) then
-            options.size := hom.preimage.size;
+        elif IsBound( hom.preImage.size ) then
+            options.size := hom.preImage.size;
         elif IsBound( hom.source.stabChain ) then
             options.size := Size( hom.source );
-        elif IsBound( hom.preimage.stabChain ) then
-            options.size := Size( hom.preimage );
+        elif IsBound( hom.preImage.stabChain ) then
+            options.size := Size( hom.preImage );
         fi;
         if not IsBound( options.size ) then
             if IsBound( Parent(hom.source).size ) then
@@ -797,14 +800,14 @@
           and IsBound( hom.source.stabChainOptions.knownBase )
         then
             options.knownBase := hom.source.stabChainOptions.knownBase;
-        elif  IsBound( hom.preimage.stabChainOptions )
-          and IsBound( hom.preimage.stabChainOptions.knownBase )
+        elif  IsBound( hom.preImage.stabChainOptions )
+          and IsBound( hom.preImage.stabChainOptions.knownBase )
         then
-            options.knownBase := hom.preimage.stabChainOptions.knownBase;
+            options.knownBase := hom.preImage.stabChainOptions.knownBase;
         elif IsBound( hom.source.stabChain ) then
             options.knownBase := Base( hom.source );
-        elif IsBound( hom.preimage.stabChain ) then
-            options.knownBase := Base( hom.preimage );
+        elif IsBound( hom.preImage.stabChain ) then
+            options.knownBase := Base( hom.preImage );
         elif IsBound( Parent(hom.source).stabChainOptions )
           and IsBound( Parent(hom.source).stabChainOptions.knownBase )
         then
@@ -818,14 +821,14 @@

         if IsBound( hom.source.size ) then
             options.limitsource := hom.source.size;
-        elif IsBound( hom.preimage.size ) then
-            options.limitsource := hom.preimage.size;
+        elif IsBound( hom.preImage.size ) then
+            options.limitsource := hom.preImage.size;
         elif IsBound( Parent(hom.source).size ) then
             options.limitsource := Parent(hom.source).size;
         elif IsBound( hom.source.stabChain ) then
             options.limitsource := Size( hom.source );
-        elif IsBound( hom.preimage.stabChain ) then
-            options.limitsource := Size( hom.preimage );
+        elif IsBound( hom.preImage.stabChain ) then
+            options.limitsource := Size( hom.preImage );
         elif IsBound( Parent(hom.source).stabChain ) then
             options.limitsource := Size( Parent(hom.source) );
         fi;
@@ -834,10 +837,10 @@
           and IsBound( hom.source.stabChainOptions.knownBase )
         then
             options.knownBasesource := hom.source.stabChainOptions.knownBase;
-        elif  IsBound( hom.preimage.stabChainOptions )
-          and IsBound( hom.preimage.stabChainOptions.knownBase )
+        elif  IsBound( hom.preImage.stabChainOptions )
+          and IsBound( hom.preImage.stabChainOptions.knownBase )
         then
-            options.knownBasesource := hom.preimage.stabChainOptions.knownBase;
+            options.knownBasesource := hom.preImage.stabChainOptions.knownBase;
         elif IsBound( Parent(hom.source).stabChainOptions )
           and IsBound( Parent(hom.source).stabChainOptions.knownBase )
         then
@@ -845,8 +848,8 @@
                 := Parent(hom.source).stabChainOptions.knownBase;
         elif IsBound( hom.source.stabChain ) then
             options.knownBasesource := Base( hom.source );
-        elif IsBound( hom.preimage.stabChain ) then
-            options.knownBasesource := Base( hom.preimage );
+        elif IsBound( hom.preImage.stabChain ) then
+            options.knownBasesource := Base( hom.preImage );
         elif IsBound( Parent(hom.source).stabChain ) then
             options.knownBasesource := Base( Parent(hom.source) );
         fi;
Prereq: 3.1.1.2
--- lib/sq.g    1995/12/21 15:30:42
+++ lib/sq.g    1996/06/11 16:50:12
@@ -3,7 +3,7 @@
 #A  sq.g                        GAP library                      Frank Celler
 #A                                                           Alexander Wegner
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -11,6 +11,9 @@
 ##  groups.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.1.1.3  1996/06/11  14:50:08  mschoene
+#H  fixed '.preimage' to '.preImage'
+#H
 #H  Revision 3.1.1.2  1994/10/07  13:10:39  fceller
 #H  added 'SQOps.AgGroup'
 #H
@@ -126,7 +129,7 @@
         a.naturalHomomorphism.isMapping := true;
         a.naturalHomomorphism.isSurjective := true;
         a.naturalHomomorphism.image := a;
-        a.naturalHomomorphism.preimage := Q.source;
+        a.naturalHomomorphism.preImage := Q.source;
     fi;
     a.sqSource := Q.source;
     return a;
END OF  bugfix13.dif ________________________________________________________



From thomas.breuer@math.rwth-aachen.de Thu Jun 13 11:42:00 1996
Date:           Thu, 13 Jun 96 11:42:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        BUGFIX #14 (DANGEROUS problem in 'PrintToMOC')

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible if you are using
    the facility to convert character tables to MOC format*.
    The problem is in 'PrintToMOC', and causes it to print code that
    may be misinterpreted by MOC 3.


HOW TO APPLY

    The problem is a dangerous problem, because it causes MOC to deal with
    corrupted data if the argument of 'PrintToMOC' contains numbers with more
    than four digits.  Thus the bugfix has high priority, and we recommend
    that you apply it as soon as possible if you are using 'PrintToMOC'.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix14.dif', and issue the command:

        patch -p0 < bugfix14.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This workaround changes only the library.
    Thus you need not recompile the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    The local function 'PrintNumber' omits the middle two of the last four
    digits of numbers with more than four decimal digits, so (in the example
    below) instead of 'v0625' the string 'v05' is printed, which is not valid
    MOC 3 code.


CORRECT BEHAVIOUR

gap> t := CharTable( "A5" );;
gap> chi := List( t.irreducibles[5], x -> x^8 );;
gap> moctbl := MOCTable( t );;
gap> PrintToMOC( moctbl, [ chi ] );
y100y105ay110fey130t60edfy140bcdfy150bbbfcabbey160bbcbdbebecy170ccbbddbbefbby210
bbbcbbbbccabbcbcbkccay220bbabcabdabeabfay230cbbabbabdabekfakfay050dbbabcabbabekf
akfay050fbbabcabdabbaay050hbbabcabdabekfakfay050t11bbabcabdabeabfay050t13bbabcab
dabekfakfay050t17bbabcabdabekfakfay050t19bbabcabdabeabfay9000039v0625bbaaz


COMMENT



PATCH

Prereq: 3.10
--- lib/ctgapmoc.g      1994/06/10 04:44:29
+++ lib/ctgapmoc.g      1996/06/11 07:14:26
@@ -2,7 +2,7 @@
 ##
 #A  ctgapmoc.g                  GAP library                     Thomas Breuer
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -10,6 +10,9 @@
 ##  to MOC format.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.10.1.1  1996/06/11  07:14:00  sam
+#H  fixed bug in 'PrintNumber' (which previously omitted digits)
+#H
 #H  Revision 3.10  1994/06/10  04:44:29  sam
 #H  fixed order and name components
 #H
@@ -1274,7 +1277,7 @@
       od;

       sumber1:= sumber{ [ 1 .. len - 4 ] };
-      sumber2:= sumber{ [ len - 3, len ] };
+      sumber2:= sumber{ [ len - 3 .. len ] };

       # code of last digits is always 'vABCD' or 'wABCD'
       if number >= 0 then
END OF  bugfix14.dif ________________________________________________________



From joachim.neubueser@math.rwth-aachen.de Thu Jun 13 17:18:46 1996
Date:           Thu, 13 Jun 96 17:18:46 +0200
From:           "Joachim Neubueser" <Joachim.Neubueser@Math.RWTH-Aachen.DE>
Subject:        Re: collection process for free groups

 Dear Forum:

Tony Gaglione and David Joyner asked on June 5:

>  Does  there exist GAP code  to implement the collection process for
> free groups?

Since nobody has answered so  far, others seems  to be as puzzled as I
am, what is meant.

GAP can work with free groups and freely reduce products:

    gap> f := FreeGroup(3);
    Group( f.1, f.2, f.3 )
    gap> w1 := f.1 * f.2 * f.2 * f.3^-2 * f.2^2;
    f.1*f.2^2*f.3^-2*f.2^2
    gap> w2 := f.2^-2 * f.3 * f.2 * f.1;
    f.2^-2*f.3*f.2*f.1
    gap> w1 * w2;
    f.1*f.2^2*f.3^-1*f.2*f.1

Surely you mean something better than that, but can you please explain
what?

Kind regards   Joachim Neubueser



From bogley@math.orst.edu Fri Jun 14 06:11:55 1996
Date:           Fri, 14 Jun 96 06:11:55 -0700 (PDT)
From:           "Bill Bogley" <bogley@math.orst.edu>
Subject:        collection process for free groups

Dear Gap Forum,

Tony Gaglione and David Joyner asked about the "collection process" for
free groups. I gather that this refers to the "commutator collection
process" as described in M.(?) Hall's text. This (algorithmic) process uses
commutator identities to express a given element of a free group in terms of
preselected "basic commutators".

Carrying out the collection process by hand is not fun, at least not after a
few minutes/hours!! A potentially useful utility.

Bill Bogley
============================================================================

Department of Mathematics               bogley@math.orst.edu
Kidder 368                              tel: (503)737-5158
Oregon State University                 fax: (503)737-0517
Corvallis, OR 97331-4705                ftp.math.orst.edu/publications/bogley
USA                                     http://www.orst.edu/~bogleyw

============================================================================

------- End of Forwarded Message



From wdj@sma.usna.navy.mil Sat Jun 15 12:38:17 1996
Date:           Sat, 15 Jun 96 12:38:17 -0400
From:           "W. David Joyner" <wdj@sma.usna.navy.mil>
Subject:        Re: collection process for free groups

> From GAP-Forum-Sender@Math.RWTH-Aachen.DE Thu Jun 13 12:17 EDT 1996
> Sender: GAP-Forum-Sender@Math.RWTH-Aachen.DE
> Reply-To: GAP Forum <GAP-Forum-Reply@Math.RWTH-Aachen.DE>
> X-Miles:        GAP Forum article 930 accepted at 13 Jun 96 17:21 +0100
> Date:           Thu, 13 Jun 96 17:18:46 +0200
> From: Joachim Neubueser <Joachim.Neubueser@Math.RWTH-Aachen.DE>
> To: Multiple recipients of list <GAP-Forum@Math.RWTH-Aachen.DE>
> Subject:        Re: collection process for free groups
> Content-Type: text
> Content-Length: 655
>
>  Dear Forum:
>
> Tony Gaglione and David Joyner asked on June 5:
>
> >  Does  there exist GAP code  to implement the collection process for
> > free groups?
>
> Since nobody has answered so  far, others seems  to be as puzzled as I
> am, what is meant.
>
> GAP can work with free groups and freely reduce products:
>
>     gap> f := FreeGroup(3);
>     Group( f.1, f.2, f.3 )
>     gap> w1 := f.1 * f.2 * f.2 * f.3^-2 * f.2^2;
>     f.1*f.2^2*f.3^-2*f.2^2
>     gap> w2 := f.2^-2 * f.3 * f.2 * f.1;
>     f.2^-2*f.3*f.2*f.1
>     gap> w1 * w2;
>     f.1*f.2^2*f.3^-1*f.2*f.1
>
> Surely you mean something better than that, but can you please explain
> what?

Dear Joachim Neubueser and the Gap Forum:

       Bill Bogley has the idea of what we are talking about. To be more
specific, we mean the following: Given a finitely generated free group
F and a fixed sequence c1, c2, ...  of basic commutators (as in M Hall,
chapter 11), can GAP reduce an arbitrary non-trivial element in F to its
normal form in terms of these basic commutators modulo F_n, where
F_n is the nth term of the lower central series of F?
 For details, see for example "The commutator collection process", by
A. Gaglione and H. Waldinger in AMS Contemp Math, vol 109, "Combinatorial
Group Theory". 1990, ed by Fine, Gaglione, Tang. A more algorithmic
description is contained in a paper called "Collection" by G. Havas
and T. Nicholson, written sometime in the 1970's. Sorry, our xerox copy
is so poor that the place it appeared can't be read (Proc of ... ACM
Symposium?).

                             - David Joyner and Tony Gaglione

>
> Kind regards   Joachim Neubueser
>
>



From werner@dcs.st-and.ac.uk Wed Jun 19 11:26:14 1996
Date:           Wed, 19 Jun 96 11:26:14 BST
From:           "Werner Nickel" <werner@dcs.st-and.ac.uk>
Subject:        Re:  aut gps of free gps

Dear Toni,

you wrote a little while ago:
>
> Let F be the free group of rank 4 freely generated
> by a1,a2,a3,a4. Let w=a1^2*a2^2*a3^2*a4^2.
> Proposition 5.7 (due to McCool) of Lyndon and Schupp
> asserts that there is an effective procedure for finding
> a finite presentation for the stabilizer in Aut(F)
> of the cyclic word (w), where (w) is the set of cyclically
> reduced conjugates of w. In this particular case, can
> anyone tell me what the finite presentation for the
> stabilizer is? Or, maybe could you tell me if some software
> (for example, GAP) can be used to compute it?

I  don't know the answer to  your first question  and only a partial answer to
the second.   There  is no procedure  in  GAP for  computing the stabiliser in
Aut(F) of a cyclic word.

After looking through the relevant part of Lyndon/Schupp I am sure that such a
procedure could be written in GAP.  I would very much welcome anyone who would
like  to do that and offer  assistance with the programming.   If you find out
anything more or if  you  want to do the   programming  yourself, I would   be
interested to know.

All the best, Werner Nickel.



From leonard@qmw.ac.uk Wed Jun 19 14:10:15 1996
Date:           Wed, 19 Jun 96 14:10:15 +0100
From:           "Leonard Soicher" <leonard@qmw.ac.uk>
Subject:        AgGroup

Dear Gap-forum,

The  AgGroup  function appears to be able to take as argument a
"PQp record" produced by the function  PQuotient,  and return the
corresponding  AgGroup.  This feature is not documented.  Is it a
supported feature?  If so, will it continue to be supported in future
releases of Gap?

Thanks for your help.

Regards,    Leonard.



From leonard@qmw.ac.uk Wed Jun 19 14:53:38 1996
Date:           Wed, 19 Jun 96 14:53:38 +0100
From:           "Leonard Soicher" <leonard@qmw.ac.uk>
Subject:        Re: Computing a presentation for a group

Dear Gap-forum,

In a letter to the Forum on 22 April 1996, Volkmar Felsch wrote:

>
>As described in the manual section 'Tietze Transformations', each
>presentation record, 'P' say, carries with it certain parameters,
>the so-called 'Tietze options'. One of these is the parameter
>'P.generatorsLimit' which by default is initialized to be zero.
>Its purpose is to prevent the Tietze transformations functions
>from eliminating too many generators.
>
>More precisely: The functions 'SimplifyPresentation', 'TzGo', and
>'TzGoGo' are not allowed to eliminate a generator if the resulting
>number of generators would be smaller than this bound.
>

However, it does appear that  SimplifyPresentation(P)  will eliminate a
generator found to be trivial, even if  P.generatorsLimit  has first
been set to  Length(P.generators).  This certainly can cause me
problems when I need there to be a bijection between two sets of
generators, even if one of the generators turns out to be trivial. Is
there any way to prevent SimplifyPresentation  from removing trivial
generators?  Am I right in assuming that the function  TzSearch  would
not do this?

Thanks for your help.

Regards,   Leonard.



From thomas.breuer@math.rwth-aachen.de Wed Jun 19 16:11:00 1996
Date:           Wed, 19 Jun 96 16:11:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 15 (DANGEROUS problem in 'CharTable( SU, 3, q )')

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3,
    namely the character table 'CharTable( "SU", 3, q )',
    for prime powers 'q', contains an incorrect component 'orders'.
    *You should apply this bugfix as soon as possible* if you are using
    the library of character tables.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation to
    produce incorrect results without a warning.  Thus the bugfix has high
    priority, and we recommend that you apply it as soon as possible.

    Go to the GAP directory (the directory with the 'tbl/' subdirectory),
    name this mail 'bugfix15.dif', and issue the command:

        patch -p0 < bugfix15.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This bugfix changes only the table library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


CORRECT BEHAVIOUR

gap> CharTable( "SU", 3, 2 ).orders;
[ 1, 3, 3, 2, 6, 6, 4, 4, 4, 12, 12, 12, 12, 12, 12, 3 ]


COMMENT

    The problem is that the parameter of the third type of classes
    in the generic table 'CharTable( "SU3" )' was used instead of its
    first entry.


PATCH

Prereq: 3.12

--- tbl/ctgeneri.tbl    Tue Jun 18 10:02:26 1996
+++ tbl/ctgeneri.tbl    Tue Jun 18 10:03:37 1996
@@ -2,7 +2,7 @@
 ##
 #A  ctgeneri.tbl                GAP table library
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -11,6 +11,9 @@
 ##  SL2even, PSL2odd, PSL2even, Suzuki, GU3, SU3, P:Q.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.12.1.1  1996/06/18  08:02:45  sam
+#H  fixed bug in 'orders' component of the table of SU3
+#H
 #H  Revision 3.12  1994/03/14  08:41:39  sam
 #H  added 'powermap' for table of 'SL2odd'
 #H
@@ -1015,7 +1018,7 @@
         function(q,k) if k = 0 then return PrimeBase(q);
                       else return LcmInt(PrimeBase(q),3); fi;end,
         function(q,k) local exp;
-                    if k = 0 then exp:= PrimeBase(q);
+                    if k[1] = 0 then exp:= PrimeBase(q);
                     else exp:= LcmInt(PrimeBase(q),3); fi;
                     if PrimeBase(q)=2 and exp*(exp-1)/2 mod 2 <> 0 then
                       return 2 * exp;
END OF  bugfix15.dif ________________________________________________________



From werner@dcs.st-and.ac.uk Thu Jun 20 10:02:05 1996
Date:           Thu, 20 Jun 96 10:02:05 BST
From:           "Werner Nickel" <werner@dcs.st-and.ac.uk>
Subject:        Re:  collection process for free groups

Dear Gap Forum members,

On July 15 Toni Gaglione und David Joyner wrote:

[...]
>                                  Given a finitely generated free group
> F and a fixed sequence c1, c2, ...  of basic commutators (as in M Hall,
> chapter 11), can GAP reduce an arbitrary non-trivial element in F to its
> normal form in terms of these basic commutators modulo F_n, where
> F_n is the nth term of the lower central series of F?

There is no routine for doing that in the current GAP release.  However, I had
written a couple of simple GAP routines  for computing basic commutators up to
a given weight  a while ago.  When I  saw the above request  I added a routine
for computing the normal form above for the special case when the word in F is
a product of the  generators (i.e.  no inverses  are involved).  I am happy to
supply the code to everone  who is interested.   There are hardly any comments
in the code and it is a fairly straightforward implementation of Chapter 11 of
M.Hall's book.  It  would need some  polishing before I would feel comfortable
to make it generally available.

If there is sufficient interest I would be interested in extending the package
and give more thought  to perfomance issues.   Adding the handling of inverses
is clear from the  theoretical point of  view, but it  needs quite a bit  more
code which is the main reason why I didn't implement it at this stage.

All the best, Werner Nickel.



From frank.celler@math.rwth-aachen.de Thu Jun 20 14:13:00 1996
Date:           Thu, 20 Jun 96 14:13:00 +0100 (MET)
From:           "Frank Celler" <Frank.Celler@Math.RWTH-Aachen.DE>
Subject:        Ag Groups

Dear Gap-Forum,

Leonard Soicher asked:

  The  AgGroup  function appears to be able to take as argument a
  "PQp record" produced by the function  PQuotient,  and return the
  corresponding  AgGroup.  This feature is not documented.  Is it a
  supported feature?  If so, will it continue to be supported in future
  releases of Gap?

yes, such a function will be supported in further releases.  However,
its name will change because ag groups will be treated in a more
general context of polycyclic groups.  There will be backward
compatibility mode so that you can still use 'AgGroup' even for the
output of 'PrimeQuotient'.

best wishes
  Frank



From thomas.breuer@math.rwth-aachen.de Tue Jun 25 13:27:00 1996
Date:           Tue, 25 Jun 96 13:27:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        BUGFIX # 16 (serious problem in 'Symmetrisations')

    This mail contains a bugfix for a serious problem in GAP 3.4.3.
    You should apply this bugfix soon if you are computing with characters.
    The problem is in 'Symmetrisations', and causes it to fail.


HOW TO APPLY

    The problem is a serious problem, because it may cause a computation to
    fail.  Thus the bugfix has medium priority, and we recommend that you
    apply it soon if you are computing with characters.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix16.dif', and issue the command:

        patch -p0 < bugfix16.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This workaround changes only the library.  Thus you need not recompile
    the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    'Symmetrisations' fails and signals

        Error, List Element: <list>[1] must have a value at
        lst[i] := fun( arg[1][i] ) ... in
        List( powermap, Length ) called from
        Symmetrisations( t, t.irreducibles, 2 ) called from
        main loop


CORRECT BEHAVIOUR

gap> t:= CharTable( "A5" );;
gap> Symmetrisations( t, t.irreducibles, 2 );
[ [ 0, 0, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ],
  [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ], [ 6, 2, 0, 1, 1 ],
  [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ], [ 6, 2, 0, 1, 1 ],
  [ 6, -2, 0, 1, 1 ], [ 10, 2, 1, 0, 0 ], [ 10, -2, 1, 0, 0 ],
  [ 15, 3, 0, 0, 0 ] ]


COMMENT

    'Symmetrizations' called 'List' with a list that contains holes.
    The manual forbids this, and since version 3.4.3 'List' does not
    accept lists with holes.


PATCH

Prereq: 3.52.1.2
--- lib/ctcharac.g      Wed Jun 19 16:46:18 1996
+++ lib/ctcharac.g      Wed Jun 19 17:00:44 1996
@@ -3,13 +3,16 @@
 #A  ctcharac.g                  GAP library                     Thomas Breuer
 #A                                                              & Ansgar Kaup
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
 ##  This file contains those functions which mainly deal with characters.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.52.1.3  1996/06/19  14:58:39  sam
+#H  'List' does no longer accept lists with holes.
+#H
 #H  Revision 3.52.1.2  1995/06/28  07:03:38  sam
 #H  fixed 'IntegralizedMat', 'Decomposition'
 #H
@@ -1260,7 +1263,6 @@
 #F  Symmetrisations( <tbl>, <characters>, <Sn> )
 #F  Symmetrisations( <tbl>, <characters>, <n> )
 ##
-##
 Symmetrisations := function( tbl, characters, Sn )

     local i, j, l, n, cyclestruct, symmirreds, symmclasses, symmorder, cycl,
@@ -1311,7 +1313,13 @@
       fi;
     od;
     powermap:= ShallowCopy( tbl.powermap );
-    powermap[1]:= [ 1 .. Maximum( List( powermap, Length ) ) ];
+    i:= Length( powermap[ Length( powermap ) ] );
+    for j in [ 2 .. Length( powermap ) - 1 ] do
+      if IsBound( powermap[j] ) and i < Length( powermap[j] ) then
+        i:= Length( powermap[j] );
+      fi;
+    od;
+    powermap[1]:= [ 1 .. i ];

     symmetrisations:= [];
     for chi in characters do
END OF  bugfix16.dif ________________________________________________________



From volkmar.felsch@math.rwth-aachen.de Tue Jun 25 13:46:11 1996
Date:           Tue, 25 Jun 96 13:46:11 +0200
From:           "Volkmar Felsch" <Volkmar.Felsch@Math.RWTH-Aachen.DE>
Subject:        Re: Computing a presentation for a group

Dear Gap-forum,

Leonard Soicher wrote:

> However, it does appear that  SimplifyPresentation(P)  will eliminate a
> generator found to be trivial, even if  P.generatorsLimit  has first
> been set to  Length(P.generators).  This certainly can cause me
> problems when I need there to be a bijection between two sets of
> generators, even if one of the generators turns out to be trivial. Is
> there any way to prevent SimplifyPresentation  from removing trivial
> generators?

Not at present, but in the next patch or release.

The above question is asking for a change of the current concept of
the functions which create or handle presentation records, i. e., the
functions

    PresentationFpGroup,
    PresentationSubgroupMtc,
    PresentationSubgroupRrs,
    PresentationNormalClosureRrs,

and all the Tietze transformations functions.

In fact, this change will come with the next patch or release of Gap,
for it is part of an extension of the Tietze transformations functions
which is presently under work. It will provide a possibility to trace
the images of the given generators as words in the final generators as
well as the preimages of the final generators as words in the given
generators under the isomorphism which is defined by all the Tietze
transformations that are applied to a presentation.

Unfortunately, these extensions are not yet available. Therefore, if
there are Gap users who urgently need an intermediate ad hoc solution
which guarantees the above mentioned bijection, I would suggest that
they contact me directly.

Volkmar Felsch            volkmar.felsch@math.rwth-aachen.de



From thomas.breuer@math.rwth-aachen.de Tue Jun 25 17:51:00 1996
Date:           Tue, 25 Jun 96 17:51:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        problem with BUGFIX 15

Dear GAP-Forum,

last week bugfix 15 was sent to you.
When applying the patch, one got a message

   Hunk #1 failed at 2.

This was reported to GAP-trouble, with the question whether
this is a problem.
No, this is not a problem, since the differences affect only comment lines.

Sorry for the inconveniences.
Thomas Breuer



From thomas.breuer@math.rwth-aachen.de Wed Jun 26 17:29:00 1996
Date:           Wed, 26 Jun 96 17:29:00 +0100 (MET)
From:           "Thomas Breuer" <Thomas.Breuer@Math.RWTH-Aachen.DE>
Subject:        BUGFIX 17 (DANGEROUS problem in 'LLL')

    This mail contains a bugfix for a dangerous problem in GAP 3.4.3.
    *You should apply this bugfix as soon as possible if you are using
    the function 'LLL'*.  The problem is in 'LLL' when called with the
    option '"sort"', and may cause it to produce inconsistent results.
    This does affect neither the components 'irreducibles' and 'remainders'
    of the result nor the functions 'LLLReducedBasis' and
    'LLLReducedGramMat'.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation to
    produce incorrect results without a warning.  Thus the bugfix has high
    priority, and we recommend that you apply it as soon as possible.

    Go to the GAP directory (the directory with the 'lib/' subdirectory),
    name this mail 'bugfix17.dif', and issue the command:

        patch -p0 < bugfix17.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This bugfix changes only the library.
    Thus you need not recompile the GAP kernel.


VERSION

    GAP 3.4.3.0


DESCRIPTION

    When 'LLL' is called with the optional parameter '"sort"', the vectors
    in the 'remainders' component of the result are sorted but the component
    'norms' is not, so these two components may be inconsistent.


CORRECT BEHAVIOUR

gap> t:= CharTable("J2");;
gap> x:= t.irreducibles{[2..5]};;
gap> tens:= Tensored( x, x );;
gap> lll:= LLL( t, tens, "sort" );;
gap> List( lll.remainders, x -> ScalarProduct( t, x, x ) ) = lll.norms;
true


COMMENT


PATCH

Prereq: 3.20
--- lib/ctlattic.g      Fri Jun 21 13:42:52 1996
+++ lib/ctlattic.g      Fri Jun 21 13:59:48 1996
@@ -2,7 +2,7 @@
 ##
 #A  ctlattic.g                  GAP library                       Ansgar Kaup
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -10,6 +10,9 @@
 ##  or less in the context of character tables).
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.20.1.1  1996/06/21  11:59:11  sam
+#H  fixed that 'norms' is also sorted when '"sort"' is specified
+#H
 #H  Revision 3.20  1994/06/22  16:47:20  sam
 #H  fixed call of 'LLL' with "sort" option
 #H
@@ -950,6 +953,7 @@
     # 6. Sort 'remainders' component if necessary.
     if "sort" in arg then
       perm:= SortCharactersCharTable( arg[1], lll.remainders, "degree" );
+      lll.norms:= Permuted( lll.norms, perm );
       if "linearcomb" in arg then
         lll.reddecomp:= Permuted( lll.reddecomp, perm );
       fi;
END OF  bugfix17.dif ________________________________________________________



From alexander.hulpke@math.rwth-aachen.de Thu Jun 27 12:09:40 1996
Date:           Thu, 27 Jun 96 12:09:40 +0200
From:           "Alexander Hulpke" <Alexander.Hulpke@Math.RWTH-Aachen.DE>
Subject:        BUGFIX #18

Dear GAP-Forum,

    This mail contains a bugfix for a dangerous problems in GAP 3.4.3.
    *You should apply this bugfix as soon as possible if you are using
    the solvable groups library.*  The problem is in 'AllSolvableGroups',
    and causes it to miss the last group of size 100.


HOW TO APPLY

    The problem is a dangerous problem, because it may cause a computation to
    produce incorrect results without a warning.  Thus the bugfix has high
    priority, and we recommend that you apply it as soon as possible.

    Go to the GAP directory (the directory with the 'grp/' subdirectory),
    name this mail 'bugfix18.dif', and issue the command:

        patch -p0 < bugfix18.dif

    If 'patch' writes "I can't seem to find a patch in there" try 'patch -v'.
    If 'patch -v' gives an error message or reports a version older than 2.1,
    get 2.1 from 'ftp://FTP.Math.RWTH-Aachen.DE/pub/gap/utils/patch2_1.zoo'.

    This fix changes only the groups library.
    Thus you need not recompile the GAP kernel.


VERSION

    3.4.3.0


DESCRIPTION

    'AllSolvableGroups' misses the last group of size 100.


CORRECT BEHAVIOUR

gap> AllSolvableGroups(Size,100);
[ 10^2, 50x2, 5x20, c100, 10xD10, 5x10.2, 5x5:4, 2x5^2:2, (5^2x2).2, D100,
  50.2, D10^2, grp_100_13, grp_100_14, grp_100_15, 25:4 ]


COMMENT

    The list was corrected at one point to add a missing group of size 96.
    Unfortunately, this fix did not note, that the number of groups was
    hard-coded in the selection functions.


PATCH

Prereq: 3.5
--- grp/solvable.grp    Thu Dec 21 15:25:52 1995
+++ grp/solvable.grp    Wed Jun 26 17:07:47 1996
@@ -2,7 +2,7 @@
 ##
 #A  solvable.grp                GAP group library          Hans Ulrich Besche
 ##
-#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
+#A  @(#)$Id: forum96b.txt,v 1.1 1997/04/06 10:38:52 gap Exp $
 ##
 #Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
 ##
@@ -13,6 +13,16 @@
 ##  Aachen 1982 and all the other groups are from J.  Neubuesser, Kiel 1967.
 ##
 #H  $Log: forum96b.txt,v $
 #H  Revision 1.1  1997/04/06 10:38:52  gap
 #H  Added forum archives (ahulpke)
 #H
+#H  Revision 3.5.1.3  1996/06/24 09:32:06  ahulpke
+#H  fixed number of groups
+#H
+#H  Revision 3.5.1.2  1995/07/03 13:04:12  sam
+#H  fixed 'SolvableGroup'
+#H  (for some strange reason the operator {} behaves differently in GAP-3.4)
+#H
+#H  Revision 3.5.1.1  1994/09/27 14:42:25  sam
+#H  replaced 'Coefficients' call by call of 'CoefficientsInt'
+#H
 #H  Revision 3.5  1993/06/24  17:26:22  fceller
 #H  added missing group of order 96
 #H
@@ -1249,14 +1259,14 @@
 AGGroup := function ( nr )
     local   gens,  rels,  g,  j,  l,  ind,  d,  c,  i,  f,  o,  p;

-    f := Factors(AGTable[nr][1]);
-    i := Maximum(f)+1;
+    f := FactorsInt( AGTable[nr][1] );
+    i := Maximum( f ) + 1;

     # length of composition series
-    l := Length(f);
+    l := Length( f );

     # indices of composition series
-    ind  := Coefficients( List([1..l]*0+i,x->x), AGTable[nr][4] );
+    ind  := CoefficientsInt( [ 1 .. l ] * 0 + i, AGTable[nr][4] );
     g    := ["a","b","c","d","e","f"];
     gens := [];
     rels := [];
@@ -1269,10 +1279,10 @@

     # fetch non-canonical relations
     for i in [5..Length(AGTable[nr])]  do
-        d := Coefficients( [l+1,l,AGTable[nr][1]], AGTable[nr][i] );
+        d := CoefficientsInt( [l+1,l,AGTable[nr][1]], AGTable[nr][i] );

         # fetch the value of a nontrivial relation
-        c := Coefficients( ind, d[3] );
+        c := CoefficientsInt( ind, d[3] );
         g := gens[1]^0;
         for j in [1..l]  do
             if c[j]> 0  then
@@ -1321,7 +1331,7 @@
         # <name> = "grp_1234"
         name   := arg[1];
         digits := "0123456789";
-        if name{[1..4]} = "grp_"  then
+        if 3 < Length( name ) and name{[1..4]} = "grp_"  then
             ord := 0;
             p   := 5;
             i   := Position( digits, name[p] );
@@ -1439,7 +1449,7 @@
     fi;
     # initialize
     allgrps:=[];
-    for i in [1..1045] do
+    for i in [1..Length(AGTable)] do
         flag:=AGTable[i][1] in sizes;
         if flag and tAbel then
             flag:=(QuoInt(AGTable[i][3],100) mod 10=1)=vAbel;
@@ -1502,7 +1512,7 @@
     else
         sizes:=arg[pSize+1]; arg[pSize]:=x->true; arg[pSize+1]:=[true];
     fi;
-    for i in [1..1045] do
+    for i in [1..Length(AGTable)] do
         flag:=AGTable[i][1] in sizes;
         if flag and tAbel then
             flag:=(QuoInt(AGTable[i][3],100) mod 10=1)=vAbel;
END OF  bugfix18.dif ________________________________________________________



