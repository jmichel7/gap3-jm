This file contains the mails sent to the GAP forum in October-December 1992.

Name               Email address                           Mails    Lines
Martin Schoenert   martin@bert.math.rwth-aachen.de            12     1171
Joachim Neubeuser  neubuese@samson.math.rwth-aachen.de         7      214
Werner Nickel      werner@pell.anu.edu.au                      4      130
Frank Celler       fceller@bert.math.rwth-aachen.de            4       47
Michael K Johnson  johnsonm@stolaf.edu                         3       74
Ansgar Kaup        kaup@ccucvx.unican.es                       3       23
Dawn Endico        dawn@math.wayne.edu                         2      246
Meinolf Geck       geck@tiffy.math.rwth-aachen.de              2      233
Boric Boris        borbor@divsun.unige.ch                      2       69
Geoff Smith        gcs@maths.bath.ac.uk                        2       45
Michael J. Falk    mjf@caliban.math.nau.edu                    2       41
Peter Jipsen       pjipsen@iastate.edu                         2       28
Derek Holt         dfh@maths.warwick.ac.uk                     2       28
Daniel Ruberman    ruberman@binah.cc.brandeis.edu              2       23
Kay Magaard        kaym@math.wayne.edu                         2       22
Eamonn O'Brien     obrien@pell.anu.edu.au                      1       44
Keith Dennis       dennis@math.cornell.edu                     1       40
Eric J. Rossin     ejr@vonnegut.ee.cornell.edu                 1       33
Steve Linton       sal@maths.su.oz.au                          1       28
Donald L. Kreher   kreher@math.mtu.edu                         1       24
David Sibley       sibley@math.psu.edu                         1       21
Michael Smith      smith@pell.anu.edu.au                       1       18
Toni Greil         greil@guug.de                               1       17
Duane Broline      cfdmb@ux1.cts.eiu.edu                       1       17
Dr D. L. Johnson   dlj@maths.nott.ac.uk                        1       17
Alain Dresse       adresse@ulb.ac.be                           1       16
Andrea Caranti     caranti@itnsp2.cineca.it                    1       15
Charley Wright     wright@bright.uoregon.edu                   1       15
Jacob Hirbawi      jcbhrb@cerf.net                             1       15
Hwee Huat Tan      mattanhh@nuscc.nus.sg                       1       10
N. S. Mendelsohn   mendel@ccu.umanitoba.ca                     1        7
Leonard Soicher    L.H.Soicher@qmw.ac.uk                       1        7
Piotr Dowbor       dowbor@mat.torun.edu.pl                     1        3

This  file is in Berkeley mail drop format, which means you can read this
file with 'mail -f <name-of-the-file>'  or 'mailx -f <name-of-the-file>'.
It is also possible however to read this file with any text editor.



From gcs@maths.bath.ac.uk Thu Oct  1 11:53:38 1992
From:       gcs@maths.bath.ac.uk "Geoff Smith"
Date:       Thu, 1 Sep 92 11:53:38 +0100
Subject:    sad news

Colin Campbell reports the following sad news.

____________________________________________________________________________
John Leech

Sad news. In the Glasgow Herald this morning I was shocked to come across an
obituary of John Leech who collapsed and died on board his beloved paddle
steamer Waverley on Monday.

Colin
____________________________________________________________________________

Geoff Smith



From martin@bert.math.rwth-aachen.de Fri Oct  2 13:40:45 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Fri, 2 Oct 92 13:40:45 +0100
Subject:    Iterators in GAP

I want to say a little bit more about iterators in GAP.

Our  plans are as  follows.   There will be a  function 'Iterator'.  This
function can be applied to any domain.  It  returns an iterator, which is
represented by record of course.   You can apply two functions to such an
iterator, 'IsDone'  and  'Next'.   The first call  to  'Next' returns the
first  element of the domain, successive calls to 'Next' return the other
elements of  the domain.   'IsDone' returns 'true' until all elements  of
the domain have been returned by 'Next'.  So you can write a 'while'-loop
to iterate over all elements of a domain <D> as follows

    iter := Iterator( <D> );
    while not IsDone( iter )  do
        elm := Next( iter );
        <do something with elm>
    od;

This  can also be abbreviated with the 'for'-loop (for that we will  have
to extend the kernel a little bit)

    for elm  in <D>  do
        <do something with elm>
    od;

One  thing that we have not yet decided  is  whether  the iterator should
return the elements in order, i.e., smallest element first.

Another problem is that  the  iterator mustn't use  data from  the domain
that may  change.   For example  the iterator  for  a  permutation  group
mustn't use the stabilizer chain of  that  permutation  group, instead it
must make a copy of the stabilizer chain first.

Iterators aren't  on top of the priority list, because  we found that  we
can get by without them.  One  reason is  that for  those groups where we
know how to do an iteration well, i.e., permutation groups and AG groups,
those  functions that could make  use of an  iterator have the  iteration
hardcoded  into them  already.  Especially for permutation groups this is
necessary so that they can do without copying the stabilizer chain first.

However  iterators  aren't  at  the bottom of our  priority  list either.
(What is at the  bottom  of our priority list?  Well I don't know.  And I
cant look, 'bert' has only 3 MByte space  on its harddisk free currently,
which isn't enough to load the to-do list from the backup ;-)

Martin.

--
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From neubuese@samson.math.rwth-aachen.de Fri Oct  9 17:27:31 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Fri, 9 Oct 92 17:27:31 +0100
Subject:    GAP on VAX under VMS?

A  short  time  ago  the  message  from  Nathan  Mendelsohn about  the
portation of GAP to a MAC came as a plesant surprise. Meanwhile I have
heard  that this  portation  has already  been  brought to  some other
places, so thanks again.

We have also been asked a few times privately if GAP is available also
on  VAXes under VMS and  I want to try our  luck again by  asking  the
gap-forum if somebody has such a portation or volunteers do it.

Thanks in advance for any help.      Joachim Neubueser



From dowbor@mat.torun.edu.pl Mon Oct 12 13:18:24 1992
From:       dowbor@mat.torun.edu.pl "Piotr Dowbor"
Date:       Mon, 12 Oct 92 13:18:24 +0100
Subject:    Re: GAP on VAX under VMS?

I am sorry but we have had GAP only since three weeks and on SUN4 so we are not
able to help. Piotr Dowbor 



From johnsonm@stolaf.edu Wed Oct 14 16:00:27 1992
From:       johnsonm@stolaf.edu "Michael K Johnson"
Date:       Wed, 14 Oct 92 16:00:27 +0100
Subject:    Press any key to continue...

I wrote a gap procedure to print nicely formatted cayley tables of
groups, but I am missing one thing.  I want to stop after each screen
page and print "Press any key to continue", wait for any keystroke,
erase those characters, and go on.  I can do all that except actually
waiting for a single keypress.  Right now, I have written a
unix-specific C program that gets a single character in non-echo mode
and returns that character.  Then I have a small function that looks
like this:

GetCont := function ()
  Print("Press any key to continue\c");
  Exec("getchar");
  Print("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\c");
end;;


This works, but it requires the getchar program, which, as I said
before, is a unix-specific C program I wrote.  I would rather only
have to use gap.  I have not seen a way to do this in gap after
reading the parts of the manual which seem to apply.

Is there a way to do this PORTABLY, between different versions of gap?
If so, I would be happy to use it and post my code for general
consumption, if it is of use to anyone...

ADVThanksANCE,

michaelkjohnson
johnsonm@stolaf.edu



From werner@pell.anu.edu.au Wed Oct 14 16:49:54 1992
From:       werner@pell.anu.edu.au "Werner Nickel"
Date:       Wed, 14 Oct 92 16:49:54 +0100
Subject:    Re:  Press any key to continue...

Here is an example of a function that prints the numbers from
1 to 100. The function prints 20 numbers at a time waiting
for the user to press Cntrl-D after having printed 20 numbers:

Print20AtATime := function( )
    local  i;
    for i  in [ 1 .. 100 ]  do
        Print( i, "\n" );
        if i mod 20 = 0  then
            Print( "Press Cntrl-D" );
            Read( "*stdin*" );
        fi;
    od;
end;

The trick is to use the statement    Read("*stdin*")   in order to
read from standard input. However, I cannot see how one can erase
the "Press Cntrl-D" since GAP produces a newline after it has read
Cntrl-D.

Werner Nickel
Mathematics Research Section
Australian National University



From johnsonm@stolaf.edu Wed Oct 14 17:53:00 1992
From:       johnsonm@stolaf.edu "Michael K Johnson"
Date:       Wed, 14 Oct 92 17:53:00 +0100
Subject:    Re: Press any key to continue...

werner@pell.anu.edu.au (Werner Nickel) said, in a moment of inspiration:

   Here is an example of a function that prints the numbers from
   1 to 100. The function prints 20 numbers at a time waiting
   for the user to press Cntrl-D after having printed 20 numbers:

   Print20AtATime := function( )
       local  i;
       for i  in [ 1 .. 100 ]  do
	   Print( i, "\n" );
	   if i mod 20 = 0  then
	       Print( "Press Cntrl-D" );
	       Read( "*stdin*" );
	   fi;
       od;
   end;

   The trick is to use the statement    Read("*stdin*")   in order to
   read from standard input. However, I cannot see how one can erase
   the "Press Cntrl-D" since GAP produces a newline after it has read
   Cntrl-D.

I know about Read("*stdin*") -- but it is the kludgy C-D and messed-up
output that I am trying to avoid.  GAP's help system allows the kind
of thing I am asking for
    -- <space> for more --
gets erased after you press space, and goes on, and maybe having q for
quit would be good in my program too, so it would be nice if this
facility was available for gap programs as well as the kernel help
proceedures.  It allows for /much/ friendlier programs, and as a
programmer, I strongly dislike writing kludges.

michaelkjohnson



From ruberman@binah.cc.brandeis.edu Thu Oct 22 23:45:08 1992
From:       ruberman@binah.cc.brandeis.edu "Daniel Ruberman"
Date:       Thu, 22 Oct 92 23:34:08 +0100
Subject:    Re: GAP for Mac

Has anyone had any success in obtaining the port of GAP for the Macintosh
which was announced recently in this forum?  It is available by 
anonymous ftp from ccu.umanitoba.edu, as the file /pub/mac/GAP.sit.hqx.
I have tried various times to ftp the file; several times the transfer
was so slow that my machine gave up.  The two occasions when I could get
the whole file, I was unable to unbinhex it, because of `missing EOF'.
If someone has successfully downloaded GAP from this site (or perhaps
some other site) could you please let me know, so I can figure out what went
wrong. 

Thanks,
Daniel Ruberman
ruberman@binah.cc.brandeis.edu
ruberman@brandeis.bitnet



From ruberman@binah.cc.brandeis.edu Thu Oct 22 23:46:11 1992
From:       ruberman@binah.cc.brandeis.edu "Daniel Ruberman"
Date:       Thu, 22 Oct 92 23:46:11 +0100
Subject:    Re: GAP for Mac (correction)

In my preceding message I referred to a port of GAP for the Macintosh,
but gave an incorrect site for finding it: the correct address is
ccu.umanitoba.ca (not ....edu).
Sorry for the confusion.
Daniel Ruberman
ruberman@binah.cc.brandeis.edu
ruberman@brandeis.bitnet



From jcbhrb@cerf.net Mon Oct 26 02:49:28 1992
From:       jcbhrb@cerf.net "Jacob Hirbawi"
Date:       Mon, 26 Oct 92 02:49:28 +0100
Subject:    compiling gap source code under DOS

I would like to compile the source code for gap on an IBM PC running DOS.

I downloaded the 386 executable a few months ago and haven't had too many
problems with it (actually the only problem I had is using the
"Edit(filename)" command which I could not get to work; but since 
Exec("myeditor filename") works fine, that hasn't been much of an abstacle.)
I have also been using the gcc compiler for DOS for a while and would like
to try it out on the gap source code. Is there a "system.c" file for DOS
and do I need anything else to generate the executable myself?

Thanks.

Jacob Hirbawi
JcbHrb@CERF.net



From fceller@bert.math.rwth-aachen.de Mon Oct 26 13:39:01 1992
From:       fceller@bert.math.rwth-aachen.de "Frank Celler"
Date:       Mon, 26 Oct 92 13:39:01 +0100
Subject:    Re: compiling gap source code under DOS

> to try it out on the gap source code. Is there a "system.c" file for DOS
> and do I need anything else to generate the executable myself?

Yes, there is a "system.c" for DOS, called "system.dos".  This file
however is not in the orginal release but in the upgrade to 3.1
PatchLevel 2.  So you need (in addition to "src3r1.zoo" or
"src3r1.tar.Z") the files "upg3r1.dif.Z" and "upg3r1p2.dif.Z".

> "Edit(filename)" command which I could not get to work; but since 
> Exec("myeditor filename") works fine, that hasn't been much of an abstacle.)

Try
  EDITOR := "myeditor";
in your .gaprc file.

mfg
  Frank Celler



From sal@maths.su.oz.au Mon Oct 26 04:18:54 1992
From:       sal@maths.su.oz.au "Steve Linton"
Date:       Mon, 26 Oct 92 04:18:54 +0100
Subject:    Re: compiling gap source code under DOS 

 Jacob Hirbawi asks:

> I would like to compile the source code for gap on an IBM PC running DOS.
> 
> I downloaded the 386 executable a few months ago and haven't had too many
> problems with it (actually the only problem I had is using the
> "Edit(filename)" command which I could not get to work; but since 
> Exec("myeditor filename") works fine, that hasn't been much of an abstacle.)
> I have also been using the gcc compiler for DOS for a while and would like
> to try it out on the gap source code. Is there a "system.c" file for DOS
> and do I need anything else to generate the executable myself?

There is a system.dos file included with any sufficiently recent
distribution of the GAP sources. Apart from that and a suitable
makefile (which depends rather heavily on your make file
unfortunately - if I can find mine on-line anywhere (I'm away from
my PC until Christmas) I'll send it directly to you) there's nothing
you need.

I'd recommend avoiding DJGPP 1.06, as I found that programs using
that version of GO32 hung erratically every half-hour or so. Any
later version should work fine, as did 1.05. 

Remember to link with -lpc to pick up library functions from 
LIBPC.A.

	Steve Linton



From martin@bert.math.rwth-aachen.de Mon Oct 26 20:37:23 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Mon, 26 Oct 92 20:37:23 +0100
Subject:    Re: Press any key to continue...

In his article of 14-Oct-92 Michael K Johnson writes

    I wrote a gap procedure to print nicely formatted cayley tables of
    groups, but I am missing one thing.  I want to stop after each screen
    page and print "Press any key to continue", wait for any keystroke,
    erase those characters, and go on.  I can do all that except actually
    waiting for a single keypress.  Right now, I have written a
    unix-specific C program that gets a single character in non-echo mode
    and returns that character.  Then I have a small function that looks
    like this:

    GetCont := function ()
      Print("Press any key to continue\c");
      Exec("getchar");
      Print("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\c");
    end;;

In his article of 14-Oct-92 Werner Nickel gives a possible solution

    Here is an example of a function that prints the numbers from
    1 to 100. The function prints 20 numbers at a time waiting
    for the user to press Cntrl-D after having printed 20 numbers:

    Print20AtATime := function( )
        local  i;
        for i  in [ 1 .. 100 ]  do
            Print( i, "\n" );
            if i mod 20 = 0  then
                Print( "Press Cntrl-D" );
                Read( "*stdin*" );
            fi;
        od;
    end;

    The trick is to use the statement    Read("*stdin*")   in order to
    read from standard input. However, I cannot see how one can erase
    the "Press Cntrl-D" since GAP produces a newline after it has read
    Cntrl-D.

I don't  see a way to erase the 'Press Cntr-D'.  Besides, I  wouldn't bet
that reading <ctr>-'D' as EOF from '*stdin*' will  work on the Macintosh.
I will put this item on my TODO list.  Actually I think that the extended
file handling facilities will make this possible automatically.

Users here have  asked me for a related thing.  They want the  ability to
paginate the normal GAP output this way.  Especially they want to be able
to  type 'q' after seeing the first 20 lines, skipping the remaining 1000
lines.  This is important when one forgets the second semicolon.

Martin.

--
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From wright@bright.uoregon.edu Mon Oct 26 23:11:47 1992
From:       wright@bright.uoregon.edu "Charley Wright"
Date:       Mon, 26 Oct 92 23:11:47 +0100
Subject:    manuals

We're going to need to print out a few more copies of the GAP manual for
new users.  Does it make sense to wait for the next revision of GAP, or
will the differences be few enough that we should print more now and have
them immediately available?
-- 

wright@math.uoregon.edu

Charles R.B. Wright
Department of Mathematics
University of Oregon
Eugene, OR 97403

503-346-4730 (office)	503-485-4399 (home)



From borbor@divsun.unige.ch Tue Oct 27 00:22:03 1992
From:       borbor@divsun.unige.ch "Boric Boris"
Date:       Tue, 27 Oct 92 00:22:03 +0100
Subject:    Re: GAP for Mac ; and question(s)

I had similar problems downloading the port of GAP for the Mac from
umanitoba : for a few times during the first 10 days after the announcement
the connection was *very* slow and broke after transmitting between
8 and 80K. I stopped trying, and tried again maybe two weeks later
without any problem. Since I am using Xferit 1.5 in hqx mode, decoding
is simultaneous with transmition - I can't help you about the unbinhex
problem.

If it can be of help, I put GAP in anonymous ftp :

machine :    fpssun19.unige.ch
login   :    anonymous
dir/file :   outgoing/GAP31.sea.hqx

I will leave it there for a while. This is the Mac port, of course.
The on-line doc and the smallest group libraries are included (e.g.
NOT the two-groups, nor the character tables). There are also
some group definitions for some sporadic groups that were
provided with the previous release of GAP but were (as far as I
know) not included in the last release. The syntax has changed,
but one may plausibly scavenge generating permutations from
the code (I am not sure this is wise, though... ).

the .hqx is 1.8M, the .sea fits on a diskette, although the
uncompressed files take close to 5M (this was my first use of
the Stuffit Lite shareware; the package then started to boast
about its impressive feat each time I started it to push me
into registering).

I have had no time to play with GAP since that time, but forwarded
it to a friend. On the phone yesterday, he "complained" on the
"added workload", but commented on the human interface of the Mac
port. 

As it is, GAP outputs to a window with no sliders, and thus no 
history. The THINK C wrapper allows to copy this output into
a file, but that file can only be consulted after exiting GAP.
He tells me that adding a slider to the window might simply
be a matter of putting the right resource into the GAP application.
I am doubtful. Does anyone *know* what would be involved ?
This would be a huge improvement for someone working with
an SE/30 !

BTW, is the source for the Mac port available ?

Regards,
                                    10   2+1     5  2
Boris Borcic                     1+2  -10       2 -5
School of Psy. & Ed. Sci.        ----------  = ------ = 1
U. of Geneva                         1     -1    2+5
                                 2*10 +10*2



From sibley@math.psu.edu Tue Oct 27 00:47:18 1992
From:       sibley@math.psu.edu "David Sibley"
Date:       Tue, 27 Oct 92 00:47:18 +0100
Subject:    Re: GAP for Mac ; and question(s)

Borcic Boris <borbor@divsun.unige.ch> writes:

> As it is, GAP outputs to a window with no sliders, and thus no 
> history. The THINK C wrapper allows to copy this output into
> a file, but that file can only be consulted after exiting GAP.
> He tells me that adding a slider to the window might simply
> be a matter of putting the right resource into the GAP application.
> I am doubtful. Does anyone *know* what would be involved ?
> This would be a huge improvement for someone working with
> an SE/30 !

Alas, much more is involved than adding a resource to the file.  This
seems to be a common misunderstanding among naive Mac users.  My
favorite is the fellow who used ResEdit to add an entry to a menu,
thinking that adding a few words to a menu was all that was necessary
to add a new feature.  Your friend's proposal is no more correct than
this.  The resources can be changed so that the window that comes up
has a slider on it, but there is still no code to make the slider
actually do anything.  Indeed, there's not even any code to make the
slider move.



From neubuese@samson.math.rwth-aachen.de Tue Oct 27 09:32:28 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Tue, 27 Oct 92 09:32:28 +0100
Subject:    manual and version 3.2

Charles Wright asks for advice whether they should at the present time
print a few more manuals for gap or  rather  wait for the  release 3.2
that has been promised as coming soon for a while now.

While I  cannot make  the decision for  them (and possibly others in a
similar situation), I want to report as honestly as possible about the
state of affairs.  Gap 3.2 will  indeed be released  soon, but  "soon"
may well mean another two to three weeks - as usual we  underestimated
the time needed, I can only hope that we do not underestimate it again
now.  The new version will contain quite a number of new routines, but
several will hardly  show up in the  manual  since they either replace
old ones  or are called by generic  functions  to  do  some  job  more
efficiently in some special case. This  is for instance the  case with
several algorithms  for  permutation groups.   Extensions that will be
rather  visible  in  the manual will  e.g.  concern  the  handling  of
presentations, the introduction of polynomials as a new data type, and
a Dixon/Schneider for finding the charactertable of a concretely given
group.  Of  course  we  are  also  trying  to  eliminate  mistakes and
shortcomings in the manual that we have become aware of.

So the question whether to print  or to  wait depends a little on what
area you are particularly interested in, what group of people you want
the manual for, and how urgently you need futher copies.

Joachim Neubueser



From borbor@divsun.unige.ch Tue Oct 27 11:24:43 1992
From:       borbor@divsun.unige.ch "Boric Boris"
Date:       Tue, 27 Oct 92 11:24:43 +0100
Subject:    Re: GAP for Mac ; and question(s)

 David Sibley <sibley@math.psu.edu> writes :

> to add a new feature.  Your friend's proposal is no more correct than
> this.  The resources can be changed so that the window that comes up
> has a slider on it, but there is still no code to make the slider
> actually do anything.  Indeed, there's not even any code to make the
> slider move.

This is exactly what I told him. Nevertheless, as GAP is doing unadorned
IO (if I remember well, the GAP line editing features are off), I had a
feeling that it is not completely unreasonable to expect there is a way
to make this IO take place in a more intelligent window, without recom-
piling GAP that is. After all, this is a truly trivial task in some
other environments.

- Boris Borcic                (10^3+1)/(10+1) = (10-3)(10+3)



From fceller@bert.math.rwth-aachen.de Tue Oct 27 15:50:49 1992
From:       fceller@bert.math.rwth-aachen.de "Frank Celler"
Date:       Tue, 27 Oct 92 15:50:49 +0100
Subject:    complement bug

There is a bug in "agcomple.g" which makes it impossible to use
'Complements' for ag groups. This bug was introduced when I added a
undocumented feature to 'Complements' in order to have a (very
rudimentary) isomorphism test. The bug will be fixed in the next
release of gap.

Sorry for any inconvenience
    Frank Celler



From johnsonm@stolaf.edu Sat Oct 31 00:36:21 1992
From:       johnsonm@stolaf.edu "Michael K Johnson"
Date:       Sat, 31 Oct 92 00:36:21 +0100
Subject:    Teaching Abstract Algebra with GAP

A few of us at St. Olaf are writing a Laboratory Manual for GAP which
is intended to complement (although it does not /require/) Joseph
Gallian's text Contemporary_Abstract_Algebra.  We would like to know
if anyone else is using GAP to teach undergraduate abstract algebra,
and if so, what pedagogical materials you use or have developed.

If anyone is using GAP in this way, please contact me.

michaelkjohnson



From obrien@pell.anu.edu.au Mon Nov  2 10:53:35 1992
From:       obrien@pell.anu.edu.au "Eamonn O'Brien"
Date:       Mon, 2 Nov 92 10:53:35 +0100
Subject:    Reading from files

Why does the following piece of code not work? It generates
an error message 

Error, Variable 'G' must have a value at 
...

I know that by not declaring G locally within the procedure
I can persuade it to work OK -- but if I do that, it 
overwrites whatever existing value G had.  

This may have serious side effects -- where for example
I have a group G defined in Gap, and I now want to read 
another group called G defined in "file.g" and return it 
from ReadFromFile to the main level
under some other name. Is there any sensible way to 
achieve this without wiping out my existing G? 

I guess that I can encase the definition of G in the file 
within a function and call that function. But are there 
other approaches? Is this problem something which is 
intended /unavoidable / or a bug?

Thanks,
Eamonn O'Brien
obrien@pell.anu.edu.au

##################################################
#code to read value from file and return it 
ReadFromFile := function ()

   local exist, G;

   exist := READ("file.g");
   return G;
end; #ReadFromFile

l := ReadFromFile ();
Print ("The value returned from the function is ", l, "\n");

############################################################

#contents of file.g
G := 5;



From kreher@math.mtu.edu Mon Nov  2 13:34:38 1992
From:       kreher@math.mtu.edu "Donald L. Kreher"
Date:       Mon, 2 Nov 92 13:34:38 +0100
Subject:    Re: Teaching Abstract Algebra with GAP

> 
> A few of us at St. Olaf are writing a Laboratory Manual for GAP which
> is intended to complement (although it does not /require/) Joseph
> Gallian's text Contemporary_Abstract_Algebra.  We would like to know
> if anyone else is using GAP to teach undergraduate abstract algebra,
> and if so, what pedagogical materials you use or have developed.
> 
> If anyone is using GAP in this way, please contact me.
> 
> michaelkjohnson
> 
> 
> 
> 


I was hoping to do rougghly the same, buut with Rotman's Group Theory Text.
I would be very interested in seeing your Lab Manual. Also in particular
I would be interested  in any other recomendations from persons using
GAP in Graduate Group Theory, Algebra or Discrete Mathematics Courses.

Don Kreher
Kreher@math.mtu.edu



From neubuese@samson.math.rwth-aachen.de Mon Nov  2 16:46:46 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Mon, 2 Nov 92 16:46:46 +0100
Subject:    Use of GAP in teaching

Michael K. Johnson and Don Kreher report  that they are working on the
development  of course  material using GAP and ask where else  work of
this kind is done.

It will be  no  surprise that  we do use GAP  in  teaching  in Aachen,
although we have not written a laboratory  manual or systematic course
material. In order to explain the situation it should perhaps first be
explained  that  the contents  of  courses  is less  fixed  in  German
universities than it usually seems to be in  the US, that  is, each of
us rather goes his own way in teaching a  course on group theory, say,
and may also  change  his course from one  year to another. With  this
reservation made, one can say  that we have perhaps  two main lines in
integrating algorithmic  methods and the  use  of a system such as GAP
into such a course.

In one line, which I have followed two years ago, I gave a course that
was entitled  "Groups,  theory and algorithms"  parts I  and II over a
full  year, in which algorithmic aspects and methods were closely knit
into the theory, e.g. the course - that assumed a course on Algebra I
which gave the basics up to  Jordan-Hoelder  and Sylow -  started with
free groups and presentations and alongside with the theory introduced
computational  methods  such  as  Todd-Coxeter, Reidemeister-Schreier,
Low-index  and   IMD.    These   then  were   treated   through   easy
hand-calculations as well  as examples using programs in the exercises
( at  that  time  we  had partially  to  resort to  SPAS  because  the
algorithms were not all in GAP yet, but they will be in GAP 3.2  to be
released soon ).  In a  similar way  then permutation  groups, soluble
groups  and  p-groups  were  treated.  This course was  followed  by a
further year on  representation  theory,  of which I  gave  the  first
semester  on ordinary representation theory, again interlacing  theory
with computational  methods mainly for  charactertheory,  again  using
GAP, which provides quite a lot of possibilities in this field.

From these  courses we have files  with the weekly exercises given  to
the students and some percentage of these involve the use of  GAP.  If
somebody is interested  to  get these  ( in German  and not  specially
organized for export ) we will be happy to send them.

In another  setup,  which  we follow this  year,  my colleague,  Prof.
Pahlings  will  give a more  traditional  one-semester course on group
theory,  in  which  again GAP may be used occasionally,  but more as a
black box, while most of the algorithmic  aspects will be treated in a
separate course by me next  summer, in which GAP will naturally play a
more central  role.  Prof  Pahlings  meanwhile will  already  go on to
representation theory next summer.

We have  followed that line also some  years ago,  both  seem  to have
advantages and  drawbacks and I really cannot say that I recommend one
of them as the better setup.

Generally we tend to allow or even  recommend the use  of GAP also  in
other  courses such as the introductory  algebra course.  We hope that
for  students, who  nowadays tend to  come being pretty  well used  to
PASCAL or the like, using GAP is not so difficult, so in these courses
usually  we have made no attempt with a systematic introduction to GAP
but  rather have "let things happen" and  this is perhaps even so with
the above-mentioned courses.  But  I am sure  we  could do better than
that and  hence I would  be  very interested  to  get whatever  course
material is developed. I would also very much welcome if such material
- perhaps  after  some test  with students - could be  made  generally
available alongside with GAP.

Joachim Neubueser



From martin@bert.math.rwth-aachen.de Mon Nov  2 21:58:52 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Mon, 2 Nov 92 21:58:52 +0100
Subject:    Re: Reading from files

Eamonn O'Brien writes in his e-mail message of 2-Nov-92

    Why does the following piece of code not work? It generates
    an error message

    Error, Variable 'G' must have a value at
    ..

    I know that by not declaring G locally within the procedure
    I can persuade it to work OK -- but if I do that, it
    overwrites whatever existing value G had.

    This may have serious side effects -- where for example
    I have a group G defined in Gap, and I now want to read
    another group called G defined in "file.g" and return it
    from ReadFromFile to the main level
    under some other name. Is there any sensible way to
    achieve this without wiping out my existing G?

    I guess that I can encase the definition of G in the file
    within a function and call that function. But are there
    other approaches? Is this problem something which is
    intended /unavoidable / or a bug?

    Thanks,
    Eamonn O'Brien
    obrien@pell.anu.edu.au

    ##################################################
    #code to read value from file and return it
    ReadFromFile := function ()

       local exist, G;

       exist := READ("file.g");
       return G;
    end; #ReadFromFile

    l := ReadFromFile ();
    Print ("The value returned from the function is ", l, "\n");

    ############################################################

    #contents of file.g
    G := 5;

Let me try to explain why this works this  way.  I make this  fairly long
because most descriptions of programming  languages  are quite  brief  in
this  regard  (in  fact  most fail  to  describe  the  difference between
identifiers and variables).

On the one hand there are *variables*.  A variable is an abstract entity.
Variables  are  either global  variables,  formal  argument variables  of
functions, or local variables of functions.  Global variables are created
on demand.   With each function  call GAP creates one  variable  for each
formal  argument  (i.e.,  for   each  identifier  that   appears  in  the
parenthesis  following   the   'function'   keyword  in   the  function's
definition),  and one  variable for each local (i.e., for each identifier
that follows the 'local' keyword in the function's definition).

On  the  other  hand there are *identifiers*.   They are  just strings of
characters that appear in GAP's input (there are certain rules which rule
what is considered  an identifier as opposed to  an integer or a keyword,
but  this does  not  interest  us  here).   Each  variable  has a  unique
identifier, which is usually called its *name*.

The interesting connection  is  the one  that goes  from  identifiers  to
variables.  So for example in the following piece of code there are three
variables whose name is 'a' and we must define to which such variable the
identifier 'a' in the 'Print' statement is referring to.

    a := "global a";
    f := function ()
        local a;
        a := "a of f";
        h();
    end;
    g := function ()
        local a;
        a := "a of f";
        h := function ()
            Print( a, "\n" );
        end;
        f();
    end;
    g();

There  are  three  variables  called  'a', so there  are  three different
possibilities.  The first is to argue that the function 'h' has  no local
variable called 'a',  so  the  identifier  'a' must refer  to the  global
variable (and 'Print' should print "global a").

Another interpretation is that when the 'Print' statement is executed the
last *dynamically* created variable called 'a' is the one of  'f', so the
identifier  'a'  in  the  'Print' statement should refer to this variable
(and  'Print' should print "a  of  f").   This  point of view is  usually
called *dynamical scoping*.

The last interpretation is that when one reads the text the last variable
that was introduced before the  'Print' statement is that of the function
'g', so the identifier 'a' in  the 'Print' statement should refer to this
variable (and 'Print'  should  print  "a of  g").  This point  of view is
usually called *lexical scoping*.

If you try  this example in GAP you will see that the last interpretation
is the one adopted in GAP.

Lexical  scoping is considered  a *good  thing*  (by the Lisp  community,
which  initially tried dynamical  scoping), because it  has the following
property (usually called *alpha-renaming*):

    If one  replaces the identifier of an argument or a local variable of
    a function with  another  identifier  that  is not used  within  the
    functions body, the behavior of any program that calls this function
    does not change.

For example assume for the moment that GAP uses  dynamical scoping.  Then
the above example would print "a of f".  If we now change the name of the
local variable of 'f' from  'a' to 'aa', calling 'g' would suddenly print
"a of g" (because this becomes  the  dynamically innermost instance of  a
variable called 'a').

Thus  lexical  scoping confines the scope  where the name  of a  variable
makes  any  difference  to a lexically  apparent part of the source  text
(hence  the  name).   The  philosophy behind  this  is  the  idea that  a
programming  language should  be  as little surprising as possible.   And
having a program's behavior  changed simply by renaming a local variable
'i' to 'ThisIsALoopVariable' is surprising.

If we look at Eamonn's code fragment,  we see that what he asks for would
violate this property.  Suppose for the moment that the definition of the
local  variable  called  'G'  would  indeed  capture  the  assignment  in
'file.g'.  If  we now would change the name of this  local variable  from
'G' to  'H'  in the  function  'ReadFromFile' but  not in  'file.g', then
suddenly the  program would (mysteriously) behave  different,  because now
the  assignment in 'file.g'  would assign to the global variable with the
name 'G' (or a local  variable of the name 'G' that happens to be  active
when we execute 'ReadFromFile').

I  hope that this rather  long  explanation  impressed  you  above on the
virtues  of lexical  scoping that  you don't  actually  want  to use  the
following hack ;-)

    ReadFromFile := function ( name )
        local    oldG, newG, exists;
        if IsBound( G )  then
            oldG := G;
        fi;
        exists := READ( name );
        newG := G;
        if IsBound( oldG )  then
            G := oldG;
        else
            Unbind( G );
        fi;
        return newG;
    end;

Martin.

--
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From pjipsen@iastate.edu Fri Nov  6 01:35:54 1992
From:       pjipsen@iastate.edu "Peter Jipsen"
Date:       Fri, 6 Nov 92 01:35:54 +0100
Subject:    debugging

Is it possible to trace through gap code? 
Are there some useful commands to help debugging
gap routines? I found out about Backtrace in some
message on this forum, but couldn't find it
in the manual. Of course one can always interrupt
execution and inspect variables (very useful) and
after inserting enough ugly print statements in the
clean (but errant) gap code
one can eventually figure out what went wrong,
but then everything needs to be cleaned back up.
Maybe other users have come up with more 
elegant ideas? 

I guess in an ideal world only bug
free code would be written, and gap goes a long way
towards implementing mathematical algorithms in a
natural way, but with the innovative semantics of
list assingment I have managed to create some rather
subtle bugs. Even so, writing gap routines is in my experience far
less time consuming that using traditional programming
tools.

Peter Jipsen



From werner@pell.anu.edu.au Fri Nov  6 03:10:43 1992
From:       werner@pell.anu.edu.au "Werner Nickel"
Date:       Fri, 6 Nov 92 03:10:43 +0100
Subject:    Re:  debugging

Peter Jipsen writes:

>  Is it possible to trace through gap code? 
>  Are there some useful commands to help debugging
>  gap routines? I found out about Backtrace in some
>  message on this forum, but couldn't find it
>  in the manual. Of course one can always interrupt
>  execution and inspect variables (very useful) and
>  after inserting enough ugly print statements in the
>  clean (but errant) gap code
>  one can eventually figure out what went wrong,
>  but then everything needs to be cleaned back up.
>  Maybe other users have come up with more 
>  elegant ideas? 
>  
>  [stuff deleted]
Instead of interrupting an execution and end up at a more or
less random point in the GAP code one can use the function
Error() to halt the execution of GAP code at specific points.
For example, the following function has a bug. In order to look
at what's going on in the for-loop one can insert a call to
Error():

WrongIntegratePol := function( p )

	local	i, q;

	q := [ 0 ];
	for i in [1..Length(p)] do
	    q[i+1] := 1/(i+1) * p[i];
	    Error( "break point" );
	od;
	return p;
end;

As soon as Error() is executed, GAP goes into a break loop and one
can have a look at the state of the execution at this point. It is
possible, of course, to continue the execution by `returning' from
the break loop.

This technique suggests a way of implementing a step by step execution
of GAP code. The user would tell GAP at some point that she wants to
start to trace through the GAP code step by step. This could be done
by calling an internal function (which would have to be inserted at
some point into the GAP code). From then on, the internal functiont
which is responsible for executing a sequence of GAP statements could
generate a call to Error() after each statement has been executed. It
would also be useful to choose specific functions for step by step
execution. In this case a break loop would be created after each
statement in one of the chosen functions has been executed.

I don't know how difficult it would be to make the necessary changes
to the GAP kernel. At a superficial level it does not look to be too hard.

Any comments ?

Werner Nickel
Mathematics Research Section
Australian National University



From werner@pell.anu.edu.au Fri Nov  6 07:08:53 1992
From:       werner@pell.anu.edu.au "Werner Nickel"
Date:       Fri, 6 Nov 92 07:08:53 +0100
Subject:    Corrupted heap.

A while ago there was a bit of discussion about GAP's Error message

      gap: panic 'SyGetmem' detected corrupted heap!

Martin Schoenert explained that GAP basically produces this error
message if it detects that some subroutine interferes with GAP's
storage management. I just got this error message from GAP. In
trying to understand why, I discovered that there is an implicit
assumption made about sbrk() in the routine SyGetmem(). This
assumption does not seem to be satisfied in SunOS 4.1.1.

SyGetmem() contains the following line of code:

    if ( ret != (char*)-1 )  syHighmem = ret + size;

This line of code assumes that the new break value (assigned to
'syHighmem') is equal to the old break value (stored in 'ret')
plus 'size' (the argument to SyGetmem()). That means it assumes
that the alignment of 'size' is consistent with the alignment that
sbrk() enforces.
But on SunOS 4.1.1 it seems to be the case that sbrk() aligns the
additional memory to a multiple of 8 while  'size'  is only
guaranteed to be divisible by 4. Therefore in the next call of
SyGetmem() there can be a discrepancy of 4 bytes between syHighmem
and the value returned by sbrk() in which case GAP believes that
the heap is corrupted. This was precisely the reason why GAP gave me
the error message above. 

My suggestion is to remove this implicit assumption by replacing that
line of code by the following:

    if ( ret != (char*)-1 )  syHighmem = sbrk(0);


Werner Nickel
Mathematics Research Section
Australian National University



From fceller@bert.math.rwth-aachen.de Fri Nov  6 08:57:44 1992
From:       fceller@bert.math.rwth-aachen.de "Frank Celler"
Date:       Fri, 6 Nov 92 08:57:44 +0100
Subject:    Bug in Centralizer

There is a bug in 'Centralizer( <G>, <U> )' for ag groups which occurs
only if <G> is not the parent of <U>. In this case GAP returns a
subgroup of the parent of <G> which is not a subgroup of <G>. This bug
will be fixed in GAP 3.2.

sorry for any inconvenience
  Frank Celler



From dfh@maths.warwick.ac.uk Fri Nov  6 10:25:50 1992
From:       dfh@maths.warwick.ac.uk "Derek Holt"
Date:       Fri, 6 Nov 92 10:25:50 +0100
Subject:    debugging

The discussion on break loops reminded me of a problem I had the other day.
What happened when I entered the break loop was that I got a complete 
traceback of all the functions that were currently being executed.
Something like:

Error, Finite field /: operands must have the same characteristic at
g := RemainderCoeffs( f, g ) ... in
GcdPol( f, cyc ) called from
IorNIPol( f, fld ) called from
Exploitable( g, p, F ) called from
SLIdentify( f, gens ) called from
main loop
brk> 


(in fact exactly that). Notice that several of the functions involved have
parameters f and g, all with different values. I was not sure how to
inspect the current value of f, say, in a particular function, say
IorNIPol. Can someone tell me how to do that?

Derek Holt. 



From martin@bert.math.rwth-aachen.de Mon Nov  9 20:12:32 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Mon, 9 Nov 92 20:12:32 +0100
Subject:    Re: debugging

Peter Jipsen writes in his e-mail message of 6-Nov-92:

    Is it possible to trace through gap code? 
    Are there some useful commands to help debugging
    gap routines?

Well there  is  a function in the  GAP kernel that switches a flag  for a
function.  Afterwards this  function prints out its arguments whenever it
is called and its  result whenever  it is done.  This function is  called
'TraceFunc' and the corresponding function is called 'UntraceFunc' (or is
it only  'Untrace', I  can't remember).  Unfortunately  this  function is
next to useless because it simply produces too much output.

He continues:

                   I found out about Backtrace in some
    message on this forum, but couldn't find it
    in the manual.

Yes  it is  simply an oversight that 'Backtrace' isn't in the manual.  (I
guess  this  could happen because everyone of us used it so much  that we
never had to look it up in the manual ;-)

He continues:

                  Of course one can always interrupt
    execution and inspect variables (very useful) and
    after inserting enough ugly print statements in the
    clean (but errant) gap code
    one can eventually figure out what went wrong,
    but then everything needs to be cleaned back up.

Yes, we do this a lot.  (A side note.  When I am  looking for a bug I use
lots of print  statemtents or  other  tools.  But more  often  than not I
finally nail  it  down while not sitting  at the terminal or  reading the
code.  It happens quite often on my way home.)

He continues:

    Maybe other users have come up with more 
    elegant ideas?

Werner made one suggestion in his message.  I address this below.

He continues:

        I guess in an ideal world only bug
    free code would be written, and gap goes a long way
    towards implementing mathematical algorithms in a
    natural way,

You might just as  well say  that  in  an  ideal world we would know  the
answers  to  all  (important)  questions  and  wouldn't  need  to  employ
computers at all.

He continues:

                 but with the innovative semantics of
    list assingment I have managed to create some rather
    subtle bugs.

Yes,  the  list  assignment  is  the  major  stumbling block  for  almost
everyone.  Especially those who had previously experience with Pascal, C,
or Fortran.   (Is anybody  reading this  forum  who was used to  Lisp and
found GAP's semantics quite natural?)

He continues:

                 Even so, writing gap routines is in my experience far
    less time consuming that using traditional programming
    tools.

Depends  on the problem of course.  But yes, for mathematical stuff  this
was our hope and is our experience too.

Werner Nickel answered less than 2 hours later:

    Instead of interrupting an execution and end up at a more or
    less random point in the GAP code one can use the function
    Error() to halt the execution of GAP code at specific points.

    [example deleted]

    As soon as Error() is executed, GAP goes into a break loop and one
    can have a look at the state of the execution at this point. It is
    possible, of course, to continue the execution by `returning' from
    the break loop.

Indeed this is better than ordinary print statements,  because one can do
more things in the break loop.   (Of course one could  use '1/0;' instead
of 'Error()').

Still there are several problems  with this approach.  The  first is that
the bug  may not be  in your function but in a library function, and  you
may not have write permissions to edit the file in order to put a call to
'Error' into the function.

The other problem is more serious.  Suppose you have a  larger  function.
You have edited it, and it now contains a call to 'Error()'.  So you work
your  way through the execution.  After  quite some  time you finally see
something and  you say to yourself ``Ah,  I shouldn't  be looking at this
loop, this  loop  is probably o.k.  Instead I should be looking  at  this
other loop.''  Then you  would have to terminate your execution, edit the
file again, and *start all over again*.  This is very annoying.

Werner continues:

    This technique suggests a way of implementing a step by step execution
    of GAP code. The user would tell GAP at some point that she wants to
    start to trace through the GAP code step by step. This could be done
    by calling an internal function (which would have to be inserted at
    some point into the GAP code). From then on, the internal functiont
    which is responsible for executing a sequence of GAP statements could
    generate a call to Error() after each statement has been executed. It
    would also be useful to choose specific functions for step by step
    execution. In this case a break loop would be created after each
    statement in one of the chosen functions has been executed.

    I don't know how difficult it would be to make the necessary changes
    to the GAP kernel. At a superficial level it does not look to be too hard.

    Any comments ?

(You knew I wouldn't resist ;-)

Let me put it this way.   Since the GAP kernel  is an interpreter (and so
the  machinery  to evaluate arbitrary expressions  is  always available),
since break-loops  are already  there,  and  since  the  functions of the
interpreter that  implement the (GAP level) function calls leave lots  of
information around  (which is  used  e.g. by  'Backtrace'),  most  of the
machinery to do all kinds of nice things is there.  Breakpoints that  can
be dynamically  set and  unset, single stepping, even  a  limited form of
watchpoints, should all be possible.

Still there  are a  few tricky issues.  The first is how to specify where
to put a breakpoint.  This will probably require that GAP keeps  track of
linenumbers.   For   another  example  if  one  wants   breakpoints  with
conditions  (e.g., break at line 123 but only if i <=  0), then it is not
so easy to ensure that  the variable  references  ('i'  in this case) are
evaluated in the right environment  (e.g.,  we probably  don't  mean  the
global variable 'i', but whatever variable would be referenced by  'i' in
line 123).

We are in contact  with Benno Fuchsteiners group in Paderborn.  They have
implemented a very nice debugger for a system that is implemented similar
to GAP.  We will see what of their ideas, or maybe even of their code, we
can use.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From martin@bert.math.rwth-aachen.de Mon Nov  9 20:17:41 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Mon, 9 Nov 92 20:17:41 +0100
Subject:    Re: Corrupted heap.

Werner Nickel writes in his message of 06-Nov-92:

    A while ago there was a bit of discussion about GAP's Error message

          gap: panic 'SyGetmem' detected corrupted heap!

    Martin Schoenert explained that GAP basically produces this error
    message if it detects that some subroutine interferes with GAP's
    storage management. I just got this error message from GAP. In
    trying to understand why, I discovered that there is an implicit
    assumption made about sbrk() in the routine SyGetmem(). This
    assumption does not seem to be satisfied in SunOS 4.1.1.

    SyGetmem() contains the following line of code:

        if ( ret != (char*)-1 )  syHighmem = ret + size;

    This line of code assumes that the new break value (assigned to
    'syHighmem') is equal to the old break value (stored in 'ret')
    plus 'size' (the argument to SyGetmem()). That means it assumes
    that the alignment of 'size' is consistent with the alignment that
    sbrk() enforces.
    But on SunOS 4.1.1 it seems to be the case that sbrk() aligns the
    additional memory to a multiple of 8 while  'size'  is only
    guaranteed to be divisible by 4. Therefore in the next call of
    SyGetmem() there can be a discrepancy of 4 bytes between syHighmem
    and the value returned by sbrk() in which case GAP believes that
    the heap is corrupted. This was precisely the reason why GAP gave me
    the error message above.

    My suggestion is to remove this implicit assumption by replacing that
    line of code by the following:

        if ( ret != (char*)-1 )  syHighmem = sbrk(0);

Thanks  for  this patch  Werner.  I was under the  impression that Gasman
(GAP's  storage manager) would only  try to allocate memory in increments
that are a multiple of 1024 bytes large.  Since I assumed (and  still do)
that  this is consistent with  the alignment restrictions  on almost  all
systems, it  never occured  to  me that 'syHighmem  = ret +  size;' might
cause  the problem.  I will use  your patch  (and  also change Gasman, so
that my original assumption holds).

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From martin@bert.math.rwth-aachen.de Mon Nov  9 20:25:01 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Mon, 9 Nov 92 20:25:01 +0100
Subject:    Re: debugging

Derek Holt writes in his message of 06-Nov-92:

(During  that  day I  had  two corrupt  e-mail  addresses  on the forum's
mailing list, so I received every letter thrice.  One copy for me and two
e-mails returned by some MAIL-DAEMONS.  Can  you imagine my feelings when
I saw that morning that I had more than 30 new e-mail messages? ;-)

    The discussion on break loops reminded me of a problem I had the other day.
    What happened when I entered the break loop was that I got a complete
    traceback of all the functions that were currently being executed.
    Something like:

    Error, Finite field /: operands must have the same characteristic at
    g := RemainderCoeffs( f, g ) ... in
    GcdPol( f, cyc ) called from
    IorNIPol( f, fld ) called from
    Exploitable( g, p, F ) called from
    SLIdentify( f, gens ) called from
    main loop
    brk>

    (in fact exactly that). Notice that several of the functions involved have
    parameters f and g, all with different values. I was not sure how to
    inspect the current value of f, say, in a particular function, say
    IorNIPol. Can someone tell me how to do that?

There will be functions 'NextEnvironment'  and  'PrevEnvironment',  which
will  allow  you to step up and down the stack.  Each local variable will
then  be searched on that level.  So  to find  'foobar' 8 levels deep you
write 'NextEnvironment(8); foobar; PrevEnvironment(8);'.  Currently it is
not possible.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From mjf@caliban.math.nau.edu Wed Nov 11 20:18:46 1992
From:       mjf@caliban.math.nau.edu "Michael J. Falk"
Date:       Wed, 11 Nov 92 20:18:46 +0100
Subject:    solaris

Dear friend: I forward the following query from our system administrator:

Will your product run if we upgrade our SUN machine from SunOS 4.1.2
to Solaris 2.1?  In other words, SunOS 4.1.2 and Solaris 2.1 are
not binary compatible.  However, Solaris 2.1 has a 4.1.3 compatibility
mode which is sufficient for many products.  SUN suggests, however,
that we contact each vendor and ask if their product will continue to
run in compatibility mode or not.

Hence this question.  Will GAP run in compatiblity mode under
Solaris 2.1?

Thanks for your help. 
Yours, Mike.



From martin@bert.math.rwth-aachen.de Thu Nov 12 13:31:22 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Thu, 12 Nov 92 13:31:22 +0100
Subject:    Re: solaris

Michael Falk writes in his e-mail message of 12-Nov-92:

    Will your product run if we upgrade our SUN machine from SunOS 4.1.2
    to Solaris 2.1?  In other words, SunOS 4.1.2 and Solaris 2.1 are
    not binary compatible.  However, Solaris 2.1 has a 4.1.3 compatibility
    mode which is sufficient for many products.  SUN suggests, however,
    that we contact each vendor and ask if their product will continue to
    run in compatibility mode or not.

GAP  makes very  moderate  demands with respect  to the  operation system
interface.   Thus I  expect  that it  will  run  without problems  in the
compatibility  mode.  I cannot  say for certain,  because  we  don't have
Suns.

If there are any  problems, one can always recompile the source for  GAP.
For this you need a C compiler of course.  I understand that Solaris  2.1
does not contain a C compiler by  default, and that  you have to purchase
it as a separate product (I think you or your system administrator should
complain with Sun about that).  If there are problems with GAP running in
the compatibility  mode, and you  will not have a  C compiler,  I suggest
that you ask in this forum again.  I am certain that you will find a kind
soul willing to send you an executable.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From adresse@ulb.ac.be Fri Nov 13 09:45:30 1992
From:       adresse@ulb.ac.be "Alain Dresse"
Date:       Fri, 13 Nov 92 09:45:30 +0100
Subject:    share library?

Dear Gap-users,

I would like to know if there is somewhere on the net an
ftp-accessible location for individual developments in gap, such as
the share library for maple or the netlib library for reduce. In
particular, I was wondering where one could find the GRAPE package
mentioned in the Gap manual...

Thank you for your help,

--
Alain Dresse, Universite Libre de Bruxelles
Campus Plaine, CP 231, B-1050 Bruxelles, Belgium

email: adresse@ulb.ac.be



From dfh@maths.warwick.ac.uk Fri Nov 13 10:39:42 1992
From:       dfh@maths.warwick.ac.uk "Derek Holt"
Date:       Fri, 13 Nov 92 10:39:42 +0100
Subject:    RestrictedPerm

A user in Oxford (Jane Bamblett) has pointed out to me that the function
RestrictedPerm( <perm>, <list> )
fails when <perm> is the identity. This seems undesirable to me.

Derek Holt.



From martin@bert.math.rwth-aachen.de Fri Nov 13 11:02:09 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Fri, 13 Nov 92 11:02:09 +0100
Subject:    Re: share library?

Alain Dresse writes in his message of 13-Nov-92:

    I would like to know if there is somewhere on the net an
    ftp-accessible location for individual developments in gap, such as
    the share library for maple or the netlib library for reduce. In
    particular, I was wondering where one could find the GRAPE package
    mentioned in the Gap manual...

There must be some kind of misunderstanding here.   The share library for
Maple and the  netlib  library for Reduce  have nothing to  do with  GAP.
They contain freely available stuff for those systems.

Maple's share library is available via 'ftp' from

    daisy.waterloo.edu	(129.97.140.58)
    neptune.inf.ethz.ch	(129.132.101.33)

Reduce's netlib is (as far as I can tell) not available via 'ftp'.  Send
a e-mail message containing the line 'help' to

    reduce-netlib@rand.org

The GRAPE package  can be obtained via anonymous  'ftp'.  Leonard Soicher
('L.H.Soicher@qmw.ac.uk') writes:

    GRAPE (Unix version) is now available via anonymous ftp from 
    IP number 138.37.80.15.  It is in the pub directory in files
    grape.README and grape.tar.Z. Please read grape.README -- it is short.

    If you collect a copy of GRAPE and set it up (or have problems setting
    it up), please email me to this effect.

    Note: This version of GRAPE is an improved and expanded version of 
    that released at the Deinze conference, June 1992. 
    Note that the CompleteSubgraphs function now returns a list of vertex sets 
    instead of vertex-name sets.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From martin@bert.math.rwth-aachen.de Fri Nov 13 11:03:47 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Fri, 13 Nov 92 11:03:47 +0100
Subject:    Re: RestrictedPerm

Derek Holt writes in his e-mail message of 13-Nov-92:

    A user in Oxford (Jane Bamblett) has pointed out to me that the function
    RestrictedPerm( <perm>, <list> )
    fails when <perm> is the identity. This seems undesirable to me.

Indeed it  does.  A quick fix  is to add the following three lines to the
file '<gap-dir>/lib/permutat.g'.

  RestrictedPerm := function( g, D )
      local   res, d;

      # check the arguments
      if not IsPerm( g )  then
          Error("<g> must be a permutation");
      elif not IsList( D )  then
          Error("<D> must be a list");
      fi;

+     # handle the identity
+     if g = ()  then return ();  fi;
+
      # compute the restricted permutation <res>
      res := [ 1 .. Maximum( LargestMovedPointPerm(g), Maximum(D) ) ];
      for d  in D  do
          if not d^g in D  then
              Error("<D> must be invariant under the action of <g>");
          fi;
          res[d] := d^g;
      od;

      # return the restricted permutation <res>
      return PermList( res );
  end;

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From neubuese@samson.math.rwth-aachen.de Fri Nov 13 12:22:48 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Fri, 13 Nov 92 12:22:48 +0100
Subject:    mis- and understandings

Martin answered two letters a  moment ago,  and  all real  information
needed is in his answers, but let me clarify two points:

1.  Alain Dresse asked of  course if there is something for  GAP *such
as* the share library for Maple. The answer to this  is: not yet , but
there will be and in fact  a beginning will be made at the time of the
release of GAP 3.2, which we hope to get out in real near future (dont
ask back what that means exactly)  with a  few  such packages. We will
then also explain how this will be organised.

2. Martin  gave a  fix for Derek Holt's (justified)  complaint. He did
not mention, but  this should be understood that this fix as hopefully
all that have been given in such cases will be contained in GAP 3.2.

Joachim Neubueser



From pjipsen@iastate.edu Thu Nov 19 19:37:03 1992
From:       pjipsen@iastate.edu "Peter Jipsen"
Date:       Thu, 19 Nov 92 19:37:03 +0100
Subject:    automorphism group of a group

  How can I make GAP compute Aut(G) for small groups G in a simple
and/or efficient way?
                       Peter Jipsen



From kaym@math.wayne.edu Thu Nov 19 20:06:03 1992
From:       kaym@math.wayne.edu "Kay Magaard"
Date:       Thu, 19 Nov 92 20:06:03 +0100
Subject:    Re: automorphism group of a group

How can I make GAP compute Aut(G) for small groups G in a simple
and/or efficient way?
                       Peter Jipsen


I don't know, but my first guess would be:
Take a small faithfull permutation representation of G and 
compute the normalizer in that Symmetric group.
Kay
Magaard



From kaym@math.wayne.edu Thu Nov 19 20:14:39 1992
From:       kaym@math.wayne.edu "Kay Magaard"
Date:       Thu, 19 Nov 92 20:14:39 +0100
Subject:    Re: automorphism group of a group

 How can I make GAP compute Aut(G) for small groups G in a simple
and/or efficient way?
                       Peter Jipsen

I forgot to mention that you need to make sure that the 
representaion you take has a point stabilizer that is 
invariant under Aut(G). This will off course be guaranteed
if for some reason you know that there is a unique G-conjugacy class
of that isomorphism type.
Kay Magaard



From kaup@ccucvx.unican.es Fri Nov 20 17:54:36 1992
From:       kaup@ccucvx.unican.es "Ansgar Kaup"
Date:       Fri, 20 Nov 92 17:54:36 +0100
Subject:    GAP for Mac, ?Invoking Editor from the inside of GAP ?

Does anyone know how to invoke an Editor from the inside of GAP working
on a Mac ? Quite sure it is possible to leave, to edit and to come in again
but this takes quite a lot time and you have to save all your data...
I would be happy if anyone can help me.

Ansgar Kaup



From fceller@bert.math.rwth-aachen.de Mon Nov 30 11:27:05 1992
From:       fceller@bert.math.rwth-aachen.de "Frank Celler"
Date:       Mon, 30 Nov 92 11:27:05 +0100
Subject:    *CFV*: 'Depth( <agword> )'

I would like to know if  anyone needs the  following (strange) feature
of 'Depth( <g> )',  where  <g>  is an agword:  If <g> is  the identity
'Depth' will  return zero and *not* the composition  length + 1 of the
parent of <g>.  This is due to historic reasons, because in  the first
versions of GAP there existed an identity without parent group.

If nobody uses this feature I will change this in GAP 3.2.

mfg
    Frank Celler
    fceller@bert.math.rwth-aachen.de



From geck@tiffy.math.rwth-aachen.de Wed Dec  2 14:17:42 1992
From:       geck@tiffy.math.rwth-aachen.de "Meinolf Geck"
Date:       Wed, 2 Dec 92 14:17:42 +0100
Subject:    exercises with GAP

Hello!
Several e-mails ago there was a short discussion about GAP and its possible
use in exercises to courses in group theory or similar topics. At present,
Prof. Pahlings is giving a course on group theory (for 3rd year students),
and in addition to the ''usual theoretical'' exercises we have prepared
some exercises involving simple groups. In most cases, the purpose was
to show that a  group given by permutations or matrices over a finite field
is in fact simple (e.g., the Mathieu groups, Janko's smallest group).

Very little knowledge about the functions and the structure of GAP 
is needed to solve these exercises, and we taught this in a preliminary
2 hour session.

Of course, the exercises are written in German. If someone is very much
intersested in these and cannot understand the German, please send a 
message to me and I will try to translate them.

I enclose a latex file which contains several ''Aufgaben''. The intention
of the first one is to explain the Schreier--Sims procedure for calculating
the order of a permuatation group. The second one gives a useful criterion
for showing that a group is simple. These are the basic tools for solving 
the following exercises.

                                                   Meinolf Geck
                                                   Lehrstuhl D f"ur Mathematik
                                                   RWTH Aachen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentstyle{article}
\textheight 21cm
\textwidth 14cm

\newcommand{\N}{\mbox{$I\!\! N$}}	% die natuerlichen Zahlen
\newcommand{\Z}{\mbox{$Z\!\!\! Z\!$}}	% die ganzen Zahlen
\newcommand{\Q}{\mbox{$Q\!\!\!\! I$}}	% die rationalen Zahlen
\newcommand{\R}{\mbox{$I\!\! R$}}	% die reellen Zahlen
\newcommand{\C}{\mbox{$C\!\!\!\! I$}}	% die komplexen Zahlen
\newcommand{\F}{\mbox{$I\!\! F\!$}}	% endliche K"orper

\begin{document}
\begin{center}
{\Large {\bf "\Ubung zur Gruppentheorie I \hspace{5 mm} (WS92/93)}}\\
Prof. Dr. Pahlings
\end{center}
\vspace{3 mm}
\newcounter{nummer}

\setcounter{nummer}{1}

\newenvironment{aufgabe}{\noindent {\bf Aufgabe \thenummer.}\\ 
 \addtocounter{nummer}{1} }{\vspace{3 mm} \\ }

\begin{aufgabe}
Sei $G$ eine endliche Permutationsgruppe. Ziel dieser Aufgabe ist es, einen
Algorithmus zu beschreiben, mit dem man die Ordnung von $G$ berechnen kann.
Dazu nehmen wir an, da{\ss} Permutationen $X \subseteq S_n$ gegeben
sind, so da{\ss} $G=\langle X \rangle$ gilt. \\
(a) Sei $i \in \{1,\ldots,n\}$. Zeigen Sie, da{\ss} die folgende Prozedur
die Bahn $B$ von $i$ (in der Variablen {\tt bahn}) sowie Elemente $g_j \in G$ 
(in der Variablen {\tt elts}) zur\"uckgibt, so da{\ss} man den $j$--ten 
Bahnpunkt als $i.g_j$ erh\"alt.

\begin{verbatim}
    bahn := [i]; elts := [()]; b := 1;
    while b <= Length( bahn ) do
      for x in X do
        if not bahn[b]^x in bahn then
          Add( bahn, bahn[b]^x ); Add( elts, elts[b] * x );
        fi;
      od;
      b := b + 1;
    od;
    return [bahn, elts]; 
\end{verbatim}

\noindent (Dabei bezeichnet $()$ die Identit\"at von $G$, $*$ das Produkt von 
Permutationen und $\hat{\;}$ das Anwenden einer Permutation auf 
einen Punkt. Mit {\tt l[i]} ist das $i$--te Element einer Liste $l$ gemeint.
Die Anweisung {\tt Add} f\"ugt einer Liste ein weiteres Element hinzu.)\\

\noindent (b) Beschreiben Sie ein rekursives Verfahren, das mit Hilfe 
des Algorithmus 
in (a) und Schreier's Untergruppensatz (siehe Satz 1 in \S 5 von Kap.I der 
Vorlesung) die Ordnung von $G$ berechnet.

{\em Hinweis:} Die Elemente $g_j$, die man in (a) erh\"alt, bilden ein 
Nebenklassenvertretersystem f\"ur den Stabilsator $H$ des Punktes $i$ in $G$.
Die Rekursion wird auf die Untergruppe $H$ angewandt.
\end{aufgabe}


\noindent Ziel der folgenden Aufgaben wird es sein, mit Hilfe des 
Programmsystems {\sf GAP} einige Permutationsgruppen praktisch zu
untersuchen und mit den gewonnenen rechnerischen Ergebnissen die
Einfachheit dieser Gruppen nachzuweisen. Dazu zuerst eine theoretische
Aufgabe:

\begin{aufgabe}
Sei $G$ eine endliche Gruppe, die treu, transitiv und primitiv auf einer
Menge $X$ operiert, und $p$ eine Primzahl mit folgenden Eigenschaften:\\
(i) $p \mid |X|$ und $p$ teilt $|G|$ genau einmal.\\
(ii) $G$ wird von  Elementen der  Ordnung $p$ erzeugt.\\
Zeigen Sie, da{\ss} dann $G$ einfach ist.
\end{aufgabe}

\begin{aufgabe}
Seien $a:=(1,2,3,4,5,6,7,8,9,10,11)$ und $b:=(3,7,11,8)(4,10,5,6)$ 
Permutationen in $S_{11}$ und $H:=\langle s,b\rangle$.\\
(a) Berechnen Sie mit Hilfe von {\sf GAP} die punktweisen Stabilisatoren
von $\{1\}$, $\{1,2\}$, $\{1,2,3\}$, $\{1,2,3,4\}$ sowie jeweils die Bahnen
dieser Stabilisatoren auf $\{1,\ldots,11\}$. Berechnen Sie die damit
die Ordnung von $H$ und ihre Faktorisierung als Produkt von
Primzahlpotenzen.\\
(b) Sei $U:=\langle a,bab^{-1} \rangle \leq H$. Zeigen Sie, da{\ss} $U=H$
gilt. {\em Hinweis:} Berechnen Sie mit {\sf GAP} die Ordnung von $U$.\\
(c) Zeigen Sie, da{\ss} $H$ einfach ist. {\em Hinweis:} Benutzen Sie
Aufgabe 1.\\
Die Gruppe $H$ wird \"uberlicherweise mit $M_{11}$ bezeichnet.
\end{aufgabe}

\begin{aufgabe}
Wir fassen die Elemente $a,b$ aus Aufgabe 2 als Permutationen in $S_{12}$ auf,
die den Punkt $12$ festlassen. Sei weiterhin $c:=(1,12)(2,11)(3,6)(4,8)(5,9)
(7,10)$ und $G:=\langle a,b,c \rangle \leq S_{12}$.\\
(a) Wieviel--fach transitiv operiert $G$ auf $\{1,\ldots,12\}$? Zeigen Sie
mit Hilfe von {\sf GAP}, da{\ss} $H$ (aus Aufgabe 2) der Stabilisator von $12$
ist.\\
(b) Berechnen Sie mit Hilfe von {\sf GAP} die Ordnung von $G$.\\
(c) Zeigen Sie, da{\ss} $G$ einfach ist. {\em Hinweis:} Beachten Sie, da{\ss}
$H$ eine einfache und maximale Untergruppe von $G$ ist.\\
Die Gruppe $G$ wird \"ublicherweise mit $M_{12}$ bezeichnet.
\end{aufgabe}

\begin{aufgabe}
Sei $M_{24}:=\langle
( 1,24)( 2,23)( 3,12)( 4,
            16)( 5,18)( 6,10)( 7,20)( 8,14)( 9,21)(11,17)(13,22)(15,19)$,\\
$( 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11,12,13,14,15,16,17,18,19,20,21,22,23)$,\\
$ ( 3,17,10, 7, 9)( 4,13,14, 19, 5)( 8,18,11,12,23)(15,20,22,21,16) \rangle
\leq S_{24}$. Bestimmen Sie die punktweisen Stabilisatoren $M_{23}$ bzw.\
$M_{22}$ von $\{24\}$ bzw.\ $\{23,24\}$. Untersuchen Sie, wieviel--fach
transitiv $M_{22}$, $M_{23}$, $M_{24}$ sind, bestimmen Sie die Ordnungen
und zeigen Sie jeweils, da{\ss} diese Gruppen einfach sind. Benutzen Sie dabei
\"ahnliche Methoden wie in den vorherigen Aufgaben.
\end{aufgabe} 

\begin{aufgabe}
Gegeben seien die folgenden invertierbaren Matrizen \"uber dem 
K\"orper $F:={\Z}/11{\Z}$ mit $11$ Elementen:
{ \[a:=\left( \begin{array}{rrrrrrr}
 10 & 6 & 6 & 7 & 6 & 7 & 7 \\  
 6 & 6 & 7 & 6 & 7 & 7 & 10 \\  
 6 & 7 & 6 & 7 & 7 & 10 & 6 \\  
 7 & 6 & 7 & 7 & 10 & 6 & 6 \\  
 6 & 7 & 7 & 10 & 6 & 6 & 7 \\  
 7 & 7 & 10 & 6 & 6 & 7 & 6 \\  
 7 & 10 & 6 & 6 & 7 & 6 & 7 \end{array} \right),\;\;
 b:=\left( \begin{array}{rrrrrrr}
 0 & 6 & 0 & 0 & 0 & 0 & 0 \\  
 0 & 0 & 6 & 0 & 0 & 0 & 0 \\  
 0 & 0 & 0 & 5 & 0 & 0 & 0 \\  
 0 & 0 & 0 & 0 & 6 & 0 & 0 \\  
 0 & 0 & 0 & 0 & 0 & 5 & 0 \\  
 0 & 0 & 0 & 0 & 0 & 0 & 5 \\  
 5 & 0 & 0 & 0 & 0 & 0 & 0 \end{array} \right).\]}
Ziel dieses \"Ubungsblattes ist die Untersuchung der Gruppe 
$J:=\langle a,b \rangle \leq GL_7(11)$. Wir werden eine Permutationsdarstellung
von $J$ konstruieren und dann auf \"ahnliche Weise wie in der 1.Zusatz\"ubung
zeigen k\"onnen, da{\ss} $J$ einfach ist. Die Gruppe $J$ wurde von Z.Janko
entdeckt (siehe der Artikel in Journal of Algebra 3 (1966), 147--186).\\
(i) Geben Sie  die Matrizen $a,b$ in {\sf GAP} ein, berechnen Sie 
$c:=baba^2ba^3b^2$, die Ordnung von $c$ und zeigen Sie, da{\ss} der Vektor 
$v_0:=(1,1,7,3,0,2,3) \in F^7$ eine Basis des Eigenraums zum Eigenwert 
$1$ ist.\\
(ii) Sei $0 \neq v=(v_1,\ldots,v_7) \in F^7$ und $i \geq 1$ minimal mit
$v_i \neq 0$. Dann nennen wir $N(v):=v_i^{-1} \cdot v$ den zugeh\"origen
normierten Vektor. Schreiben Sie ein {\sf GAP}--Programm, welches f\"ur
jedes $0 \neq v \in F^7$ den zugeh\"origen normierten Vektor zur\"uckgibt.\\
(iii) Die Gruppe $J$ operiert auf nat\"urliche Weise auf den normierten
Vektoren $\neq 0$ in $F^7$ (f\"ur $g \in G$ und $v \in F^7$ normiert ist
$v.g:=N(v \cdot g)$). Schreiben Sie ein {\sf GAP}--Programm, welches die 
Bahn $B$ von $v_0$ unter dieser Operation berechnet.\\
(iv) Zeigen Sie, da{\ss} $J$ treu auf $B$ operiert. Numerieren Sie die
Elemente von $B$ mit $1,\ldots,|B|$ und schreiben Sie ein {\sf GAP}--Programm, 
welches die von den Matrizen $a,b$ bewirkten Permutationen
$\pi_a,\pi_b$ auf den Ziffern $1,\ldots,|B|$ zur\"uckgibt.\\
(v) Bestimmen Sie mit Hilfe von {\sf GAP} die Ordnung von $J$ und zeigen Sie,
da{\ss} $J$ primitiv operiert.\\
(vi) Bilden Sie mit Hilfe von {\sf GAP} einige beliebige Produkte der Matrizen
$a,b$. Versuchen Sie, auf diese Weise ein Element von $J$ der Ordnung 19 zu 
finden. Benutzen Sie schlie{\ss}lich Aufgabe 1 der 1.Zusatz\"ubung, um die 
Einfachheit von $J$ nachzuweisen.\\
(vii) Bestimmen Sie mit Hilfe von {\sf GAP} eine $2$--Sylowgruppe $P$ von $J$,
ein Element $z \in Z(P)$ der Ordnung 2, sowie $C:=C_J(z)$. Berechnen Sie die
Ordnung von $C$, die Kommutatorgruppe von $C$ und zeigen Sie, da{\ss}
$C \cong {\Z}_2 \times A_5$ gilt.\\
{\em Bem.:} Janko zeigt in dem oben erw\"ahnten Artikel, da{\ss} $J$ die
einzige einfache Gruppe ist, in der es ein Element der Ordnung 2 wie in (vii)
gibt. 
\end{aufgabe}

\end{document}



From dlj@maths.nott.ac.uk Thu Dec  3 14:35:14 1992
From:       dlj@maths.nott.ac.uk "Dr D. L. Johnson"
Date:       Thu, 3 Dec 92 14:35:14 +0100
Subject:    Re:  exercises with GAP

Dear Meinolf,

Thanks very much for the tex file with 3rd year exercises in GAP, which
I will save till next session. I've just finished a 3rd year course
similar to that given by Prof.Pahlings but will probably teach it again 
in 93. I'll also pass this on to Martin Edjvet, who is the other group
theorist here. We are both looking forward to the appearance of GAP3.2
which we'll get bfrom Derek Holt in due course.

I'm planning to visit Aachen around next Easter and hope to see you

again then.

Best wishes,

Dave Johnson



From dawn@math.wayne.edu Thu Dec  3 23:52:38 1992
From:       dawn@math.wayne.edu "Dawn Endico"
Date:       Thu, 3 Dec 92 23:52:38 +0100
Subject:    Do standard test routines exist?

Hello,

Some of you may be interested to know that I was able to compile GAP
on an Amdahl mainframe under UTS unix.  (System V.3.1 / UTS 2.1)
I did it using "make usg".

I was wondering if some sort of standard test routines already exist
that I could use to exercise this new system.  I would want to check
for both correct results as well as timing.  It would be useful to
compare performance on this machine to implementations on other
systems.

Thanks,
 
~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
Dawn Endico                                   dawn@math.wayne.edu
Mathematics Department              ... umich!wsu-cs!mathsun!dawn
Wayne State University                              (313)577-3183
1150 FAB Detroit, MI 48202                           DON'T PANIC!



From cfdmb@ux1.cts.eiu.edu Sat Dec  5 23:30:22 1992
From:       cfdmb@ux1.cts.eiu.edu "Duane Broline"
Date:       Sat, 5 Dec 92 23:30:22 +0100
Subject:    Porting to AIX

   With a good deal of healp from some of the experts here,
I have been able to port GAP to an IBM RISC/6000 machine running
AIX.  Since AIX was not one of the options specified in the makefile
some modifications to the code had to be made.
   They were very simple.
   Comment out the lines which defined ulong and ushort
as unsigned long and unsigned short types.  AIX already uses
ulong and ushort to indicate these types.  (At least it runs
and has done everything I have asked it.
   
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+   Duane Broline                       email: cfdmb@eiu.edu    +
+   Department of Mathematics           phone: 217-581-6278     +
+   Eastern Illinois Univ.              office: OM 328          +
+   Charleston, IL 61920                                        +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



From geck@tiffy.math.rwth-aachen.de Mon Dec  7 16:30:04 1992
From:       geck@tiffy.math.rwth-aachen.de "Meinolf Geck"
Date:       Mon, 7 Dec 92 16:30:04 +0100
Subject:    exercises

Hello again!
Recently I sent some latex file containing exercises with GAP. One of them
involved the construction of Janko's smallest group J1. Unfortunately I
mixed up MeatAxe-- and GAP--conventions about finite field elements. So
this exercise needs a further specification:

In order to read into GAP the matrices given in that exercise one has to
proceed as follows:

a := [ [10,6,6,7,6,7,7], [6,6,7,6,7,7,10], [6,7,6,7,7,10,6], [7,6,7,7,10,6,6],
[6,7,7,10,6,6,7], [7,7,10,6,6,7,6], [7,10,6,6,7,6,7] ]*Z(11);

b := [ [0,6,0,0,0,0,0], [0,0,6,0,0,0,0], [0,0,0,5,0,0,0], [0,0,0,0,6,0,0],
[0,0,0,0,0,5,0], [0,0,0,0,0,0,5], [5,0,0,0,0,0,0] ]*Z(11);

So one has to multiply the integer matrices by Z(11), and not by Z(11)^0,
as one might have expected! The vector to be spanned can be calculated as
follows:

c:=b*a*b*a^2*b*a^3*b^2;
v:=NullspaceMat(c-c^0)[1];

The operation of matrices on vectors I have in mind is multiplication of
vectors by matrices: v*a, v*b, etc.

                                             Sorry for this confusion,
                                                   Meinolf Geck
                                                   Lehrstuhl D f"ur Mathematik
                                                   RWTH Aachen



From mattanhh@nuscc.nus.sg Wed Dec  9 03:33:54 1992
From:       mattanhh@nuscc.nus.sg "Hwee Huat Tan"
Date:       Wed, 9 Dec 92 03:33:54 +0100
Subject:    GAP on OS/2 2.0

Have GAP been ported to OS/2 2.0? If it have not been done, is there
any plan to do?


Thank you.

Hwee Huat Tan
Department of Mathematics
National University of Singapore



From martin@bert.math.rwth-aachen.de Wed Dec  9 09:59:18 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Wed, 9 Dec 92 09:59:18 +0100
Subject:    Re: Do standard test routines exist?

Dawn Endico writes in his e-mail of 3-Dec-92:

    Some of you may be interested to know that I was able to compile GAP
    on an Amdahl mainframe under UTS unix.  (System V.3.1 / UTS 2.1)
    I did it using "make usg".

    I was wondering if some sort of standard test routines already exist
    that I could use to exercise this new system.  I would want to check
    for both correct results as well as timing.  It would be useful to
    compare performance on this machine to implementations on other
    systems.

We don't have a complete test set.  The following  file 'combinat.tst' is
our  standard  test.   Start   GAP  and  issue   the  command  'ReadTest(
"combinat.tst" );'.  This will read the file and  compare the output with
the comments  (those  beginning with '#>') in this  file.  If they match,
nothing is printed, otherwise the differences are printed.  So if you see

    gap> ReadTest( "combinat.tst" );
    combinat  3.1   1992/04/29  50000 GAPstones
    gap>

you know  that  everything worked  as expected.  'combinat.tst' exercises
GAP  quite  a   bit,  with   lots  of  function  calls,  several  garbage
collections,  lots  of  list  manipulations, etc.   So  if 'combinat.tst'
passes it is likely that everything else will also work.

GAPstones are used  to  measure GAP's  performance.  An Atari ST achieves
about 1000 GAPstones (actually now with GNU cc 2.2 it is more like 1500),
our DECstations 5120 achieve about 22000  GAPstones,  and our HP 9000/730
achieves about 65000 GAPstones.   This  is currently the best result I am
aware of.  Actually I would be quite interested  in further  results.  So
if you have another machine, run this test  and e-mail me the results,  I
will summarize them in this forum.

Martin.

#############################################################################
##
#A  combinat.tst                GAP tests                    Martin Schoenert
##
#A  @(#)$Id: forum92d.txt,v 1.1.1.1 1996/12/11 12:37:11 werner Exp $
##
#Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This  file  tests  the functions that  mainly  deal  with  combinatorics.
##
#H  $Log: forum92d.txt,v $
#H  Revision 1.1.1.1  1996/12/11 12:37:11  werner
#H  Preparing 3.4.4 for release
#H
#H  Revision 3.1  1992/04/29  08:53:40  martin
#H  changed the output (because of the new printer)
#H
#H  Revision 3.0  1991/07/22  18:13:03  martin
#H  initial revision under RCS
#H
##

#F  Factorial( <n> )  . . . . . . . . . . . . . . . . factorial of an integer
List( [0..10], Factorial );
#>[ 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 ]
Factorial( 50 );
#>30414093201713378043612608166064768844377641568960512000000000000

#F  Binomial( <n>, <k> )  . . . . . . . . .  binomial coefficient of integers
List( [-8..8], k -> Binomial( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Binomial( n, 0 ) );
#>[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
ForAll( [-8..8], n -> ForAll( [-2..8], k ->
    Binomial(n,k) = Binomial(n-1,k) + Binomial(n-1,k-1) ) );
#>true
Binomial( 400, 50 );
#>17035900270730601418919867558071677342938596450600561760371485120

#F  Bell( <n> ) . . . . . . . . . . . . . . . . .  value of the Bell sequence
List( [0..10], n -> Bell(n) );
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
List( [0..10], n -> Sum( [0..n], k -> Stirling2( n, k ) ) );
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
Bell( 60 );
#>976939307467007552986994066961675455550246347757474482558637

#F  Stirling1( <n>, <k> ) . . . . . . . . . Stirling number of the first kind
List( [-8..8], k -> Stirling1( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Stirling1( n, 0 ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
ForAll( [-8..8], n -> ForAll( [-8..8], k ->
    Stirling1(n,k) = (n-1) * Stirling1(n-1,k) + Stirling1(n-1,k-1) ) );
#>true
Stirling1( 60, 20 );
#>568611292461582075463109862277030309493811818619783570055397018154658816

#F  Stirling2( <n>, <k> ) . . . . . . . .  Stirling number of the second kind
List( [-8..8], k -> Stirling2( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Stirling2( n, 0 ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
ForAll( [-8..8], n -> ForAll( [-8..8], k ->
    Stirling2(n,k) = k * Stirling2(n-1,k) + Stirling2(n-1,k-1) ) );
#>true
Stirling2( 60, 20 );
#>170886257768137628374668205554120607567311094075812403938286

#F  Combinations( <mset>, <k> ) . . . .  set of sorted sublists of a multiset
Combinations( [] );
#>[ [  ] ]
List( [0..1], k -> Combinations( [], k ) );
#>[ [ [  ] ], [  ] ]
Combinations( [1..4] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ], [ 1, 2, 3, 4 ], [ 1, 2, 4 ], [ 1, 3 ], 
#>  [ 1, 3, 4 ], [ 1, 4 ], [ 2 ], [ 2, 3 ], [ 2, 3, 4 ], [ 2, 4 ], [ 3 ], 
#>  [ 3, 4 ], [ 4 ] ]
List( [0..5], k -> Combinations( [1..4], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ], 
#>  [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ], [ [ 1, 2, 3, 4 ] ], 
#>  [  ] ]
Combinations( [1,2,2,3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ], [ 1, 3 ], 
#>  [ 2 ], [ 2, 2 ], [ 2, 2, 3 ], [ 2, 3 ], [ 3 ] ]
List( [0..5], k -> Combinations( [1,2,2,3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ], 
#>  [ [ 1, 2, 2 ], [ 1, 2, 3 ], [ 2, 2, 3 ] ], [ [ 1, 2, 2, 3 ] ], [  ] ]
Combinations( [1..12] )[4039];
#>[ 7, 8, 9, 10, 11, 12 ]
Combinations( [1..16], 4 )[266];
#>[ 1, 5, 9, 13 ]
Combinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7] )[378];
#>[ 1, 2, 3, 4, 5, 6, 7 ]
Combinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,8], 8 )[97];
#>[ 1, 2, 3, 4, 5, 6, 7, 8 ]

#F  NrCombinations( <mset>, <k> ) . . number of sorted sublists of a multiset
NrCombinations( [] );
#>1
List( [0..1], k -> NrCombinations( [], k ) );
#>[ 1, 0 ]
NrCombinations( [1..4] );
#>16
List( [0..5], k -> NrCombinations( [1..4], k ) );
#>[ 1, 4, 6, 4, 1, 0 ]
NrCombinations( [1,2,2,3] );
#>12
List( [0..5], k -> NrCombinations( [1,2,2,3], k ) );
#>[ 1, 3, 4, 3, 1, 0 ]
NrCombinations( [1..12] );
#>4096
NrCombinations( [1..16], 4 );
#>1820
NrCombinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7] );
#>2880
NrCombinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,8], 8 );
#>1558

#F  Arrangements( <mset> )  . . . . set of ordered combinations of a multiset
Arrangements( [] );
#>[ [  ] ]
List( [0..1], k -> Arrangements( [], k ) );
#>[ [ [  ] ], [  ] ]
Arrangements( [1..3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ], [ 1, 3 ], [ 1, 3, 2 ], [ 2 ], [ 2, 1 ], 
#>  [ 2, 1, 3 ], [ 2, 3 ], [ 2, 3, 1 ], [ 3 ], [ 3, 1 ], [ 3, 1, 2 ], [ 3, 2 ], 
#>  [ 3, 2, 1 ] ]
List( [0..4], k -> Arrangements( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ], 
#>  [ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ], 
#>      [ 3, 2, 1 ] ], [  ] ]
Arrangements( [1,2,2,3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ], 
#>  [ 1, 2, 3, 2 ], [ 1, 3 ], [ 1, 3, 2 ], [ 1, 3, 2, 2 ], [ 2 ], [ 2, 1 ], 
#>  [ 2, 1, 2 ], [ 2, 1, 2, 3 ], [ 2, 1, 3 ], [ 2, 1, 3, 2 ], [ 2, 2 ], 
#>  [ 2, 2, 1 ], [ 2, 2, 1, 3 ], [ 2, 2, 3 ], [ 2, 2, 3, 1 ], [ 2, 3 ], 
#>  [ 2, 3, 1 ], [ 2, 3, 1, 2 ], [ 2, 3, 2 ], [ 2, 3, 2, 1 ], [ 3 ], [ 3, 1 ], 
#>  [ 3, 1, 2 ], [ 3, 1, 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 3, 2, 1, 2 ], 
#>  [ 3, 2, 2 ], [ 3, 2, 2, 1 ] ]
List( [0..5], k -> Arrangements( [1,2,2,3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ], 
#>  [ [ 1, 2, 2 ], [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 2 ], [ 2, 1, 3 ], 
#>      [ 2, 2, 1 ], [ 2, 2, 3 ], [ 2, 3, 1 ], [ 2, 3, 2 ], [ 3, 1, 2 ], 
#>      [ 3, 2, 1 ], [ 3, 2, 2 ] ], 
#>  [ [ 1, 2, 2, 3 ], [ 1, 2, 3, 2 ], [ 1, 3, 2, 2 ], [ 2, 1, 2, 3 ], 
#>      [ 2, 1, 3, 2 ], [ 2, 2, 1, 3 ], [ 2, 2, 3, 1 ], [ 2, 3, 1, 2 ], 
#>      [ 2, 3, 2, 1 ], [ 3, 1, 2, 2 ], [ 3, 2, 1, 2 ], [ 3, 2, 2, 1 ] ], [  ] ]
Arrangements( [1..6] )[736];
#>[ 3, 2, 1, 6, 5, 4 ]
Arrangements( [1..8], 4 )[443];
#>[ 3, 1, 7, 5 ]
Arrangements( [1,2,3,3,4,4,5] )[3511];
#>[ 5, 4, 3, 2, 1 ]
Arrangements( [1,2,3,4,4,5,5,6,6], 5 )[424];
#>[ 2, 3, 4, 5, 6 ]

#F  NrArrangements( <mset>, <k> ) . . number of sorted sublists of a multiset
NrArrangements( [] );
#>1
List( [0..1], k -> NrArrangements( [], k ) );
#>[ 1, 0 ]
NrArrangements( [1..3] );
#>16
List( [0..4], k -> NrArrangements( [1..3], k ) );
#>[ 1, 3, 6, 6, 0 ]
NrArrangements( [1,2,2,3] );
#>35
List( [0..5], k -> NrArrangements( [1,2,2,3], k ) );
#>[ 1, 3, 7, 12, 12, 0 ]
NrArrangements( [1..6] );
#>1957
NrArrangements( [1..8], 4 );
#>1680
NrArrangements( [1,2,3,3,4,4,5] );
#>3592
NrArrangements( [1,2,3,4,4,5,5,6,6], 5 );
#>2880

#F  UnorderedTuples( <set>, <k> ) . . . .  set of unordered tuples from a set
List( [0..1], k -> UnorderedTuples( [], k ) );
#>[ [ [  ] ], [  ] ]
List( [0..4], k -> UnorderedTuples( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ], [ 3, 3 ] ], 
#>  [ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 2, 3 ], 
#>      [ 1, 3, 3 ], [ 2, 2, 2 ], [ 2, 2, 3 ], [ 2, 3, 3 ], [ 3, 3, 3 ] ], 
#>  [ [ 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 1, 3 ], [ 1, 1, 2, 2 ], 
#>      [ 1, 1, 2, 3 ], [ 1, 1, 3, 3 ], [ 1, 2, 2, 2 ], [ 1, 2, 2, 3 ], 
#>      [ 1, 2, 3, 3 ], [ 1, 3, 3, 3 ], [ 2, 2, 2, 2 ], [ 2, 2, 2, 3 ], 
#>      [ 2, 2, 3, 3 ], [ 2, 3, 3, 3 ], [ 3, 3, 3, 3 ] ] ]
UnorderedTuples( [1..10], 6 )[1459];
#>[ 1, 3, 5, 7, 9, 10 ]

#F  NrUnorderedTuples( <set>, <k> ) . . number unordered of tuples from a set
List( [0..1], k -> NrUnorderedTuples( [], k ) );
#>[ 1, 0 ]
List( [0..4], k -> NrUnorderedTuples( [1..3], k ) );
#>[ 1, 3, 6, 10, 15 ]
NrUnorderedTuples( [1..10], 6 );
#>5005

#F  Tuples( <set>, <k> )  . . . . . . . . .  set of ordered tuples from a set
List( [0..1], k -> Tuples( [], k ) );
#>[ [ [  ] ], [  ] ]
List( [0..3], k -> Tuples( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], 
#>      [ 3, 2 ], [ 3, 3 ] ], 
#>  [ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 1 ], [ 1, 2, 2 ], 
#>      [ 1, 2, 3 ], [ 1, 3, 1 ], [ 1, 3, 2 ], [ 1, 3, 3 ], [ 2, 1, 1 ], 
#>      [ 2, 1, 2 ], [ 2, 1, 3 ], [ 2, 2, 1 ], [ 2, 2, 2 ], [ 2, 2, 3 ], 
#>      [ 2, 3, 1 ], [ 2, 3, 2 ], [ 2, 3, 3 ], [ 3, 1, 1 ], [ 3, 1, 2 ], 
#>      [ 3, 1, 3 ], [ 3, 2, 1 ], [ 3, 2, 2 ], [ 3, 2, 3 ], [ 3, 3, 1 ], 
#>      [ 3, 3, 2 ], [ 3, 3, 3 ] ] ]
Tuples( [1..8], 4 )[167];
#>[ 1, 3, 5, 7 ]

#F  NrTuples( <set>, <k> )  . . . . . . . number of ordered tuples from a set
List( [0..1], k -> NrTuples( [], k ) );
#>[ 1, 0 ]
List( [0..3], k -> NrTuples( [1..3], k ) );
#>[ 1, 3, 9, 27 ]
NrTuples( [1..8], 4 );
#>4096

#F  PermutationsList( <mset> )  . . . . . . set of permutations of a multiset
PermutationsList( [] );
#>[ [  ] ]
PermutationsList( [1..4] );
#>[ [ 1, 2, 3, 4 ], [ 1, 2, 4, 3 ], [ 1, 3, 2, 4 ], [ 1, 3, 4, 2 ], 
#>  [ 1, 4, 2, 3 ], [ 1, 4, 3, 2 ], [ 2, 1, 3, 4 ], [ 2, 1, 4, 3 ], 
#>  [ 2, 3, 1, 4 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 2, 4, 3, 1 ], 
#>  [ 3, 1, 2, 4 ], [ 3, 1, 4, 2 ], [ 3, 2, 1, 4 ], [ 3, 2, 4, 1 ], 
#>  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 1, 3, 2 ], 
#>  [ 4, 2, 1, 3 ], [ 4, 2, 3, 1 ], [ 4, 3, 1, 2 ], [ 4, 3, 2, 1 ] ]
PermutationsList( [1,2,2,3,] );
#>[ [ 1, 2, 2, 3 ], [ 1, 2, 3, 2 ], [ 1, 3, 2, 2 ], [ 2, 1, 2, 3 ], 
#>  [ 2, 1, 3, 2 ], [ 2, 2, 1, 3 ], [ 2, 2, 3, 1 ], [ 2, 3, 1, 2 ], 
#>  [ 2, 3, 2, 1 ], [ 3, 1, 2, 2 ], [ 3, 2, 1, 2 ], [ 3, 2, 2, 1 ] ]
PermutationsList( [1..6] )[ 128 ];
#>[ 2, 1, 4, 3, 6, 5 ]
PermutationsList( [1,2,2,3,3,4,4,4] )[1359];
#>[ 4, 3, 2, 1, 4, 3, 2, 4 ]

#F  NrPermutationsList( <mset> )  . . .  number of permutations of a multiset
NrPermutationsList( [] );
#>1
NrPermutationsList( [1..4] );
#>24
NrPermutationsList( [1,2,2,3] );
#>12
NrPermutationsList( [1..6] );
#>720
NrPermutationsList( [1,2,2,3,3,4,4,4] );
#>1680

#F  Derangements( <list> ) . . . . set of fixpointfree permutations of a list
Derangements( [] );
#>[ [  ] ]
Derangements( [1..4] );
#>[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
#>  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
#>  [ 4, 3, 2, 1 ] ]
Derangements( [1..6] )[ 128 ];
#>[ 4, 3, 6, 1, 2, 5 ]
Derangements( [1,2,2,3,3,4,4,4] )[64];
#>[ 4, 1, 4, 2, 4, 2, 3, 3 ]

#F  NrDerangements( <list> ) .  number of fixpointfree permutations of a list
NrDerangements( [] );
#>1
NrDerangements( [1..4] );
#>9
NrDerangements( [1..6] );
#>265
NrDerangements( [1,2,2,3,3,4,4,4] );
#>126

#F  Permanent( <mat> )  . . . . . . . . . . . . . . . . permanent of a matrix
Permanent( [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]] );
#>9
Permanent( [[1,1,0,1,0,0,0],[0,1,1,0,1,0,0],[0,0,1,1,0,1,0],[0,0,0,1,1,0,1],
            [1,0,0,0,1,1,0],[0,1,0,0,0,1,1],[1,0,1,0,0,0,1]] );
#>24

#F  PartitionsSet( <set> )  . . . . . . . . . . .  set of partitions of a set
PartitionsSet( [] );
#>[ [  ] ]
List( [0..1], k -> PartitionsSet( [], k ) );
#>[ [ [  ] ], [  ] ]
PartitionsSet( [1..4] );
#>[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], [ [ 1 ], [ 2 ], [ 3, 4 ] ], 
#>  [ [ 1 ], [ 2, 3 ], [ 4 ] ], [ [ 1 ], [ 2, 3, 4 ] ], 
#>  [ [ 1 ], [ 2, 4 ], [ 3 ] ], [ [ 1, 2 ], [ 3 ], [ 4 ] ], 
#>  [ [ 1, 2 ], [ 3, 4 ] ], [ [ 1, 2, 3 ], [ 4 ] ], [ [ 1, 2, 3, 4 ] ], 
#>  [ [ 1, 2, 4 ], [ 3 ] ], [ [ 1, 3 ], [ 2 ], [ 4 ] ], [ [ 1, 3 ], [ 2, 4 ] ], 
#>  [ [ 1, 3, 4 ], [ 2 ] ], [ [ 1, 4 ], [ 2 ], [ 3 ] ], [ [ 1, 4 ], [ 2, 3 ] ] ]
List( [0..4], k -> PartitionsSet( [1..3], k ) );
#>[ [  ], [ [ [ 1, 2, 3 ] ] ], 
#>  [ [ [ 1 ], [ 2, 3 ] ], [ [ 1, 2 ], [ 3 ] ], [ [ 1, 3 ], [ 2 ] ] ], 
#>  [ [ [ 1 ], [ 2 ], [ 3 ] ] ], [  ] ]
PartitionsSet( [1..7] )[521];
#>[ [ 1, 3, 5, 7 ], [ 2, 4, 6 ] ]
PartitionsSet( [1..8], 3 )[96];
#>[ [ 1, 2, 3 ], [ 4, 5 ], [ 6, 7, 8 ] ]

#F  NrPartitionsSet( <set> )  . . . . . . . . . number of partitions of a set
NrPartitionsSet( [] );
#>1
List( [0..1], k -> NrPartitionsSet( [], k ) );
#>[ 1, 0 ]
NrPartitionsSet( [1..4] );
#>15
List( [0..4], k -> NrPartitionsSet( [1,2,3], k ) );
#>[ 0, 1, 3, 1, 0 ]
NrPartitionsSet( [1..8] );
#>4140
NrPartitionsSet( [1..9], 3 );
#>3025

#F  Partitions( <n> ) . . . . . . . . . . . . set of partitions of an integer
Partitions( 0 );
#>[ [  ] ]
List( [0..1], k -> Partitions( 0, k ) );
#>[ [ [  ] ], [  ] ]
Partitions( 6 );
#>[ [ 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 2, 2 ], 
#>  [ 3, 1, 1, 1 ], [ 3, 2, 1 ], [ 3, 3 ], [ 4, 1, 1 ], [ 4, 2 ], [ 5, 1 ], 
#>  [ 6 ] ]
List( [0..7], k -> Partitions( 6, k ) );
#>[ [  ], [ [ 6 ] ], [ [ 3, 3 ], [ 4, 2 ], [ 5, 1 ] ], 
#>  [ [ 2, 2, 2 ], [ 3, 2, 1 ], [ 4, 1, 1 ] ], 
#>  [ [ 2, 2, 1, 1 ], [ 3, 1, 1, 1 ] ], [ [ 2, 1, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1, 1 ] ], [  ] ]
Partitions( 20 )[314];
#>[ 7, 4, 3, 3, 2, 1 ]
Partitions( 20, 10 )[17];
#>[ 5, 3, 3, 2, 2, 1, 1, 1, 1, 1 ]

#F  NrPartitions( <n> ) . . . . . . . . .  number of partitions of an integer
NrPartitions( 0 );
#>1
List( [0..1], k -> NrPartitions( 0, k ) );
#>[ 1, 0 ]
NrPartitions( 6 );
#>11
List( [0..7], k -> NrPartitions( 6, k ) );
#>[ 0, 1, 3, 3, 2, 1, 1, 0 ]
NrPartitions( 100 );
#>190569292
NrPartitions( 100, 10 );
#>2977866

#F  OrderedPartitions( <n> ) . . . .  set of ordered partitions of an integer
OrderedPartitions( 0 );
#>[ [  ] ]
List( [0..1], k -> OrderedPartitions( 0, k ) );
#>[ [ [  ] ], [  ] ]
OrderedPartitions( 5 );
#>[ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 1, 3 ], 
#>  [ 1, 2, 1, 1 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 1, 4 ], [ 2, 1, 1, 1 ], 
#>  [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 3 ], [ 3, 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5 ] ]
List( [0..6], k -> OrderedPartitions( 5, k ) );
#>[ [  ], [ [ 5 ] ], [ [ 1, 4 ], [ 2, 3 ], [ 3, 2 ], [ 4, 1 ] ], 
#>  [ [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 2, 1, 2 ], [ 2, 2, 1 ], 
#>      [ 3, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 2, 1, 1 ], [ 2, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1 ] ], [  ] ]
OrderedPartitions( 13 )[2048];
#>[ 1, 12 ]
OrderedPartitions( 16, 6 )[1001];
#>[ 1, 11, 1, 1, 1, 1 ]

#F  NrOrderedPartitions( <n> ) . . number of ordered partitions of an integer
NrOrderedPartitions( 0 );
#>1
List( [0..1], k -> NrOrderedPartitions( 0, k ) );
#>[ 1, 0 ]
NrOrderedPartitions( 5 );
#>16
List( [0..6], k -> NrOrderedPartitions( 5, k ) );
#>[ 0, 1, 4, 6, 4, 1, 0 ]
NrOrderedPartitions( 13 );
#>4096
NrOrderedPartitions( 16, 6 );
#>3003

#F  RestrictedPartitions( <n>, <set> )  . restricted partitions of an integer
RestrictedPartitions( 0, [1..10] );
#>[ [  ] ]
List( [0..1], k -> RestrictedPartitions( 0, [1..10], k ) );
#>[ [ [  ] ], [  ] ]
RestrictedPartitions( 10, [1,2,5,10] );
#>[ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ], 
#>  [ 2, 2, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 2, 1, 1, 1, 1 ], [ 2, 2, 2, 2, 1, 1 ], 
#>  [ 2, 2, 2, 2, 2 ], [ 5, 1, 1, 1, 1, 1 ], [ 5, 2, 1, 1, 1 ], [ 5, 2, 2, 1 ], 
#>  [ 5, 5 ], [ 10 ] ]
List( [1..10], k -> RestrictedPartitions( 10, [1,2,5,10], k ) );
#>[ [ [ 10 ] ], [ [ 5, 5 ] ], [  ], [ [ 5, 2, 2, 1 ] ], 
#>  [ [ 2, 2, 2, 2, 2 ], [ 5, 2, 1, 1, 1 ] ], 
#>  [ [ 2, 2, 2, 2, 1, 1 ], [ 5, 1, 1, 1, 1, 1 ] ], [ [ 2, 2, 2, 1, 1, 1, 1 ] ],
#>  [ [ 2, 2, 1, 1, 1, 1, 1, 1 ] ], [ [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ] ]
RestrictedPartitions( 20, [2,5,10] );
#>[ [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ], [ 5, 5, 2, 2, 2, 2, 2 ], [ 5, 5, 5, 5 ], 
#>  [ 10, 2, 2, 2, 2, 2 ], [ 10, 5, 5 ], [ 10, 10 ] ]
List( [1..20], k -> RestrictedPartitions( 20, [2,5,10], k ) );
#>[ [  ], [ [ 10, 10 ] ], [ [ 10, 5, 5 ] ], [ [ 5, 5, 5, 5 ] ], [  ], 
#>  [ [ 10, 2, 2, 2, 2, 2 ] ], [ [ 5, 5, 2, 2, 2, 2, 2 ] ], [  ], [  ], 
#>  [ [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ] ], [  ], [  ], [  ], [  ], [  ], [  ], 
#>  [  ], [  ], [  ], [  ] ]
RestrictedPartitions( 60, [2,3,5,7,11,13,17] )[600];
#>[ 13, 7, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]
RestrictedPartitions( 100, [2,3,5,7,11,13,17], 10 )[75];
#>[ 17, 17, 13, 13, 13, 7, 5, 5, 5, 5 ]

#F  NrRestrictedPartitions(<n>,<set>) . . . . number of restricted partitions
NrRestrictedPartitions( 0, [1..10] );
#>1
List( [0..1], k -> NrRestrictedPartitions( 0, [1..10], k ) );
#>[ 1, 0 ]
NrRestrictedPartitions( 50, [1,2,5,10] );
#>341
List( [1..50], k -> NrRestrictedPartitions( 50, [1,2,5,10], k ) );
#>[ 0, 0, 0, 0, 1, 1, 1, 2, 4, 6, 6, 8, 10, 11, 11, 12, 13, 14, 14, 14, 15, 15, 
#>  14, 14, 14, 13, 12, 12, 11, 10, 9, 9, 8, 7, 6, 6, 6, 5, 4, 4, 4, 3, 2, 2, 
#>  2, 2, 1, 1, 1, 1 ]
NrRestrictedPartitions( 50, [2,5,10] );
#>21
List( [1..50], k -> NrRestrictedPartitions( 50, [2,5,10], k ) );
#>[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 
#>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
NrRestrictedPartitions( 60, [2,3,5,7,11,13,17] );
#>1213
NrRestrictedPartitions( 100, [2,3,5,7,11,13,17], 10 );
#>125

#F  Lucas(<P>,<Q>,<k>)  . . . . . . . . . . . . . . value of a lucas sequence
List( [0..10], i->Lucas(1,-2,i)[1] );
#>[ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341 ]
List( [0..10], i->Lucas(1,-2,i)[2] );
#>[ 2, 1, 5, 7, 17, 31, 65, 127, 257, 511, 1025 ]
List( [0..10], i->Lucas(1,-1,i)[1] );
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
List( [0..10], i->Lucas(2,1,i)[1] );
#>[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
Lucas( 0, -4, 100 ) = [ 0, 2^101, 4^100 ];
#>true

#F  Fibonacci( <n> )  . . . . . . . . . . . . value of the Fibonacci sequence
List( [0..17], Fibonacci );
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 ]
Fibonacci( 333 );
#>1751455877444438095408940282208383549115781784912085789506677971125378

#F  Bernoulli( <n> )  . . . . . . . . . . . . value of the Bernoulli sequence
List( [0..14], Bernoulli );
#>[ 1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66, 0, -691/2730, 0, 7/6 ]
Bernoulli( 80 );
#>-4603784299479457646935574969019046849794257872751288919656867/230010

# thats it for the combinatorical package  ##################################
Print("combinat  3.1   1992/04/29  ",QuoInt(700000000,time)," GAPstones\n");
if IsBound( GAPSTONES )  then Add( GAPSTONES, QuoInt(700000000,time) );  fi;



From martin@bert.math.rwth-aachen.de Wed Dec  9 10:03:38 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Wed, 9 Dec 92 10:03:38 +0100
Subject:    Re: Porting to AIX

Duane Broline writes:

       With a good deal of healp from some of the experts here,
    I have been able to port GAP to an IBM RISC/6000 machine running
    AIX.  Since AIX was not one of the options specified in the makefile
    some modifications to the code had to be made.
       They were very simple.
       Comment out the lines which defined ulong and ushort
    as unsigned long and unsigned short types.  AIX already uses
    ulong and ushort to indicate these types.  (At least it runs
    and has done everything I have asked it.

Yes that  should be about  everything that needs to be done  to  get  GAP
running under  AIX.   The same set of changes are  in the  first  update.
(BTW,  AIX's  usage of  'ushort' and 'ulong' is not  allowed according to
ANSI C).

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From werner@pell.anu.edu.au Wed Dec  9 11:39:46 1992
From:       werner@pell.anu.edu.au "Werner Nickel"
Date:       Wed, 9 Dec 92 11:39:46 +0100
Subject:    Re: Do standard test routines exist?

On a SparcStation 10 running SunOS 4.1.3 GAP got 48329 GAPstones.
It was compiled with cc and -O4 and ran with 2 MB of startup memory.
Started with 8 MB it achieved 49585 GAPstones.

Werner Nickel
Mathematics Research Section
Australian National University



From martin@bert.math.rwth-aachen.de Wed Dec  9 11:55:06 1992
From:       martin@bert.math.rwth-aachen.de "Martin Schoenert"
Date:       Wed, 9 Dec 92 11:55:06 +0100
Subject:    Re: Re: Do standard test routines exist?

Werner writes in his e-mail of 9-Dec-92:

    On a SparcStation 10 running SunOS 4.1.3 GAP got 48329 GAPstones.
    It was compiled with cc and -O4 and ran with 2 MB of startup memory.
    Started with 8 MB it achieved 49585 GAPstones.

Thanks.  Which SparcStation 10 is it?  A model 41 perhaps?

Werner's e-mail reminds me of something else I forgot.  The  test  should
be performed with 2 MB of memory, i.e., with option '-m 2m'.

As another result.   On a  IBM PC  with 80486  DX 50 with 386BSD compiled
with GNU gcc  2.3.1  options '-O2', GAP  3.2  achieves  32700  GAPstones.
Pretty fast for such a cheap system.

Martin.

-- .- .-. - .. -.  .-.. --- ...- . ...  .- -. -. .. -.- .-
Martin Sch"onert,   Martin.Schoenert@Math.RWTH-Aachen.DE,  +49 241 804551
Lehrstuhl D f"ur Mathematik, Templergraben 64, RWTH, D 51 Aachen, Germany



From L.H.Soicher@qmw.ac.uk Wed Dec  9 13:21:51 1992
From:       L.H.Soicher@qmw.ac.uk "Leonard Soicher"
Date:       Wed, 9 Dec 92 13:21:51 +0100
Subject:    GAPstones

Using the  gapexe.386  executable distributed by Aachen, my Dell 486P/33 
(33 MHz 486 DX) achieved  9948  GAPstones doing the  combinat.tst  test.

Leonard Soicher
School of Mathematical Sciences
QMW, London



From caranti@itnsp2.cineca.it Wed Dec  9 17:05:42 1992
From:       caranti@itnsp2.cineca.it "Andrea Caranti"
Date:       Wed, 9 Dec 92 17:05:42 +0100
Subject:    combinat.tst

This is the result of combinat.tst on a SPARCstation 2 running SunOS
4.1.1:

gap> ReadTest("combinat.tst");
combinat  3.1   1992/04/29  24013 GAPstones

Andreas Caranti

---------------------------------------------------------------------
A Caranti                                 Tel ++39 461 881618
Dipartimento di Matematica                Fax ++39 461 881624
Universita' degli Studi di Trento
I-38050 Povo (Trento)                     caranti@itnsp2.cineca.it
Italia                                    caranti@itncisca.bitnet



From dawn@math.wayne.edu Wed Dec  9 19:03:53 1992
From:       dawn@math.wayne.edu "Dawn Endico"
Date:       Wed, 9 Dec 92 19:03:53 +0100
Subject:    Re: Do standard test routines exist?

Martin,

Thanks for posting combinat.tst.  It turned out to be *very* useful.

On a Sparcstation SLC with 12mb ram, 80 mb swap, SunOS 4.1.2 running
the pre-compiled version of GAPv3r1 I got 12477 GAPstones.

On a Sparcstation IPX with 64mb ram, 180 mb swap, SunOS 4.1.2 running
the pre-compiled version of GAPv3r1 I got 23782 GAPstones.

The third machine is an Amdahl 5890-300E with 55mb ram, 100 mb virtual
memory (that we can use).  The OS is UTS, Amdahl's Sys. 5 Rel 3.4
product.  Although the program seemed to compile normally, the GAP
program it created seems to be rather crippled :-(  The good news is
that the test reported a new world record of over 2,000,000 GAPstones
;-).   The bad news is that several of the tests failed (looks like
overflow errors?).

I've included the output of "make usg" in case the error messages are
of any help.  If you have any ideas how I can fix this, please let me
know.  On the other hand, this isn't a terribly high priority since
this is only a test system and will be taken way on December 24.
However, it would be nice to get it going to help us evaluate this
system.

This test program turned out to very useful.  I suggest that you include
it in the next release so that it is automatically run by make when
GAP is compiled.  The distributions of TeX, GCC and perl all include 
such tests and are useful for weeding out many errors.

Thanks for your help,

Dawn

------ error messages from combinat 3.1 test -------
gap> ReadTest("combinat.tst");
[  ]
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
[  ]
#>[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
Error, Range: <high> must be an integer at
for <var>  in [ 1 .. n - 1 ] ... in
Bell( n ) called from
fun( i ) called from
List( [ 0 .. 10 ], function ( n ) ... end ) called from
main loop
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, -19795712349051/2835 ]
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
[  ]
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
[  ]
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
[  ]
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
[  ]
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
189716653967246317102219841803592079875786289982825807408418883233113779617440\
7638/9280784638125
#>170886257768137628374668205554120607567311094075812403938286
27692248700036124567107335014580233
#>9
5321157941168254033546471297717501542400437583349037/5
#>265
356811921265724728180664990332289807596650505
#>9
165641909854716711007828196609624895704068987930461438638163658455121944
#>24
Error, Range: <high> must be an integer at
for <var>  in [ 1 .. n - 1 ] ... in
Bell( Size( set ) ) called from
NrPartitionsSet( [  ] ) called from
Bell( n ) called from
fun( i ) called from
List( [ 0 .. 10 ], function ( n ) ... end ) called from
main loop
#>1
25441820363276742883607945813580428205317908552744971
#>11
103445980859711697995668758589333890877387084633322583554786870805163715674586\
382283216930470467004063923134244997005088911195688883980350143867868650519199\
255463162359189104634221737705197994835522875243609678612273035836031000540847\
879370061132590904417753208251770796456301698992792567377381177431998746706824\
895700578698097589340459891022789690549060482923693175349457995902190264395485\
270884028375345458096994745360117317857209769253571592337759885481666800589264\
114458182334885045235011330071469352561430714562360768501935580707455023840389\
412014421805463889657468591001103387599424033354742851050553023446594897501289\
805860063896293850725801219437039364643073739058210980320234306208036491802816\
400811239008992346941826854043729985019085586118717030222680381808819917575335\
266682473085849077472986231119938203834090754532250687228265588621311429507200\
8970908708100940
#>190569292
[ 0, 1, 1, -536870909, -1073741819, 288230374541099019, 864691119865200661, 
  -154742519898652116263108565, -618970009842857398757228459, 
  85672934994540862368995528128069803, 415383742493086060260628694699082069 ]
#>[ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341 ]
[ 2, 1, -1073741819, -1610612729, 576460745860972561, 1441151867336785951, 
  -309485022215251278681866175, -1083197527457178791815675777, 
  171345791379889220316510857174450433, 750286880274547222578878952931066367, 
  -89202977060861102344628131533586030537997311 ]
#>[ 2, 1, 5, 7, 17, 31, 65, 127, 257, 511, 1025 ]
[ 0, 1, 1, -536870910, -1073741821, 288230375614840837, 864691123086426120, 
  -154742511540111934077534195, -618970013301621882512998379, 
  85672896000034073954266207567740962, 415383745587936126768738156656197687 ]
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
false
#>true
[ 0, 1, 1, -536870910, -1073741821, 288230375614840837, 864691123086426120, 
  -154742511540111934077534195, -618970013301621882512998379, 
  85672896000034073954266207567740962, 415383745587936126768738156656197687, 
  -44601488740718563110999340270705688317001639, 
  -267608952933114634820076485700250203139866480, 
  71835732982839338679231443703812501888996891407941865, 
  167616706829394533669627392795558287289818369897791865, 
  -12855503611769392947089542050797870482256065104344334993456542, 
  -106057907535834706391533870608303841267974783539608212457126949, 
  891201476416135891846766331438310389883836271092900458793881427645564477 ]
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 ]
135738349279776867027993904418466224053009993148602642567552723657351343772050\
216142505137454048707280279205807983451045439248675629354398237452629374074999\
387095541931700660069064754600737235826430110846163438878465147490822924468131\
794379119150986537740545913207487860819988017476575921092763352224767132851986\
984649114742559091240753504448640651982014011262456107282151921925049918047392\
143241554042772010299027904456756459331779796377958748201619854923481717346701\
177624836072109803555466915318502006112521888216765742677893133260546747425553\
271794753853591734213433468782739620386169784293875461990168427739198435938937\
580292726566640987556414084576638582982585882053295629811282197110939351331852\
717761929302407462864916633932854332927570571513984768151268014774548511974383\
979921068825388572990598424800592056589172755164757584549543765463184903323690\
868098059654307199789224244346249880706650473563360259164152962912803580059659\
465596511670519117115080459110785437458795994689653444565981628973066887033138\
380388046974681096824052269835725672859954153880725022286303832048082319624754\
495333839165255114817076472223045099550497553254468841586926970329925276617785\
017576075438313828182274519999907261916065702046763117743626170989518955297491\
619789760254956948452005735806820414508635353825370782568114761534754545332734\
781597769653717123352680772212111499161397756942231762884472367431825474895333\
18533686861432334192786548186464749568175610313288746114
#>1751455877444438095408940282208383549115781784912085789506677971125378
[ 1, 536870911/2, 1/6, 0, 536870911/30, 0, 1/42, 0, 536870911/30, 0, 5/66, 0, 
  536870221/2730, 0, 7/6 ]
#>[ 1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66, 0, -691/2730, 0, 7/6 ]
802253496557036953319516546081147151131269605994715702835087291317704257795261\
574992461094736310619798197331947999519662834583957107667389224105531454507586\
851169348493282576133837315191806493255472708172907606845613681544962381267561\
842305305600940841066484533313652248239845963584155602532913747676128347430418\
667046313619438157293336987448546888989998914845819745531165082612272808525450\
9733/62730
#>-4603784299479457646935574969019046849794257872751288919656867/230010
combinat  3.1   1992/04/29  2473498 GAPstones
Syntax error: warning, undefined global variable in combinat.tst line 233
if IsBound( GAPSTONES )  then Add( GAPSTONES, QuoInt(700000000,time) );  fi;
                      ^
%
------ error messages from compiling GAP -------
% make usg
        ln system.usg system.c
        cc -O -c gap.c
gap.c: 448: warning: hdCall set but not used
gap.c: 887: warning: hdCall set but not used
        cc -O -c system.c
system.c: 890: warning: invariant comparison

        Base registers used - 3/0 for text/literals for system.c

        cc -O -c gasman.c
        cc -O -c scanner.c
        cc -O -c idents.c
        cc -O -c read.c
        cc -O -c eval.c
eval.c: 762: warning: hdR set but not used
eval.c: 762: warning: hdL set but not used
eval.c: 779: warning: hdR set but not used
eval.c: 779: warning: hdL set but not used
        cc -O -c integer.c
        cc -O -c rational.c
        cc -O -c cyclotom.c
        cc -O -c finfield.c
        cc -O -c unknown.c
unknown.c: 191: warning: hdL set but not used
        cc -O -c permutat.c
        cc -O -c word.c
word.c: 2465: warning: j unused
        cc -O -c agcollec.c
agcollec.c: 1624: warning: nr set but not used
agcollec.c: 1701: warning: nr set but not used
agcollec.c: 1837: warning: nr set but not used
        cc -O -c aggroup.c
        cc -O -c pcpresen.c
        cc -O -c list.c

        Base registers used - 2/0 for text/literals for list.c

        cc -O -c set.c
set.c: 167: warning: hdSet set but not used
        cc -O -c vector.c
vector.c: 197: warning: hdVec set but not used

        Base registers used - 2/0 for text/literals for vector.c

        cc -O -c blister.c
blister.c: 701: warning: ptList unused

        Base registers used - 2/0 for text/literals for blister.c

        cc -O -c range.c
        cc -O -c record.c
record.c: 1161: warning: hdLt unused
        cc -O -c string.c
        cc -O -c statemen.c
        cc -O -c function.c
function.c: 734: warning: hdFun set but not used

        Base registers used - 2/0 for text/literals for function.c

        cc -o gap gap.o system.o gasman.o  scanner.o idents.o read.o \
            eval.o integer.o rational.o cyclotom.o finfield.o unknown.o \
            permutat.o word.o agcollec.o aggroup.o pcpresen.o \
            list.o set.o vector.o blister.o range.o \
            record.o string.o statemen.o function.o
 
~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
Dawn Endico                                   dawn@math.wayne.edu
Mathematics Department              ... umich!wsu-cs!mathsun!dawn
Wayne State University                              (313)577-3183
1150 FAB Detroit, MI 48202                           DON'T PANIC!



From kaup@ccucvx.unican.es Thu Dec 10 10:56:25 1992
From:       kaup@ccucvx.unican.es "Ansgar Kaup"
Date:       Thu, 10 Dec 92 10:56:25 +0100
Subject:    Do standard test routines...

I made the test with our Macintosh LCII with Harry's port of GAP
and it obtained about 30000 GAPstones. I am quite astonished about
this result because our SUN Spark-station obtained about 42000 GAPstones
and the test took only one fingersnip in comparision with the time it
took on the Mac. Can someone tell me anything about the relation between
time and GAPstones ?

Ansgar



From kaup@ccucvx.unican.es Thu Dec 10 11:28:28 1992
From:       kaup@ccucvx.unican.es "Ansgar Kaup"
Date:       Thu, 10 Dec 92 11:28:28 +0100
Subject:    GAP test on MAC

I have another astonishing result. I made the test with another MAC,
a MAC IIsi, and it obtained about 55000 GAPstones which is even more than
our SUN. We used about 2Mbyte virtual memory but I don't think that this
is important. Does anyone have an explanation ?

Ansgar



From mendel@ccu.umanitoba.ca Fri Dec 11 20:06:43 1992
From:       mendel@ccu.umanitoba.ca "N. S. Mendelsohn"
Date:       Fri, 11 Dec 92 20:06:43 +0100
Subject:    GAPstones on Mac

Harry Lakser's first porting of GAP to Mac used the 'tick' rather than the
millisecond as the unit of time as explained in the ReadMe file.  The next
version will have a full Mac implementation including slide bars and 'save'
and 'print' in the roll down menu.  It will also use the millisecond as the
unit of time.  An announcement will appear in mid-January.
N. S. Mendelsohn



From ejr@vonnegut.ee.cornell.edu Sat Dec 12 22:04:41 1992
From:       ejr@vonnegut.ee.cornell.edu "Eric J. Rossin"
Date:       Sat, 12 Dec 92 22:04:41 +0100
Subject:    Question on direct products

Hi!

First, I am a relatively new user of GAP, as well as a novice on
group theory. My question is...

I am trying to explicitly find all sub-direct products of the direct
product group SxGxS, where S and G are both 2-groups, which have the
property that the subgroup of elements of the form {(e,g,s)} (e is 
identity of S, g is in G and s is in S) have a particular order (such as 4).

The size of S is typically 8,16 or 32 while G is 32, 64 or 128.

My questions are...

1) In general, does anyone have any guidelines as to the most efficient
presentations of these groups for calculation in GAP?

2) In specific, does anyone have ideas for a good course of action for
this problem.

I have so far been trying to use the Ag presentations from the 2-groups
library for S and G then forming the DirectProduct. GAP seems to compute
with this presentation fairly fast, but clearly an attempt to, say, use
Lattice seems futile (the direct products are 2k-128K in size!).

Anyway, any input would be greatly appreciated, particularly as to whether
the representation from the 2-group library or a permutation rep would
be more efficient.

thanks...

-eric (ejr@ee.cornell.edu)



From neubuese@samson.math.rwth-aachen.de Mon Dec 14 16:16:43 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Mon, 14 Dec 92 16:16:43 +0100
Subject:    subdirect products

Eric  J.  Rossin  asks  in  a  letter  to  the  GAP-forum for  ways of
constructing subdirect products  of three 2-groups. I have no complete
answer but just a few comments on his specific questions:

1.  I think that working with the polycyclic presentations of 2-groups
as given in the 2-group library of Eamonn O'Brien that is available in
GAP should be most efficient.

2. Subdirect products of *two* factors G and  H can best  be described
by giving epimorphisms p and q of the two  groups onto the same group.
The subdirect product G/\H can then be described as

G/\H  =  { (g.h) |  gp = hq }

This   construction   is   actually   used    in   the   GAP   command
SubdirectProduct.   To classify the subdirect  products use actions on
such pairs  by  the  automorphism groups.  For a practical use of such
ideas  see e.g.  a paper by  H.Brown,  H.  Zassenhaus,and  myself:  On
integral  groups I, Num. Math.  19, 1972, p. 386-399, but there may be
better  sources,  we needed this in the course of looking at reducible
finite unimodular groups which are such  subdirect products,  but  the
aim was not the study of subdirect products.

3.   Subdirect products of more than two factors are more difficult to
describe.  There  are several  papers  by Robert Remak,  in particular
"Ueber Untergruppen direkter Produkte von drei Faktoren", Crelle's  J.
fuer  die reine u.  angewandte  Math.   166, 1931  and  several others
between  1913 and the latter  paper.  I do not remember  if he gives a
construction   that   is   explicit  enough   to  lend  itself  to   a
classification of such subdirekt products up  to isomorphism.  To look
at the subgroup  lattice  of the  direct  product of the three factors
computed by GAP sounds rather hopeless to me, rather study the work of
Remak first and also have a look into  the  forward citation  index if
you can  find later papers  taking  up Remak's  work and  quoting him.

Perhaps somebody else in the Gap-forum knows such papers?

Joachim Neubueser



From dennis@math.cornell.edu Wed Dec 16 19:01:33 1992
From:       dennis@math.cornell.edu "Keith Dennis"
Date:       Wed, 16 Dec 92 19:01:33 +0100
Subject:    commutator questions

In case this is not the right place to ask this question, let me ask
another:  Is there a group theory discussion list on the net?  If not,
should there be one?

		Commutator Properties of Groups

The properties defined below arose several years ago in work with 
R. Alperin in computing the second homology group H_2(G,Z).


A group  G  will be said to satisfy the property  C_n  if for every
collection of  n  elements  x_1,...,x_n  in  G , there exist elements
z, y_1,...,y_n  in  G  so that for each  i = 1,...,n,  x_i = [z,y_i].

A group  G  will be said to satisfy the property  C'_n  if for every
collection of  n  elements  x_1,...,x_n  in  G' , there exist elements
z, y_1,...,y_n  in  G  so that for each  i = 1,...,n,  x_i = [z,y_i].


Thus a group satisfies  C_1  precisely when every element of  G  is
a commutator.  It is well-known that for  n >= 5,  A_n  satisfies  C_1.
Several years ago, Ulf Rehmann (Bielefeld) and I checked that  A_n
satisfies  C_2  for  5 <= n <= 10.  As I recall,  A_5  did not
satisfy  C_3.  If  U  is the multiplicative group of real quaternions
of norm 1, then one can show that  U  satisfies  C_3.  

One might reasonably conjecture that  A_n  satisfies  C_2  for  n >= 5.
One might also ask if there is a function  c(n)  so that  A_m  satisfies
C_n  provided that  m >= c(n).  One would then presumably have
c(1) = 5, c(2) = 5, and  c(3) > 5.  I have no evidence that such
a function should exist.

What results of this type are known for other groups, for example,
PSL_n(F) or the non-abelian finite simple groups?  How easy is it to
use GAP to study questions of this type?  How large can they be?  The
computations mentioned earlier used a special purpose C program and
took lots of memory and time.

Keith Dennis



From greil@guug.de Thu Dec 17 10:45:36 1992
From:       greil@guug.de "Toni Greil"
Date:       Thu, 17 Dec 92 10:45:36 +0100
Subject:    a question to HNN extensions

Dear Gap-Forum,

I have a conceptual question concerning "HNN extensions". 

In the book

  B. Chandler / W. Magnus, "The History of Combinatorial Group Theory" (1982)

on page 111, the definition of the HNN extension is given. It is followed
by the remark: "In particular, t (the "stable letter") is always of infinite
order in H (the extended group)."

Is this remark really correct - and if, then why ?

Thank you!
--Toni



From mjf@caliban.math.nau.edu Fri Dec 18 18:37:18 1992
From:       mjf@caliban.math.nau.edu "Michael J. Falk"
Date:       Fri, 18 Dec 92 18:37:18 +0100
Subject:    Re: a question to HNN extensions

Dear friends, Since noone has yet answered this question, I volunteer. If one 
kills the generators of the "base group", the quotient is isomorphic to the
infinite cyclic group with presentation <t| >. So the stable letter t maps
to a generator of Z, and thus has infinite order in the HNN group. 
(Geometrically, the "torus" collapses onto the "core S^1".) 
Best regards, Michael Falk.
> 
> Dear Gap-Forum,
> 
> I have a conceptual question concerning "HNN extensions". 
> 
> In the book
> 
>   B. Chandler / W. Magnus, "The History of Combinatorial Group Theory" (1982)
> 
> on page 111, the definition of the HNN extension is given. It is followed
> by the remark: "In particular, t (the "stable letter") is always of infinite
> order in H (the extended group)."
> 
> Is this remark really correct - and if, then why ?
> 
> Thank you!
> --Toni
> 
> 



From neubuese@samson.math.rwth-aachen.de Wed Dec 30 16:38:15 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubueser"
Date:       Wed, 30 Dec 92 16:38:15 +0100
Subject:    policy

In a  letter  to the GAP-forum  Keith Dennis  asked  a  more  or  less
theoretical question  about  commutators  for  which  a  group  theory
program might at best provide some evidence. In a second letter I will
give  a  little  partial information towards  his  question, but Keith
Dennis also asked first of all,  if the GAP-forum might  at all be the
right  place for  his question,  and if not, if there is another place
for such  a question, and if  not, if  there should be one.  I want to
comment on these questions here.

I think the GAP-forum is primarily for discussion of  GAP and its use.
So a question, if  some  problem can be  tackled with  GAP,  certainly
belongs into  it as much as technical questions about its  use, or bug
reports.   In  fact  concrete  questions  have often  enough  been the
incentive for new algorithmic  ideas  and  even implementations  and I
certainly welcome if these are done in GAP.

As a recent example showed even a purely theoretical  question  on the
meaning of a passage  in  the literature found a  quick answer in  the
forum  and  since  the  number  of letters  to the  forum is not  that
overwhelming yet,  I  think  there  is no  reason  to  introduce  firm
restrictions on the topics to be discussed yet although I ask  to keep
the main objective of the forum in mind.
 
As to Keith Dennis' question I certainly like to see it in the  forum,
since it might trigger thoughts how to provide further evidence.

I  do  not  know  of  an  electronic  forum  for  the   discussion  of
group-theoretical questions.  The Kourovka notebook  from Novosibirsk,
which  by  the  way  now is  also  distributed  in English,  certainly
demonstrates  the  usefulness  of  a  medium  in which  questions  and
problems can be made public. To  set up something like that via e-mail
might be a  nice idea,  but it will  then need  somebody who does some
careful editing and bookkeeping of the progress of the problems, as is
done  with the Kourovka Notebook, since problems  may remain open much
longer than it takes e.g.  to answer questions about GAP. We certainly
do have no intention (nor manpower) to start such an enterprise.

Joachim Neubueser



From neubuese@samson.math.rwth-aachen.de Wed Dec 30 17:02:26 1992
From:       neubuese@samson.math.rwth-aachen.de "Joachim Neubeuser"
Date:       Wed, 30 Dec 92 17:02:26 +0100
Subject:    re commutators

In a letter to the GAP-forum Keith Dennis asks various questions about
all elements in a group being commutators of  kinds.  I cannot provide
any information on his  properties C_n for n>1, but I can report  that
in his thesis, just finished under the direction of Professor Pahlings
in Aachen, Oliver Bonten has  proved that C_1 holds  for 'almost  all'
simple groups of Lie type. To be more precise, for each series of such
groups with fixed dimension n there is a  bound for the order q of the
field  involved such that C_1 holds for all groups with  q bigger than
this  bound.   The  bounds  are very big  and  no  hope  to settle the
remaining cases  by  computer even for  small  n.  The  methods of the
proofs are from  Character  theory  - as well  as by the way were  the
methods by which some years ago we verified by computer that C_1 holds
for all sporadic groups. Can one perhaps use character theory also for
verifying C_2 or C_3? I have no idea,  so here is another question. If
so, we  have plenty of charactertables  and tools for handling them in
GAP.

Joachim Neubueser



From gcs@maths.bath.ac.uk Wed Dec 30 17:12:23 1992
From:       gcs@maths.bath.ac.uk "Geoff Smith"
Date:       Wed, 30 Dec 92 17:12:23 +0100
Subject:    group theory discussion

> ....
> I  do  not  know  of  an  electronic  forum  for  the   discussion  of
> group-theoretical questions.... 

> Joachim Neubueser

__________

Well, one does exist, though hitherto it has not been widely publicized.
I maintain a mailing list, which currently has about 30 members in the UK,
Germany, Australia and elsewhere. It was set up last summer as an experiment,
and after reasonable initial use, it has since been used less frequently.

I think, therefore, that 30 is below the `critical mass' and invite all
interested group theorists (and friends of group theory) to join the 
mailing list. You do this by sending me a request to join. The procedure to 
quit the list is similar.

The mailing list address is:

group-pub-forum@maths.bath.ac.uk

(The reason for the name is that the atmosphere is supposed to be
 that of a public house situated next to a good group theory conference)

As usual, mail to this address is automatically forwarded to list members.
 
Geoff Smith

gcs@maths.bath.ac.uk



From smith@pell.anu.edu.au Thu Dec 31 01:07:44 1992
From:       smith@pell.anu.edu.au "Michael Smith"
Date:       Thu, 31 Dec 92 01:07:44 +0100
Subject:    GAPstones on Suns

I have run the combinat test on some Sun SparcStations. I had thought to
use an averaged figure after doing ReadTest("combinat.tst") 10 times within
a loop, but it appears that the first run is always a bit slower than the
rest, presumably because GAP has to read in some library files, so I shall
just quote the first figure in each case. All machines were running SunOS
4.1.*.

    SparcStation      GAPstones for
    model             combinat.tst

    SLC               11962
    1+                15032
    ELC               19821
    10 model 31       44917

----------------------------/|-|--|-|--|------Michael-Smith-------------------
smith@pell.anu.edu.au      /_| |\ | |  |      Mathematics Research Section
--------------------------/--|-|-\|-|_/|------Australian-National-University--


