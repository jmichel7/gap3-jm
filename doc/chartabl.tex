%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  chartabl.tex                GAP documentation              Goetz Pfeiffer
%%
%A  @(#)$Id: chartabl.tex,v 1.3 1997/01/24 14:14:49 gap Exp $
%%
%Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
%%
%H  $Log: chartabl.tex,v $
%H  Revision 1.3  1997/01/24 14:14:49  gap
%H  vfelsch corrected two record component names
%H
%H  Revision 1.2  1997/01/24 14:03:38  gap
%H  upgraded to 3.4.4
%H
%H  Revision 1.1.1.1  1996/12/11 12:36:43  werner
%H  Preparing 3.4.4 for release
%H
%H  Revision 3.43  1994/07/07  13:23:35  mschoene
%H  changed "TransformingPermutationsCharTables" to avoid moving reference
%H
%H  Revision 3.42  1994/07/05  15:57:36  vfelsch
%H  included some more final changes for version 3.4
%H
%H  Revision 3.41  1994/06/30  15:31:53  vfelsch
%H  included final changes for version 3.4
%H
%H  Revision 3.40  1994/06/18  12:16:21  sam
%H  fixed 'identifier' component in the text
%H
%H  Revision 3.39  1994/06/17  19:01:38  vfelsch
%H  examples adjusted to version 3.4
%H
%H  Revision 3.38  1994/05/31  15:34:29  vfelsch
%H  index entries rearranged
%H
%H  Revision 3.37  1994/05/19  13:46:28  sam
%H  introduced 'PrintCharTable' and functions and operators for c.t.
%H
%H  Revision 3.36  1993/07/14  07:14:19  sam
%H  fixed 'ClassMultCoeffCharTable'
%H
%H  Revision 3.35  1993/02/19  11:41:43  gap
%H  removed unecessary reference
%H
%H  Revision 3.34  1993/02/19  11:30:42  gap
%H  removed overfull hboxes
%H
%H  Revision 3.33  1993/02/19  10:48:42  gap
%H  adjustments in line length and spelling
%H
%H  Revision 3.32  1993/02/18  16:42:22  fceller
%H  added Alexander's Dixon/Schneider
%H
%H  Revision 3.31  1993/02/18  16:18:11  felsch
%H  documentation of Dixon algorithm added
%H
%H  Revision 3.30  1993/02/12  13:41:02  felsch
%H  examples fixed
%H
%H  Revision 3.28  1992/11/20  18:48:27  martin
%H  fixed a reference and two underfull vboxes
%H
%H  Revision 3.27  1992/11/03  10:24:29  sam
%H  added info about generic table 'P:Q'
%H
%H  Revision 3.26  1992/10/28  14:06:40  goetz
%H  added descriptions of 'CharDegAgGroup', 'CharTableSSGroup'
%H
%H  Revision 3.25  1992/09/07  14:15:31  sam
%H  added info about new tables 'GU3' and 'SU3'
%H
%H  Revision 3.24  1992/08/12  13:24:38  sam
%H  added interface to MOC
%H
%H  Revision 3.23  1992/08/06  13:26:55  hbesche
%H  little change in 'CharTablePGroup'
%H
%H  Revision 3.22  1992/07/03  12:27:37  sam
%H  little change in 'CharTableSplitClasses'
%H
%H  Revision 3.21  1992/07/01  16:51:24  sam
%H  added description of 'SortCharTable'
%H
%H  Revision 3.20  1992/04/27  11:55:51  martin
%H  replaced '\size{<set>}' with '\|<set>\|'
%H
%H  Revision 3.19  1992/04/07  23:05:55  martin
%H  changed the author line
%H
%H  Revision 3.18  1992/04/07  22:58:58  martin
%H  removed overfull and underfull boxes
%H
%H  Revision 3.17  1992/04/07  21:03:56  sam
%H  added documentation of Hans--Ulrich's functions
%H
%H  Revision 3.16  1992/04/03  08:32:27  sam
%H  correction concerning 'SizeScreen'
%H
%H  Revision 3.15  1992/04/02  16:15:15  martin
%H  replaced 'Linelength' by 'SizeScreen'
%H
%H  Revision 3.14  1992/04/01  15:46:26  sam
%H  added citation
%H
%H  Revision 3.13  1992/03/31  09:45:19  sam
%H  *** empty log message ***
%H
%H  Revision 3.12  1992/03/27  16:58:28  sam
%H  added section 'Some Notes on ...'
%H
%H  Revision 3.11  1992/03/27  13:51:48  sam
%H  removed "'" in index entries
%H
%H  Revision 3.10  1992/03/20  16:36:08  sam
%H  removed reference of 'CharTableDixonSchneider'
%H
%H  Revision 3.9  1992/03/13  18:30:17  goetz
%H  added 'CharTableWreathSymmetric'.
%H
%H  Revision 3.8  1992/03/13  18:24:16  goetz
%H  added "WeylB" and "WeylD" to 'CharTable'.
%H
%H  Revision 3.7  1992/03/10  18:02:31  goetz
%H  added 'NrPolyhedralSubgroups'.
%H
%H  Revision 3.6  1992/03/03  14:03:16  sam
%H  added documantation of 'ClassStructureCharTable'
%H
%H  Revision 3.5  1992/02/24  14:04:49  sam
%H  changed format of Brauer tables
%H
%H  Revision 3.4  1992/02/13  15:01:34  sam
%H  renamed 'MatrixAutomorphisms' to 'MatAutomorphisms'
%H
%H  Revision 3.3  1992/02/06  13:03:56  sam
%H  added change in 'GetFusionMap',
%H  reformatted file (to 73 columns)
%H
%H  Revision 3.2  1992/01/14  13:59:15  sam
%H  adjusted citations
%H
%H  Revision 3.1  1991/12/30  08:06:08  sam
%H  initial revision under RCS
%H
%%
\Chapter{Character Tables}%
\index{tables}

This chapter contains

the introduction of {\GAP} character tables (see "Some Notes on Character
Theory  in  GAP",  "Character Table  Records",  "Brauer  Table  Records",
"IsCharTable",   "PrintCharTable", "TestCharTable",  "Operations  Records
for  Character Tables",  "Functions  for  Character  Tables",  "Operators
for  Character Tables")  and  some  conventions  for   their  usage  (see
"Conventions for Character Tables"),

the  description how to construct or get  character tables  (see "Getting
Character Tables",  "CharTable";  for the contents  of the table library,
see  Chapter "Character  Table Libraries"),  matrix representations  (see
"MatRepresentationsPGroup").

the  description  of  some functions  which  give information  about  the
conjugacy  classes of character tables, that  is, to compute classlengths
(see       "InitClassesCharTable"),      inverse       classes       (see
"InverseClassesCharTable")  and  classnames  (see "ClassNamesCharTable"),
structure        constants        (see         "ClassMultCoeffCharTable",
"MatClassMultCoeffsCharTable",  "ClassStructureCharTable"),  the  set  of
real  classes (see "RealClassesCharTable"), orbits of the Galois group on
the  classes  (see  "ClassOrbitCharTable")  and  roots  of  classes  (see
"ClassRootsCharTable"),

the  description  how character tables or parts of them  can be displayed
(see  "DisplayCharTable")   and  sorted  (see  "SortCharactersCharTable",
"SortClassesCharTable", "SortCharTable").

the description of functions  which  compute  the automorphism group of a
matrix    (see    "MatAutomorphisms")    or    character    table    (see
"TableAutomorphisms"), or which compute permutations relating permutation
equivalent matrices (see "TransformingPermutations") or  character tables
(see "TransformingPermutationsCharTables"),

the description of functions which get fusions from and store fusions on
tables (see "GetFusionMap", "StoreFusion", "FusionConjugacyClasses"),

the description of the interface  between {\GAP} and the MOC3 system (see
"MAKElb11",  "ScanMOC", "MOCChars",  "GAPChars", "MOCTable", "PrintToMOC"
), and  of a function which converts {\GAP} tables  to {\CAS} tables (see
"PrintToCAS").

\vspace{5mm}
This chapter does *not* contain information about

functions   to  construct  characters  (see  Chapter  "Characters"),   or
functions to construct and use  maps  (see Chapter "Maps and Parametrized
Maps").

For some  elaborate examples how character tables are  handled in {\GAP},
see "About Character Tables".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Some Notes on Character Theory in GAP}

It seems to be necessary to state some basic facts --and maybe warnings--
at the beginning of the character theory  package.  This holds for people
who  are  familiar  with  character theory  because there  is  no  global
reference on  computational  character  theory,  although  there are many
papers  on  this  topic,  like~\cite{NPP84}  or~\cite{LP91}.   It  holds,
however, also for people who are familiar with {\GAP} because the general
concept of categories and domains (see "About Domains and Categories" and
chapter  "Domains") plays no important  role here --we  will justify this
later in this section.

Intuitively, characters of  the  finite  group  $G$ can be  thought of as
certain mappings defined on $G$, with values in the complex number field;
the set of  all characters  of $G$  forms  a semiring  with addition  and
multiplication  both defined pointwise, which is embedded in the ring  of
generalized (or virtual) characters in the natural way.  A {\bf Z}--basis
of this ring, and also  a vector space  base of the vector space of class
functions, is given by the irreducible characters.

At this stage  one  could ask where there  is a problem,  since all these
algebraic structures are supported by {\GAP}, as is described in chapters
"Domains", "Rings", "Vector Spaces", "Mappings", and others.

Now,  we  first  should  say  that  characters are  *not*  implemented as
mappings, that there are *no* {\GAP}  domains  denoting character  rings,
and that a character table is *not* a domain.

For computations with characters of a finite group $G$ with $n$ conjugacy
classes,  say,  we  fix an order of the classes, and  then identify  each
class with its position according to  this order.  Each character of  $G$
will be  represented as list of length $n$ where at  the $i$--th position
the  character value  for elements of the $i$--th  class is stored.  Note
that we do not need to know the conjugacy classes of $G$ physically, even
our ``knowledge\'\'\ of the group may be  implicit in the sense that e.g.
we  know how  many classes of involutions $G$ has, and which length these
classes have, but we never have seen an element of $G$, or a presentation
or representation  of $G$.  This allows to work with the character tables
of very large  groups, e.g., of the so--called monster,  where {\GAP} has
no chance to work with the group.

As a consequence,  also other information involving  characters is  given
implicitly.  For example, we can talk about the kernel of a character not
as a  group but as a list of classes  (more  exactly\:\  a list  of their
positions according to  the order of classes) forming this kernel; we can
deduce the  group order, the contained cyclic subgroups and so on, but we
do not get the group itself.

Characters are one kind of class functions, and we also represent general
class functions as lists.  Two important  kinds of these functions  which
are not characters are power maps and fusion maps.  The $k$--th power map
maps  each  class to the class  of $k$--th  powers  of its elements,  the
corresponding list  contains at each position the position of the  image.
A subgroup fusion  map  between the classes  of a subgroup $H$ of $G$ and
the classes of $G$ maps each class $c$ of $H$  to that class of $G$  that
contains $c$;  if  we  know only  the character tables of the two groups,
this means with respect to a fixed embedding of $H$ in $G$.

So the  data  mainly consist of  lists,  and  typical  calculations  with
character tables are more or less  loops over these lists.  For  example,
the known scalar product of two characters $\chi$, $\psi$ of $G$ given by
\[ [\chi,\psi] = \frac{1}{\|G\|}  \sum_{g\in G}  \chi(g)  \psi(g^{-1}) \]
can be written as

|    Sum( [1..n], i -> t.classes[i]*chi[i]*GaloisCyc(psi[i],-1) );|

where 't.classes' is the  list  of classlengths, and 'chi', 'psi' are the
lists  corresponding  to   $\chi$,  $\psi$,  respectively.    Characters,
classlengths,  element  orders,  power  maps,  fusion   maps  and   other
information about a  group is stored in  a  common character table record
just  to avoid  confusion, not to  indicate an algebraic structure (which
would mean a domain in the sense of {\GAP}).

A character table is  not determined  by something similar  to generators
for groups or rings in {\GAP} where other components (the knowledge about
the domain) is stored for the sake of efficiency.  In many situations one
works  with incomplete tables or preliminary tables which  are,  strictly
speaking, no character tables but shall be handled like character tables.
Moreover, the correctness or even the consistency of a character table is
hard to prove.  Thus  it is not sufficient to view a character table as a
black box, and to  get information  about it using a  few  property  test
functions.  In fact  there are very few  functions that return  character
tables  or that  are property tests.  Most {\GAP} functions dealing  with
character tables return class functions, or lists of them, or information
about class functions.  For that, {\GAP} directly accesses the components
of  the  table  record, and  the  user will  have to  look  at the record
components, too, in order to  put  the pieces of the puzzle together, and
to decide how to go on.

So it is not easy to say what a character table *is*; it *describes* some
properties of  the  underlying group, and it describes  them in  a rather
abstract way.   Also  {\GAP} does not  know whether  or not a list *is* a
character,  it will e.g. regard a list with all entries equal to 1 as the
trivial character if it is passed to a function that expects characters.

It is  one of  the advantages  of  character theory that  after  one  has
translated  a problem concerning groups into  a  problem concerning their
character  tables the calculations are mostly  simple.  For  example, one
can often prove that a group is  a Galois group  over the rationals using
calculations  of  structure  constants  that  can be  computed  from  the
character table, and  informations on  (the character tables of)  maximal
subgroups.

In this  kind  of  problems the translation back to  the group is just an
interpretation by the  user, it does  not take place in  {\GAP}.   At the
moment, the only interface between handling groups and handling character
tables is the fixed order of conjugacy classes.

Note that  algebraic  structures are  not  of  much interest in character
theory.  The main  reason for this is that we have no homomorphisms since
we need not to know anything about the group multiplication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Character Table Records}%
\index{character tables!format}%
\index{tables!format}

For  {\GAP}, a  character  table is any  record  that  has the components
'centralizers' and 'identifier' (see "IsCharTable").

There are  three different but very similar types of character  tables in
{\GAP},  namely  ordinary  tables,  Brauer  tables  and  generic  tables.
Generic  tables  are described in  Chapter  "Generic  Character  Tables".
Brauer tables are defined and stored relative to ordinary tables, so they
will be described  in  "Brauer Table Records", and we start with ordinary
tables.

You may  store arbitrary information on an  ordinary character table, but
these are the only fields used by {\GAP} functions\:

'centralizers':\\  the list of centralizer orders which should be
                   positive integers

'identifier':\\ a string that identifies the table, sometimes also called
          he table name; it is used for fusions (see below), programs for
          generic tables (see chapter "Generic Character Tables") and for
          access to library tables (see "CharTable", "Contents of the
          Table Libraries")

'order':\\ the group order, a positive integer; in most cases, it is
           equal to 'centralizers[1]'

'classes':\\ the lengths of conjugacy classes, a list of positive
             integers

'orders':\\ the list of representative orders

'powermap':\\ a list where at position <p>, if bound, the <p>-th powermap
              is stored; the <p>-th powermap is a -possibly parametrized-
              map (see "More about Maps and Parametrized Maps")

'fusions':\\ a list of records which describe the fusions into other
             character tables, that is subgroup fusions and factor
             fusions; any record has fields 'name' (the 'identifier'
             component of the destination table) and 'map' (a list of
             images for the classes, it may be parametrized (see "More
             about Maps and Parametrized Maps"));
             if there are different fusions with same destination table,
             the field 'specification' is used to distinguish them;
             optional fields are 'type' (a string that is '\"normal\"'
             for normal subgroup fusions and '\"factor\"' for factor
             fusions) and 'text' (a string with information about the
             fusion)

'fusionsource':\\ a list of table names of those tables which contain a
                  fusion into the actual table

'irreducibles':\\ a list of irreducible characters (see below)

'irredinfo':\\ a list of records with information about 'irreducibles',
               usual entries are 'indicator', 'pblock' and 'charparam'
               (see "Indicator", "PrimeBlocks", "Generic Character
               Tables"); if the field 'irreducibles' is sorted using
               "SortCharactersCharTable", the 'irredinfo' field is
               sorted, too.  So any information about 'irreducibles'
               should be stored here.

'projectives':\\ (only for \ATLAS\ tables, see "ATLAS Tables") a list of
                 records, each with fields 'name' (of the table of a
                 covering group) and 'chars' (a list of --in general not
                 all-- faithful irreducibles of the covering group)

'permutation':\\ the actual permutation of the classes
                 (see "Conventions for Character Tables",
                 "SortClassesCharTable")

'classparam':\\ a list of parameter values specifying the classes of
                tables constructed via specialisation of a generic
                character table (see chapter "Generic Character Tables")

'classtext':\\ a list of additional information about the conjugacy
               classes (e.g. representatives of the class for matrix
               groups or permutation groups)

'text':\\ a string containing information about the table; these are
          e.g.\ its source (see Chapter "Character Table Libraries"),
          the tests it has passed ('1.o.r.'\ for the test of
          orthogonality, 'pow[<p>]' for the construction of the <p>-th
          powermap, 'DEC' for the decomposition of ordinary characters in
          Brauer characters),
          and choices made without loss of generality where possible

'automorphisms':\\ the permutation group of column permutations
                   preserving the set 'irreducibles'
                   (see "MatAutomorphisms", "TableAutomorphisms")

'classnames':\\ a list of names for the classes, a string each
                (see "ClassNamesCharTable")

<classnames>:\\ for each entry <clname> in 'classnames', a field
                <tbl>.<clname> that has the position of <clname> in
                'classnames' as value (see "ClassNamesCharTable")

'operations':\\ a record with fields 'Print' (see "DisplayCharTable") and
                'ScalarProduct' (see "ScalarProduct"); the default value
                of the 'operations' field is 'CharTableOps'
                (see "Operations Records for Character Tables")

'CAS':\\ a list of records, each with fields 'permchars', 'permclasses'
         (both permutations), 'name' and eventually 'text' and
         'classtext'; application of the two permutations to
         'irreducibles' and classes yields the original {\CAS} library
         table with name 'name' and text 'text' (see "CAS Tables")

'libinfo':\\ a record with components 'othernames' and perhaps 'CASnames'
             which are all admissible names of the table (see
             "CharTable");
             using these records, the list 'LIBLIST.ORDINARY' can be
             constructed from the library using 'MakeLIBLIST'
             (see "Organization of the Table Libraries")

'group':\\ the group the table belongs to; if the table was computed
           using 'CharTable' (see "CharTable") then this component holds
           the group, with conjugacy classes sorted compatible with the
           columns of the table

*Note* that tables in library files may have different format
(see chapter "Character Table Libraries").

This is a typical example of a character table, first the ``naked\'\'\
record, then the displayed version\:

|    gap> t:= CharTable( "2.A5" );; PrintCharTable( t );
    rec( text := "origin: ATLAS of finite groups, tests: 1.o.r., pow[2,3,5\
    ]", centralizers := [ 120, 120, 4, 6, 6, 10, 10, 10, 10
     ], powermap := [ , [ 1, 1, 2, 4, 4, 8, 8, 6, 6 ],
      [ 1, 2, 3, 1, 2, 8, 9, 6, 7 ],, [ 1, 2, 3, 4, 5, 1, 2, 1, 2 ]
     ], fusions := [ rec(
          name := "A5",
          map := [ 1, 1, 2, 3, 3, 4, 4, 5, 5 ] ), rec(
          name := "2.A5.2",
          map := [ 1, 2, 3, 4, 5, 6, 7, 6, 7 ] ), rec(
          name := "2.J2",
          map := [ 1, 2, 5, 8, 9, 16, 17, 18, 19 ],
          text := [ 'f', 'u', 's', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
              'm', 'a', 'x', 'i', 'm', 'a', 'l', ' ', '2', '.', 'A', '5',
              ' ', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'e', 'd', ' ',
              'b', 'y', ' ', 't', 'h', 'e', ' ', '3', 'B', ' ', 'e', 'l',
              'e', 'm', 'e', 'n', 't', 's' ] ) ], irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 3, 3, -1, 0, 0, -E(5)-E(5)^4, -E(5)-E(5)^4, -E(5)^2-E(5)^3,
          -E(5)^2-E(5)^3 ],
      [ 3, 3, -1, 0, 0, -E(5)^2-E(5)^3, -E(5)^2-E(5)^3, -E(5)-E(5)^4,
          -E(5)-E(5)^4 ], [ 4, 4, 0, 1, 1, -1, -1, -1, -1 ],
      [ 5, 5, 1, -1, -1, 0, 0, 0, 0 ],
      [ 2, -2, 0, -1, 1, E(5)+E(5)^4, -E(5)-E(5)^4, E(5)^2+E(5)^3,
          -E(5)^2-E(5)^3 ],
      [ 2, -2, 0, -1, 1, E(5)^2+E(5)^3, -E(5)^2-E(5)^3, E(5)+E(5)^4,
          -E(5)-E(5)^4 ], [ 4, -4, 0, 1, -1, -1, 1, -1, 1 ],
      [ 6, -6, 0, 0, 0, 1, -1, 1, -1 ] ], automorphisms := Group( (6,8)
    (7,9) ), construction := function ( tbl )
        ConstructProj( tbl );
    end, irredinfo := [ rec(
          pblock := [ , 1, 1,, 1 ] ), rec(
          pblock := [ , 1, 2,, 1 ] ), rec(
          pblock := [ , 1, 3,, 1 ] ), rec(
          pblock := [ , 2, 1,, 1 ] ), rec(
          pblock := [ , 1, 1,, 2 ] ), rec(
          pblock := [ , 1, 4,, 3 ] ), rec(
          pblock := [ , 1, 4,, 3 ] ), rec(
          pblock := [ , 2, 4,, 3 ] ), rec(
          pblock := [ , 1, 5,, 3 ] )
     ], identifier := "2.A5", operations := CharTableOps, fusionsource :=
    [ "P2/G1/L1/V1/ext2", "P2/G1/L1/V1/ext3", "P2/G2/L1/V1/ext2",
      "P2/G2/L1/V1/ext3", "P2/G2/L1/V2/ext2" ], name := "2.A5", size :=
    120, order := 120, classes := [ 1, 1, 30, 20, 20, 12, 12, 12, 12
     ], orders := [ 1, 2, 4, 3, 6, 5, 10, 5, 10 ] )|

\bigskip

|    gap> DisplayCharTable( t );
    2.A5

         2  3  3  2  1  1   1   1   1   1
         3  1  1  .  1  1   .   .   .   .
         5  1  1  .  .  .   1   1   1   1

           1a 2a 4a 3a 6a  5a 10a  5b 10b
        2P 1a 1a 2a 3a 3a  5b  5b  5a  5a
        3P 1a 2a 4a 1a 2a  5b 10b  5a 10a
        5P 1a 2a 4a 3a 6a  1a  2a  1a  2a

    X.1     1  1  1  1  1   1   1   1   1
    X.2     3  3 -1  .  .   A   A  *A  *A
    X.3     3  3 -1  .  .  *A  *A   A   A
    X.4     4  4  .  1  1  -1  -1  -1  -1
    X.5     5  5  1 -1 -1   .   .   .   .
    X.6     2 -2  . -1  1  -A   A -*A  *A
    X.7     2 -2  . -1  1 -*A  *A  -A   A
    X.8     4 -4  .  1 -1  -1   1  -1   1
    X.9     6 -6  .  .  .   1  -1   1  -1

    A = -E(5)-E(5)^4
      = (1-ER(5))/2 = -b5 |

\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Brauer Table Records}%
\index{Brauer tables!format}%
\index{tables!format}

Brauer table records are similar to the records which represent  ordinary
character  tables.   They   contain   many  of   the  well--known  record
components, like 'identifier', 'centralizers', 'irreducibles'  etc.;  but
there are two kinds of differences\:

First,   the   operations   record   is   'BrauerTableOps'   instead   of
'CharTableOps' (see "Operations Records for  Character Tables").  Second,
there are two extra components, namely

'ordinary',  which contains the ordinary character table corresponding to
the Brauer table, and

'blocks', which reflects the *block* information; it is a list of records
with components

'defect': \\
     the defect of the block,

'ordchars': \\
     a list of integers indexing the ordinary irreducibles in the block,

'modchars': \\
     a list of integers indexing the Brauer characters in the block,

'basicset': \\
     a list of integers indexing the ordinary irreducibles of a basic
     set; *note* that the indices refer to the positions in the whole
     'irreducibles' list of the ordinary table, not to the positions in
     the block,

'decinv': \\
     the inverse of the restriction of the decomposition matrix of the
     block to the basic set given by the 'basicset' component,
     and possibly

'brauertree': \\
     if exists, a list that represents the decomposition matrix which in
     this case is viewed as incidence matrix of a tree (the so--called
     Brauer tree); the entries of the list correspond to the edges of the
     tree, they refer to positions in the block, not in the whole
     'irreducibles' list of the tables.  Brauer trees are mainly used to
     store the information in a more compact way than by decomposition
     matrices, planar embeddings etc.\ are not (or not yet) included.

*Note* that Brauer tables in the library have different format
(see "Organization of the Table Libraries").

We give an example\:

|    gap> PrintCharTable( CharTable( "M11" ) mod 11 );
    rec( identifier := "M11mod11", text := "origin: modular ATLAS of finit\
    e groups, tests: DEC, TENS", prime := 11, size :=
    7920, centralizers := [ 7920, 48, 18, 8, 5, 6, 8, 8 ], orders :=
    [ 1, 2, 3, 4, 5, 6, 8, 8 ], classes :=
    [ 1, 165, 440, 990, 1584, 1320, 990, 990 ], powermap :=
    [ , [ 1, 1, 3, 2, 5, 3, 4, 4 ], [ 1, 2, 1, 4, 5, 2, 7, 8 ],,
      [ 1, 2, 3, 4, 1, 6, 8, 7 ],,,,,, [ 1, 2, 3, 4, 5, 6, 7, 8 ]
     ], fusions := [ rec(
          name := "M11",
          map := [ 1, 2, 3, 4, 5, 6, 7, 8 ],
          type := "choice" ) ], irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, 1, 1 ], [ 9, 1, 0, 1, -1, -2, -1, -1 ],
      [ 10, -2, 1, 0, 0, 1, E(8)+E(8)^3, -E(8)-E(8)^3 ],
      [ 10, -2, 1, 0, 0, 1, -E(8)-E(8)^3, E(8)+E(8)^3 ],
      [ 11, 3, 2, -1, 1, 0, -1, -1 ], [ 16, 0, -2, 0, 1, 0, 0, 0 ],
      [ 44, 4, -1, 0, -1, 1, 0, 0 ], [ 55, -1, 1, -1, 0, -1, 1, 1 ]
     ], irredinfo := [ rec(
           ), rec(
           ), rec(
           ), rec(
           ), rec(
           ), rec(
           ), rec(
           ), rec(
           ) ], blocks := [ rec(
          defect := 1,
          ordchars := [ 1, 2, 3, 4, 6, 7, 9 ],
          modchars := [ 1, 2, 3, 4, 6 ],
          decinv :=
           [ [ 1, 0, 0, 0, 0 ], [ -1, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ],
              [ 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ] ],
          basicset := [ 1, 2, 3, 4, 6 ],
          brauertree :=
           [ [ 1, 2 ], [ 2, 7 ], [ 3, 7 ], [ 4, 7 ], [ 5 .. 7 ] ] ), rec(
          defect := 0,
          ordchars := [ 5 ],
          modchars := [ 5 ],
          decinv := [ [ 1 ] ],
          basicset := [ 5 ] ), rec(
          defect := 0,
          ordchars := [ 8 ],
          modchars := [ 7 ],
          decinv := [ [ 1 ] ],
          basicset := [ 8 ] ), rec(
          defect := 0,
          ordchars := [ 10 ],
          modchars := [ 8 ],
          decinv := [ [ 1 ] ],
          basicset := [ 10 ] )
     ], ordinary := CharTable( "M11" ), operations := BrauerTableOps, orde\
    r := 7920, name := "M11mod11", automorphisms := Group( (7,8) ) ) |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{IsCharTable}

'IsCharTable( <obj> )'

returns 'true' if <obj> is a record with fields 'centralizers' (a list)
and 'identifier' (a string), otherwise it returns 'false'.

|    gap> IsCharTable( rec( centralizers:= [ 2,2 ], identifier:= "C2" ) );
    true |

There is one exception\:\ If the record does not contain an 'identifier'
component, but a 'name' component instead, then the function returns
'true'. Note, however, that this exception will disappear in forthcoming
{\GAP} versions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{PrintCharTable}

'PrintCharTable( <tbl> )'

prints the information stored in the character table <tbl> in a format
that is {\GAP} readable.  The call can be used as argument of 'PrintTo'
in order to save the table to a file.

|    gap> t:= CharTable( "Cyclic", 3 );
    CharTable( "C3" )
    gap> PrintCharTable( t );
    rec( identifier := "C3", name := "C3", size := 3, order :=
    3, centralizers := [ 3, 3, 3 ], orders := [ 1, 3, 3 ], powermap :=
    [ ,, [ 1, 1, 1 ] ], irreducibles :=
    [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ], [ 1, E(3)^2, E(3) ]
     ], classparam := [ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ] ], irredinfo :=
    [ rec(
          charparam := [ 1, 0 ] ), rec(
          charparam := [ 1, 1 ] ), rec(
          charparam := [ 1, 2 ] )
     ], text := "computed using generic character table for cyclic groups"\
    , classes := [ 1, 1, 1 ], operations := CharTableOps, fusions :=
    [  ], fusionsource := [  ], projections := [  ], projectionsource :=
    [  ] ) |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{TestCharTable}

'TestCharTable( <tbl> )'

checks the character table <tbl>:\\
 if '<tbl>.centralizers', '<tbl>.classes', '<tbl>.orders' and the entries
 of '<tbl>.powermap' have same length,\\
 if the product of '<tbl>.centralizers[<i>]' with '<tbl>.classes[<i>]' is
 equal to '<tbl>.order',\\
 if '<tbl>.orders[<i>]' divides '<tbl>.centralizers[<i>]',\\
 if the entries of '<tbl>.classnames' and the corresponding record fields
 are consistent,\\
 if the first orthogonality relation for '<tbl>.irreducibles' is
 satisfied,\\
 if the centralizers agree with the sums of squared
 absolute values of '<tbl>.irreducibles' and\\
 if powermaps and representative orders are consistent.

If no inconsistency occurs, 'true' is returned, otherwise each error is
signalled, and 'false' is returned at the end.

|    gap> t:= CharTable("A5");; TestCharTable(t);
    true
    gap> t.irreducibles[2]:= t.irreducibles[3] - t.irreducibles[1];;
    gap> TestCharTable(t);
    &E TestCharTable(A5): Scpr( ., X[2], X[1] ) = -1
    &E TestCharTable(A5): Scpr( ., X[2], X[2] ) = 2
    &E TestCharTable(A5): Scpr( ., X[3], X[2] ) = 1
    &E TestCharTable(A5): centralizer orders inconsistent with irreducibles
    false|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations Records for Character Tables}%
\index{CharTableOps}%
\index{BrauerTableOps}

Although a character table is not a domain (see "Some Notes on Character
Theory in GAP"), it needs an operations record.
That for *ordinary character tables* is 'CharTableOps', that for
*Brauer tables* is 'BrauerTableOps'.  The functions in these records
are listed in section "Functions for Character Tables".

In the following two cases it may be useful to overlay these functions.

Character tables are printed using the 'Print' component, one can for
example replace the default 'Print' by "DisplayCharTable"
'DisplayCharTable'.

Whenever a library function calls the scalar product this is the
'ScalarProduct' field of the operations record, so one can replace the
default function (see "ScalarProduct") by a more efficient one for special
cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Character Tables}

The following polymorphic functions are overlaid in the 'operations'
record of character tables.
They are listed in alphabetical order.

'AbelianInvariants( <tbl> )'%
\index{AbelianInvariants!for character tables}

'Agemo( <tbl>, <p> )'%
\index{Agemo!for character tables}

'Automorphisms( <tbl> )'%
\index{Automorphisms!for character tables}

'Centre( <tbl> )'%
\index{Centre!for character tables}

'CharacterDegrees( <tbl> )'%
\index{CharacterDegrees!for character tables}

'DerivedSubgroup( <tbl> )'%
\index{DerivedSubgroup!for character tables}

'Display( <tbl> )'%
\index{Display!for character tables}

'ElementaryAbelianSeries( <tbl> )'%
\index{ElementaryAbelianSeries!for character tables}

'Exponent( <tbl> )'%
\index{Exponent!for character tables}

'FittingSubgroup( <tbl> )'%
\index{FittingSubgroup!for character tables}

'FrattiniSubgroup( <tbl> )'%
\index{FrattiniSubgroup!for character tables}

'FusionConjugacyClasses( <tbl1>, <tbl2> )'%
\index{FusionConjugacyClasses!for character tables}

'Induced'%
\index{Induced!for character tables}

'IsAbelian( <tbl> )'%
\index{IsAbelian!for character tables}

'IsCyclic( <tbl> )'%
\index{IsCyclic!for character tables}

'IsNilpotent( <tbl> )'%
\index{IsNilpotent!for character tables}

'IsSimple( <tbl> )'%
\index{IsSimple!for character tables}

'IsSolvable( <tbl> )'%
\index{IsSolvable!for character tables}

'IsSupersolvable( <tbl> )'%
\index{IsSupersolvable!for character tables}

'LowerCentralSeries( <tbl> )'%
\index{LowerCentralSeries!for character tables}

'MaximalNormalSubgroups( <tbl> )'%
\index{MaximalNormalSubgroups!for character tables}

'NoMessageScalarProduct( <tbl>, <chi1>, <chi2> )'%
\index{NoMessageScalarProduct!for character tables}

'NormalClosure( <tbl>, <classes> )'%
\index{NormalClosure!for character tables}

'NormalSubgroups( <tbl> )'%
\index{NormalSubgroups!for character tables}

'Print( <tbl> )'%
\index{Print!for character tables}

'Restricted'%
\index{Restricted!for character tables}

'ScalarProduct( <tbl>, <chi1>, <chi2> )'%
\index{ScalarProduct!for character tables}

'Size( <tbl> )'%
\index{Size!for character tables}

'SizesConjugacyClasses( <tbl> )'%
\index{SizesConjugacyClasses!for character tables}

'SupersolvableResiduum( <tbl> )'%
\index{SupersolvableResiduum!for character tables}

'UpperCentralSeries( <tbl> )'%
\index{UpperCentralSeries!for character tables}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operators for Character Tables}%
\index{mod for character tables}%
\index{'/' for character tables}%
% \index{'\*' for character tables}

The following operators are defined for character tables.

'<tbl1> \* \ <tbl2>': \\ direct product of two character tables
                       (see "CharTableDirectProduct"),

'<tbl> / <list>':   \\ table of the factor group modulo the classes in
                       the list <list> (see "CharTableFactorGroup"),

'<tbl> mod <p>':    \\ <p>--modular table corresponding to <tbl>
                       (see "CharTable").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conventions for Character Tables}%
\index{character tables!conventions}

The following few conventions should be noted\:
\begin{description}
\item[The identity element] is expected to be in the first class.
\item[Characters] are lists of cyclotomics (see Chapter "Cyclotomics")
      or unknowns (see chapter "Unknowns");
      they do not physically ``belong\'\'\ to a
      table, so when necessary, functions ``regard\'\'\ them as
      characters of a table which is given as another parameter.
\item[Conversely], most functions that take a character table as a
      parameter and work with characters expect these characters as a
      parameter, too.

      Some functions, however, expect the characters to be stored in the
      'irreducibles' field of the table (e.g.\ "TestCharTable"
      'TestCharTable')
      or allow application either to a list of characters given by a
      parameter or to the 'irreducibles' field (e.g. "Indicator"
      'Indicator') if this parameter is missing.
\item[The trivial character] need not be the first one in a list of
      characters.
\item[Sort convention\:]
      Whenever "SortClassesCharTable" 'SortClassesCharTable' or
      "SortCharTable" 'SortCharTable' is used to sort the classes of a
      character table, the fusions into that table are *not* adjusted;
      only the 'permutation' field of the sorted table will be
      actualized.

      If one handles fusions only using "GetFusionMap" 'GetFusionMap' and
      "StoreFusion" 'StoreFusion', the maps are adjusted automatically
      with respect to the value of the field 'permutation' of the
      destination table.  So one should not change this field by hand.
      Fusion maps that are entered explicitly (e.g. because they are not
      stored on a table) are expected to be sorted, they will not be
      adjusted.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Getting Character Tables}%
\index{tables}%
\index{character tables}%
\index{library tables}%
\index{generic character tables}

There are in general four different ways to get a character table which
{\GAP} already ``knows\'\'\:\ You can either

read a file that contains the table record,\\
construct the table using generic formulae,\\
derive it from known tables or\\
use a presentation or representation of the group.

The first two methods are used by "CharTable" 'CharTable'.
For the conception of generic character tables,
see chapter "Generic Character Tables".
*Note* that library files often contain something that is much different
from the tables returned by 'CharTable', see chapter "Character Table
Libraries".  Especially see "Selecting Library Tables".

As for the third method, some generic ways to derive a character table
are implemented\::\\
One can obtain it as table of a factor group where the table
      of the group is given (see "CharTableFactorGroup"),\\
for given tables the table of the direct product can be constructed
      (see "CharTableDirectProduct"),\\
the restriction of a table to the $p$-regular classes can be formed
      (see "CharTableRegular"),\\
for special cases, an isoclinic table of a given table can be
      constructed (see "CharTableIsoclinic"),\\
the splitting and fusion of classes may be viewed as a generic process
      (see "CharTableSplitClasses", "CharTableCollapsedClasses").

At the moment, for the last method there are algorithms dealing with
arbitrary groups (see "CharTable"), and with finite polycyclic groups
with special properties (see "CharTablePGroup").

*Note* that whenever fusions between tables occur in these functions,
they are stored on the concerned tables, and the 'fusionsource' fields
are updated (see "Character Table Records").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTable}%
\index{character tables!access to}%
\index{character tables!calculate}%
\index{Dixon Schneider}%
\index{character tables!of groups}

'CharTable( <G> )'\\
'CharTable( <tblname> )'\\
'CharTable( <series>, <parameter1>, <parameter2> ... )'

'CharTable( <G> )'

returns the  character table  of the group <G>.  If  '<G>.name' is bound,
the table is  baptized  the  same.  Otherwise  it is given the identifier
component '\"\"'
(empty string).  This  is necessary since every  character table needs an
identifier in {\GAP} (see "IsCharTable").

'CharTable'  first  computes  the linear characters, using the commutator
factor group. If irreducible characters  are missing afterwards, they are
computed using the algorithm of Dixon and Schneider (see~\cite{Dix67} and
\cite{Sch90}).

|    gap> M11 := Group((1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6));;
    gap> M11.name := "M11";;
    gap> PrintCharTable( CharTable( M11 ) );
    rec( size := 7920, centralizers := [ 7920, 11, 11, 8, 48, 8, 8, 18,
      5, 6 ], orders := [ 1, 11, 11, 4, 2, 8, 8, 3, 5, 6 ], classes :=
    [ 1, 720, 720, 990, 165, 990, 990, 440, 1584, 1320 ], irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 10, -1, -1, 2, 2, 0, 0, 1, 0, -1 ],
      [ 10, -1, -1, 0, -2, E(8)+E(8)^3, -E(8)-E(8)^3, 1, 0, 1 ],
      [ 10, -1, -1, 0, -2, -E(8)-E(8)^3, E(8)+E(8)^3, 1, 0, 1 ],
      [ 11, 0, 0, -1, 3, -1, -1, 2, 1, 0 ],
      [ 16, E(11)^2+E(11)^6+E(11)^7+E(11)^8+E(11)^10,
          E(11)+E(11)^3+E(11)^4+E(11)^5+E(11)^9, 0, 0, 0, 0, -2, 1, 0 ],
      [ 16, E(11)+E(11)^3+E(11)^4+E(11)^5+E(11)^9,
          E(11)^2+E(11)^6+E(11)^7+E(11)^8+E(11)^10, 0, 0, 0, 0, -2, 1, 0 ]
        , [ 44, 0, 0, 0, 4, 0, 0, -1, -1, 1 ],
      [ 45, 1, 1, 1, -3, -1, -1, 0, 0, 0 ],
      [ 55, 0, 0, -1, -1, 1, 1, 1, 0, -1 ]
     ], operations := CharTableOps, identifier := "M11", order :=
    7920, name := "M11", powermap :=
    [ , [ 1, 3, 2, 5, 1, 4, 4, 8, 9, 8 ], [ 1, 2, 3, 4, 5, 6, 7, 1, 9, 5 ]
       ,, [ 1, 2, 3, 4, 5, 7, 6, 8, 1, 10 ],,
      [ 1, 3, 2, 4, 5, 7, 6, 8, 9, 10 ],,,,
      [ 1, 1, 1, 4, 5, 6, 7, 8, 9, 10 ] ], galomorphisms := Group(
    ( 6, 7),
    ( 2, 3) ), text := "origin: Dixon's Algorithm", group := M11 )|

The columns of the table will be sorted in the same order, as the classes
of the group, thus allowing a bijection  between group and table.  If the
conjugacy classes are bound in  '<G>.conjugacyClasses'  the order  is not
changed.  Otherwise  the routine  itself  computes the  classes.  One can
sort  them  in  the  canonical  way,  using  'SortClassesCharTable'  (see
"SortClassesCharTable").  If an entry  '<G>.charTable' exists the routine
uses information contained in this table.  This also  provides a facility
for entering known characters,  but then the user  assumes responsibility
for the correctness  of the characters (There is little use  in providing
the trivial character to the routine).

*Note*{\:} The algorithm binds the record component 'galomorphisms' of the
character   table.   This  is  a  permutation  group   generated  by  the
*Galois*-morphisms only.  If there is no 'automorphisms' component in the
table then this group is used by routines like 'SubgroupFusion'.

The  computation of  character tables  needs  to  identify the classes of
group elements very  often, so it can be helpful to store a class list of
all group elements. Since this is obviously limited by the group size, it
is controlled by the global variable 'LARGEGROUPORDER', which  is set  by
standard to 10000. If the group is smaller,  the  class  map  is  stored.
Otherwise each occuring element is identified individually.

*Limitations{\:}* At the moment  there  is a limitation to the group size
given by the  following condition{\:}  the routine  computes  in  a prime
field of size $p$.  $p$ is a prime number, such that the exponent  of the
group divides  $(p-1)$  and  such  that $2  \sqrt{\|G\|}  \< p$.   At the
moment, {\GAP} provides only prime fields up to size 65535.

The routine also sets up a component  '<G>.dixon'. Using this  component,
routines  that  identify  classes, for  example 'FusionConjugacyClasses',
will  work  much  faster.  When  interrupting  the algorithm, however,  a
neccessary cleanup has  not  taken place.  Thus you should  call 'Unbind(
<G>.dixon  )' to  avoid possible further confusion.  This is also  a good
idea  because '<G>.dixon' may become very large. When the  computation by
'CharTable'  is  complete, this record is  shrunk  to an acceptable size,
something that could not be done when interrupting.

\vspace{5mm}

'CharTable( <tblname> )'

If the only parameter is a string <tblname>  and  this is  an  admissible
name  of  a  library  table,  'CharTable'  returns  this  library  table,
otherwise 'false'.   A call of 'CharTable' may cause to read some library
files and  to construct the table from the data in the files, see chapter
"Character Table Libraries" for the details.

Admissible names  for  the *ordinary character table* <tbl> of the  group
<grp> are

\begin{itemize}
\item the {\ATLAS} name if <tbl> is an {\ATLAS} table (see "ATLAS Tables"),
      e.g., 'M22' for the table of the Mathieu group $M_{22}$, 'L2(13)'
      for $L_2(13)$ and '12\_1.U4(3).2\_1' for $12_1.U_4(3).2_1$,
\item the names that were admissible for tables of <grp> in {\CAS} if the
      {\CAS} table library contained a table of <grp>, e.g., 'sl42' for
      the table of the alternating group $A_8$ (but note that the table
      may be different from that in {\CAS}, see "CAS Tables") and
\item some ``relative\'\'\ names\:

      For <grp> the <n>--th maximal subgroup (in decreasing group order)
      of a sporadic simple group with admissible name <name>, <name>M<n>
      is admissible for <tbl>, e.g., 'J3M2' for the second maximal
      subgroup of the Janko group $J_3$ which has the name 'J3'.

      For <grp> a nontrivial Sylow normalizer of a sporadic simple group
      with admissible name <name>, where nontrivial means that the group
      is not contained in $p$\:$(p-1)$, <name>N<p> is an admissible name
      of <tbl>, e.g., $J4N11$ for the Sylow 11 normalizer of the Janko
      group $J_4$.

      In a few cases, the table of the Sylow $p$ subgroup of <grp> is
      accessible by <name>Syl<p> where <name> is an admissible name of
      the table of <grp>, e.g., 'A11Syl2' for the Sylow 2 subgroup of the
      alternating group $A_{11}$.

      In a few cases, the table of an element centralizer of <grp> is
      accessible by <name>C<cl> where <name> is an admissible name of the
      table of <grp>, e.g., 'M11C2' for an involution centralizer in the
      Mathieu group $M_{11}$.
\end{itemize}

Admissible  names for a  *Brauer table* <tbl> (modulo the  prime $p$) are
all names '<name>mod<p>' where <name> is admissible for the corresponding
ordinary  table, e.g., 'M12mod11'  for the 11 modular table  of $M_{12}$,
and 'L2(25).2\_1mod3' for the 3 modular table of $L_2(25).2_1$.
Brauer tables in the library can be got also from the underlying ordinary
table using the 'mod' operator, as in the following example.

|    gap> CharTable( "A5" ) mod 2;
    CharTable( "A5mod2" ) |

*Generic tables* are accessible  only  by the name  given by their
'identifier' component (see below).

Case  is not significant for table names,  e.g., 'suzm3' and  'SuzM3' are
both  admissible  names  for  the third maximal subgroup of the  sporadic
Suzuki group.

The  admissible  names  reflect  the  structure  of  the  libraries,  see
"Contents  of  the  Table  Libraries"  and  "Organization  of  the  Table
Libraries".

|    gap> CharTable( "A5.2" );;  # returns the character table of the
                                # symmetric group on five letters
                                # (in \ATLAS\ format)
    gap> CharTable( "Symmetric" );;  # returns the generic table of the
                                     # symmetric group
    gap> CharTable( "J5" );
    &E CharTableLibrary: no library table with name 'J5'
    false|

If 'CharTable' is called with more than one  parameter, the first must be
a string specifying a series of groups which is implemented via a generic
character  table   (see  chapter   "Generic  Character   Tables"),   e.g.
'\"Symmetric\"'  for  the  symmetric  groups;  the  following  parameters
specialise the required member of the series\:

|    gap> CharTable( "Symmetric", 5 );; # the table of the symmetric
                                       # group $S_5$ (got by specializing
                                       # the generic table)|

These are the valid calls of 'CharTable' with parameter <series>\:

|    |'CharTable( \"Alternating\", <n> )':\\
    returns the table of the alternating group on <n> letters,

|    |'CharTable( \"Cyclic\", <n> )':\\
    returns the table of the cyclic group of order <n>,

|    |'CharTable( \"Dihedral\", <2n> )':\\
    returns the table of the dihedral group of order <2n>,

|    |'CharTable( \"GL\", 2, <q> )':\\
    returns the table of the general linear group $\mbox{\rm GL}(2,q)$
    for a prime power <q>,

|    |'CharTable( \"GU\", 3, <q> )':\\
    returns the table of the general unitary group $\mbox{\rm GU}(3,q)$
    for a prime power <q>,

|    |'CharTable( \"P\:Q\", [ <p>, <q> ] )':\\
    returns the table of the extension of the cyclic group of prime order
    <p> by a cyclic group of order <q> where <q> divides $p-1$,

|    |'CharTable( \"PSL\", 2, <q> )':\\
    returns the table of the projective special linear group
    $\mbox{\rm PSL}(2,q)$ for a prime power <q>,

|    |'CharTable( \"SL\", 2, <q> )':\\
    returns the table of the special linear group $\mbox{\rm SL}(2,q)$
    for a prime power <q>,

|    |'CharTable( \"SU\", 3, <q> )':\\
    returns the table of the special unitary group $\mbox{\rm SU}(3,q)$
    for a prime power <q>,

|    |'CharTable( \"Quaternionic\", <4n> )':\\
    returns the table of the quaternionic (dicyclic) group of order <4n>,

|    |'CharTable( \"Suzuki\", <q> )':\\
    returns the table of the Suzuki group $Sz(q) = ^2B_2(q)$ for <q> an
    odd power of 2,

|    |'CharTable( \"Symmetric\", <n> )':\\
    returns the table of the symmetric group on <n> letters.

|    |'CharTable( \"WeylB\", <n> )':\\
    returns the table of the Weyl group of type $B_n$.

|    |'CharTable( \"WeylD\", <n> )':\\
    returns the table of the Weyl  group of type $D_n$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Advanced Methods for Dixon Schneider Calculations}%
\index{character tables!computation}

The computation of character tables  of very large  groups may take quite
some time.  On the other hand, for  the  expert  only a  few  irreducible
characters may  be needed, since the other  ones can  be  computed  using
character  theoretic  methods like tensoring, induction, and restriction.
Thus   {\GAP}  provides   also  step-by-step   routines  for   doing  the
calculations, that will allow to compute some characters, and stop before
all  are calculated.  Note  that there is no  \'safety net\',  i.e.,  the
routines, being  somehow internal, do no error  checking,  and assume the
information given are correct.

When the global variable 'InfoCharTable1' if set to 'Print',  information
about  the  progress  of  splitting  is  printed.  The  default  value of
'InfoCharTable1' is 'Ignore'.

'DixonInit( <G> )'%
\index{DixonInit}

does  the  setup  for  the  computation  of  characters{\:}  It  computes
conjugacy classes, power  maps  and  linear characters  (in  the  case of
AgGroups  it also  contains  a  call  of  'CharTablePGroup'). 'DixonInit'
returns a special record <D> (see below), which  stores all  informations
needed for the  further computations. The power maps are computed for all
primes  smaller than  the  exponent of  <G>, thus allowing  to induce the
characters   of   all   cyclic   subgroups   by   'InducedCyclic'    (see
"InducedCyclic").  For internal purposes, the  algorithm uses  a permuted
arrangement of the classes and probably a different ---but  isomorphic---
group.   It  is  possible  to  obtain  different  informations  about the
progress of the  splitting  process as  well  as the  partially  computed
character table from the record <D>.

'DixontinI( <D> )'%
\index{DixontinI}

is the reverse function{\:} It  takes a Dixon  record <D> and returns the
old group  <G>.  It also  does  the cleanup  of <D>.  The  returned group
contains the component 'charTable', containing the character table as far
as known. The  classes are arranged in the  same  way,  as the classes of
<G>.

'DixonSplit( <D> )'%
\index{DixonSplit}

will  do  the  main splitting task{\:} It chooses a  class and splits the
character spaces using  the  corresponding class matrix.   Characters are
computed as far as possible.

'CombinatoricSplit( <D> )'%
\index{CombinatoricSplit}

tries to split two-dimensional character spaces by combinatoric means. It
is called automatically by 'DixonSplit'.  A separate call can be  useful,
when new  characters have  been  found,  that  reduce  the  size  of  the
character spaces.

'IncludeIrreducibles( <D>, <list> )'%
\index{IncludeIrreducibles}

If you have found irreducible characters by other means ---like tensoring
etc.--- you  must not include them in the character  table  yourself, but
let them include, using this routine. Otherwise {\GAP} would lose control
of the  characters  yet known.  The  characters given in  <list> must  be
according to the arrangement of classes in <D>. {\GAP} will automatically
take the closure of <list> under the galoisgroup and tensor products with
one-dimensional characters.

'SplitCharacters( <D>, <list> )'%
\index{SplitCharacters}

This routine decomposes  the characters, given in <list> according to the
character spaces  found up  to this point.  By  applying this routine  to
tensor products etc., it may result in characters with smaller norm, even
irreducible ones. Since the recalculation of characters is only possible,
if the degree is small  enough, the splitting process is applied  only to
characters of sufficiently small degree.

Some notes on the record <D> returned by 'DixonInit'{\:}

This record stores several items of mainly  internal interest.  There are
some entries, however, that may be  useful  to  know about when using the
advanced  methods described above. The computation need not to take place
in the original group,  but in an isomorphic image  <W>.  This may be the
same group as the group  given, but --- depending on the group --- also a
new  one.  Additionally the initialisation process will create a new list
of the conjugacy classes with possibly different arrangement.  For access
to  these informations, the following record components  of  the  ``Dixon
Record\'\' <D> might be of interest\:

'group':\\
    the group <W>,

'oldG':\\
    the group <G>, of which the character table is to be computed,

'conjugacyClasses':\\
    classes   of  <W>;  this  list  contains   the  *same*   classes   as
    '<W>.conjugacyClasses', only the arrangement is different,

'charTable':\\
    contains  the partially computed character table.   The  classes  are
    arranged according to '<D>.conjugacyClasses',

'classPermutation':\\
    permutation to apply to the classes to obtain the old arrangement.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{An Example of Advanced Dixon Schneider Calculations}

First, we set

|    gap> InfoCharTable1 := Print;;|

for  printout of some internal results. We now define our group, which is
isomorphic  to ${\rm PSL}_4(3)$  (we use  a permutation representation of
${\rm  PSL}_4(3)$  instead  of matrices  since  this will  speed  up  the
computations).

|    gap> g := PrimitiveGroup(40,5);
    PSL(4,3)
    gap> Size(g);
    6065280
    gap> d := DixonInit(g);;
    &I  29 classes
    gap> c := d.charTable;;|

After the initialisation, one  structure  matrix  is evaluated,  yielding
smaller spaces and several irreducible characters.

|    gap> DixonSplit(d);
    &I  Matrix 2, Representative of Order 3, Centralizer: 5832
    &I  Dimensions: [ 1, 12, 2, 2, 4, 2, 1, 1, 1, 1, 1 ]
    &I  Two-dim space split
    &I  Two-dim space split
    &I  Two-dim space split|

In this  case  spaces  of the  listed  dimensions  are  a result  of  the
splitting   process.  The   three  two   dimensional   spaces  are  split
successfully by combinatoric means.

We obtain  several characters  by tensor products and notify  them to the
program.   The  tensor products  of the nonlinear characters  are reduced
with  the  irreducible characters.  The result  is split according to the
spaces  found,  which  yields characters  of smaller  norms,  but  no new
irreducibles.

|    gap> asp:= AntiSymmetricParts( c, c.irreducibles, 2 );;
    gap> ro:= ReducedOrdinary( c, c.irreducibles, asp );;
    gap> Length( ro.irreducibles );
    3
    gap> IncludeIrreducibles( d, ro.irreducibles );
    gap> nlc:= Filtered( c.irreducibles, i -> i[1] > 1 );;
    gap> t:= Tensored( nlc, nlc );;
    gap> ro:= ReducedOrdinary( c, c.irreducibles, t );; ro.irreducibles;
    [  ]
    gap> List( ro.remainders, i -> ScalarProduct( c, i, i) );
    [ 2, 2, 4, 4, 4, 4, 13, 13, 18, 18, 19, 21, 21, 36, 36, 29, 34, 34,
      42, 34, 48, 54, 62, 68, 68, 78, 84, 84, 88, 90, 159, 169, 169, 172,
      172, 266, 271, 271, 268, 274, 274, 280, 328, 373, 373, 456, 532,
      576, 679, 683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601,
      1601, 1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744,
      2920, 3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414,
      6080, 6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922,
      14122, 14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950,
      78778 ]
    gap> t := SplitCharacters( d, ro.remainders );;
    gap> List( t, i -> ScalarProduct( c, i, i ) );
    [ 2, 2, 4, 2, 2, 4, 4, 3, 6, 5, 5, 9, 9, 4, 12, 13, 18, 18, 18, 26,
      32, 32, 16, 42, 36, 84, 84, 88, 90, 159, 169, 169, 172, 172, 266,
      271, 271, 268, 274, 274, 280, 328, 373, 373, 456, 532, 576, 679,
      683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601, 1601,
      1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744, 2920,
      3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414, 6080,
      6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922, 14122,
      14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950, 78778 ] |

Finally we calculate the characters induced from all cyclic subgroups and
obtain the missing irreducibles by applying the LLL-algorithm to them.

|    gap> ic:= InducedCyclic( c, "all" );;
    gap> ro:= ReducedOrdinary( c, c.irreducibles, ic );;
    gap> Length( ro.irreducibles );
    0
    gap> l:= LLL( c, ro.remainders );;
    gap> Length( l.irreducibles );
    13
    gap> IncludeIrreducibles( d, l.irreducibles );
    gap> Length( c.irreducibles );
    29
    gap> Length( c.classes );
    29 |

As the last step, we return to our original group.

|    gap> g:= DixontinI( d );
    &I  Total:1 matrices, [ 2 ]
    PSL(4,3)
    gap> c:= g.charTable;;
    gap> List( c.irreducibles, i -> i[1] );
    [ 1, 26, 26, 39, 52, 65, 65, 90, 234, 234, 260, 260, 260, 351, 390,
      416, 416, 416, 416, 468, 585, 585, 640, 640, 640, 640, 729, 780,
      1040 ]
    gap> Sum( last, i -> i^2 );
    6065280 |


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableFactorGroup}%
\index{table of factor group}%
\index{factor group!table of}

'CharTableFactorGroup( <tbl>, <classes\_of\_normal\_subgroup> )'

returns the table of the factor group of <tbl> with respect to a
particular normal subgroup\:\ If the list of irreducibles stored in
'<tbl>.irreducibles' is complete, this normal subgroup is the normal
closure of <classes\_of\_normal\_subgroup>;
otherwise it is the intersection of kernels of those irreducibles stored
on <tbl> which contain <classes\_of\_normal\_subgroups> in their kernel
--that may cause strange results.

|    gap> s4:= CharTable( "Symmetric", 4 );;
    gap> PrintCharTable( CharTableFactorGroup( s4, [ 3 ] ) );
    rec( size := 6, identifier := "S4/[ 3 ]", order :=
    6, name := "S4/[ 3 ]", centralizers := [ 6, 2, 3 ], powermap :=
    [ , [ 1, 1, 3 ], [ 1, 2, 1 ] ], fusions := [  ], fusionsource :=
    [ "S4" ], irreducibles := [ [ 1, -1, 1 ], [ 2, 0, -1 ], [ 1, 1, 1 ]
     ], orders := [ 1, 2, 3 ], classes :=
    [ 1, 3, 2 ], operations := CharTableOps )
    gap> s4.fusions;
    [ rec(
          map := [ 1, 2, 1, 3, 2 ],
          type := "factor",
          name := "S4/[ 3 ]" ) ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableNormalSubgroup}%
\index{table of normal subgroup}%
\index{normal subgroup!table of}

'CharTableNormalSubgroup( <tbl>, <normal\_subgroup> )'

returns the restriction of the character table <tbl> to the classes in
the list <normal\_subgroup>.
This table is an approximation of the character table of this normal
subgroup. It has components 'order', 'identifier', 'centralizers',
'orders', 'classes', 'powermap', 'irreducibles' (contains the set of
those restrictions of irreducibles of <tbl> which are irreducible), and
'fusions' (contains the fusion in <tbl>).

In most cases, some classes of the normal subgroup must be split, see
"CharTableSplitClasses".

|    gap> s5:= CharTable( "A5.2" );;
    gap> s3:= CharTable( "Symmetric", 3 );;
    gap> SortCharactersCharTable( s3 );;
    gap> s5xs3:= CharTableDirectProduct( s5, s3 );;
    gap> nsg:= [ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 20 ];;
    gap> sub:= CharTableNormalSubgroup( s5xs3, nsg );;
    &I CharTableNormalSubgroup: classes in [ 8 ] necessarily split
    gap> PrintCharTable( sub );
    rec( identifier := "Rest(A5.2xS3,[ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 2\
    0 ])", size :=
    360, name := "Rest(A5.2xS3,[ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 20 ])",\
     order := 360, centralizers := [ 360, 180, 24, 12, 18, 9, 15, 15/2,
      12, 4, 6 ], orders := [ 1, 3, 2, 6, 3, 3, 5, 15, 2, 4, 6
     ], powermap := [ , [ 1, 2, 1, 2, 5, 6, 7, 8, 1, 3, 5 ],
      [ 1, 1, 3, 3, 1, 1, 7, 7, 9, 10, 9 ],,
      [ 1, 2, 3, 4, 5, 6, 1, 2, 9, 10, 11 ] ], classes :=
    [ 1, 2, 15, 30, 20, 40, 24, 48, 30, 90, 60
     ], operations := CharTableOps, irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1 ],
      [ 2, -1, 2, -1, 2, -1, 2, -1, 0, 0, 0 ],
      [ 6, 6, -2, -2, 0, 0, 1, 1, 0, 0, 0 ],
      [ 4, 4, 0, 0, 1, 1, -1, -1, 2, 0, -1 ],
      [ 4, 4, 0, 0, 1, 1, -1, -1, -2, 0, 1 ],
      [ 8, -4, 0, 0, 2, -1, -2, 1, 0, 0, 0 ],
      [ 5, 5, 1, 1, -1, -1, 0, 0, 1, -1, 1 ],
      [ 5, 5, 1, 1, -1, -1, 0, 0, -1, 1, -1 ],
      [ 10, -5, 2, -1, -2, 1, 0, 0, 0, 0, 0 ] ], fusions := [ rec(
          name := [ 'A', '5', '.', '2', 'x', 'S', '3' ],
          map := [ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 20 ] ) ] ) |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableDirectProduct}%
\index{Cartesian product}%
\index{direct product}%
\index{Kronecker product}%
\index{tensor product}

'CharTableDirectProduct( <tbl1>, <tbl2> )'

returns the character table of the direct product of the groups given by
the character tables <tbl1> and <tbl2>.

The matrix of irreducibles is the Kronecker product (see
"KroneckerProduct") of '<tbl1>.irreducibles' with '<tbl2>.irreducibles'.

|    gap> c2:= CharTable( "Cyclic", 2 );; s2:= CharTable( "Symmetric", 2 );;
    gap> SortCharactersCharTable( s2 );;
    gap> v4:= CharTableDirectProduct( c2, s2 );;
    gap> PrintCharTable( v4 );
    rec( size := 4, identifier := "C2xS2", centralizers :=
    [ 4, 4, 4, 4 ], order := 4, name := "C2xS2", classparam :=
    [ [ [ 1, 0 ], [ 1, [ 1, 1 ] ] ], [ [ 1, 0 ], [ 1, [ 2 ] ] ],
      [ [ 1, 1 ], [ 1, [ 1, 1 ] ] ], [ [ 1, 1 ], [ 1, [ 2 ] ] ]
     ], orders := [ 1, 2, 2, 2 ], powermap := [ , [ 1, 1, 1, 1 ]
     ], irreducibles := [ [ 1, 1, 1, 1 ], [ 1, -1, 1, -1 ],
      [ 1, 1, -1, -1 ], [ 1, -1, -1, 1 ] ], irredinfo := [ rec(
          charparam := [ [ 1, 0 ], [ 1, [ 2 ] ] ] ), rec(
          charparam := [ [ 1, 0 ], [ 1, [ 1, 1 ] ] ] ), rec(
          charparam := [ [ 1, 1 ], [ 1, [ 2 ] ] ] ), rec(
          charparam := [ [ 1, 1 ], [ 1, [ 1, 1 ] ] ] ) ], charparam :=
    [  ], fusionsource := [ [ 'C', '2' ], "S2" ], fusions := [ rec(
          name := [ 'C', '2' ],
          map := [ 1, 1, 2, 2 ],
          type := "factor" ), rec(
          name := "S2",
          map := [ 1, 2, 1, 2 ],
          type := "factor" ) ], classes :=
    [ 1, 1, 1, 1 ], operations := CharTableOps )
    gap> c2.fusions;
    [ rec(
          map := [ 1, 3 ],
          type := "normal",
          name := "C2xS2" ) ]|

*Note*\:\ The result will contain those $p$-th powermaps for primes $p$
where both <tbl1> and <tbl2> contain the $p$-th powermap.
Additionally, if one of the tables contains it, and $p$ does not divide
the order of the other table, and the $p$-th powermap is uniquely
determined (see "Powermap"), it will be computed; then the table of the
direct product will contain the $p$-th powermap, too.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableWreathSymmetric}%
\index{wreath product!character table}

'CharTableWreathSymmetric( <tbl>, <n> )'

returns  the character table of the  wreath product of an arbitrary group
$G$ with  the  full symmetric group $S_n$, where  <tbl>  is the character
table of $G$.

|    gap> c3:= CharTable("Cyclic", 3);;
    gap> wr:= CharTableWreathSymmetric(c3, 2);;
    gap> PrintCharTable( wr );
    rec( size := 18, identifier := "C3wrS2", centralizers :=
    [ 18, 9, 9, 18, 9, 18, 6, 6, 6 ], classes :=
    [ 1, 2, 2, 1, 2, 1, 3, 3, 3 ], orders := [ 1, 3, 3, 3, 3, 3, 2, 6, 6
     ], irredinfo := [ rec(
          charparam := [ [ 1, 1 ], [  ], [  ] ] ), rec(
          charparam := [ [ 1 ], [ 1 ], [  ] ] ), rec(
          charparam := [ [ 1 ], [  ], [ 1 ] ] ), rec(
          charparam := [ [  ], [ 1, 1 ], [  ] ] ), rec(
          charparam := [ [  ], [ 1 ], [ 1 ] ] ), rec(
          charparam := [ [  ], [  ], [ 1, 1 ] ] ), rec(
          charparam := [ [ 2 ], [  ], [  ] ] ), rec(
          charparam := [ [  ], [ 2 ], [  ] ] ), rec(
          charparam := [ [  ], [  ], [ 2 ] ] )
     ], name := "C3wrS2", order := 18, classparam :=
    [ [ [ 1, 1 ], [  ], [  ] ], [ [ 1 ], [ 1 ], [  ] ],
      [ [ 1 ], [  ], [ 1 ] ], [ [  ], [ 1, 1 ], [  ] ],
      [ [  ], [ 1 ], [ 1 ] ], [ [  ], [  ], [ 1, 1 ] ],
      [ [ 2 ], [  ], [  ] ], [ [  ], [ 2 ], [  ] ], [ [  ], [  ], [ 2 ] ]
     ], powermap := [ , [ 1, 3, 2, 6, 5, 4, 1, 4, 6 ],
      [ 1, 1, 1, 1, 1, 1, 7, 7, 7 ] ], irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, -1, -1, -1 ],
      [ 2, -E(3)^2, -E(3), 2*E(3), -1, 2*E(3)^2, 0, 0, 0 ],
      [ 2, -E(3), -E(3)^2, 2*E(3)^2, -1, 2*E(3), 0, 0, 0 ],
      [ 1, E(3), E(3)^2, E(3)^2, 1, E(3), -1, -E(3), -E(3)^2 ],
      [ 2, -1, -1, 2, -1, 2, 0, 0, 0 ],
      [ 1, E(3)^2, E(3), E(3), 1, E(3)^2, -1, -E(3)^2, -E(3) ],
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 1, E(3), E(3)^2, E(3)^2, 1, E(3), 1, E(3), E(3)^2 ],
      [ 1, E(3)^2, E(3), E(3), 1, E(3)^2, 1, E(3)^2, E(3) ]
     ], operations := CharTableOps )|

\medskip

|    gap> DisplayCharTable( wr );
    C3wrS2

         2  1   .   .   1  .   1  1   1   1
         3  2   2   2   2  2   2  1   1   1

           1a  3a  3b  3c 3d  3e 2a  6a  6b
        2P 1a  3b  3a  3e 3d  3c 1a  3c  3e
        3P 1a  1a  1a  1a 1a  1a 2a  2a  2a

    X.1     1   1   1   1  1   1 -1  -1  -1
    X.2     2   A  /A   B -1  /B  .   .   .
    X.3     2  /A   A  /B -1   B  .   .   .
    X.4     1 -/A  -A  -A  1 -/A -1  /A   A
    X.5     2  -1  -1   2 -1   2  .   .   .
    X.6     1  -A -/A -/A  1  -A -1   A  /A
    X.7     1   1   1   1  1   1  1   1   1
    X.8     1 -/A  -A  -A  1 -/A  1 -/A  -A
    X.9     1  -A -/A -/A  1  -A  1  -A -/A

    A = -E(3)^2
      = (1+ER(-3))/2 = 1+b3
    B = 2*E(3)
      = -1+ER(-3) = 2b3|

\medskip

The record component 'classparam' contains the sequences of partitions
that parametrize the classes as well as the characters of the wreath
product. Note that this parametrization prevents the principal character
from being the first one in the list 'irreducibles'.

\medskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableRegular}%
\index{p-regular table}%
\index{regular classes}

'CharTableRegular( <tbl>, <prime> )'

returns the character table consisting of the <prime>-regular classes of
the character table <tbl>.

|    gap> a5:= CharTable( "Alternating", 5 );;
    gap> PrintCharTable( CharTableRegular( a5, 2 ) );
    rec( identifier := "Regular(A5,2)", prime := 2, size := 60, orders :=
    [ 1, 3, 5, 5 ], centralizers := [ 60, 3, 5, 5 ], powermap :=
    [ , [ 1, 2, 4, 3 ], [ 1, 1, 4, 3 ],, [ 1, 2, 1, 1 ] ], fusions :=
    [ rec(
          map := [ 1, 3, 4, 5 ],
          type := "choice",
          name := "A5" )
     ], ordinary := CharTable( "A5" ), operations := CharTableOps, order :\
    = 60, name := "Regular(A5,2)", classes := [ 1, 20, 12, 12 ] )
    gap> a5.fusionsource;
    [ "Regular(A5,2)" ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableIsoclinic}%
\index{isoclinic table}

'CharTableIsoclinic( <tbl> )'\\
'CharTableIsoclinic( <tbl>, <classes\_of\_normal\_subgroup> )'

If <tbl> is a character table of a group with structure $2.G.2$ with a
unique central subgroup of order 2 and a unique subgroup of index 2,
'CharTableIsoclinic( <tbl> )' returns the table of the isoclinic group
(see~\cite[Chapter 6, Section 7]{CCN85});
if the subgroup of index 2 is not unique, it must be specified by
enumeration of its classes in <classes\_of\_normal\_subgroup>.

|    gap> d8:= CharTable( "Dihedral", 8 );;
    gap> PrintCharTable( CharTableIsoclinic( d8, [ 1, 2, 3 ] ) );
    rec( identifier := "Isoclinic(D8)", size := 8, centralizers :=
    [ 8, 4, 8, 4, 4 ], classes := [ 1, 2, 1, 2, 2 ], orders :=
    [ 1, 4, 2, 4, 4 ], fusions := [  ], fusionsource := [  ], powermap :=
    [ , [ 1, 3, 1, 3, 3 ] ], irreducibles :=
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, -1, -1 ], [ 1, -1, 1, 1, -1 ],
      [ 1, -1, 1, -1, 1 ], [ 2, 0, -2, 0, 0 ]
     ], operations := CharTableOps, order := 8, name := "Isoclinic(D8)" )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableSplitClasses}%
\index{split classes}

'CharTableSplitClasses( <tbl>, <fusionmap> )'\\
'CharTableSplitClasses( <tbl>, <fusionmap>, <exponent> )'

returns a character table where the classes of the character table <tbl>
are split according to the fusion map <fusionmap>.

The two forms correspond to the two different situations to split
classes\:

'CharTableSplitClasses( <tbl>, <fusionmap> )'

If one constructs a normal subgroup (see "CharTableNormalSubgroup"),
the order remains unchanged, powermaps, classlengths and centralizer
orders are changed with respect to the fusion, representative orders and
irreducibles are simply split.
The ``factor fusion\'\'\ <fusionmap> to <tbl> is stored on the result.

|    # see example in "CharTableNormalSubgroup"
    gap> split:= CharTableSplitClasses(sub,[1,2,3,4,5,6,7,8,8,9,10,11]);;
    gap> PrintCharTable( split );
    rec( identifier := "Split(Rest(A5.2xS3,[ 1, 3, 4, 6, 7, 9, 10, 12, 14,\
     17, 20 ]),[ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11 ])", size :=
    360, order :=
    360, name := "Split(Rest(A5.2xS3,[ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 2\
    0 ]),[ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11 ])", centralizers :=
    [ 360, 180, 24, 12, 18, 9, 15, 15, 15, 12, 4, 6 ], classes :=
    [ 1, 2, 15, 30, 20, 40, 24, 24, 24, 30, 90, 60 ], orders :=
    [ 1, 3, 2, 6, 3, 3, 5, 15, 15, 2, 4, 6 ], powermap :=
    [ , [ 1, 2, 1, 2, 5, 6, 7, [ 8, 9 ], [ 8, 9 ], 1, 3, 5 ],
      [ 1, 1, 3, 3, 1, 1, 7, 7, 7, 10, 11, 10 ],,
      [ 1, 2, 3, 4, 5, 6, 1, 2, 2, 10, 11, 12 ] ], irreducibles :=
    [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1 ],
      [ 2, -1, 2, -1, 2, -1, 2, -1, -1, 0, 0, 0 ],
      [ 6, 6, -2, -2, 0, 0, 1, 1, 1, 0, 0, 0 ],
      [ 4, 4, 0, 0, 1, 1, -1, -1, -1, 2, 0, -1 ],
      [ 4, 4, 0, 0, 1, 1, -1, -1, -1, -2, 0, 1 ],
      [ 8, -4, 0, 0, 2, -1, -2, 1, 1, 0, 0, 0 ],
      [ 5, 5, 1, 1, -1, -1, 0, 0, 0, 1, -1, 1 ],
      [ 5, 5, 1, 1, -1, -1, 0, 0, 0, -1, 1, -1 ],
      [ 10, -5, 2, -1, -2, 1, 0, 0, 0, 0, 0, 0 ] ], fusions := [ rec(
          name := "Rest(A5.2xS3,[ 1, 3, 4, 6, 7, 9, 10, 12, 14, 17, 20 ])",
          map := [ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11 ] )
     ], operations := CharTableOps )
    gap> # the table of $(3\times A_5)\!\:\! 2$ (incomplete)|

\vspace{5mm}
'CharTableSplitClasses( <tbl>, <fusionmap>, <exponent> )'

To construct a downward extension is somewhat more complicated, since the
new order, representative orders, centralizer orders and classlengths are
not known at the moment when the classes are split.
So the order remains unchanged, centralizer orders will just be split,
classlengths are divided by the number of image classes, and the
representative orders become parametrized with respect to the exponent
<exponent> of the normal subgroup.
Power maps and irreducibles are computed from <tbl> and <fusionmap>,
and the factor fusion <fusionmap> to <tbl> is stored on the result.

|    gap> a5:= CharTable( "Alternating", 5 );;
    gap> CharTableSplitClasses( a5, [ 1, 1, 2, 3, 3, 4, 4, 5, 5 ], 2 );;
    gap> PrintCharTable( last );
    rec( identifier := "Split(A5,[ 1, 1, 2, 3, 3, 4, 4, 5, 5 ])", size :=
    60, order :=
    60, name := "Split(A5,[ 1, 1, 2, 3, 3, 4, 4, 5, 5 ])", centralizers :=\
     [ 60, 60, 4, 3, 3, 5, 5, 5, 5 ], classes :=
    [ 1/2, 1/2, 15, 10, 10, 6, 6, 6, 6 ], orders :=
    [ 1, 2, [ 2, 4 ], [ 3, 6 ], [ 3, 6 ], [ 5, 10 ], [ 5, 10 ],
      [ 5, 10 ], [ 5, 10 ] ], powermap :=
    [ , [ 1, 1, [ 1, 2 ], [ 4, 5 ], [ 4, 5 ], [ 8, 9 ], [ 8, 9 ],
          [ 6, 7 ], [ 6, 7 ] ],
      [ 1, 2, 3, [ 1, 2 ], [ 1, 2 ], [ 8, 9 ], [ 8, 9 ], [ 6, 7 ],
          [ 6, 7 ] ],,
      [ 1, 2, 3, [ 4, 5 ], [ 4, 5 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ],
          [ 1, 2 ] ] ], irreducibles := [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
      [ 4, 4, 0, 1, 1, -1, -1, -1, -1 ], [ 5, 5, 1, -1, -1, 0, 0, 0, 0 ],
      [ 3, 3, -1, 0, 0, -E(5)-E(5)^4, -E(5)-E(5)^4, -E(5)^2-E(5)^3,
          -E(5)^2-E(5)^3 ],
      [ 3, 3, -1, 0, 0, -E(5)^2-E(5)^3, -E(5)^2-E(5)^3, -E(5)-E(5)^4,
          -E(5)-E(5)^4 ] ], fusions := [ rec(
          name := "A5",
          map := [ 1, 1, 2, 3, 3, 4, 4, 5, 5 ] )
     ], operations := CharTableOps )|

*Note* that powermaps (and in the second case also the representative
orders) may become parametrized maps
(see Chapter "Maps and Parametrized Maps").

The inverse process of splitting is the fusion of classes, see
"CharTableCollapsedClasses".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableCollapsedClasses}%
\index{fusion of classes}

'CharTableCollapsedClasses( <tbl>, <fusionmap> )'

returns a character table where all classes of the character table <tbl>
with equal images under the map <fusionmap> are collapsed;
the fields 'orders', 'classes', and the characters in 'irreducibles' are
the images under <fusionmap>, the powermaps are obtained on conjugation
(see "TransferDiagram") with <fusionmap>, 'order' remains unchanged,
and 'centralizers' arise from 'classes' and 'order'.

The fusion to the returned table is stored on <tbl>.

|    gap> c3:= CharTable( "Cyclic", 3 );;
    gap> t:= CharTableSplitClasses( c3, [ 1, 2, 2, 3, 3 ] );;
    gap> PrintCharTable( t );
    rec( identifier := "Split(C3,[ 1, 2, 2, 3, 3 ])", size := 3, order :=
    3, name := "Split(C3,[ 1, 2, 2, 3, 3 ])", centralizers :=
    [ 3, 6, 6, 6, 6 ], classes := [ 1, 1/2, 1/2, 1/2, 1/2 ], orders :=
    [ 1, 3, 3, 3, 3 ], powermap := [ ,, [ 1, 1, 1, 1, 1 ]
     ], irreducibles :=
    [ [ 1, 1, 1, 1, 1 ], [ 1, E(3), E(3), E(3)^2, E(3)^2 ],
      [ 1, E(3)^2, E(3)^2, E(3), E(3) ] ], fusions := [ rec(
          name := [ 'C', '3' ],
          map := [ 1, 2, 2, 3, 3 ] ) ], operations := CharTableOps )
    gap> c:= CharTableCollapsedClasses( t, [ 1, 2, 2, 3, 3 ] );;
    gap> PrintCharTable( c );
    rec( identifier := "Collapsed(Split(C3,[ 1, 2, 2, 3, 3 ]),[ 1, 2, 2, 3\
    , 3 ])", size := 3, order :=
    3, name := "Collapsed(Split(C3,[ 1, 2, 2, 3, 3 ]),[ 1, 2, 2, 3, 3 ])",\
     centralizers := [ 3, 3, 3 ], orders := [ 1, 3, 3 ], powermap :=
    [ ,, [ 1, 1, 1 ] ], fusionsource := [ "Split(C3,[ 1, 2, 2, 3, 3 ])"
     ], irreducibles := [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ],
      [ 1, E(3)^2, E(3) ] ], classes :=
    [ 1, 1, 1 ], operations := CharTableOps )|

The inverse process of fusion is the splitting of classes, see
"CharTableSplitClasses".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharDegAgGroup}

'CharDegAgGroup( <G> [, <q> ] )'

'CharDegAgGroup'  computes  the  degrees of irreducible   characters
of  the finite polycyclic group  <G> over the algebraic closed field of
characteristic <q>.  The default value for <q> is zero.
The degrees are returned as a list of pairs, the first entry  denoting a
degree,  and  the  second  denoting  its multiplicity.

|    gap> g:= SolvableGroup( 24, 15 );
    S4
    gap> CharDegAgGroup( g );
    [ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ] ]    # two linear characters, one of
                                        # degree 2, two of degree 3
    gap> CharDegAgGroup( g, 3 );
    [ [ 1, 2 ], [ 3, 2 ] ]|

The  algorithm  bases on~\cite{Con90b}. It works for all solvable groups.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTableSSGroup}

'CharTableSSGroup( <G> )'

'CharTableSSGroup' returns  the  character  table  of  the  supersolvable
ag-group  <G>  and   stores   it   in  '<G>.charTable'.  If  <G>  is  not
supersolvable  not all irreducible  characters migth be calculated  and a
warning will  be  printed  out. The algorithm bases  on \cite{Con90a} and
\cite{Con90b}.

All the characters calculated are monomial, so they are the  induced of a
linear  character of  some  subgroup  of <G>.  For  every  character  the
subgroup  it is induced from and the  kernel the linear character has are
written    down     in    '<t>.irredinfo[i].inducedFrom.subgroup'     and
'<t>.irredinfo[i].inducedFrom.kernel'.

|    gap> t:= CharTableSSGroup( SolvableGroup( 8 , 5 ) );;
    gap> PrintCharTable( t );
    rec( size := 8, classes := [ 1, 1, 2, 2, 2 ], powermap :=
    [ , [ 1, 1, 2, 2, 2 ]
     ], operations := CharTableOps, group := Q8, irreducibles :=
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, -1, -1 ], [ 1, 1, -1, 1, -1 ],
      [ 1, 1, -1, -1, 1 ], [ 2, -2, 0, 0, 0 ] ], orders :=
    [ 1, 2, 4, 4, 4 ], irredinfo := [ rec(
          inducedFrom := rec(
              subgroup := Q8,
              kernel := Q8 ) ), rec(
          inducedFrom := rec(
              subgroup := Q8,
              kernel := Subgroup( Q8, [ b, c ] ) ) ), rec(
          inducedFrom := rec(
              subgroup := Q8,
              kernel := Subgroup( Q8, [ a, c ] ) ) ), rec(
          inducedFrom := rec(
              subgroup := Q8,
              kernel := Subgroup( Q8, [ a*b, c ] ) ) ), rec(
          inducedFrom := rec(
              subgroup := Subgroup( Q8, [ b, c ] ),
              kernel := Subgroup( Q8, [  ] ) ) ) ], order :=
    8, centralizers := [ 8, 8, 4, 4, 4
     ], identifier := "Q8", name := "Q8" )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MatRepresentationsPGroup}%
\index{Matrix Representations of Finite Polycyclic Groups}%
\index{Monomial Representations of Finite Polycyclic Groups}

'MatRepresentationsPGroup( <G> )'\\
'MatRepresentationsPGroup( <G> [, <int> ] )'

'MatRepresentationsPGroup( <G> )' returns a list of homomorphisms from
the finite polycyclic group <G> to irreducible complex matrix groups.
These matrix groups form a system of representatives of the complex
irreducible representations of <G>.

'MatRepresentationsPGroup( <G>, <int> )' returns only the <int>-th
representation.

Let <G> be a finite polycyclic group with an abelian  normal subgroup <N>
such   that    the   factorgroup    $<G>   /   <N>$   is   supersolvable.
'MatRepresentationsPGroup' uses the algorithm  described in \cite{Bau91}.
Note  that for  such  groups all  such representations are equivalent  to
monomial  ones,  and  in  fact  'MatRepresentationsPGroup'  only  returns
monomial representations.

If <G> has not the property stated above, a system of representatives of
irreducible representations and characters only for the factor group
$<G> / <M>$ can be computed using this algorithm, where <M> is the
derived subgroup of the supersolvable residuum of <G>.  In this case
first a warning is printed.  'MatRepresentationsPGroup' returns
the irreducible representations of <G> with kernel containing <M> then.

|    gap> g:= SolvableGroup( 6, 2 );
    S3
    gap> MatRepresentationsPGroup( g );
    [ GroupHomomorphismByImages( S3, Group( [ [ 1 ] ] ), [ a, b ],
        [ [ [ 1 ] ], [ [ 1 ] ] ] ), GroupHomomorphismByImages( S3, Group(
        [ [ -1 ] ] ), [ a, b ], [ [ [ -1 ] ], [ [ 1 ] ] ] ),
      GroupHomomorphismByImages( S3, Group( [ [ 0, 1 ], [ 1, 0 ] ],
        [ [ E(3), 0 ], [ 0, E(3)^2 ] ] ), [ a, b ],
        [ [ [ 0, 1 ], [ 1, 0 ] ], [ [ E(3), 0 ], [ 0, E(3)^2 ] ] ] ) ]|

'CharTablePGroup' can be used to compute the character table of a group
with the above properties (see "CharTablePGroup").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CharTablePGroup}%
\index{Characters of Finite Polycyclic Groups}

'CharTablePGroup( <G> )'

'CharTablePGroup' returns the character table of the finite polycyclic
group <G>, and stores it in '<G>.charTable'.  Do not change the order of
'<G>.conjugacyClasses' after having called 'CharTablePGroup'.

Let <G> be a finite polycyclic group with an abelian normal subgroup <N>
such that the factorgroup $<G> / <N>$ is supersolvable.
'CharTablePGroup' uses the algorithm described in \cite{Bau91}.

If <G> has not the property stated above, a system of representatives of
irreducible representations and characters only for the factor group $<G>
/ <M>$ can be computed using this algorithm, where <M> is the derived
subgroup of the supersolvable residuum of <G>.  In this case first a
warning is printed.  'CharTablePGroup' returns an incomplete table
containing exactly those irreducibles with kernel containing <M>.

|    gap> t:= CharTablePGroup( SolvableGroup( 8, 4 ) );;
    gap> PrintCharTable( t );
    rec( size := 8, centralizers := [ 8, 8, 4, 4, 4 ], classes :=
    [ 1, 1, 2, 2, 2 ], orders := [ 1, 2, 2, 2, 4 ], irreducibles :=
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, -1, 1, -1 ], [ 1, 1, 1, -1, -1 ],
      [ 1, 1, -1, -1, 1 ], [ 2, -2, 0, 0, 0 ]
     ], operations := CharTableOps, order := 8, powermap :=
    [ , [ 1, 1, 1, 1, 2 ]
     ], identifier := "D8", name := "D8", group := D8 )|

'MatRepresentationsPGroup' can be used to compute representatives of
the complex irreducible representations (see "MatRepresentationsPGroup").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{InitClassesCharTable}%
\index{initialize classlengths}

'InitClassesCharTable( <tbl> )'

returns the list of conjugacy class lengths of the character table <tbl>,
and assigns it to the field '<tbl>.classes'; the classlengths are
computed from the centralizer orders of <tbl>.

'InitClassesCharTable' is called automatically for tables that are read
from the library (see "CharTable") or constructed as generic character
tables (see "Generic Character Tables").

|    gap> t:= rec( centralizers:= [ 2, 2 ], identifier:= "C2" );;
    gap> InitClassesCharTable( t ); t;
    [ 1, 1 ]
    rec(
      centralizers := [ 2, 2 ],
      identifier := "C2",
      classes := [ 1, 1 ] )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{InverseClassesCharTable}

'InverseClassesCharTable( <tbl> )'

returns the list mapping each class of the character table <tbl> to its
inverse class. This list can be regarded as (-1)-st powermap; it is
computed using '<tbl>.irreducibles'.


|    gap> InverseClassesCharTable( CharTable( "L3(2)" ) );
    [ 1, 2, 3, 4, 6, 5 ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ClassNamesCharTable}%
\index{class names}

'ClassNamesCharTable( <tbl> )'

'ClassNamesCharTable'  computes  names  for the classes of  the character
table <tbl> as strings consisting of the order of an element of the class
and and least one distinguishing letter.

The list of these names at the same time is returned by this
function and stored in the table <tbl> as record component 'classnames'.

Moreover for each class a component with its name is constructed,
containing the position of this name in the list 'classnames' as its
value.

|    gap> c3:= CharTable( "Cyclic", 3 );;
    gap> ClassNamesCharTable( c3 );
    [ "1a", "3a", "3b" ]
    gap> PrintCharTable( c3 );
    rec( identifier := "C3", name := "C3", size := 3, order :=
    3, centralizers := [ 3, 3, 3 ], orders := [ 1, 3, 3 ], powermap :=
    [ ,, [ 1, 1, 1 ] ], irreducibles :=
    [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ], [ 1, E(3)^2, E(3) ]
     ], classparam := [ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ] ], irredinfo :=
    [ rec(
          charparam := [ 1, 0 ] ), rec(
          charparam := [ 1, 1 ] ), rec(
          charparam := [ 1, 2 ] )
     ], text := "computed using generic character table for cyclic groups"\
    , classes := [ 1, 1, 1 ], operations := CharTableOps, fusions :=
    [  ], fusionsource := [  ], projections := [  ], projectionsource :=
    [  ], classnames := [ "1a", "3a", "3b" ], 1a := 1, 3a := 2, 3b := 3 )|

If the record component 'classnames' of <tbl> is unbound,
'ClassNamesCharTable' is automatically called by  'DisplayCharTable' (see
"DisplayCharTable").

Note that once the class names are computed the resulting record fields
are stored on <tbl>. They are not deleted by another call of
'ClassNamesCharTable'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ClassMultCoeffCharTable}%
\index{class multiplication coefficient}%
\index{structure constant}

'ClassMultCoeffCharTable( <tbl>, <c1>, <c2>, <c3> )'

returns the class  multiplication coefficient of the  classes  <c1>, <c2>
and <c3> of the group $G$ with character table <tbl>.

|    gap> t:= CharTable( "L3(2)" );;
    gap> ClassMultCoeffCharTable( t, 2, 2, 4 );
    4|

The class  multiplication coefficient  $c_{1,2,3}$ of  the classes  <c1>,
<c2> and <c3> equals the number of pairs $(x,y)$ of elements $x, y \in G$
such  that  $x$ lies  in class <c1>, $y$ lies  in  class  <c2>  and their
product $xy$ is a fixed element of class <c3>.

Also  in  the  center of  the group  algebra  these  numbers are found as
coefficients of the decomposition of the product  of two class sums $K_i$
and $K_j$ into class sums, \[ K_i K_j = \sum_k c_{ijk} K_k. \]

Given the character table of a finite group $G$, whose classes  are $C_1,
\dots, C_r$ with representatives $g_i \in C_i$,  the class multiplication
coefficients $c_{ijk}$ can be computed by the following formula.

\[c_{ijk} = \frac{\|C_i\|\|C_j\|}{\|G\|}
             \sum_{\chi \in \mbox{\footnotesize Irr}(G)}
             \frac{\chi(g_i) \chi(g_j) \overline{\chi(g_k)}}{\chi(1)} \]

On the other hand the knowledge of the class multiplication  coefficients
enables the computation of the character table (see "CharTable").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MatClassMultCoeffsCharTable}%
\index{structure constant}%
\index{class multiplication coefficient}

'MatClassMultCoeffsCharTable( <tbl>, <class> )'

returns the matrix $<C_i> = [ a_{ijk}]_{j,k}$ of structure constants
(see "ClassMultCoeffCharTable").

|    gap> L3_2:= CharTable( "L3(2)" );;
    gap> MatClassMultCoeffsCharTable( t, 2 );
    [ [ 0, 1, 0, 0, 0, 0 ], [ 21, 4, 3, 4, 0, 0 ], [ 0, 8, 6, 8, 7, 7 ],
      [ 0, 8, 6, 1, 7, 7 ], [ 0, 0, 3, 4, 0, 7 ], [ 0, 0, 3, 4, 7, 0 ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ClassStructureCharTable}%
\index{class multiplication coefficient}%
\index{structure constant}

'ClassStructureCharTable( <tbl>, <classes> )'

returns the so--called class structure of the classes in the list
<classes>, for the character table <tbl> of the group $G$.
The length of <classes> must be at least 2.

|    gap> t:= CharTable( "M12" );;
    gap> ClassStructureCharTable( t, [2,6,9,13] );
    916185600
    gap> ClassStructureCharTable( t, [2,9,13] ); # equals the group order
    95040|

Let $C_1, \dots, C_n$ denote the conjugacy classes of $G$ that are
indexed by <classes>.  The class structure $n(C_1, C_2, \ldots, C_n)$
equals the number of tuples $(g_1, g_2, \ldots, g_n)$ of elements
$g_i\in C_i$ with $g_1 g_2 \cdots g_n = 1$.  Note the difference to the
definition of the class multiplication coefficients in
"ClassMultCoeffCharTable" 'ClassMultCoeffCharTable'.

$n(C_1, C_2, \ldots, C_n)$ is computed using the formula
\[ n(C_1, C_2, \ldots, C_n) = \frac{\|C_1\|\|C_2\|\cdots\|C_n\|}{\|G\|}
             \sum_{\chi \in \mbox{\footnotesize Irr}(G)}
             \frac{\chi(g_1)\chi(g_2)\cdots\chi(g_n)}{\chi(1)^{n-2}} . \]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{RealClassesCharTable}%
\index{classes!real}

'RealClassesCharTable( <tbl> )'

returns a list of the real classes of the group $G$ with character table
<tbl>.

|    gap> RealClassesCharTable(L3_2);
    [ 1, 2, 3, 4 ]|

An element $x \in G$ is called *real*, if it is conjugate with its
inverse. And as $x^{-1} = x^{o(x)-1}$, this fact is tested by looking
at the powermap of <tbl>.

Real elements take only real character values.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ClassOrbitCharTable}%
\index{classes!of cyclic subgroup}

'ClassOrbitCharTable( <tbl>, <class> )'

returns a list of classes containing elements of
the cyclic subgroup generated by an element $x$ of class <class>.

|    gap> ClassOrbitCharTable(L3_2, 5);
    [ 5, 6 ]|

Being all powers of $x$ this data is recovered from the powermap
of <tbl>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ClassRootsCharTable}%
\index{classes!roots of}

'ClassRootsCharTable( <tbl> )'

returns a list of the classes of all nontrivial $p$--th roots of the
classes of <tbl> where for each class, $p$ runs over the prime divisors
of the representative order.

|    gap> ClassRootsCharTable(L3_2);
    [ [ 2, 3, 5, 6 ], [ 4 ], [  ], [  ], [  ], [  ] ]|

This information is found by looking at the powermap of <tbl>, too.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{NrPolyhedralSubgroups}%
\index{subgroups!polyhedral}

'NrPolyhedralSubgroups( <tbl>, <c1>, <c2>, <c3> )'

returns the  number  and isomorphism type  of polyhedral subgroups of the
group with character table <tbl> which are generated by an element $g$ of
class <c1> and an element  $h$ of class <c2> with  the  property that the
product $gh$ lies in class <c3>.

|    gap> NrPolyhedralSubgroups(L3_2, 2, 2, 4);
    rec(
      number := 21,
      type := "D8" ) |

According to~\cite[p.~233]{NPP84} the  number of polyhedral  subgroups of
isomorphism type $V_4$, $D_{2n}$, $A_4$, $S_4$ and  $A_5$  can be derived
from the class multiplication coefficient (see "ClassMultCoeffCharTable")
and    the   number   of    Galois   conjugates   of   a    class    (see
"ClassOrbitCharTable").

Note that the classes <c1>,  <c2> and <c3> in the parameter list  must be
ordered according to the order of the elements in these classes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{DisplayCharTable}%
\index{character table!display}

'DisplayCharTable( <tbl> )' \\
'DisplayCharTable( <tbl>, <arec> )'

'DisplayCharTable' prepares the data contained in the character table
<tbl> for a pretty columnwise output.

In the first form 'DisplayCharTable' prints all irreducible characters
of the table <tbl>, together with the orders of the centralizers in
factorized form and the available powermaps.

Thus it can be used  to echo character tables in interactive use, being
the value of the record field 'Print' of a record field 'operations'
of <tbl> (see "Character Table Records",
"Operations Records for Character Tables").

Each displayed character is given a name 'X.<n>'.

The number of columns printed at one time depends on the actual
linelength, which is restored by the function 'SizeScreen' (see
"SizeScreen").

The first lines of the output describe the order of the centralizer
of an element of the class factorized into its prime divisor.

The next line gives the name of the class. If the record field
'classnames' of the table <tbl> is not bound, 'DisplayCharTable'
calls the function 'ClassNamesCharTable' to determine the class names
and to store them on the table <tbl> (see "ClassNamesCharTable").

Preceded by a name 'P<n>' the next lines show the <n>th powermaps
of <tbl> in terms of the former shown class names.

Every  ambiguous  or  unknown  (see "Unknown")  value  of  the  table  is\
displayed as a question mark '?'.

Irrational character values are not printed explicitly because the
lengths of their printed representation might disturb the view.
Instead of that every irrational value is indicated by a name, which
is a string of a least one capital letter.

Once a name for an irrational number is found, it is used all over the
printed table. Moreover the complex conjugate and the star of an
irrationality are represented by that very name preceded by a '/'
resp. a '\*'.

The printed  character  table  is  then followed  by  a  legend,  a  list
identifying  the  occurred  symbols with their actual  irrational  value.
Occasionally this identity is supplemented by a quadratic  representation
of the irrationality together with the corresponding \ATLAS--notation.

|    gap> a5:= CharTable("A5");;
    gap> DisplayCharTable(a5);
    A5

         2  2  2  .  .  .
         3  1  .  1  .  .
         5  1  .  .  1  1

           1a 2a 3a 5a 5b
        2P 1a 1a 3a 5b 5a
        3P 1a 2a 1a 5b 5a
        5P 1a 2a 3a 1a 1a

    X.1     1  1  1  1  1
    X.2     3 -1  .  A *A
    X.3     3 -1  . *A  A
    X.4     4  .  1 -1 -1
    X.5     5  1 -1  .  .

    A = -E(5)-E(5)^4
      = (1-ER(5))/2 = -b5|

In the second form 'DisplayCharTable' takes an argument record <arec> as
an additional argument. This record can be used to change the default
style for displaying a character as shown above. Its relevant fields
are

'chars': \\ an integer or a list of integers to select a sublist of the
irreducible characters of <tbl>, or a list of characters of <tbl>
(in this case the letter '\"X\"' is replaced by '\"Y\"'),

'classes': \\ an integer or a list of integers to select a sublist of the
classes of <tbl>,

'centralizers': \\ suppresses the printing of the orders of the
centralizers if 'false',

'powermap': \\ an integer or a list of integers to select a subset of the
available powermaps, or 'false' to suppress the powermaps,

'letter': \\ a single capital letter (e.~g.\ '\"P\"' for permutation
characters) to replace '\"X\"',

'indicator': \\ 'true' enables the printing of the second Schur
indicator, a list of integers enables the printing of the corresponding
indicators.

|    gap> arec:= rec( chars:= 4, classes:= [a5.3a..a5.5a],
    > centralizers:= false, indicator:= true, powermap:= [2] );;
    gap> Indicator( a5, 2 );;
    gap> DisplayCharTable( a5, arec );
    A5

              3a 5a
           2P 3a 5b
           2
    X.4    +   1 -1
    |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{SortCharactersCharTable}%
\index{character tables!sort}%
\index{characters!sort}%
\index{tables!sort}

'SortCharactersCharTable( <tbl> )'\\
'SortCharactersCharTable( <tbl>, <permutation> )'\\
'SortCharactersCharTable( <tbl>, <chars> )'\\
'SortCharactersCharTable( <tbl>, <chars>, <permutation> )'\\
'SortCharactersCharTable( <tbl>, <chars>, \"norm\" )'\\
'SortCharactersCharTable( <tbl>, <chars>, \"degree\" )'

If no list <chars> of characters of the character table <tbl> is
entered, 'SortCharactersCharTable' sorts '<tbl>.irreducibles'; then
additionally the list '<tbl>.irredinfo' is permuted by the same
permutation. Otherwise 'SortCharactersCharTable' sorts the list <chars>.

There are four possibilities to sort characters\:\
Besides the application of an explicitly given permutation (see
"Permuted"), they can be sorted according to ascending norms (parameter
'\"norm\"'), to ascending degree (parameter '\"degree\"') or both (no
third parameter), i.e., characters with same norm are sorted according to
ascending degree, and characters with smaller norm precede those with
bigger norm.

If the trivial character is contained in the sorted list, it will be
sorted to the first position.
Rational characters always will precede other ones with same norm resp.\
same degree afterwards.

'SortCharactersCharTable' returns the permutation that was applied to
<chars>.

|    gap> t:= CharTable( "Symmetric", 5 );;
    gap> PrintCharTable( t );
    rec( identifier := "S5", name := "S5", size := 120, order :=
    120, centralizers := [ 120, 12, 8, 6, 6, 4, 5 ], orders :=
    [ 1, 2, 2, 3, 6, 4, 5 ], powermap :=
    [ , [ 1, 1, 1, 4, 4, 3, 7 ], [ 1, 2, 3, 1, 2, 6, 7 ],,
      [ 1, 2, 3, 4, 5, 6, 1 ] ], irreducibles :=
    [ [ 1, -1, 1, 1, -1, -1, 1 ], [ 4, -2, 0, 1, 1, 0, -1 ],
      [ 5, -1, 1, -1, -1, 1, 0 ], [ 6, 0, -2, 0, 0, 0, 1 ],
      [ 5, 1, 1, -1, 1, -1, 0 ], [ 4, 2, 0, 1, -1, 0, -1 ],
      [ 1, 1, 1, 1, 1, 1, 1 ] ], classparam :=
    [ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ],
      [ 1, [ 3, 1, 1 ] ], [ 1, [ 3, 2 ] ], [ 1, [ 4, 1 ] ], [ 1, [ 5 ] ]
     ], irredinfo := [ rec(
          charparam := [ 1, [ 1, 1, 1, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 2, 1, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 2, 2, 1 ] ] ), rec(
          charparam := [ 1, [ 3, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 3, 2 ] ] ), rec(
          charparam := [ 1, [ 4, 1 ] ] ), rec(
          charparam := [ 1, [ 5 ] ] )
     ], text := "computed using generic character table for symmetric grou\
    ps", classes := [ 1, 10, 15, 20, 20, 30, 24
     ], operations := CharTableOps, fusions := [  ], fusionsource :=
    [  ], projections := [  ], projectionsource := [  ] )
    gap> SortCharactersCharTable( t, t.irreducibles, "norm" );
    (1,2,3,4,5,6,7)      # sort the trivial character to the first position
    gap> SortCharactersCharTable( t );
    (4,5,7)
    gap> t.irreducibles;
    [ [ 1, 1, 1, 1, 1, 1, 1 ], [ 1, -1, 1, 1, -1, -1, 1 ],
      [ 4, -2, 0, 1, 1, 0, -1 ], [ 4, 2, 0, 1, -1, 0, -1 ],
      [ 5, -1, 1, -1, -1, 1, 0 ], [ 5, 1, 1, -1, 1, -1, 0 ],
      [ 6, 0, -2, 0, 0, 0, 1 ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{SortClassesCharTable}%
\index{character tables!sort}%
\index{tables!sort}

'SortClassesCharTable( <tbl> )'\\
'SortClassesCharTable( <tbl>, \"centralizers\" )'\\
'SortClassesCharTable( <tbl>, \"representatives\" )'\\
'SortClassesCharTable( <tbl>, <permutation> )'\\
'SortClassesCharTable( <chars>, <permutation> )'

The last form simply permutes the classes of all elements of <chars>
with <permutation>. All other forms take a character table <tbl> as
parameter, and 'SortClassesCharTable' permutes the classes of <tbl>\:

'SortClassesCharTable( <tbl>, \"centralizers\" )':\\
    sorts the classes according to descending centralizer orders,

'SortClassesCharTable( <tbl>, \"representatives\" )':\\
    sorts the classes according to ascending representative orders,

'SortClassesCharTable( <tbl> )':\\
    sorts the classes according to ascending representative orders,
    and classes with equal representative orders according to descending
    centralizer orders,

'SortClassesCharTable( <tbl>, <permutation> )':\\
    sorts the classes by application of <permutation>

After having calculated the permutation, 'SortClassesCharTable' will
adjust the following fields of <tbl>\:

by application of the permutation\:\ 'orders', 'centralizers', 'classes',
   'print', all entries of 'irreducibles', 'classtext', 'classparam',
   'classnames', all fusion maps, all entries of the 'chars' lists in the
   records of 'projectives'

by conjugation with the permutation\:\ all powermaps,
'automorphisms',

by multiplication with the permutation\:\ 'permutation',

and the fields corresponding to '<tbl>.classnames'
(see "ClassNamesCharTable").

The applied permutation is returned by 'SortClassesCharTable'.

*Note* that many programs expect the class '1A' to be the first one
(see "Conventions for Character Tables").

|    gap> t:= CharTable( "Symmetric", 5 );;
    gap> PrintCharTable( t );
    rec( identifier := "S5", name := "S5", size := 120, order :=
    120, centralizers := [ 120, 12, 8, 6, 6, 4, 5 ], orders :=
    [ 1, 2, 2, 3, 6, 4, 5 ], powermap :=
    [ , [ 1, 1, 1, 4, 4, 3, 7 ], [ 1, 2, 3, 1, 2, 6, 7 ],,
      [ 1, 2, 3, 4, 5, 6, 1 ] ], irreducibles :=
    [ [ 1, -1, 1, 1, -1, -1, 1 ], [ 4, -2, 0, 1, 1, 0, -1 ],
      [ 5, -1, 1, -1, -1, 1, 0 ], [ 6, 0, -2, 0, 0, 0, 1 ],
      [ 5, 1, 1, -1, 1, -1, 0 ], [ 4, 2, 0, 1, -1, 0, -1 ],
      [ 1, 1, 1, 1, 1, 1, 1 ] ], classparam :=
    [ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ],
      [ 1, [ 3, 1, 1 ] ], [ 1, [ 3, 2 ] ], [ 1, [ 4, 1 ] ], [ 1, [ 5 ] ]
     ], irredinfo := [ rec(
          charparam := [ 1, [ 1, 1, 1, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 2, 1, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 2, 2, 1 ] ] ), rec(
          charparam := [ 1, [ 3, 1, 1 ] ] ), rec(
          charparam := [ 1, [ 3, 2 ] ] ), rec(
          charparam := [ 1, [ 4, 1 ] ] ), rec(
          charparam := [ 1, [ 5 ] ] )
     ], text := "computed using generic character table for symmetric grou\
    ps", classes := [ 1, 10, 15, 20, 20, 30, 24
     ], operations := CharTableOps, fusions := [  ], fusionsource :=
    [  ], projections := [  ], projectionsource := [  ] )
    gap> SortClassesCharTable( t, "centralizers" );
    (6,7)
    gap> SortClassesCharTable( t, "representatives" );
    (5,7)
    gap> t.centralizers; t.orders;
    [ 120, 12, 8, 6, 4, 5, 6 ]
    [ 1, 2, 2, 3, 4, 5, 6 ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{SortCharTable}%
\index{character tables!sort}%
\index{tables!sort}

'SortCharTable( <tbl>, <kernel> )'\\
'SortCharTable( <tbl>, <normalseries> )'\\
'SortCharTable( <tbl>, <facttbl>, <kernel> )'

sorts classes and 'irreducibles' of the character table <tbl>, and
returns a record with components 'columns' and 'rows', which are the
permutations applied to classes and characters.

The first form sorts the classes at positions contained in the list
<kernel> to the beginning, and sorts all characters in
'<tbl>.irreducibles' such that the first characters are those that
contain <kernel> in their kernel.

The second form does the same successively for all kernels $k_i$ in
the list $'normalseries' = [ k_1, k_2, \ldots, k_n ]$ where
$k_i$ must be a sublist of $k_{i+1}$ for $1 \leq i \leq n-1$.

The third form computes the table <F> of the factor group of <tbl>
modulo the normal subgroup formed by the classes whose positions are
contained in the list <kernel>;
<F> must be permutation equivalent to the table <facttbl> (in the
sense of "TransformingPermutationsCharTables"), else 'false' is
returned.  The classes of <tbl> are sorted such that the preimages
of a class of <F> are consecutive, and that the succession of
preimages is that of <facttbl>.  '<tbl>.irreducibles' is sorted as
by 'SortCharTable( <tbl>, <kernel> )'.
(*Note* that the transformation is only unique up to table automorphisms
of <F>, and this need not be unique up to table automorphisms of <tbl>.)

All rearrangements of classes and characters are stable, i.e., the
relative positions of classes and characters that are not distinguished
by any relevant property is not changed.

'SortCharTable' uses "SortClassesCharTable" 'SortClassesCharTable' and
"SortCharactersCharTable" 'SortCharactersCharTable'.

|    gap> t:= CharTable("Symmetric",4);;
    gap> Set( List( t.irreducibles, KernelChar ) );
    [ [ 1 ], [ 1, 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 3, 4 ] ]
    gap> SortCharTable( t, Permuted( last, (2,4,3) ) );
    rec(
      columns := (2,4,3),
      rows := (1,2,4,5) )
    gap> DisplayCharTable( t );
    S4

         2  3  3  .  2  2
         3  1  .  1  .  .

           1a 2a 3a 2b 4a
        2P 1a 1a 3a 1a 2a
        3P 1a 2a 1a 2b 4a

    X.1     1  1  1  1  1
    X.2     1  1  1 -1 -1
    X.3     2  2 -1  .  .
    X.4     3 -1  . -1  1
    X.5     3 -1  .  1 -1
    |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MatAutomorphisms}%
\index{automorphism group!of a matrix}

'MatAutomorphisms( <mat>, <maps>, <subgroup> )'

returns the permutation group record representing the matrix
automorphisms of the matrix <mat> that respect all lists in the list
<maps>, i.e. representing the group of those permutations of columns of
<mat> which acts on the set of rows of <mat> and additionally fixes all
lists in <maps>.

<subgroup> is a list of permutation generators of a subgroup of this
group. E.g. generators of the Galois automorphisms of a matrix of
ordinary characters may be entered here.

|    gap> t:= CharTable( "Dihedral", 8 );;
    gap> PrintCharTable( t );
    rec( identifier := "D8", name := "D8", size := 8, order :=
    8, centralizers := [ 8, 4, 8, 4, 4 ], orders := [ 1, 4, 2, 2, 2
     ], powermap := [ , [ 1, 3, 1, 1, 1 ] ], irreducibles :=
    [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, -1, -1 ], [ 1, -1, 1, 1, -1 ],
      [ 1, -1, 1, -1, 1 ], [ 2, 0, -2, 0, 0 ] ], classparam :=
    [ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ], [ 2, 0 ], [ 2, 1 ] ], irredinfo :=
    [ rec(
          charparam := [ 1, 0 ] ), rec(
          charparam := [ 1, 1 ] ), rec(
          charparam := [ 1, 2 ] ), rec(
          charparam := [ 1, 3 ] ), rec(
          charparam := [ 2, 1 ] )
     ], text := "computed using generic character table for dihedral group\
    s", classes := [ 1, 2, 1, 2, 2
     ], operations := CharTableOps, fusions := [  ], fusionsource :=
    [  ], projections := [  ], projectionsource := [  ] )
    gap> MatAutomorphisms( t.irreducibles, [], Group( () ) );
    Group( (4,5), (2,4) )
    gap> MatAutomorphisms( t.irreducibles, [ t.orders ], Group( () ) );
    Group( (4,5) )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{TableAutomorphisms}%
\index{automorphism group!of a character table}

'TableAutomorphisms( <tbl>, <chars> )'\\
'TableAutomorphisms( <tbl>, <chars>, \"closed\" )'

returns a permutation group record for the group of those matrix
automorphisms of <chars> (see "MatAutomorphisms") which are
admissible by (i.e. which fix) the fields 'orders' and all uniquely
determined (i.e.\ not parametrized) maps in 'powermap' of
the character table <tbl>; the action on 'orders' is the natural
permutation, that on the powermaps is conjugation.

If <chars> is closed under galois conjugacy --this is always satisfied
for ordinary character tables-- the parameter \"closed\"\ may be entered.
In that case the subgroup of Galois automorphisms is computed by
"GaloisMat" 'GaloisMat'.

|    gap> t:= CharTable( "Dihedral", 8 );; # as in "MatAutomorphisms"
    gap> TableAutomorphisms( t, t.irreducibles );
    Group( (4,5) )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{TransformingPermutations}

'TransformingPermutations( <mat1>, <mat2> )'

tries to construct a permutation $\pi$ that transforms the set of rows of
the matrix <mat1> to the set of rows of the matrix <mat2> by permutation
of columns.
If such a permutation exists, a record with fields 'columns', 'rows'
and 'group' is returned, otherwise 'false'\:\
If $'TransformingPermutations( <mat1>, <mat2> ) = <r>' \not= 'false'$
then

'Permuted( List(<mat1>,x->Permuted(x,<r>.columns)),<r>.rows ) = <mat2>',

and '<r>.group' is the group of matrix automorphisms of <mat2>;
this group stabilizes the transformation, i.e. for $g$ in that group and
$\pi$ the value of the 'columns' field, also $\pi g$ would be a valid
permutation of columns.

|    gap> mat1:= CharTable( "Alternating", 5 ).irreducibles;
    [ [ 1, 1, 1, 1, 1 ], [ 4, 0, 1, -1, -1 ], [ 5, 1, -1, 0, 0 ],
      [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ],
      [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ]
    gap> mat2:= CharTable( "A5" ).irreducibles;
    [ [ 1, 1, 1, 1, 1 ], [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ],
      [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ], [ 4, 0, 1, -1, -1 ],
      [ 5, 1, -1, 0, 0 ] ]
    gap> TransformingPermutations( mat1, mat2 );
    rec(
      columns := (),
      rows := (2,4)(3,5),
      group := Group( (4,5) ) )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{TransformingPermutationsCharTables}

'TransformingPermutationsCharTables( <tbl1>, <tbl2> )'

tries to construct a permutation $\pi$ that transforms the set of rows of
'<tbl1>.irreducibles' to the set of rows of '<tbl2>.irreducibles' by
permutation of columns (see "TransformingPermutations") and that also
transforms the powermaps and the 'orders' field.  If such a permutation
exists, it returns a record with components 'columns' (a valid
permutation of columns), 'rows' (the permutation of '<tbl>.irreducibles'
corresponding to that permutation), and 'group' (the permutation group
record of table automorphisms of <tbl2>, see "TableAutomorphisms").  If
no such permutation exists, it returns 'false'.

|    gap> t1:= CharTable("Dihedral",8);;t2:= CharTable("Quaternionic",8);;
    gap> TransformingPermutations( t1.irreducibles, t2.irreducibles );
    rec(
      columns := (),
      rows := (),
      group := Group( (4,5), (2,4) ) )
    gap> TransformingPermutationsCharTables( t1, t2 );
    false
    gap> t1:= CharTable( "Dihedral", 6 );; t2:= CharTable("Symmetric",3);;
    gap> TransformingPermutationsCharTables( t1, t2 );
    rec(
      columns := (2,3),
      rows := (1,3,2),
      group := Group( () ) )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{GetFusionMap}%
\index{fusion map!get}%
\index{subgroup fusions}

'GetFusionMap( <source>, <destination> )'\\
'GetFusionMap( <source>, <destination>, <specification> )'

For character tables <source> and <destination>,
'GetFusionMap( <source>, <destination> )' returns the 'map' field of the
fusion stored on the character table <source> that has the 'identifier'
component '<destination>.name';

'GetFusionMap( <source>, <destination>, <specification> )' gets that
fusion that additionally has the 'specification' field <specification>.

Both versions adjust the ordering of classes of <destination> using
'<destination>.permutation' (see "SortClassesCharTable", "Conventions for
Character Tables").
That is the reason why <destination> cannot be simply the identifier of
the destination table.

If both <source> and <destination> are Brauer tables, 'GetFusionMap'
returns the fusion corresponding to that between the ordinary tables;
for that, this fusion must be stored on '<source>.ordinary'.

If no appropriate fusion is found, 'false' is returned.

|    gap> s:= CharTable( "L2(11)" );;
    gap> t:= CharTable( "J1" );;
    gap> SortClassesCharTable( t, ( 3, 4, 5, 6 ) );;
    gap> t.permutation;
    (3,4,5,6)
    gap> GetFusionMap( s, t );
    [ 1, 2, 4, 6, 5, 3, 10, 10 ]
    gap> s.fusions[5];
    rec(
      name := "J1",
      map := [ 1, 2, 3, 5, 4, 6, 10, 10 ],
      text := [ 'f', 'u', 's', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'u',
          'n', 'i', 'q', 'u', 'e', ' ', 'u', 'p', ' ', 't', 'o', ' ',
          't', 'a', 'b', 'l', 'e', ' ', 'a', 'u', 't', 'o', 'm', 'o',
          'r', 'p', 'h', 'i', 's', 'm', 's', ',', '\n', 't', 'h', 'e',
          ' ', 'r', 'e', 'p', 'r', 'e', 's', 'e', 'n', 't', 'a', 't',
          'i', 'v', 'e', ' ', 'i', 's', ' ', 'e', 'q', 'u', 'a', 'l',
          ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'f', 'u', 's', 'i',
          'o', 'n', ' ', 'm', 'a', 'p', ' ', 'o', 'n', ' ', 't', 'h',
          'e', ' ', 'C', 'A', 'S', ' ', 't', 'a', 'b', 'l', 'e' ] )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{StoreFusion}%
\index{fusion!store}%
\index{subgroup fusions}

'StoreFusion( <source>, <destination>, <fusion> )'\\
'StoreFusion( <source>, <destination>, <fusionmap> )'

For character tables <source> and <destination>, <fusion> must be a
record containing at least the field 'map' which is regarded as a fusion
from <source> to <destination>.
<fusion> is stored on <source> if no ambiguity arises, i.e.\ if there is
not yet a fusion into <destination> stored on <source> or if any fusion
into destination stored on <source> has a 'specification' field different
from that of <fusion>.
The 'map' field of <fusion> is adjusted by '<destination>.permutation'.
(Thus the map will remain correct even if the classes of a concerned
table are sorted, see "SortClassesCharTable" and "Conventions for
Character Tables"; the
correct fusion can be got using "GetFusionMap", so be careful!).
Additionally, '<source>.identifier' is added to
'<destination>.fusionsource'.

The second form works like the first, with
'<fusion> = rec( map\:= <fusionmap> )'.

|    gap> s:= CharTable( "A6.2_1" );; t:= CharTable( "A7.2" );;
    gap> fus:= RepresentativesFusions( s, SubgroupFusions( s, t ), t );
    [ [ 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13 ] ]
    gap> s.fusions; t.fusionsource;
    [  ]
    [ "2.A7.2", "3.A7.2", "6.A7.2", "A7" ]
    gap> StoreFusion( s, t, fus[1] );
    gap> s.fusions; t.fusionsource;
    [ rec(
          name := "A7.2",
          map := [ 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13 ] ) ]
    [ "2.A7.2", "3.A7.2", "6.A7.2", "A6.2_1", "A7" ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{FusionConjugacyClasses}

'FusionConjugacyClasses( <subgroup>, <group>       )'\\
'FusionConjugacyClasses( <group>   , <factorgroup> )'

'FusionConjugacyClasses' returns a list denoting the fusion of
conjugacy classes from
the  first  group  to the  second one.   If both  groups  have components
'charTable' this list is written to the character tables, too.

|    gap> g := SolvableGroup( 24, 14 );
    Sl(2,3)
    gap> FusionConjugacyClasses( g, g / Subgroup( g, [ g.4 ] ) );
    [ 1, 1, 2, 3, 3, 4, 4 ]
    gap> FusionConjugacyClasses( Subgroup( g, [ g.2, g.3, g.4 ] ), g );
    [ 1, 2, 3, 3, 3 ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MAKElb11}%
\index{MOC!interface to}

'MAKElb11( <listofns> )'

prints field information for fields with conductor $Q_n$ where <n> is in
the list <listofns>;

'MAKElb11( [ 3 .. 189 ] )' will print something very similar to
Richard Parker\'s file 'lb11'.

|    gap> MAKElb11( [ 3, 4 ] );
       3   2   0   1   0
       4   2   0   1   0|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ScanMOC}%
\index{MOC!interface to}

'ScanMOC( <list> )'

returns a record containing the information encoded in the list <list>,
the components of the result are the labels in <list>.  If <list> is in
MOC2 format (10000--format) the names of components are 30000--numbers,
if it is in MOC3 format the names of components have yABC--format.

|    gap> ScanMOC( "y100y105ay110t28t22z" );
    rec(
      y105 := [ 0 ],
      y110 := [ 28, 22 ] )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MOCChars}%
\index{MOC!interface to}

'MOCChars( <tbl>, <gapchars> )'

returns translations of {\GAP} format characters <gapchars> to MOC
format.  <tbl> must be a {\GAP} format table or a MOC format table.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{GAPChars}%
\index{MOC!interface to}

'GAPChars( <tbl>, <mocchars> )'

returns translations of MOC format characters <mocchars> to {\GAP}
format.  <tbl> must be a {\GAP} format table or a MOC format table.

<mocchars> may also be a list of integers, e.g., a component containing
characters in a record produced by "ScanMOC".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MOCTable}%
\index{MOC!interface to}

'MOCTable( <gaptbl> )'\\
'MOCTable( <gaptbl>, <basicset> )'

return the MOC format table record of the {\GAP} table <gaptbl>, and
stores it in the component 'MOCtbl' of <gaptbl>.

The first form can be used for ordinary ($G.0$) tables only, for modular
($G.p$) tables one has to specify a basic set <basicset> of ordinary
irreducibles which must be the list of positions of these characters in
the 'irreducibles' component of the corresponding ordinary table (which
is stored in <gaptbl>.ordinary).

The result contains the information of <gaptbl> in a format similar to
the MOC 3 format, the table itself can e.g. easily be printed out or be
used to print out characters using "PrintToMOC".

The components of the result are
'identifier'  : the string 'MOCTable( <name> )' where <name> is the
                'identifier' component of <gaptbl>,

'isMOCformat' : has value 'true',

'GAPtbl'      : the record <gaptbl>,

'operations'  : equal to 'MOCTableOps', containing just an appropriate
                'Print' function,

'prime'       : the characteristic of the field (label 30105 in MOC),

'centralizers': centralizer orders for cyclic subgroups (label 30130)

'orders'      : element orders for cyclic subgroups (label 30140)

'fields'      : at position 'i' the number field generated by the
                character values of the 'i'--th cyclic subgroup;
                the 'base' component of each field is a Parker base,
                (the length of 'fields' is equal to the value of label
                30110 in MOC).

'cycsubgps'   : 'cycsubgps[i] = j' means that class 'i' of
                the {\GAP} table belongs to the 'j'--th cyclic subgroup
                of the {\GAP} table,

'repcycsub'   : 'repcycsub[j] = i' means that class 'i' of
                the {\GAP} table is the representative of
                the 'j'--th cyclic subgroup of the {\GAP} table.
                *Note* that the representatives of {\GAP} table and
                MOC table need not agree!

'galconjinfo' : a list $[ r_1,c_1,r_2,c_2,\ldots,r_n,c_n ]$
                which means that the $i$--th class of the GAP table is
                the $c_i$--th conjugate of the representative of
                the $r_i$--th cyclic subgroup on the MOC table.
                (This is used to translate back to GAP format,
                stored under label 30160)

'30170'       : (power maps) for each cyclic subgroup (except
                the trivial one) and each prime divisor of
                the representative order store four values, the number
                of the subgroup, the power, the number of the cyclic
                subgroup containing the image, and the power to which
                the representative must be raised to give the image
                class.  (This is used only to construct the '30230'
                power map/embedding information.)
                In 'result.30170' only a list of lists (one for each
                cyclic subgroup) of all these values is stored,
                it will not be used by {\GAP}.

'tensinfo'    : tensor product information, used to compute the
                coefficients of the Parker base for tensor products
                of characters (label 30210 in MOC).
                For a field with vector space base $(v_1,v_2,\ldots,v_n)$
                the tensor product information of a cyclic subgroup
                in MOC (as computed by 'fct') is either 1 (for rational
                classes) or a sequence
                \[ n x_{1,1} y_{1,1} z_{1,1} x_{1,2} y_{1,2} z_{1,2}
                   \ldots x_{1,m_1} y_{1,m_1} z_{1,m_1} 0 x_{2,1} \ldots
                   z_{2,m_2} 0 \ldots x_{n,m_n} y_{n,m_n} z_{n,m_n} 0 \]
                which means that the coefficient of $v_k$ in the product
                \[ ( \sum_{i=1}^{n} a_i v_i ) ( \sum_{j=1}^{n} b_j v_j ) \]
                is equal to
                \[ \sum_{i=1}^{m_k} x_{k,i} a_{y_{k,i}} b_{z_{k,i}}\ . \]
                On a MOC table in {\GAP} the 'tensinfo' component is
                a list of lists, each containing exactly the sequence

'invmap'      : inverse map to compute complex conjugate characters,
                label 30220 in MOC.

'powerinfo'   : field embeddings for $p$--th symmetrizations, $p$ prime
                in '[ 2 .. 19 ]'; note that the necessary power maps
                must be stored on <gaptbl> to compute this component.
                (label 30230 in MOC)

'30900'       : basic set of restricted ordinary irreducibles in the
                case of nonzero characteristic, all ordinary irreducibles
                else.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{PrintToMOC}%
\index{MOC!interface to}

'PrintToMOC( <moctbl> )'\\
'PrintToMOC( <moctbl>, <chars> )'

The first form prints the MOC3 format of the character table <moctbl>
which must be an character table in MOC format (as produced by
"MOCTable").  The second form prints a table in MOC3 format that
contains the MOC format characters <chars> (as produced by "MOCChars")
under label 'y900'.

|    gap> t:= CharTable( "A5mod3" );;
    gap> moct:= MOCTable( t, [ 1, 2, 3, 4 ] );;
    gap> PrintTo( "a5mod3", PrintToMOC( moct ), "\n" ); |

produces a file 'a5mod3' whose first characters are

|    y100y105dy110edy130t60efy140bcfy150bbfcabbey160bbcbdbdcy170ccbbefbb|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{PrintToCAS}%
\index{CAS tables,CAS format,CAS}

'PrintToCAS( <filename>, <tbl> )'\\
'PrintToCAS( <tbl>, <filename> )'

produces a file with name <filename> which contains a {\CAS} library table
of the {\GAP} character table <tbl>; this file can be read into {\CAS}
using the 'get'-command (see~\cite{NPP84}).

The line length in the file is at most the current value 'SizeScreen()[1]'
(see "SizeScreen").

Only the components 'identifier', 'text', 'order', 'centralizers',
'orders', 'print', 'powermap', 'classtext' (for partitions only),
'fusions', 'irredinfo', 'characters', 'irreducibles' of <tbl> are
considered.

If '<tbl>.characters' is bound, this list is taken as 'characters' entry
of the {\CAS} table, otherwise '<tbl>.irreducibles' (if exists) will form
the list 'characters' of the {\CAS} table.

|    gap> PrintToCAS( "c2", CharTable( "Cyclic", 2 ) );|

produces a file with name 'c2' containing the following data\:

|    'C2'
    00/00/00. 00.00.00.
    (2,2,0,2,-1,0)
    text:
    (&computed using generic character table for cyclic groups&),
    order=2,
    centralizers:(2,2),
    reps:(1,2),
    powermap:2(1,1),
    characters:
    (1,1)
    (1,-1);
    /// converted from GAP|


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  Emacs . . . . . . . . . . . . . . . . . . . . . local Emacs variables
%%
%%  Local Variables:
%%  mode:               outline
%%  outline-regexp:     "\\\\Chapter\\|\\\\Section"
%%  fill-column:        73
%%  eval:               (hide-body)
%%  End:
%%
