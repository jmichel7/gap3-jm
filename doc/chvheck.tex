%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  chvheck.tex       CHEVIE documentation       Meinolf Geck, Frank Luebeck,
%A                                               Jean Michel, G"otz Pfeiffer
%%
%Y  Copyright (C) 1992 - 1996  Lehrstuhl D f\"ur Mathematik, RWTH Aachen, IWR
%Y  der Universit\"at Heidelberg, University of St. Andrews, and   University
%Y  Paris VII.
%%
%%  This  file  contains  the  description  of  the  GAP functions of CHEVIE
%%  dealing with Iwahori-Hecke algebras.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Chapter{Iwahori-Hecke algebras}

In  this  chapter  we  describe  functions  for  dealing with Iwahori-Hecke
algebras associated to Coxeter groups.

Let  $W,S$ be a Coxeter system, where $W$ is generated by $S$ and denote by
$m_{s,t}$  the  order  of  the  product  $st$  for $s,t\in S$. Let $R$ be a
commutative  ring with~1 and for $s\in S$ let $u_{s,0},u_{s,1}$ be elements
in  $R$ such that $u_{s,0}=u_{t,0}$  and $u_{s,1}=u_{t,1}$ whenever $s,t\in
S$ are conjugate in $W$ (this is the same as requiring that
$u_{s,i}=u_{t,i}$   whenever   $m_{s,t}$   is   odd).   The   corresponding
Iwahori-Hecke algebra with parameters $\{u_{s,i}\}$ is a deformation of the
group  algebra of $W$ over $R$.  More precisely, $H=H(W,R, \{u_{s,i}\})$ is
the  unitary associative  $R$-algebra generated  by elements $\{T_s\}_{s\in
S}$    subject   to   the  relations\:   $$\begin{array}{ccll}
(T_s-u_{s,0})(T_s-u_{s,1})  & =  & 0  & \mbox{  for all  $s$ (the quadratic
relations)}\\  T_sT_tT_s  \cdots  &  =  &  T_tT_sT_t  \cdots  & \mbox{ with
$m_{s,t}$ factors on each side (the braid relations)}. \end{array} $$

If $u_{s,0}=1$ and $u_{s,1}=-1$ for all $s$ then the quadratic relations
become $T_s^2=1$ and the
deformation of the group algebra is trivial.

Since  the generators $T_s$ satisfy the braid relations, the algebra $H$ is
in  fact a quotient of the group algebra of the braid group associated with
$W$. It follows that, if $w=s_1 \cdots s_m= t_1 \cdots t_m$ are two reduced
expressions  of  $w  \in  W$  as  products  of  elements  of  $S$, then the
corresponding  products of the  generators $T_{s_i}$ respectively $T_{t_j}$
will  give the same element of $H$, which we may therefore denote by $T_w$.
We have $T_1=1$.

If  one  of  $u_{s,0}$  or  $u_{s,1}$  is  invertible  in  $R$, for example
$u_{s,1}$,  then by changing the  generators to $-T_s/u_{s,1}$, and setting
$q_s=-u_{s,0}/u_{s,1}$,  the  braid  relations  do  no  change  (since when
$m_{s,t}$  is odd  we have  $u_{s,i}=u_{t,i}$) but  the quadratic relations
become  $(T_s-q_s)(T_s+1)=0$.  This  last  form  is  the  most  common form
considered  in  the  literature.  Another  common  form  in  the context of
Kazhdan-Lusztig   theory  is   obtained  by   scaling  the   generators  as
$-T_s/\sqrt{-u_{s,0}u_{s,1}}$,  giving  rise  to  the  quadratic  relations
$(T_s-v_s)(T_s+v_s^{-1})=0$  where  $v_s=\sqrt{q_s}$.  The  general form of
parameters  provided by  \CHEVIE\ is  a special  case of general cyclotomic
Hecke algebras, and can be useful in many contexts.

The  second form  above, or  for some  algebras the  character table in the
first form, require a square root of $-u_{s,0}u_{s,1}$. \CHEVIE\ provides a
way  to specify it with the field  |.rootParameter| which can be given when
constructing  the algebra. If  not given a  root is automatically extracted
when needed by the function |RootParameter|. Note however that sometimes an
explicit  choice  of  root  is  necessary  which  cannot  be  automatically
determined.

There   is   a   universal   choice   for   $R$  and  $\{u_{s,i}\}$\:\  Let
$\{u_{s,i}\}_{s\in    S,i\in\{0,1\}}$    be    indeterminates   such   that
$u_{s,i}=u_{t,i}$ whenever $m_{s,t}$ is odd, and let
$A_0=\Z[u_{s,i}]_{s,i}$   be  the   corresponding  polynomial   ring.  Then
$H_0\:=H(W,A_0,\{u_{s,i}\})$  is called the *generic Iwahori-Hecke algebra*
associated  with $W$. Another algebra  $H(W,R,\{v_{s,i}\})$ can be obtained
by specialization from $H_0$\:\ There is a unique ring homomorphism $f\:A_0
\rightarrow R$ such that $f(u_{s,i})=v_{s,i}$ for all $i$. Then we can view
$R$  as an $A_0$-module  via $f$ and  we can identify $H(W,R,\{v_{s,i}\})=R
\otimes_{A_0} H_0$.

The  elements $\{T_w \mid w  \in W\}$ actually form  an $R$-basis of $H$ if
one  of the $u_{s,i}$ is invertible for all $s$. The structure constants in
that  basis is obtained  as follows. To  multiply $T_v$ by  $T_w$, choose a
reduced  expression for $v$,  say $v=s_1 \cdots  s_k$ and apply inductively
the formula\:
$$
 T_sT_w = \left\{ \begin{array}{cl}
   T_{sw} & \mbox{ if  $l(sw)=l(w)+1$}\\
   -u_{s,0}u_{s,1}T_{sw}+(u_{s,0}+u_{s,1})T_w &
     \mbox{ if $l(sw)=l(w)-1$.}
  \end{array}\right.
$$
If all $s$ we have $u_{s,0}=q$, $u_{s,1}=-1$ then we call the corresponding
algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with
$W$;  it can  be obtained  with the  simplified call  'Hecke(W,q)'. Certain
invariants  of the  irreducible characters  of this  algebra play a special
role  in the representation theory of the underlying finite Coxeter groups,
namely  the $a$- and $A$-invariants already occured in chapter "Classes and
representations  for  reflection  groups" (see "LowestPowerGenericDegrees",
"JInductionTable").  For  basic  properties  of  Iwahori-Hecke algebras and
their  relevance to the representation theory of finite groups of Lie type,
see for example \cite{CR87}, Sections~67 and 68.

In the  following example, we  compute  the multiplication table for  the
$0$-Iwahori--Hecke algebra  associated  with  the Coxeter group   of type
$A_2$.

|    gap> W := CoxeterGroup( "A", 2 );
    CoxeterGroup("A",2)|

One-parameter algebra with $q=0$\:

|    gap> H := Hecke( W, 0 );
    Hecke(A2,0)|

Create the $T$-basis\:

|    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> el := CoxeterWords( W );
    [ [  ], [ 2 ], [ 1 ], [ 2, 1 ], [ 1, 2 ], [ 1, 2, 1 ] ]|

Multiply any two $T$-basis elements\:

|    gap> PrintArray(List(el,x->List(el,y->T(x)*T(y))));
    [[     T(),      T(2),      T(1),    T(2,1),    T(1,2),  T(1,2,1)],
     [    T(2),     -T(2),    T(2,1),   -T(2,1),  T(1,2,1), -T(1,2,1)],
     [    T(1),    T(1,2),     -T(1),  T(1,2,1),   -T(1,2), -T(1,2,1)],
     [  T(2,1),  T(1,2,1),   -T(2,1), -T(1,2,1), -T(1,2,1),  T(1,2,1)],
     [  T(1,2),   -T(1,2),  T(1,2,1), -T(1,2,1), -T(1,2,1),  T(1,2,1)],
     [T(1,2,1), -T(1,2,1), -T(1,2,1),  T(1,2,1),  T(1,2,1), -T(1,2,1)]]|

Thus,  we work  with algebras  with arbitrary  parameters. We will see that
this also works on the level of characters and representations.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Hecke for Coxeter groups}

'Hecke( <W> [, <parameter>, [<rootparameter>]] )'
\index{Hecke}

Constructs  the Iwahori-Hecke algebra  <H> of the  given Coxeter group. The
following  forms are accepted for <parameter>\:\ if <parameter> is a single
value,  it is replicated to  become a list of  same length as the number of
generators  of $W$.  Otherwise, <parameter>  should be  a list  of the same
length  as the number  of generators of  $W$, with possibly unbound entries
(which  means it can also  be a list of  lesser length). There should be at
least one entry bound for each orbit of reflections, and if several entries
are  bound for one orbit, they should all be identical. Now again, an entry
for  a reflection can be either a single value or a list of length 2. If it
is a list, it is interpreted as the list $[u_0,u_1]$ of parameters for that
reflection. If it is a single value $q$, it is interpreted as '[q,-1]'.

If  <parameter>  are  not  given,  they  are  assumed to be equal to 1. The
Iwahori-Hecke  algebra then degenerates to the group algebra of the Coxeter
group.  Thus both 'Hecke(W)' and 'Hecke(W,1)'  specify the group algebra of
$W$.

<rootparameter>  is used  to specify  a square  root of $-u_0u_1$ (a square
root  of $q$  when $[u_0,u_1]$  are '[q,-1]').  It is  usually a  list like
<parameter>  with at least one  bound entry per orbit  of reflection, or it
can  be a single value which is replicated  to become a list of same length
as  the number of generators  of <W>. If not  given then <rootparameter> is
computed   upon  need   by  calling   the  function   |RootParameter|  (see
"RootParameter").

|    gap> W := CoxeterGroup( "B", 3 );
    CoxeterGroup("B",3)
    gap> u := X( Rationals );; u.name := "u";;|

One parameter algebra without and with specifying square roots\:

|    gap> H := Hecke( W, u );
    Hecke(B3,u)
    gap> H := Hecke( W, u^2, u );
    Hecke(B3,u^2,u)
    gap> H := Hecke( W, [ u^6, u^4, u^4 ], [ u^3, -u^2, -u^2 ] );
    Hecke(B3,[u^6,u^4,u^4],[u^3,-u^2,-u^2])|

The parameters do not have to be indeterminates\:

|    gap> H := Hecke( W, 9, 3 );
    Hecke(B3,9,3)
    gap> H := Hecke( W, [ u^6, u^4, u^8] );
    Error, parameters should be equal for conjugate reflections 3 and 2 in
    function ( arg ) ... end( CoxeterGroup("B",3), [ u^6, u^4, u^8 ]
     ) called from
    function ( arg ) ... end( CoxeterGroup("B",3), [ u^6, u^4, u^8 ]
     ) called from
    Hecke( W, [ u ^ 6, u ^ 4, u ^ 8 ] ) called from
    main loop
    brk>|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations and functions for Iwahori-Hecke algebras}

All operations for cyclotomic Hecke algebras are defined for Iwahori-Hecke
algebras, in particular \:

'Group':\\  returns the Coxeter  group from which  the  Hecke algebra was
     generated.

'Print':\\  prints the Hecke algebra in a compact form. use 'FormatGAP' for
     a form which can be read back into \GAP.

\index{SchurElements}
'SchurElements':\\   see  "SchurElement" and "SchurElements".

\index{CharTable}
'CharTable':\\ returns the character table  of the Hecke algebra. This is
     a record with  exactly the same  components as for the corresponding
     finite Coxeter group but where the component 'irreducibles' contains
     the values  of the irreducible characters   of the algebra  on basis
     elements $T_w$ where  $w$ runs  over  the elements in the  component
     'classtext'. Thus, the value  are now polynomials in the  parameters
     of the algebra.  For  more details see the  chapter "Representations
     of Iwahori-Hecke algebras".

\index{Basis}
'Basis':\\ the 'T' basis is described in  the section below.  Other bases
     are described in chapter "Kazhdan-Lusztig polynomials and bases".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{RootParameter}

'RootParameter(<H>, <i>)'
\index{RootParameter}

<H>  should be an  Iwahori-Hecke algebra. If  its parameters are $u_0, u_1$
for  the $i$-th generating reflection, this  function returns a square root
of  $-u_0u_1$.  These  roots  are  necessary  for certain operations on the
algebra,  like the  character values  of algebras  of type $E_7$, $E_8$, or
two-parameter $G_2$. If |rootparameters| have been given at the time of the
definition  of the Hecke algebra (see "Hecke for Coxeter groups") then they
are  returned. If they had not been specified, then if $u_0u_1=-1$ then $1$
is  returned, else  the square  root is  computed as 'GetRoot('$-u_0u_1$')'
(see  "GetRoot").  It  is  useful  to  specify explicit square roots, since
'GetRoot'  does not  work in  all cases,  or may  yield the negative of the
desired  root  and  is  generally  inconsistent  with  respect  to  various
specializations  (there  cannot  exist  any  function  'GetRoot' which will
commute with arbitrary specializations).

|    gap> W:=CoxeterGroup("A",2);;
    gap> q:=X(Rationals);;q.name:="q";;
    gap> H:=Hecke(W,q^2,-q);
    Hecke(A2,q^2,-q)
    gap> RootParameter(H,1);
    -q
    gap> H:=Hecke(W,q^2);
    Hecke(A2,q^2)
    gap> RootParameter(H,1);
    q
    gap> H:=Hecke(W,3);
    Hecke(A2,3)
    gap> RootParameter(H,1);
    -E(12)^7+E(12)^11|

'RootParameter(<H>, <w>)'

If <w> is an element of |Group(H)| then the function returns the product of
the 'RootParameter's for the reflections in a reduced expression for <w>.

|    gap> H:=Hecke(W,q^2,-q);
    Hecke(A2,q^2,-q)
    gap> RootParameter(H,LongestCoxeterElement(W));
    -q^3|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{HeckeSubAlgebra}

'HeckeSubAlgebra( <H>, <r> )'
\index{HeckeSubAlgebra}

Given  an Hecke Algebra <H> and a  set of reflections of 'Group(<H>)' given
as   their   index   in   the   reflections   of   'Parent(Group(H))'  (see
"ReflectionSubgroup"),  return the Hecke sub-algebra generated by the $T_s$
corresponding  to  these  reflections.  The  reflections must be generating
reflections if the Hecke algebra is not the group algebra of $W$.

As for Subgroup,  a subalgebra of a subalgebra is  given as a subalgebra
of the parent algebra.

|    gap> u := X( Rationals );; u.name := "u";;
    gap> H := Hecke( CoxeterGroup( "B", 2 ), u );
    Hecke(B2,u)
    gap> HeckeSubAlgebra( H, [ 1, 4 ] );
    Hecke(B2,u)
    gap> HeckeSubAlgebra( H, [ 1, 7 ] );
    Error, Generators of a sub-Hecke algebra should be simple reflections \
    in
    function ( H, subW ) ... end( Hecke(B2,u), [ 1, 7 ] ) called from
    HeckeSubAlgebra( H, [ 1, 7 ] ) called from
    main loop
    brk>|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Construction of Hecke elements of the $T$ basis}

'Basis( <H>, \"T\" )'
\index{Basis}

Let  <H> be  a  Iwahori-Hecke  algebra.   The  function  'Basis(H,\"T\")'
returns a function which can  be used to make  elements of the usual  'T'
basis of the algebra.  It  is convenient to  assign this function with  a
shorter name when computing with elements of  the Hecke algebra.  In what
follows we assume that we have done the assignment\:\

|    gap> T := Basis( H, "T" );
    function ( arg ) ... end|

'T( <w> )'

Here  <w> is  an  element of  the Coxeter  group  'Group(H)'. This  call
returns the basis element $T_w$ of <H>.

'T( <elts>, <coeffs>)'

In this form, 'elts' is a list  of elements of 'Group(H)' and 'coeffs' a
list of coefficients which should be of the same length 'k'. The element
'Sum([1..k],i->coeffs[i]\*T(elts[i]))' of <H> is returned.

'T( <list> )'

'T( <s1>, .., <sn> )'

In  the  above two  forms,  the  \GAP\ list  <list>  or  the \GAP\  list
'[<s1>,..,<sn>]'  represents the  Coxeter  word for  an  element <w>  of
'Group(H)'. The basis element $T_w$ is returned (actually the call works
even  if  the word  '[<s1>,..,<sn>]'  is  not  reduced and  the  element
$T_{s_1}\ldots T_{s_n}$ is returned also in that case).

|    gap> W := CoxeterGroup( "B", 3 );;
    gap> u := X( Rationals );; u.name := "u";;
    gap> H := Hecke( W, u );;
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> T( 1, 2 ) = T( [ 1, 2 ] );
    true
    gap> T( 1, 2 ) = T( EltWord( W, [ 1, 2 ] ) );
    true
    gap> T(1,1);
    uT()+(u-1)T(1)
    gap> l := [ [], [ 1, 2, 3 ], [ 1 ], [ 2 ], [ 3 ] ];;
    gap> pl := List( l, i -> EltWord( W, i ) );;
    gap> h := T( pl, [ u^100, 1/u^20, 1, -5, 0 ] );
    u^100T()+T(1)-5T(2)+u^-20T(1,2,3)
    gap> h.elm;
    [ (), ( 1, 4)( 2,11)( 3, 5)( 8, 9)(10,13)(12,14)(17,18),
      ( 1,10)( 2, 6)( 5, 8)(11,15)(14,17),
      ( 1,16,13,10, 7, 4)( 2, 8,12,11,17, 3)( 5, 9, 6,14,18,15) ]
    gap> h.coeff;
    [ u^100, -5, 1, u^(-20) ]|

The last two lines show that a Hecke element is represented internally by a
list  of elements of $W$ and the  corresponding list of coefficients of the
basis elements in $H$.

The  way  elements  of  the  Iwahori-Hecke  algebra  are printed depends on
'CHEVIE.PrintHecke' . If it is set to
'CHEVIE.PrintHecke\:=rec(GAP\:=true)',  they are printed in a way which can
be  input back  in \GAP.  When you  load {\CHEVIE}, the record 'PrintHecke'
initially set to 'rec()'. To go on from the above example\:

|    gap> CHEVIE.PrintHecke:=rec(GAP:=true);;
    gap> h;
    u^100*T()+T(1)-5*T(2)+u^-20*T(1,2,3)
    gap> CHEVIE.PrintHecke:=rec();;
    gap> h;
    u^100T()+T(1)-5T(2)+u^-20T(1,2,3)|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Hecke elements of the $T$ basis}

All examples below are with 'CHEVIE.PrintHecke=\"\"'.

'Hecke( <a> )': returns the Hecke algebra of which <a> is an element.
\index{Hecke}

'<a> \*\ <b>':
The  multiplication of  two elements  given in  the 'T'  basis of  the same
Iwahori-Hecke  algebra is defined,  returning a Hecke  element expressed in
the 'T' basis.

|    gap> q := X( Rationals );; q.name := "q";;
    gap> H := Hecke( CoxeterGroup( "A", 2 ), q );
    Hecke(A2,q)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> ( T() + T( 1 ) ) * ( T() + T( 2 ) );
    T()+T(1)+T(2)+T(1,2)
    gap> T( 1 ) * T( 1 );
    qT()+(q-1)T(1)
    gap> T( 1, 1 ); # the same
    qT()+(q-1)T(1)|

'<a> \^\ <i>':
An  element of the  'T' basis with  a coefficient whose  inverse is still a
Laurent  polynomial  in  $q$  can  be  raised  to  an integral, positive or
negative,  power, returning  another element  of the  algebra. An arbitrary
element of the algebra can only be raised to a positive power.

|    gap> ( q * T( 1, 2 ) ) ^ -1;
    (q^-1-2q^-2+q^-3)T()+(-q^-2+q^-3)T(1)+(-q^-2+q^-3)T(2)+q^-3T(2,1)
    gap> ( T( 1 ) + T( 2 ) ) ^ -1;
    Error, inverse implemented only for single T_w in
    h.operations.inverse( h ) called from
    <rec1> ^ <rec2> called from
    main loop
    brk>
    gap> ( T( 1 ) + T( 2 ) ) ^ 2;
    2qT()+(q-1)T(1)+(q-1)T(2)+T(1,2)+T(2,1)|

'<a> /\ <b>': This is equivalent to 'a\* b\^-1'.

'<a> + <b>'

'<a> - <b>':
Elements of the  algebra  expressed in  the  'T'  basis can be   added or
subtracted, giving other elements of the algebra.

|    gap> T( 1 ) + T();
    T()+T(1)
    gap> T( 1 ) - T( 1 );
    0|

'Print( <a> )':
prints the element <a>, using the form initialized in CHEVIE.PrintHecke.

'String( <a> )':
provides a  string  containing  the same  result  that  is  printed  with
'Print'.

\index{Coefficient}
'Coefficient( <a>, <w> )':
Returns the  coefficient of the Hecke  element <a> on the  basis element
$T_w$. Here <w> can  be given either as a Coxeter word  or as an element
of the Coxeter group.

\index{AlphaInvolution}
'AlphaInvolution( <a> )':
This   implements the involution   on the algebra  defined by $T_w\mapsto
T_{w^{-1}}$.

|    gap> AlphaInvolution( T( 1, 2 ) );
    T(2,1)|

\index{BetaInvolution}
'BetaInvolution( <a> )':
This  is  only defined  when  the  Kazhdan-Lusztig  bases of  the  Hecke
algebra  can be  defined. It  implements the  involution on  the algebra
defined  by $x\mapsto\overline  x$ on  coefficients and  and $T_w\mapsto
q_{w_0}^{-1}T_{w_0w}$.

\index{AltInvolution}
'AltInvolution( <a> )':
This is only defined when the Kazhdan-Lusztig bases of the Hecke algebra
can  be defined.  It implements  the involution  on the  algebra defined
by  $x\mapsto\overline  x$  on coefficients  and  $T_s\mapsto  -q_sT_s$.
Essentially it corresponds to tensoring with the sign representation.

\index{Frobenius}
'Frobenius(<WF>)( <a> )':
The Frobenius of  a Coxeter Coset associated  to 'Group(Hecke(<a>))' can
be applied to <a>. For more details see chapter "Frobenius".

|    gap> W:=CoxeterGroup("D",4);WF:=CoxeterCoset(W,(1,2,4));
    CoxeterGroup("D",4)
    3D4
    gap> H:=Hecke(W,X(Rationals));
    Hecke(D4,q)
    gap> T:=Basis(H,"T");
    function ( arg ) ... end
    gap> Frobenius(WF)(T(1));
    T(4)
    gap> Frobenius(WF)(T(1),-1);
    T(2)|

\index{Representation}
'Representation(<a>)( <n> )':
Returns  the image of <a> in the representation <n> of 'H:=Hecke(<a>)'. <n>
can  be  a  representation  of  <H>,  or  an  integer specifying the <n>-th
representation of <H>.

|    gap> Representation(T(1,2),2);
    [ [ -q, 0*q^0, 0*q^0 ], [ 0*q^0, -q, 0*q^0 ],
      [ q^2 - q, -q + 1, q^0 ] ]
    gap> r:=Representations(H,2);
    [ [ [ q - 1, -q^0, 0*q^0 ], [ -q, 0*q^0, 0*q^0 ],
          [ -q^2 + q, q - 1, -q^0 ] ],
      [ [ 0*q^0, q^0, 0*q^0 ], [ q, q - 1, 0*q^0 ],
          [ 0*q^0, 0*q^0, -q^0 ] ],
      [ [ -q^0, 0*q^0, 0*q^0 ], [ 0*q^0, 0*q^0, q^0 ],
          [ 0*q^0, q, q - 1 ] ],
      [ [ 0*q^0, q^0, 0*q^0 ], [ q, q - 1, 0*q^0 ],
          [ 0*q^0, 0*q^0, -q^0 ] ] ]
    gap> Representation(T(1,2),r);
    [ [ -q, 0*q^0, 0*q^0 ], [ 0*q^0, -q, 0*q^0 ],
      [ q^2 - q, -q + 1, q^0 ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{HeckeClassPolynomials}

\index{HeckeClassPolynomials}
'HeckeClassPolynomials( <h> )'

returns the class polynomials of the Hecke element <h> of the Hecke algebra
$H$  with  respect  to  representatives  <reps>  of  minimal  length in the
conjugacy  classes  of  the  Coxeter  group <Group(H)>. Such minimal length
representatives are given by the function
'ChevieClassInfo(Group(H)).classtext'. These polynomials have the following
property.  Given the  class polynomials  <p> corresponding  to <h>  and the
matrix $X$ of the values of the irreducible characters of the Iwahori-Hecke
algebra  on $T_w$ (for $w$ in <reps>),  then the product 'X\*p' is the list
of  values  of  the  irreducible  characters  on  the  element  <h>  of the
Iwahori-Hecke algebra.

|    gap> u := X( Rationals );; u.name := "u";;
    gap> W := CoxeterGroup( "A", 3 );
    CoxeterGroup("A",3)
    gap> H := Hecke( W, u );;
    gap> h := Basis( H, "T" )( LongestCoxeterElement( W ) );
    T(1,2,1,3,2,1)
    gap> cp := HeckeClassPolynomials( h );
    [ 0*u^0, 0*u^0, u^2, u^3 - 2*u^2 + u, u^3 - u^2 + u - 1 ]
    gap> CharTable( H ).irreducibles * cp;
    [ u^0, -u^2, 2*u^3, -u^4, u^6 ]|

So, the entries in this list are the values of the irreducible characters
on the basis element corresponding to the  longest element in the Coxeter
group.

The class polynomials were introduced in \cite{GP93}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{HeckeCharValues}

\index{HeckeCharValues}
'HeckeCharValues( <h> [,<irreds>])'

<h> is  an element of an  Iwahori-Hecke algebra  (expressed in any basis)
and <irreds> is a set of irreducible characters of  the algebra (given as
vectors).  'HeckeCharValues'   returns the  values  of  <irreds>   on the
element <h> (the method used is to convert to the 'T' basis, and then use
'HeckeClassPolynomials').  If <irreds> is not given, all character values
are returned.

|    gap> q := X( Rationals );; q.name := "q";;
    gap> H := Hecke( CoxeterGroup( "B", 2 ), q ^ 2, q );;
    gap> HeckeCharValues( Basis( H, "C'" )( 1, 2, 1 ) );
    [ -q - q^(-1), q + q^(-1), 0*q^0, q^3 + 2*q + 2*q^(-1) + q^(-3),
      0*q^0 ]|

See also "HeckeClassPolynomials".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specialization from one Hecke algebra to another}
\index{Specialization}

'Specialization( <H1>, <H2>, <f>)'

<H1> and <H2> should be Hecke algebras of the same group, and <f> should be
a function which applied to the parameters of <H1> gives those of <H2>. The
result  is a function which can transport  Hecke elements from <H1> to <H2>
by  the specialization map induced by <f>.  As an example below, we compute
the  so-called  ``Kazhdan-Lusztig  basis\'\'\  of  the  symmetric  group by
specializing that of the Hecke algebra.

|    gap> q:=X(Rationals);;q.name:="q";;
    gap> W:=CoxeterGroup("A",2);H1:=Hecke(W,q^2);H2:=Hecke(W);
    CoxeterGroup("A",2)
    Hecke(A2,q^2)
    Hecke(A2)
    gap> T:=Basis(H1,"T");Cp:=Basis(H1,"C'");
    function ( arg ) ... end
    #warning\:\ C\' basis\:\ q chosen as 2nd root of q\^2
    function ( arg ) ... end
    gap> f:=function(x)
    >  if IsPolynomial(x) then return Value(x,1);
    >  else return x; fi;
    > end;
    function ( x ) ... end
    gap> s:=Specialization(H1,H2,f);
    function ( t ) ... end
    gap> CoxeterWords(W);
    [ [  ], [ 2 ], [ 1 ], [ 2, 1 ], [ 1, 2 ], [ 1, 2, 1 ] ]
    gap> List(last,x->s(T(Cp(x))));
    [ T(), T()+T(2), T()+T(1), T()+T(1)+T(2)+T(2,1), T()+T(1)+T(2)+T(1,2),
      T()+T(1)+T(2)+T(1,2)+T(2,1)+T(1,2,1) ]|

Note  that in  the above  example we  specialize 'T(Cp(x))', not 'Cp(x)'\:\
since  Kazhdan-Lusztig  bases  do  not,  strictly  speaking,  exist for the
symmetric  group algebra, it does not make sense to specialize them so they
have  no 'Specialization' method.  Rather, one has  to convert to basis 'T'
first, which has a specialization method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CreateHeckeBasis}

'CreateHeckeBasis(<basis>, <ops>, <heckealgebraops>)'
\index{CreateHeckeBasis}

creates a new basis for Hecke algebras in  which to do computations. (The
design of this   function has  benefited  from conversation  with  Andrew
Mathas, the author of the package 'Specht').

The first argument <basis> must be a unique (different from that used for
other bases)  character string.  The   second argument <ops> is  a record
which should contain at least two fields, '<ops>.T' and '<ops>.(<basis>)'
which should contain \:

 '<ops>.T': a  function which takes  an element in  the basis <basis> and
  converts it to the 'T' basis.

 '<ops>.(<basis>)': a function  which takes an element  in the  'T' basis
  and converts it to the <basis> basis.

The  third arguments  should be  the field  '.operations' of  some Hecke
algebra. After the  call to 'CreateHeckeBasis', a  new field '(<basis>)'
is  added  to 'heckealgebraops'  which  contains  a function  to  create
elements of  the <basis> basis. Thus  all Hecke algebras which  have the
same field '.operations' will have the new basis.

The elements  of the  new basis  will have  the standard  operations for
Hecke  elements\:\ '+',  '-', '\*',  '\^', '=',  'Print', 'Coefficient',
plus all extra operations that the  user may have specified in <ops>. It
is thus  possible to create a  new basis which has  extra operations. In
addition, for any already created basis <y> of the algebra, the function
'(<y>)'  will have  the added  capability to  convert elements  from the
<basis>  basis to  the  <y> basis.  If  the user  has  provided a  field
'<ops>.(<y>)' ,  the function found  there will be used.  Otherwise, the
function '<ops>.T'  will be used to  convert our <basis> element  to the
'T' basis, followed  by calling the function '(<y>)' which  was given in
<ops> at  the time  the <y>  basis was  created, to  convert to  the <y>
basis. The  following forms of the  Basis function will be  accepted (as
for the 'T' basis)\:

'Basis( <H>, <basis> )( <w> )'

'Basis( <H>, <basis> )( <elts>, <coeffs>)'

'Basis( <H>, <basis> )( <list> )'

'Basis( <H>, <basis> )( <s1>, .. , <sn> )'

One   should note,  however  that  for the  last  two forms  only reduced
expressions will be accepted in general.

Below  is an  example where  the basis  $t_w=q^{-l(w)/2}T_w$ is created and
used;  we  assume  the  equal  parameter  case.  As  an example of an extra
operation in <ops>, we have given a method for 'BetaInvolution', which just
dos  the map  $w\mapsto w  w_0$ for  the $t$  basis. If  methods for one of
'BetaInvolution',  'AltInvolution'  are  given  they  will be automatically
called by the generic functions with the same name.

In  order  to  understand  the  following  code,  one has to recall that an
arbitrary  Hecke element is a record  representing a sum of basis elements;
it contains a list of Coxeter group elements in the component 'elm' and the
corresponding list of coefficients in the component 'coeff'. For efficiency
reasons,  it is desirable to  describe how to convert  to another base such
general Hecke elements and not just one basis element $T_w$ or $t_w$.

|    gap> CreateHeckeBasis("t", rec(
    >   T := h->Basis( Hecke(h), "T" )(h.elm, List( [1 .. Length( h.elm )],
    >      i->RootParameter(Hecke(h),h.elm[i])^-1*h.coeff[i])),
    >   t := h->Basis( Hecke(h), "t" )(h.elm, List( [1 .. Length( h.elm )],
    >      i->RootParameter(Hecke(h), h.elm[i])*h.coeff[i])),
    >   BetaInvolution := h->Basis(Hecke(h),"t")(List(h.elm,
    >    x->x*LongestCoxeterElement(Group(Hecke(h)))),h.coeff)),
    >    H.operations);|

Now we setup the algebra using $v=q^{1/2}$ and use the basis 't'.

|    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( CoxeterGroup( "A", 3 ), v ^ 2, v );;
    gap> h := Basis( H, "t" )( 3, 1, 2 );
    t(1,3,2)
    gap> h1 := Basis( H, "T")( h );
    v^-3T(1,3,2)
    gap> h2 := Basis( H, "t" )( h1 );
    t(1,3,2)
    gap> BetaInvolution( h2 );
    t(2,1,3)|

\psubsection{Parameterized bases}

One can defined parameterized bases, that is bases whose behavior depend on
some  parameter(s). As  an example  we will  define the  basis $t(i)_w=q^{i
l(w)}T_w$,  where we  assume that  $2i$ is  an integer.  We first write the
example and then comment its differences from the previous case.

|    gap> CreateHeckeBasis( "ti", rec(
    > T := h->Basis( Hecke(h), "T" )( h.elm, List( [1 .. Length( h.elm )],
    >  i->Hecke(h).rootParameter[1]^(-CoxeterLength(
    >          Group( Hecke(h) ), h.elm[i])*2*h.i)*h.coeff[i] ) ),
    > extraFields:=["i"],
    > ti := function(h,extra) return Basis( Hecke(h), "ti" )
    >    ( h.elm, List( [1 .. Length( h.elm )],
    >    i->Hecke(h).rootParameter[1]^(CoxeterLength(
    >        Group( Hecke(h) ), h.elm[i])*2*extra.i)*h.coeff[i]), extra);
    >    end,
    > BetaInvolution:=h->Basis(Hecke(h),"ti")(
    >   H.operations.T.BetaInvolution(Basis(Hecke(h),"T")(h)),
    >   HeckeEltOps.GetExtra(h)),
    > FormatBasis:=h->SPrint("t[",h.i,"]")),
    > H.operations );|

Here  each Hecke element  'h' has a  field 'h.i' holding  the value of 'i'.
This  is used in converting the element to basis 'T'. The field 'i' must be
copied  from one  object to  the other  during various  operations on Hecke
elements.  For \CHEVIE\ to  know which fields  must be copied,  the list of
such  fields  must  be  declared,  which  is  done  by the above assignment
'extraFields\:=[\"i\"]'.  A  record  containing  the  extra  fields must be
passed  as the last  argument of each  call of the  'Basis' function, so it
knows  which information to put in the  built Hecke elements; thus the call
take one of the forms

'Basis( <H>, <basis> )( <w>, <extra> )'

'Basis( <H>, <basis> )( <elts>, <coeffs>, <extra>)'

'Basis( <H>, <basis> )( <list>, <extra> )'

'Basis( <H>, <basis> )( <s1>, .. , <sn>, <extra> )'

The  function 'ti'  to convert  to the  basis 'ti'  requires also  a record
argument  containing the extra  information, which it  passes to the second
form  above. The function 'BetaInvolution'  illustrates how one can extract
this  extra  information  record  from  a  Hecke element using the function
'HeckeEltOps.GetExtra(h))';  we also used a different method to compute the
'BetaInvolution',  delegating the computation to basis 'T' instead of doing
it  directly.  Finally  the  function  'FormatBasis',  if given, produces a
parameterized  printing of  a basis  element. Here  is how  one can use the
above definitions\:

|    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( CoxeterGroup( "A", 3 ), v ^ 2, v );;
    gap> t:=function(arg) Add(arg,rec(i:=1/2));
    >  return ApplyFunc(Basis(H,"ti"),arg);end;
    function ( arg ) ... end|

Here  the function  't' does  exactly the  same as  'Basis(H,\"t\")' in the
previous example, excepted for the printing of Hecke elements:

|    gap> h := t( 3, 1, 2 );
    t[1/2](1,3,2)
    gap> h1 := Basis( H, "T")( h );
    v^-3T(1,3,2)
    gap> h2 := t( h1 );
    t[1/2](1,3,2)
    gap> BetaInvolution( h2 );
    t[1/2](2,1,3)|

The  point is that one can now  just as easily define similar functions for
other values of 'i'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
