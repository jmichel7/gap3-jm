%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%A  chvkalu.tex       CHEVIE documentation       Meinolf Geck, Frank Luebeck,
%A                                               Jean Michel, G"otz Pfeiffer
%%
%Y  Copyright (C) 1992 - 2012  Lehrstuhl D f\"ur Mathematik, RWTH Aachen, IWR
%Y  der Universit\"at Heidelberg, University of St. Andrews, and   University
%Y  Paris VII.
%%
%%  This  file  contains  the  description  of  the  GAP functions of CHEVIE
%%  dealing with Kazhdan-Lusztig polynomials and bases.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\cH{{\mathcal H}}
\newcommand\cC{{\mathcal C}}
\newcommand\ca{{\mathcal a}}
\newcommand\cA{{\mathcal A}}
\Chapter{Kazhdan-Lusztig polynomials and bases}

Let  $\cH$ be the  Iwahori-Hecke algebra of  a Coxeter system $(W,S)$, with
quadratic   relations  $(T_s-u_{s,0})(T_s-u_{s,1})=0$  for   $s\in  S$.  If
$-u_{s,0}u_{s,1}$  has  a  square  root,  we  can  scale the basis $T_s$ to
$-T_s/\sqrt{-u_{s,0}u_{s,1}}$  to  get  a  new  basis  $t_s$ with quadratic
relations $(t_s-v_s) (t_s+v_s^{-1})=0$ where $v_s=\sqrt{-u_{s,0}/u_{s,1}}$.
The  most general  case when  Kazhdan-Lusztig bases  and polynomials can be
defined  is when the  parameters $v_s$ belong  to a totally ordered abelian
group  $\Gamma$ (where the group law  is multiplication of parameters), see
\cite{Lus83}.  We  set  $\Gamma^+=  \{\gamma\in\Gamma\mid  \gamma\>0\}$ and
$\Gamma^-=   \{\gamma^{-1}  \mid\gamma\in\Gamma^+\}  =\{\gamma\in\Gamma\mid
\gamma\<0\}$.

Thus  we assume $\cH$ defined over the ring $\Z[\Gamma]$, the group algebra
of  $\Gamma$ over $\Z$,  and the quadratic  relations of $\cH$ associate to
each  $s\in S$ a $v_s\in\Gamma^+$ such that $(t_s-v_s)(t_s+v_s^{-1})=0$. We
also  set  $q_s=v_s^2$  and  define the basis  $T_s=v_s t_s$ with quadratic
relations $(T_s-q_s)(T_s+1)=0$; we extend the notation to define an element
$q_w\in\Gamma_+$  by  setting  $q_w=q_{s_1}\ldots  q_{s_n}$ if $w=s_1\ldots
s_n$ is a reduced expression for some $w\in W$, and denote
$q_w^{(1/2)}=v_{s_1}\ldots    v_{s_n}$.

We  define the  bar involution  on $\cH$  by linearity\: on $\Z[\Gamma]$ we
define      it     by     $\overline{\sum_{\gamma\in\Gamma}a_\gamma\gamma}=
\sum_{\gamma\in\Gamma}  a_\gamma \gamma^{-1}$ and we  extend it to $\cH$ by
$\overline  T_s=T_s^{-1}$. Then  the Kazhdan-Lusztig  basis $C^\prime_w$ is
defined  as  the  only  basis  of  $\cH$  stable  by the bar involution and
congruent to $t_w$ modulo $\sum_{w\in W}\Gamma_- t_w$.

The  basis  $C^\prime_w$  can  be  computed  as follows. We define elements
$R_{x,y}$   of  $\Z[\Gamma]$  by  $T_y^{-1}=\sum_x  \overline{R_{x,y^{-1}}}
q_x^{-1}T_x$.  We then  define inductively  the Kazhdan-Lusztig polynomials
(in  this general  context we  should say  the Kazhdan-Lusztig  elements of
$\Z[\Gamma]$,  which belong to the  subalgebra of $\Z[\Gamma]$ generated by
the    $q_s$)    by    $P_{x,w}=\tau_{\le(q_w/q_x)^{1/2}}    (\sum_{x\<y\le
w}R_{x,y}P_{y,w})$  where  $\tau$  is  the  truncation  \:\  $\tau_{\le\nu}
\sum_{\gamma\in\Gamma}  a_\gamma\gamma= \sum_{\gamma\le\nu}a_\gamma\gamma$;
the induction is thus on decreasing $x$ for the Bruhat order and starts at
$P_{w,w}=1$. We have then $C^\prime_w=\sum_y q_w^{-1/2} P_{y,w}T_y$.

{\CHEVIE}  can  compute  Kazhdan-Lusztig  polynomials,  left cells, and the
various  Kazhdan-Lusztig bases of Iwahori-Hecke algebras (see \cite{KL79}).
More  facilities are implemented for the  one-parameter case when all $v_s$
have a common value $v$.

There  is  a  separate  function  to  compute one-parameter kazhdan-Lusztig
polynomials.  From a computational point of view, even this case is quite a
challenge.  It seems that the best approach still is by using the recursion
formula   in  the  original  article  \cite{KL79}  (which  deals  with  the
one-parameter  case, where the  above recursion simplifies).  One can first
run  a number of standard checks on a  given pair of elements to see if the
computation  of the  corresponding polynomial  can be  reduced to a similar
computation  for elements  of smaller  length, for  example. One such check
involves  the notion of critical pairs  (cf.\ \cite{Alv87})\: We say that a
pair of elements $w_1\le w_2 \in W$ is critical if ${\cal L}(w_2) \subseteq
{\cal  L}(w_1)$ and ${\cal  R}(w_2) \subseteq {\cal  R}(w_1)$, where ${\cal
L}$ and ${\cal R}$ denote the left and right descent set, respectively. Now
if  $y\le  w  \in  W$  are  arbitrary  elements  then there always exists a
critical  pair $(z,w)$ with $y\le z\le w$ and then $P_{y,w}=P_{z,w}$. Given
two  elements $y$ and  $w$, such a  critical pair is  found by the function
'CriticalPair'. Whenever the polynomial corresponding to a critical pair is
computed then this pair and the polynomial are stored in the field '.klpol'
of the record of the underlying Coxeter group.

A  good example to see how long  the programs will take for computations in
big Coxeter groups is the following\:

|    gap> W:=CoxeterGroup("D",5);;
    gap> LeftCells(W);;|

which  takes $10$ seconds cpu time on 3Ghz computer. The computation of all
Kazhdan-Lusztig  polynomials  for  type  $F_4$  takes  a  bit more than~$1$
minute.  Computing the Bruhat order is a bottleneck for these computations;
they can be speeded up by a factor of two if one does\:

|    gap> ReadChv("contr/brbase");
    gap> BaseBruhat(W);;|

after  which the computation  of the Bruhat  order will be  speeded up by a
large factor.

However,  Alvis\'\ computation  of the  Kazhdan--Lusztig polynomials of the
Coxeter  group of type $H_4$ in a  computer algebra system like \GAP\ would
still take many hours. For such applications, it is probably more efficient
to  use a  special purpose  program like  the one  provided by  F.\ DuCloux
\cite{DuC91}.

The  code for the Kazhdan-Lusztig bases  'C', 'D' and their primed versions
has  been written by Andrew Mathas around 1994, who also contributed to the
initial  implementation  and  to  the  design  of the programs dealing with
Kazhdan-Lusztig  bases. He also  implemented some other  bases, such as the
Murphy  basis which can  be found in  the contributions directory (see also
his  'Specht' package).  The extension  to the  unequal parameters case has
been written by F.Digne and J.Michel around 1999.

The  other Kazhdan-Lusztig bases  are computed in  \CHEVIE\ in terms of the
$C^\prime$ basis.

\CHEVIE\  is able to define automatically the bar and truncation operations
on  $\Z(\Gamma)$ when all  parameters are powers  of the same indeterminate
$q$,  with  total  order  on  $\Gamma$  by  the  power  of $q$, or when the
parameters  are monomials in some 'Mvp's, with the lexicographic order. The
bar  involution is  evaluating a  Laurent polynomial  at the inverse of the
variables,  and truncation is keeping terms  of smaller degree than that of
$\nu$.  It  is  possible  to  use  arbitrary  groups  $\Gamma$ by doing the
following  steps\:\  first,  define  the  Hecke  algebra  'H'. Then, before
defining  any  of  the  Kazhdan-Lusztig  bases, write functions 'H.Bar(p)',
'H.PositivePart(p)'  and 'H.NegativePart(p)'  which perform  the operations
respectively $\sum_{\gamma\in\Gamma} a_\gamma\gamma\mapsto
\sum_{\gamma\in\Gamma}     a_\gamma\gamma^{-1}$,    $\sum_{\gamma\in\Gamma}
a_\gamma\gamma\mapsto     \sum_{\gamma\ge     1}     a_\gamma\gamma$    and
$\sum_{\gamma\in\Gamma}     a_\gamma\gamma\mapsto     \sum_{\gamma\le    1}
a_\gamma\gamma$  on elements  'p' of  $\Z[\Gamma]$. It  is then possible to
define  Kahzdan-Lusztig  bases  and  the  operations  above  will  be  used
internally by \CHEVIE\ to compute them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{KazhdanLusztigPolynomial}
\index{KazhdanLusztigPolynomial}

'KazhdanLusztigPolynomial( <W>, <y>, <w>)'

returns  the  coefficients  of  the Kazhdan-Lusztig polynomial $P_{y,w}(q)$
attached  to  the  elements  <y>  and  <w>  of the Coxeter group <W> and to
'Hecke(W,q)'.  If one prefers to give as  input just two Coxeter words, one
can define a new function as follows (for example)\:

|    gap> klpol := function( W, x, y)
    >   return KazhdanLusztigPolynomial(W, EltWord(W, x), EltWord(W, y));
    >   end;
    function ( W, x, y ) ... end|

We  use  this  function in the   following example  where  we compute the
polynomials $P_{1,w}$  for all elements $w$ in  the Coxeter group of type
$A_3$.

|    gap> q := X( Rationals );; q.name := "q";;
    gap> W := CoxeterGroup( "B", 3 );;
    gap> el := CoxeterWords( W );
    [ [  ], [ 3 ], [ 2 ], [ 1 ], [ 3, 2 ], [ 2, 1 ], [ 2, 3 ], [ 1, 3 ],
      [ 1, 2 ], [ 2, 1, 2 ], [ 3, 2, 1 ], [ 2, 3, 2 ], [ 2, 1, 3 ],
      [ 1, 2, 1 ], [ 1, 3, 2 ], [ 1, 2, 3 ], [ 3, 2, 1, 2 ],
      [ 2, 1, 2, 3 ], [ 2, 3, 2, 1 ], [ 2, 1, 3, 2 ], [ 1, 2, 1, 2 ],
      [ 1, 3, 2, 1 ], [ 1, 2, 1, 3 ], [ 1, 2, 3, 2 ], [ 3, 2, 1, 2, 3 ],
      [ 2, 1, 2, 3, 2 ], [ 2, 3, 2, 1, 2 ], [ 2, 1, 3, 2, 1 ],
      [ 1, 3, 2, 1, 2 ], [ 1, 2, 1, 2, 3 ], [ 1, 2, 1, 3, 2 ],
      [ 1, 2, 3, 2, 1 ], [ 2, 3, 2, 1, 2, 3 ], [ 2, 1, 2, 3, 2, 1 ],
      [ 2, 1, 3, 2, 1, 2 ], [ 1, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2 ],
      [ 1, 2, 1, 3, 2, 1 ], [ 1, 2, 3, 2, 1, 2 ], [ 2, 1, 2, 3, 2, 1, 2 ],
      [ 2, 1, 3, 2, 1, 2, 3 ], [ 1, 2, 3, 2, 1, 2, 3 ],
      [ 1, 2, 1, 2, 3, 2, 1 ], [ 1, 2, 1, 3, 2, 1, 2 ],
      [ 2, 1, 2, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2, 1, 2 ],
      [ 1, 2, 1, 3, 2, 1, 2, 3 ], [ 1, 2, 1, 2, 3, 2, 1, 2, 3 ] ]
    gap> List( el, w -> Polynomial(Rationals,klpol( W, [], w )));
    [ q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0, q^0,
      q^0, q^0, q^0, q^0, q^0, q^0, q + 1, q^0, q^0, q^0, q^0, q + 1,
      q^0, q^0, q + 1, q^0, q^0, q + 1, q + 1, q^0, q + 1, q^0, q + 1,
      q^0, q^2 + 1, q + 1, q^2 + q + 1, q + 1, q + 1, q^0, q^0, q^2 + 1,
      q^0, q + 1, q^0 ]|

Kazhdan--Lusztig  polynomials for critical  pairs are stored  in the record
component  'klpol' of  $W$, which  allows the  function to work much faster
after the first time it is called.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CriticalPair}
\index{CriticalPair}

'CriticalPair( <W>, <y>, <w> )'

Given  elements  <y>  and  <w>  in  the  Coxeter  group  <W>  the  function
'CriticalPair'  returns the longest  element in the  double coset $W_{{\cal
L}(w)}y  W_{{\cal R}(w)}$; it is such that the Kazhdan--Lusztig polynomials
$P_{z,w}$ and $P_{y,w}$ are equal.

|    gap> W := CoxeterGroup( "F", 4 );
    CoxeterGroup("F",4)
    gap> w := LongestCoxeterElement( W ) * W.generators[1];;
    gap> CoxeterLength( W, w );
    23
    gap> y := EltWord( W, [ 1, 2, 3, 4 ] );;
    gap> cr := CriticalPair( W, y, w );;
    gap> CoxeterWord( W, cr);
    [ 2, 3, 2, 1, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 3 ]
    gap> KazhdanLusztigPolynomial( W, y, w);
    [ 1, 0, 0, 1 ]
    gap> KazhdanLusztigPolynomial( W, cr, w);
    [ 1, 0, 0, 1 ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{KazhdanLusztigCoefficient}
\index{KazhdanLusztigCoefficient}

'KazhdanLusztigCoefficient( <W>, <y>, <w>, <k> )'

returns   the  coefficient  of  $q^k$  in  the  Kazhdan-Lusztig  polynomial
$P_{y,w}$ attached to the elements <y> and <w> of the Coxeter group <W> and
to 'Hecke(W,q)'.

|    gap> W := CoxeterGroup( "B", 4 );;
    gap> y := [ 1, 2, 3, 4, 3, 2, 1 ];;
    gap> py := EltWord( W, y );
    ( 1,28)( 2,15)( 4,27)( 6,16)( 7,24)( 8,23)(11,20)(12,17)(14,30)(18,31)
    (22,32)
    gap> x := [ 1 ];;
    gap> px := EltWord( W, x );
    ( 1,17)( 2, 8)( 6,11)(10,14)(18,24)(22,27)(26,30)
    gap> Bruhat( W, px, py );
    true
    gap> List([0..3],i->KazhdanLusztigCoefficient( W, px, py, i ) );
    [ 1, 2, 1, 0 ]|

So  the  Kazhdan-Lusztig polynomial  corresponding  to  $x$  and  $y$  is
$1+2q+q^2$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{KazhdanLusztigMue}
\index{KazhdanLusztigMue}

'KazhdanLusztigMue( <W>, <y>, <w> )'

given  elements <y> and <w> in the Coxeter group <W>, this function returns
the   coefficient  of  degree   $(l(w)-l(y)-1)/2$  of  the  Kazhdan-Lusztig
polynomial $P_{y,w}$.

Of course, the result of this function could also be obtained by

'KazhdanLusztigCoefficient(W,y,w,(CoxeterLength(W,w)-CoxeterLength(W,y)-1)/2)'

but there are some speed-ups compared to this general function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{LeftCells}
\index{LeftCells}

'LeftCells( <W> [, <i>])'

returns  a list of  records describing left  cells of <W> for 'Hecke(W,q)'.
The  program uses  precomputed data(see  \cite{GH14}) for exceptional types
and  for type $A$, so is quite fast for these types (it takes 32 seconds to
compute  the 101796 left cells for type $E_8$). For other types, left cells
are  computed from  first principles,  thus computing  many Kazhdan-Lusztig
polynomials.  It takes 10 seconds  to compute the left  cells of $D_5$, for
example.

|    gap> W := CoxeterGroup( "G", 2 );;
    gap> LeftCells(W);
    [ LeftCell<G2: duflo= character=phi{1,0}>,
      LeftCell<G2: duflo=2 character=phi{2,1}+phi{1,3}'+phi{2,2}>,
      LeftCell<G2: duflo=1 character=phi{2,1}+phi{1,3}''+phi{2,2}>,
      LeftCell<G2: duflo=1,2 character=phi{1,6}> ]|

Printing such a record displays the character afforded by the left cell and
its  Duflo involution; the Duflo involution $r$  is printed as a subset |I|
of |[1..W.N]| such that |r=LongestCoxeterElement(ReflectionSubgroup(W,I))|,
see "DescribeInvolution".

If  a second argument <i> is given, the program returns only the left cells
which  are in the <i>-th two-sided cell,  that is whose character is in the
<i>-th family of <W> (see "Families of unipotent characters").

|    gap> LeftCells(W,1);
    [ LeftCell<G2: duflo=2 character=phi{2,1}+phi{1,3}'+phi{2,2}>,
      LeftCell<G2: duflo=1 character=phi{2,1}+phi{1,3}''+phi{2,2}> ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{LeftCell}
\index{LeftCell}

'LeftCell( <W>, <x>)'

returns  a  record  describing  the  left  cell  of  <W>  for  'Hecke(W,q)'
containing element <x>.

|    gap> W := CoxeterGroup( "E", 8 );;
    gap> LeftCell(W, Random(W));
    LeftCell<E8: duflo=6,11,82,120 character=phi{2268,30}+phi{1296,33}>|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for LeftCells}

'Size( <cell>)'

Returns the number of elements of the cell.

|    gap> W:=CoxeterGroup( "H", 3);;
    gap> c := LeftCells( W );;
    gap> List( c, Size);
    [ 1, 6, 5, 8, 5, 6, 1, 5, 8, 5, 5, 6, 6, 5, 8, 5, 5, 8, 5, 6, 6, 5 ]|

'Elements( <cell>)'

Returns the list of elements of the cell.

The operations 'in' and '=' are defined for left cells.

\index{Representation}
'Representation( <cell>, <H> )'

returns a list of matrices giving the representation of 'Hecke(W,v\^2,v)' on
the left cell <c>.

|    gap> v := X( Cyclotomics ) ;; v.name := "v";;
    gap> H := Hecke(W, v^2, v );
    Hecke(H3,v^2,v)
    gap> Representation(c[3],H);
    [ [ [ -v^0, 0*v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, -v^0, 0*v^0, 0*v^0, v ],
        [ 0*v^0, 0*v^0, -v^0, v, v ],
        [ 0*v^0, 0*v^0, 0*v^0, v^2, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, 0*v^0, v^2 ] ],
      [ [ -v^0, v, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, v^2, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, v^2, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, v, -v^0, 0*v^0 ],
        [ 0*v^0, v, v, 0*v^0, -v^0 ] ],
      [ [ v^2, 0*v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ v, -v^0, 0*v^0, 0*v^0, 0*v^0 ],
        [ 0*v^0, 0*v^0, -v^0, v, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, v^2, 0*v^0 ],
        [ 0*v^0, 0*v^0, 0*v^0, 0*v^0, -v^0 ] ] ]|

\index{Character}
'Character(c)'

Returns a list <l> such that the character of <W> afforded by the left cell
<c> is |Sum(CharTable(W).irreducibles{l})|.

|    gap> Character(c[13]);
    [ 6, 5 ]|

See  also 'WGraph' below. When 'Character(c)' has been computed, then 'c.a'
also has been bound which holds the common value of Lusztig\'s $a$-function
(see "LowestPowerGenericDegrees") for
\begin{itemize}
\item The elements of 'c'.
\item The irreducible constituents of 'Character(c)'.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{W-Graphs}

Let  $H$ be the 1-parameter Hecke  algebra with parameter $q$ associated to
the  Coxeter system $(W,S)$. A $W$-graph encodes a representation of $H$ of
the  kind which is constructed by  Kazhdan-Lusztig theory. It consists of a
basis  $V$  (the  vertices  of  the  graph)  of  a real vector space with a
function  $x\mapsto I(x)$  from $V$  to the  subsets of  $S$ and a function
$\mu\:  V^2\to\R$ (the nonzero values are thus  labels for the edges of the
graph).  This defines the representation  of $H$ given in  the basis $V$ by
the formulae
$$ T_s(x)=\left\{ \begin{array}{ll}
  -x&\text{ if $s\in I(x)$}\\
  q x+\sum_{\{y\in V\mid s\in I(y)\}} \sqrt q\mu(y,x)y&\text{ otherwise.}
\end{array}\right .$$

There  are two  points to  $W$-graphs. First,  they describe  nice, sparse,
integral representations of $H$ (and thus of $W$ also). Second, they can be
stored  very compactly;  for example,  for the  representation of dimension
7168  of the Hecke algebra of type $E_8$, a naive implementation would take
more than a gigabyte. The corresponding $W$-graph takes 500KB.

$W$-graphs are represented  in \CHEVIE\ as a  pair.
\begin{itemize}
\item
The  first element is a list describing C; its elements are either a set
I(x),  or an integer n  specifying to repeat the  previous element n more
times.
\item
The  second element is a list which  specifies $\mu$. We first describe the
$\mu$-list  for symmetric  $W$-graphs (when  $\mu(x,y)=\mu(y,x)$). There is
one  element of the $\mu$-list for each  non-zero value $m$ taken by $\mu$,
which  consists  of  a  pair  whose  first  element is $m$ and whose second
element  is  a  list  of  lists;  if  |l|  is  one of these lists each pair
|[l[1],l[i]]| represents an edge |x=l[1],y=l[i]| such that
$\mu(x,y)=\mu(y,x)=m$.  For non-symmetric $W$-graphs,  the first element of
each  pair  in  the  $\mu$-list  is  a  pair  |[m,n]| and each edge |[x,y]|
obtained  from the  lists in  the second  element has  to be interpreted as
$\mu(x,y)=m$ and $\mu(y,x)=n$.
\end{itemize}

Here  is an  example of  graph for  a Coxeter  group, and the corresponding
representation. Here |v| is a variable representing the square root of |q|.

|    gap> W:=CoxeterGroup("H",3);;
    gap> WGraph(W,3);
    [ [ [ 2 ], [ 1, 2 ], [ 1, 3 ], [ 1, 3 ], [ 2, 3 ] ],
      [ [ -1, [ [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 5 ] ] ] ] ]
    gap> WGraphToRepresentation(3,last,Mvp("v"));
    [ [ [ v^2, 0, 0, 0, 0 ], [ 0, -1, 0, 0, 0 ], [ -v, 0, -1, 0, -v ],
          [ 0, 0, 0, -1, -v ], [ 0, 0, 0, 0, v^2 ] ],
      [ [ -1, 0, -v, 0, 0 ], [ 0, -1, 0, -v, 0 ], [ 0, 0, v^2, 0, 0 ],
          [ 0, 0, 0, v^2, 0 ], [ 0, 0, -v, -v, -1 ] ],
      [ [ v^2, 0, 0, 0, 0 ], [ 0, v^2, 0, 0, 0 ], [ -v, 0, -1, 0, 0 ],
          [ 0, -v, 0, -1, 0 ], [ 0, 0, 0, 0, -1 ] ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{WGraph}
\index{WGraph}

'WGraph( <W>, <i> )'

$W$  should be a finite Coxeter group. Returns the $W$-graph for the $i$-th
representation  of the  one-parameter Hecke  algebra of  $W$ (or the $i$-th
representation  of  $W$).  For  the  moment  this  is  only implemented for
irreducible groups of exceptional type $E, F, G, H$.

'WGraph( <c> )'

$c$  should be a left cell for  the one-parameter Hecke algebra of a finite
Coxeter group $W$. Returns the corresponding $W$-graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{WGraphToRepresentation}
\index{WGraphToRepresentation}

'WGraphToRepresentation (<r>, <graph>, <v>)'

<graph>  should  be  a  $W$-graph  for  some  finite  Coxeter  group $W$ of
semisimple  rank <r>.  The function  returns the  <r> matrices defining the
representation  defined  by  <graph>  of  the  Hecke  algebra  for $W$ with
parameters $-1$ and $v^2$.

|    gap> W:=CoxeterGroup("H",3);;
    gap> g:=WGraph(W,3);
    [ [ [ 2 ], [ 1, 2 ], [ 1, 3 ], [ 1, 3 ], [ 2, 3 ] ],
      [ [ -1, [ [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 5 ] ] ] ] ]
    gap> WGraphToRepresentation(3,g,Mvp("v"));
    [ [ [ v^2, 0, 0, 0, 0 ], [ 0, -1, 0, 0, 0 ], [ -v, 0, -1, 0, -v ],
          [ 0, 0, 0, -1, -v ], [ 0, 0, 0, 0, v^2 ] ],
      [ [ -1, 0, -v, 0, 0 ], [ 0, -1, 0, -v, 0 ], [ 0, 0, v^2, 0, 0 ],
          [ 0, 0, 0, v^2, 0 ], [ 0, 0, -v, -v, -1 ] ],
      [ [ v^2, 0, 0, 0, 0 ], [ 0, v^2, 0, 0, 0 ], [ -v, 0, -1, 0, 0 ],
          [ 0, -v, 0, -1, 0 ], [ 0, 0, 0, 0, -1 ] ] ]|

'WGraphToRepresentation(<H>, <graph>)'

<H> should be a one-parameter Hecke algebra for a finite Coxeter group. The
function  returns the matrices of the  representation defined by <graph> of
$H$.

|    gap> H:=Hecke(W,[[Mvp("v"),-Mvp("v")^-1]]);
    Hecke(H3,[[v,-v^-1]])
    gap> WGraphToRepresentation(H,g);
    [ [ [ v, 0, 0, 0, 0 ], [ 0, -v^-1, 0, 0, 0 ], [ -1, 0, -v^-1, 0, -1 ],
          [ 0, 0, 0, -v^-1, -1 ], [ 0, 0, 0, 0, v ] ],
      [ [ -v^-1, 0, -1, 0, 0 ], [ 0, -v^-1, 0, -1, 0 ], [ 0, 0, v, 0, 0 ],
          [ 0, 0, 0, v, 0 ], [ 0, 0, -1, -1, -v^-1 ] ],
      [ [ v, 0, 0, 0, 0 ], [ 0, v, 0, 0, 0 ], [ -1, 0, -v^-1, 0, 0 ],
          [ 0, -1, 0, -v^-1, 0 ], [ 0, 0, 0, 0, -v^-1 ] ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Hecke elements of the $C$ basis}

\index{Basis}
'Basis( <H>, \"C\" )'

returns  a function which gives the  $C$-basis of the Iwahori-Hecke algebra
<H>.  The parameters of <H>  should be powers of  a single indeterminate or
'Mvp's  (see the introduction). This basis  is defined as follows (see e.g.
\cite[(5.1)]{Lus85}). Let $W$ be the underlying Coxeter group. For $x,y \in
W$  let  $P_{x,y}$  be  the  corresponding  Kazhdan--Lusztig polynomial. If
$\{T_w  \mid w\in W\}$ denotes the usual $T$-basis, then $C_x\:=\sum_{y \le
x} (-1)^{l(x)-l(y)}P_{y,x}(q^{-1})q_x^{1/2}q_y^{-1} T_y$ for $x \in W$. For
example,  we have $C_s=q_s^{-1/2}T_s-q_s^{1/2}T_1$ for $s \in S$. Thus, the
transformation  matrix  between  the  $T$-basis  and the $C$-basis is lower
unitriangular,  with powers of $v$ along the diagonal. In the one-parameter
case  (all $q_s$ are equal  to $v^2$) the multiplication  rules for the $C$
basis   are  given  by\:  $$   C_s  \cdot  C_x  =\left\{  \begin{array}{ll}
-(v+v^{-1})C_x  &  \mbox{,  if  $sx\<x$}\\  C_{sx}+\sum_{y}  \mu(y,x)C_y  &
\mbox{,  if $sx>x$}\end{array}\right.$$ where the sum  is over all $y$ such
that  $y\<x$, $l(y)  \not\equiv l(x)$~mod~$2$  and $sy\<y$. The coefficient
$\mu(y,x)$   is  the   coefficient  of   degree  $(l(x)-l(y)-1)/2$  in  the
Kazhdan--Lusztig polynomial $P_{x,y}$.

|    gap> W := CoxeterGroup( "B", 3 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B3,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> C := Basis( H, "C" );
    function ( arg ) ... end
    gap> T( C( 1 ) );
    -vT()+v^-1T(1)
    gap> C( T( 1 ) );
    v^2C()+vC(1)|

We can  also  compute character values  on elements  in the $C$-basis  as
follows\:

|    gap> ref := HeckeReflectionRepresentation( H );;
    gap> c := CharRepresentationWords(ref, ChevieClassInfo(W).classtext);
    [ 3*v^0, 2*v^2 - 1, v^8 - 2*v^4, -3*v^12, 2*v^2 - 1, v^4,
      v^4 - 2*v^2, -v^6, v^4 - v^2, 0*v^0 ]
    gap> List(ChevieClassInfo(W).classtext, i->HeckeCharValues(C(i),c));
    [ 3*v^0, -v - v^(-1), 0*v^0, 0*v^0, -v - v^(-1), 2*v^0, 0*v^0, 0*v^0,
      v^0, 0*v^0 ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Hecke elements of the primed $C$ basis}

'Basis( <H>, \"C\'\" )'

returns  a function which  gives the $C^\prime$-basis  of the Iwahori-Hecke
algebra  <H>  (see  \cite[(5.1)]{Lus85})  The  parameters  of <H> should be
powers  of  a  single  indeterminate  or  monomials  in  'Mvp'\'s  (see the
introduction).  This  basis  is  defined  by  $$ C_x^\prime \:= \sum_{y \le
x}P_{y,x}q_x^{-1/2}  T_y  \quad  \mbox{  for  $x \in W$}.$$ We have
$C_x^\prime=(-1)^{l(x)}\text{Alt}(C_x)$    for   all   $x   \in   W$   (see
'AltInvolution'  in  section  "Operations  for  Hecke  elements  of the $T$
basis").

|    gap>  v := X( Rationals );; v.name := "v";;
    gap>  H := Hecke( CoxeterGroup( "B", 2 ), [v ^4, v^2] );;
    gap>  h := Basis( H, "C'" )( 1 );
    #warning\:\ C\'\ basis\:\ v\^2 chosen as 2nd root of v\^4
    C'(1)
    gap>  h2 := h * h;
    (v^2+v^-2)C'(1)
    gap>  Basis( H, "T" )( h2 );
    (1+v^-4)T()+(1+v^-4)T(1)
    gap> Basis(H,"C'")(last);
    (v^2+v^-2)C'(1)|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Hecke elements of the $D$ basis}

'Basis( <H>, \"D\" )'

returns a function which gives the $D$-basis of the (one parameter generic)
Iwahori-Hecke  algebra <H> (see \cite[(5.1)]{Lus85})  of the finite Coxeter
group  <W>. This can be defined by $$ D_x \:= v^{-N}C_{xw_0}^\prime T_{w_0}
\mbox{  for every $x \in  W$}, $$ where $N$  denotes the number of positive
roots  in the root system  of $W$ and $w_0$  is the longest element of $W$.
The  $D$-basis is dual to the  $C$-basis with respect to the non-degenerate
form  $H \times  H \rightarrow  \Z[v,v^{-1}]$, $(h_1,h_2)  \mapsto \tau(h_1
\cdot  h_2)$ where $\tau  \colon H \rightarrow  \Z[v,v^{-1}]$ is the linear
form  such  that  $\tau(T_1)=1$  and  $\tau(T_x)=0$  for $x \ne 1$. We have
$D_x=\beta(C_{w_0x}^\prime)$  for all  $x \in  W$ (see  'BetaInvolution' in
section "Operations for Hecke elements of the $T$ basis").

|    gap> W := CoxeterGroup( "B", 2 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B2,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> D := Basis( H, "D" );
    function ( arg ) ... end
    gap> D( T( 1 ) );
    vD(1)-v^2D(1,2)-v^2D(2,1)+v^3D(1,2,1)+v^3D(2,1,2)-v^4D(1,2,1,2)
    gap> BetaInvolution( D( 1 ) );
    C'(2,1,2)|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Hecke elements of the primed $D$ basis}

'Basis( <H>, \"D\'\" )'

returns  a function which gives the  $D^\prime$-basis of the (one parameter
generic)  Iwahori-Hecke algebra  <H> of  the finite  Coxeter group <W> (see
\cite[(5.1)]{Lus85}).   This   can   be   defined   by  $$  D_x^\prime  \:=
v^{-N}C_{xw_0}  T_{w_0} \mbox{ for  every $x \in  W$}, $$ where $N$ denotes
the  number of positive  roots in the  root system of  $W$ and $w_0$ is the
longest  element  of  $W$.  The  $D^\prime$-basis  is  basis  dual  to  the
$C^\prime$-basis  with  respect  to  the  non-degenerate  form  $H \times H
\rightarrow  \Z[v,v^{-1}]$, $(h_1,h_2)  \mapsto \tau(h_1  \cdot h_2)$ where
$\tau  \colon  H  \rightarrow  \Z[v,v^{-1}]$  is  the linear form such that
$\tau(T_1)=1$ and $\tau(T_x)=0$ for $x \ne 1$. We have
$D_x^\prime=\text{Alt}(D_x)$  for  all  $x  \in  W$ (see 'AltInvolution' in
section "Operations for Hecke elements of the $T$ basis").

|    gap> W := CoxeterGroup( "B", 2 );;
    gap> v := X( Rationals );; v.name := "v";;
    gap> H := Hecke( W, v^2, v );
    Hecke(B2,v^2,v)
    gap> T := Basis( H, "T" );
    function ( arg ) ... end
    gap> Dp := Basis( H, "D'" );
    function ( arg ) ... end
    gap> AltInvolution( Dp( 1 ) );
    D(1)
    gap> Dp( 1 )^3;
    (v+2v^-1-5v^-5-9v^-7-8v^-9-4v^-11-v^-13)D'()+(v^2+2+v^-2)D'(1)|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Asymptotic algebra}
\index{Asymptotic algebra}

'AsymptoticAlgebra( <W>, <i>)'

The  asymptotic algebra $A$ associated to the algebra $\cH=$'Hecke(W,q)' is
an   algebra  with   basis  $\{t_x\}_{x\in   W}$  and  structure  constants
$t_xt_y=\sum_z\gamma_{x,y,z}   t_z$  given  by\:  let  $h_{x,y,z}$  be  the
coefficient  of  $C_x  C_y$  on  $C_z$. Then $h_{x,y,z}=\gamma_{x,y,z^{-1}}
q^{a(z)/2}+$lower  terms, where $q^{a(z)/2}$  is the maximum  over $x,y$ of
the degree of $h_{x,y,z}$.

The  algebra $A$ is the direct product of the subalgebras $A_\cC$ generated
by  the elements $\{t_x\}_{x\in\cC}$,  where $\cC$ runs  over the two-sided
cells  of $W$. If  $\cC$ is the  $i$-th two-sided cell  of $W$, the command
'AsymptoticAlgebra(W,i)'   returns  the  algebra  $A_\cC$.  Note  that  the
function  'a(z)' is  constant over  a two-sided  cell, equal  to the common
value  of the 'a'-function attached to the characters of the two-sided cell
(see 'Character' for left cells).

|    gap> W:=CoxeterGroup("G",2);;
    gap> A:=AsymptoticAlgebra(W,1);
    Asymptotic algebra dim.10
    gap> b:=A.basis;
    [ t(2), t(12), t(212), t(1212), t(21212), t(1), t(21), t(121),
      t(2121), t(12121) ]
    gap> List(b,x->b*x);
    [ [ t(2), t(21), t(212), t(2121), t(21212), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(21), t(2)+t(212), t(21)+t(2121), t(212)+t(21212),
          t(2121) ],
      [ t(212), t(21)+t(2121), t(2)+t(212)+t(21212), t(21)+t(2121),
          t(212), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(2121), t(212)+t(21212), t(21)+t(2121),
          t(2)+t(212), t(21) ],
      [ t(21212), t(2121), t(212), t(21), t(2), 0, 0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(1), t(12), t(121), t(1212), t(12121) ],
      [ t(12), t(1)+t(121), t(12)+t(1212), t(121)+t(12121), t(1212), 0,
          0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(121), t(12)+t(1212), t(1)+t(121)+t(12121),
          t(12)+t(1212), t(121) ],
      [ t(1212), t(121)+t(12121), t(12)+t(1212), t(1)+t(121), t(12), 0,
          0, 0, 0, 0 ],
      [ 0, 0, 0, 0, 0, t(12121), t(1212), t(121), t(12), t(1) ] ]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Lusztigaw}
\index{Lusztigaw}

'Lusztigaw( <W>, <w>)'

For  <w> an element  of the Coxeter  groups <W>, this  function returns the
coefficients on the irreducible characters of the virtual Character $\ca_w$
defined  in \cite[5.10.2]{Lus85}. This character  has the property that the
corresponding almost character is integral and positive.

|    gap> W:=CoxeterGroup("G",2);
    CoxeterGroup("G",2)
    gap> Lusztigaw(W,Reflection(W,1));
    [ 0, 0, 1, 0, 1, 1 ]
    gap> last*List([1..NrConjugacyClasses(W)],i->AlmostCharacter(W,i));
    [G2]=<phi{1,3}'>+<phi{2,1}>+<phi{2,2}>|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{LusztigAw}
\index{LusztigAw}

'LusztigAw( <W>, <w>)'

For  <w> an element  of the Coxeter  groups <W>, this  function returns the
coefficients on the irreducible characters of the virtual Character $\cA_w$
defined  in \cite[5.10.2]{Lus85}. This character  has the property that the
corresponding almost character is integral and positive.

|    gap> W:=CoxeterGroup("G",2);
    CoxeterGroup("G",2)
    gap> LusztigAw(W,Reflection(W,1));
    [ 0, 0, 0, 1, 1, 1 ]
    gap> last*List([1..NrConjugacyClasses(W)],i->AlmostCharacter(W,i));
    [G2]=<phi{1,3}''>+<phi{2,1}>+<phi{2,2}>|
